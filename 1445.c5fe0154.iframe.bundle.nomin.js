(self["webpackChunk_woocommerce_storybook"] = self["webpackChunk_woocommerce_storybook"] || []).push([[1445],{

/***/ "../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  oS: () => (/* reexport */ provider),
  m9: () => (/* reexport */ BlockList),
  LJ: () => (/* reexport */ BlockTools),
  us: () => (/* reexport */ observe_typing),
  Pe: () => (/* reexport */ writing_flow),
  M_: () => (/* reexport */ store_store)
});

// UNUSED EXPORTS: AlignmentControl, AlignmentToolbar, Autocomplete, BlockAlignmentControl, BlockAlignmentToolbar, BlockBreadcrumb, BlockColorsStyleSelector, BlockContextProvider, BlockControls, BlockEdit, BlockEditorKeyboardShortcuts, BlockFormatControls, BlockIcon, BlockInspector, BlockMover, BlockNavigationDropdown, BlockPreview, BlockSelectionClearer, BlockSettingsMenu, BlockSettingsMenuControls, BlockStyles, BlockTitle, BlockToolbar, BlockVerticalAlignmentControl, BlockVerticalAlignmentToolbar, ButtonBlockAppender, ButtonBlockerAppender, ColorPalette, ColorPaletteControl, ContrastChecker, CopyHandler, DefaultBlockAppender, FontSizePicker, InnerBlocks, Inserter, InspectorAdvancedControls, InspectorControls, JustifyContentControl, JustifyToolbar, LineHeightControl, MediaPlaceholder, MediaReplaceFlow, MediaUpload, MediaUploadCheck, MultiSelectScrollIntoView, NavigableToolbar, PanelColorSettings, PlainText, RichText, RichTextShortcut, RichTextToolbarButton, SETTINGS_DEFAULTS, SkipToSelectedBlock, ToolSelector, Typewriter, URLInput, URLInputButton, URLPopover, Warning, __experimentalBlockAlignmentMatrixControl, __experimentalBlockFullHeightAligmentControl, __experimentalBlockPatternSetup, __experimentalBlockPatternsList, __experimentalBlockVariationPicker, __experimentalBlockVariationTransforms, __experimentalBorderRadiusControl, __experimentalColorGradientControl, __experimentalColorGradientSettingsDropdown, __experimentalDateFormatPicker, __experimentalDuotoneControl, __experimentalFontAppearanceControl, __experimentalFontFamilyControl, __experimentalGetBorderClassesAndStyles, __experimentalGetColorClassesAndStyles, __experimentalGetElementClassName, __experimentalGetGapCSSValue, __experimentalGetGradientClass, __experimentalGetGradientObjectByGradientValue, __experimentalGetMatchingVariation, __experimentalGetSpacingClassesAndStyles, __experimentalImageEditingProvider, __experimentalImageEditor, __experimentalImageSizeControl, __experimentalImageURLInputUI, __experimentalInspectorPopoverHeader, __experimentalLayoutStyle, __experimentalLetterSpacingControl, __experimentalLibrary, __experimentalLinkControl, __experimentalLinkControlSearchInput, __experimentalLinkControlSearchItem, __experimentalLinkControlSearchResults, __experimentalListView, __experimentalPanelColorGradientSettings, __experimentalPreviewOptions, __experimentalPublishDateTimePicker, __experimentalRecursionProvider, __experimentalResponsiveBlockControl, __experimentalSpacingSizesControl, __experimentalTextDecorationControl, __experimentalTextTransformControl, __experimentalUnitControl, __experimentalUseBlockOverlayActive, __experimentalUseBlockPreview, __experimentalUseBorderProps, __experimentalUseColorProps, __experimentalUseCustomSides, __experimentalUseGradient, __experimentalUseHasRecursion, __experimentalUseMultipleOriginColorsAndGradients, __experimentalUseResizeCanvas, __unstableBlockNameContext, __unstableBlockSettingsMenuFirstItem, __unstableBlockToolbarLastItem, __unstableDuotoneFilter, __unstableDuotoneStylesheet, __unstableDuotoneUnsetStylesheet, __unstableEditorStyles, __unstableGetValuesFromColors, __unstableIframe, __unstableInserterMenuExtension, __unstablePresetDuotoneFilter, __unstableRichTextInputEvent, __unstableUseBlockSelectionClearer, __unstableUseClipboardHandler, __unstableUseMouseMoveTypingReset, __unstableUseTypewriter, __unstableUseTypingObserver, createCustomColorsHOC, getColorClassName, getColorObjectByAttributeValues, getColorObjectByColorValue, getFontSize, getFontSizeClass, getFontSizeObjectByValue, getGradientSlugByValue, getGradientValueBySlug, getPxFromCssUnit, storeConfig, transformStyles, useBlockDisplayInformation, useBlockEditContext, useBlockProps, useCachedTruthy, useInnerBlocksProps, useSetting, withColorContext, withColors, withFontSizes

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  getFormatType: () => (getFormatType),
  getFormatTypeForBareElement: () => (getFormatTypeForBareElement),
  getFormatTypeForClassName: () => (getFormatTypeForClassName),
  getFormatTypes: () => (getFormatTypes)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  addFormatTypes: () => (addFormatTypes),
  removeFormatTypes: () => (removeFormatTypes)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/selectors.js
var store_selectors_namespaceObject = {};
__webpack_require__.r(store_selectors_namespaceObject);
__webpack_require__.d(store_selectors_namespaceObject, {
  __experimentalGetActiveBlockIdByBlockNames: () => (__experimentalGetActiveBlockIdByBlockNames),
  __experimentalGetAllowedBlocks: () => (__experimentalGetAllowedBlocks),
  __experimentalGetAllowedPatterns: () => (__experimentalGetAllowedPatterns),
  __experimentalGetBlockListSettingsForBlocks: () => (__experimentalGetBlockListSettingsForBlocks),
  __experimentalGetDirectInsertBlock: () => (__experimentalGetDirectInsertBlock),
  __experimentalGetGlobalBlocksByName: () => (__experimentalGetGlobalBlocksByName),
  __experimentalGetLastBlockAttributeChanges: () => (__experimentalGetLastBlockAttributeChanges),
  __experimentalGetParsedPattern: () => (__experimentalGetParsedPattern),
  __experimentalGetPatternTransformItems: () => (__experimentalGetPatternTransformItems),
  __experimentalGetPatternsByBlockTypes: () => (__experimentalGetPatternsByBlockTypes),
  __experimentalGetReusableBlockTitle: () => (__experimentalGetReusableBlockTitle),
  __unstableGetBlockWithoutInnerBlocks: () => (__unstableGetBlockWithoutInnerBlocks),
  __unstableGetClientIdWithClientIdsTree: () => (__unstableGetClientIdWithClientIdsTree),
  __unstableGetClientIdsTree: () => (__unstableGetClientIdsTree),
  __unstableGetSelectedBlocksWithPartialSelection: () => (__unstableGetSelectedBlocksWithPartialSelection),
  __unstableGetVisibleBlocks: () => (__unstableGetVisibleBlocks),
  __unstableIsFullySelected: () => (__unstableIsFullySelected),
  __unstableIsLastBlockChangeIgnored: () => (__unstableIsLastBlockChangeIgnored),
  __unstableIsSelectionCollapsed: () => (__unstableIsSelectionCollapsed),
  __unstableIsSelectionMergeable: () => (__unstableIsSelectionMergeable),
  areInnerBlocksControlled: () => (areInnerBlocksControlled),
  canEditBlock: () => (canEditBlock),
  canInsertBlockType: () => (canInsertBlockType),
  canInsertBlocks: () => (canInsertBlocks),
  canLockBlockType: () => (canLockBlockType),
  canMoveBlock: () => (canMoveBlock),
  canMoveBlocks: () => (canMoveBlocks),
  canRemoveBlock: () => (canRemoveBlock),
  canRemoveBlocks: () => (canRemoveBlocks),
  didAutomaticChange: () => (didAutomaticChange),
  getAdjacentBlockClientId: () => (getAdjacentBlockClientId),
  getBlock: () => (getBlock),
  getBlockAttributes: () => (getBlockAttributes),
  getBlockCount: () => (getBlockCount),
  getBlockHierarchyRootClientId: () => (getBlockHierarchyRootClientId),
  getBlockIndex: () => (getBlockIndex),
  getBlockInsertionPoint: () => (getBlockInsertionPoint),
  getBlockListSettings: () => (getBlockListSettings),
  getBlockMode: () => (getBlockMode),
  getBlockName: () => (getBlockName),
  getBlockOrder: () => (getBlockOrder),
  getBlockParents: () => (getBlockParents),
  getBlockParentsByBlockName: () => (getBlockParentsByBlockName),
  getBlockRootClientId: () => (getBlockRootClientId),
  getBlockSelectionEnd: () => (getBlockSelectionEnd),
  getBlockSelectionStart: () => (getBlockSelectionStart),
  getBlockTransformItems: () => (getBlockTransformItems),
  getBlocks: () => (getBlocks),
  getBlocksByClientId: () => (getBlocksByClientId),
  getClientIdsOfDescendants: () => (getClientIdsOfDescendants),
  getClientIdsWithDescendants: () => (getClientIdsWithDescendants),
  getDraggedBlockClientIds: () => (getDraggedBlockClientIds),
  getFirstMultiSelectedBlockClientId: () => (getFirstMultiSelectedBlockClientId),
  getGlobalBlockCount: () => (getGlobalBlockCount),
  getInserterItems: () => (getInserterItems),
  getLastMultiSelectedBlockClientId: () => (getLastMultiSelectedBlockClientId),
  getLowestCommonAncestorWithSelectedBlock: () => (getLowestCommonAncestorWithSelectedBlock),
  getMultiSelectedBlockClientIds: () => (getMultiSelectedBlockClientIds),
  getMultiSelectedBlocks: () => (getMultiSelectedBlocks),
  getMultiSelectedBlocksEndClientId: () => (getMultiSelectedBlocksEndClientId),
  getMultiSelectedBlocksStartClientId: () => (getMultiSelectedBlocksStartClientId),
  getNextBlockClientId: () => (getNextBlockClientId),
  getPreviousBlockClientId: () => (getPreviousBlockClientId),
  getSelectedBlock: () => (getSelectedBlock),
  getSelectedBlockClientId: () => (getSelectedBlockClientId),
  getSelectedBlockClientIds: () => (getSelectedBlockClientIds),
  getSelectedBlockCount: () => (getSelectedBlockCount),
  getSelectedBlocksInitialCaretPosition: () => (getSelectedBlocksInitialCaretPosition),
  getSelectionEnd: () => (getSelectionEnd),
  getSelectionStart: () => (getSelectionStart),
  getSettings: () => (getSettings),
  getTemplate: () => (getTemplate),
  getTemplateLock: () => (getTemplateLock),
  hasBlockMovingClientId: () => (selectors_hasBlockMovingClientId),
  hasInserterItems: () => (hasInserterItems),
  hasMultiSelection: () => (hasMultiSelection),
  hasSelectedBlock: () => (hasSelectedBlock),
  hasSelectedInnerBlock: () => (hasSelectedInnerBlock),
  isAncestorBeingDragged: () => (isAncestorBeingDragged),
  isAncestorMultiSelected: () => (isAncestorMultiSelected),
  isBlockBeingDragged: () => (isBlockBeingDragged),
  isBlockHighlighted: () => (isBlockHighlighted),
  isBlockInsertionPointVisible: () => (isBlockInsertionPointVisible),
  isBlockMultiSelected: () => (isBlockMultiSelected),
  isBlockSelected: () => (isBlockSelected),
  isBlockValid: () => (isBlockValid),
  isBlockVisible: () => (isBlockVisible),
  isBlockWithinSelection: () => (isBlockWithinSelection),
  isCaretWithinFormattedText: () => (isCaretWithinFormattedText),
  isDraggingBlocks: () => (isDraggingBlocks),
  isFirstMultiSelectedBlock: () => (isFirstMultiSelectedBlock),
  isLastBlockChangePersistent: () => (isLastBlockChangePersistent),
  isMultiSelecting: () => (selectors_isMultiSelecting),
  isNavigationMode: () => (selectors_isNavigationMode),
  isSelectionEnabled: () => (selectors_isSelectionEnabled),
  isTyping: () => (selectors_isTyping),
  isValidTemplate: () => (isValidTemplate),
  wasBlockJustInserted: () => (wasBlockJustInserted)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/actions.js
var store_actions_namespaceObject = {};
__webpack_require__.r(store_actions_namespaceObject);
__webpack_require__.d(store_actions_namespaceObject, {
  __unstableDeleteSelection: () => (__unstableDeleteSelection),
  __unstableExpandSelection: () => (__unstableExpandSelection),
  __unstableMarkAutomaticChange: () => (__unstableMarkAutomaticChange),
  __unstableMarkLastChangeAsPersistent: () => (__unstableMarkLastChangeAsPersistent),
  __unstableMarkNextChangeAsNotPersistent: () => (__unstableMarkNextChangeAsNotPersistent),
  __unstableSaveReusableBlock: () => (__unstableSaveReusableBlock),
  __unstableSplitSelection: () => (__unstableSplitSelection),
  clearSelectedBlock: () => (clearSelectedBlock),
  duplicateBlocks: () => (duplicateBlocks),
  enterFormattedText: () => (enterFormattedText),
  exitFormattedText: () => (exitFormattedText),
  flashBlock: () => (flashBlock),
  hideInsertionPoint: () => (hideInsertionPoint),
  insertAfterBlock: () => (insertAfterBlock),
  insertBeforeBlock: () => (insertBeforeBlock),
  insertBlock: () => (insertBlock),
  insertBlocks: () => (insertBlocks),
  insertDefaultBlock: () => (insertDefaultBlock),
  mergeBlocks: () => (mergeBlocks),
  moveBlockToPosition: () => (moveBlockToPosition),
  moveBlocksDown: () => (moveBlocksDown),
  moveBlocksToPosition: () => (moveBlocksToPosition),
  moveBlocksUp: () => (moveBlocksUp),
  multiSelect: () => (multiSelect),
  receiveBlocks: () => (receiveBlocks),
  removeBlock: () => (removeBlock),
  removeBlocks: () => (removeBlocks),
  replaceBlock: () => (replaceBlock),
  replaceBlocks: () => (replaceBlocks),
  replaceInnerBlocks: () => (replaceInnerBlocks),
  resetBlocks: () => (resetBlocks),
  resetSelection: () => (resetSelection),
  selectBlock: () => (selectBlock),
  selectNextBlock: () => (selectNextBlock),
  selectPreviousBlock: () => (selectPreviousBlock),
  selectionChange: () => (selectionChange),
  setBlockMovingClientId: () => (setBlockMovingClientId),
  setBlockVisibility: () => (setBlockVisibility),
  setHasControlledInnerBlocks: () => (setHasControlledInnerBlocks),
  setNavigationMode: () => (setNavigationMode),
  setTemplateValidity: () => (setTemplateValidity),
  showInsertionPoint: () => (showInsertionPoint),
  startDraggingBlocks: () => (startDraggingBlocks),
  startMultiSelect: () => (startMultiSelect),
  startTyping: () => (startTyping),
  stopDraggingBlocks: () => (stopDraggingBlocks),
  stopMultiSelect: () => (stopMultiSelect),
  stopTyping: () => (stopTyping),
  synchronizeTemplate: () => (synchronizeTemplate),
  toggleBlockHighlight: () => (toggleBlockHighlight),
  toggleBlockMode: () => (toggleBlockMode),
  toggleSelection: () => (toggleSelection),
  updateBlock: () => (updateBlock),
  updateBlockAttributes: () => (updateBlockAttributes),
  updateBlockListSettings: () => (updateBlockListSettings),
  updateSettings: () => (updateSettings),
  validateBlocksToTemplate: () => (validateBlocksToTemplate)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text/styles.js
var text_styles_namespaceObject = {};
__webpack_require__.r(text_styles_namespaceObject);
__webpack_require__.d(text_styles_namespaceObject, {
  Text: () => (Text),
  block: () => (styles_block),
  destructive: () => (destructive),
  highlighterText: () => (highlighterText),
  muted: () => (muted),
  positive: () => (positive),
  upperCase: () => (upperCase)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
var build_module_store_actions_namespaceObject = {};
__webpack_require__.r(build_module_store_actions_namespaceObject);
__webpack_require__.d(build_module_store_actions_namespaceObject, {
  registerShortcut: () => (registerShortcut),
  unregisterShortcut: () => (unregisterShortcut)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
var build_module_store_selectors_namespaceObject = {};
__webpack_require__.r(build_module_store_selectors_namespaceObject);
__webpack_require__.d(build_module_store_selectors_namespaceObject, {
  getAllShortcutKeyCombinations: () => (getAllShortcutKeyCombinations),
  getAllShortcutRawKeyCombinations: () => (getAllShortcutRawKeyCombinations),
  getCategoryShortcuts: () => (getCategoryShortcuts),
  getShortcutAliases: () => (getShortcutAliases),
  getShortcutDescription: () => (getShortcutDescription),
  getShortcutKeyCombination: () => (getShortcutKeyCombination),
  getShortcutRepresentation: () => (getShortcutRepresentation)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/metadata/selectors.js
var metadata_selectors_namespaceObject = {};
__webpack_require__.r(metadata_selectors_namespaceObject);
__webpack_require__.d(metadata_selectors_namespaceObject, {
  countSelectorsByStatus: () => (countSelectorsByStatus),
  getCachedResolvers: () => (getCachedResolvers),
  getIsResolving: () => (getIsResolving),
  getResolutionError: () => (getResolutionError),
  getResolutionState: () => (getResolutionState),
  hasFinishedResolution: () => (hasFinishedResolution),
  hasResolutionFailed: () => (hasResolutionFailed),
  hasResolvingSelectors: () => (hasResolvingSelectors),
  hasStartedResolution: () => (hasStartedResolution),
  isResolving: () => (isResolving)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/metadata/actions.js
var metadata_actions_namespaceObject = {};
__webpack_require__.r(metadata_actions_namespaceObject);
__webpack_require__.d(metadata_actions_namespaceObject, {
  failResolution: () => (failResolution),
  failResolutions: () => (failResolutions),
  finishResolution: () => (finishResolution),
  finishResolutions: () => (finishResolutions),
  invalidateResolution: () => (invalidateResolution),
  invalidateResolutionForStore: () => (invalidateResolutionForStore),
  invalidateResolutionForStoreSelector: () => (invalidateResolutionForStoreSelector),
  startResolution: () => (startResolution),
  startResolutions: () => (startResolutions)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/actions.js
var notices_build_module_store_actions_namespaceObject = {};
__webpack_require__.r(notices_build_module_store_actions_namespaceObject);
__webpack_require__.d(notices_build_module_store_actions_namespaceObject, {
  createErrorNotice: () => (createErrorNotice),
  createInfoNotice: () => (createInfoNotice),
  createNotice: () => (createNotice),
  createSuccessNotice: () => (createSuccessNotice),
  createWarningNotice: () => (createWarningNotice),
  removeNotice: () => (removeNotice)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/selectors.js
var notices_build_module_store_selectors_namespaceObject = {};
__webpack_require__.r(notices_build_module_store_selectors_namespaceObject);
__webpack_require__.d(notices_build_module_store_selectors_namespaceObject, {
  getNotices: () => (getNotices)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/tooltip/styles.js
var tooltip_styles_namespaceObject = {};
__webpack_require__.r(tooltip_styles_namespaceObject);
__webpack_require__.d(tooltip_styles_namespaceObject, {
  ZI: () => (TooltipContent),
  TooltipPopoverView: () => (TooltipPopoverView),
  wy: () => (TooltipShortcut)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/styles.js
var toggle_group_control_option_base_styles_namespaceObject = {};
__webpack_require__.r(toggle_group_control_option_base_styles_namespaceObject);
__webpack_require__.d(toggle_group_control_option_base_styles_namespaceObject, {
  ButtonContentView: () => (ButtonContentView),
  LabelView: () => (LabelView),
  rK: () => (buttonActive),
  uG: () => (buttonView),
  If: () => (styles_isIcon),
  eh: () => (labelBlock)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/index.js + 67 modules
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+hooks@3.57.0/node_modules/@wordpress/hooks/build-module/index.js + 10 modules
var hooks_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+hooks@3.57.0/node_modules/@wordpress/hooks/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/compat.js
/**
 * WordPress dependencies
 */



function migrateLightBlockWrapper(settings) {
  const {
    apiVersion = 1
  } = settings;

  if (apiVersion < 2 && (0,build_module/* hasBlockSupport */.pN)(settings, 'lightBlockWrapper', false)) {
    settings.apiVersion = 2;
  }

  return settings;
}

(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/compat/migrateLightBlockWrapper', migrateLightBlockWrapper);
//# sourceMappingURL=compat.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@babel+runtime@7.23.5/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__("../../node_modules/.pnpm/@babel+runtime@7.23.5/node_modules/@babel/runtime/helpers/esm/extends.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js
var node_modules_classnames = __webpack_require__("../../node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js");
var classnames_default = /*#__PURE__*/__webpack_require__.n(node_modules_classnames);
// EXTERNAL MODULE: ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var lodash = __webpack_require__("../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/utils/create-higher-order-component/index.js + 1 modules
var create_higher_order_component = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/utils/create-higher-order-component/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@17.0.71_react@17.0.2/node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var emotion_element_c39617d8_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@17.0.71_react@17.0.2/node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+cache@11.11.0/node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js + 7 modules
var emotion_cache_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+cache@11.11.0/node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/memize@1.1.0/node_modules/memize/index.js
var memize = __webpack_require__("../../node_modules/.pnpm/memize@1.1.0/node_modules/memize/index.js");
var memize_default = /*#__PURE__*/__webpack_require__.n(memize);
// EXTERNAL MODULE: ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js + 4 modules
var v4 = __webpack_require__("../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/style-provider/index.js


/**
 * External dependencies
 */




/**
 * Internal dependencies
 */

const uuidCache = new Set();
const memoizedCreateCacheWithContainer = memize_default()(container => {
  // Emotion only accepts alphabetical and hyphenated keys so we just
  // strip the numbers from the UUID. It _should_ be fine.
  let key = v4/* default */.A().replace(/[0-9]/g, '');

  while (uuidCache.has(key)) {
    key = v4/* default */.A().replace(/[0-9]/g, '');
  }

  uuidCache.add(key);
  return (0,emotion_cache_browser_esm/* default */.A)({
    container,
    key
  });
});
function StyleProvider(props) {
  const {
    children,
    document
  } = props;

  if (!document) {
    return null;
  }

  const cache = memoizedCreateCacheWithContainer(document.head);
  return (0,react.createElement)(emotion_element_c39617d8_browser_esm.C, {
    value: cache
  }, children);
}
/* harmony default export */ const style_provider = (StyleProvider);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-context/index.js
/**
 * WordPress dependencies
 */

const ToolbarContext = (0,react.createContext)();
/* harmony default export */ const toolbar_context = (ToolbarContext);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@babel+runtime@7.25.0/node_modules/@babel/runtime/helpers/esm/extends.js
var helpers_esm_extends = __webpack_require__("../../node_modules/.pnpm/@babel+runtime@7.25.0/node_modules/@babel/runtime/helpers/esm/extends.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+deprecated@3.41.0/node_modules/@wordpress/deprecated/build-module/index.js
var deprecated_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+deprecated@3.41.0/node_modules/@wordpress/deprecated/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js
var use_instance_id = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/react.js
var build_module_react = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/react.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-debounce/index.js
var use_debounce = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-debounce/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js
var use_merge_refs = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@floating-ui+core@1.5.2/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
var floating_ui_core = __webpack_require__("../../node_modules/.pnpm/@floating-ui+core@1.5.2/node_modules/@floating-ui/core/dist/floating-ui.core.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs + 1 modules
var floating_ui_dom = __webpack_require__("../../node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js
var react_dom = __webpack_require__("../../node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@floating-ui+react-dom@1.3.0_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js






/**
 * A data provider that provides data to position an inner element of the
 * floating element (usually a triangle or caret) so that it is centered to the
 * reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, 'current');
  }
  return {
    name: 'arrow',
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return (0,floating_ui_core/* arrow */.UE)({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return (0,floating_ui_core/* arrow */.UE)({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};

var index = typeof document !== 'undefined' ? react.useLayoutEffect : react.useEffect;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0;) {
      const key = keys[i];
      if (key === '_owner' && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}

function useLatestRef(value) {
  const ref = react.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

/**
 * Provides data to position a floating element.
 * @see https://floating-ui.com/docs/react
 */
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = react.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = react.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const referenceRef = react.useRef(null);
  const floatingRef = react.useRef(null);
  const dataRef = react.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform);
  const [reference, _setReference] = react.useState(null);
  const [floating, _setFloating] = react.useState(null);
  const setReference = react.useCallback(node => {
    if (referenceRef.current !== node) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = react.useCallback(node => {
    if (floatingRef.current !== node) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const update = react.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    (0,floating_ui_dom/* computePosition */.rD)(referenceRef.current, floatingRef.current, config).then(data => {
      const fullData = {
        ...data,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        react_dom.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(data => ({
        ...data,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = react.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (reference && floating) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(reference, floating, update);
      } else {
        update();
      }
    }
  }, [reference, floating, update, whileElementsMountedRef]);
  const refs = react.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = react.useMemo(() => ({
    reference,
    floating
  }), [reference, floating]);
  return react.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, elements, setReference, setFloating]);
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@6.5.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs
var use_reduced_motion = __webpack_require__("../../node_modules/.pnpm/framer-motion@6.5.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/framer-motion@6.5.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/framer-motion/dist/es/render/dom/motion.mjs + 165 modules
var motion = __webpack_require__("../../node_modules/.pnpm/framer-motion@6.5.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/framer-motion/dist/es/render/dom/motion.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-viewport-match/index.js
var use_viewport_match = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-viewport-match/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-dialog/index.js
var use_dialog = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-dialog/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/close.js
var library_close = __webpack_require__("../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/close.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+primitives@3.55.0/node_modules/@wordpress/primitives/build-module/svg/index.js
var svg = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.55.0/node_modules/@wordpress/primitives/build-module/svg/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/scroll-lock/index.js
/**
 * WordPress dependencies
 */

/*
 * Setting `overflow: hidden` on html and body elements resets body scroll in iOS.
 * Save scroll top so we can restore it after locking scroll.
 *
 * NOTE: It would be cleaner and possibly safer to find a localized solution such
 * as preventing default on certain touchmove events.
 */

let previousScrollTop = 0;

function setLocked(locked) {
  const scrollingElement = document.scrollingElement || document.body;

  if (locked) {
    previousScrollTop = scrollingElement.scrollTop;
  }

  const methodName = locked ? 'add' : 'remove';
  scrollingElement.classList[methodName]('lockscroll'); // Adding the class to the document element seems to be necessary in iOS.

  document.documentElement.classList[methodName]('lockscroll');

  if (!locked) {
    scrollingElement.scrollTop = previousScrollTop;
  }
}

let lockCounter = 0;
/**
 * ScrollLock is a content-free React component for declaratively preventing
 * scroll bleed from modal UI to the page body. This component applies a
 * `lockscroll` class to the `document.documentElement` and
 * `document.scrollingElement` elements to stop the body from scrolling. When it
 * is present, the lock is applied.
 *
 * ```jsx
 * import { ScrollLock, Button } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyScrollLock = () => {
 *   const [ isScrollLocked, setIsScrollLocked ] = useState( false );
 *
 *   const toggleLock = () => {
 *     setIsScrollLocked( ( locked ) => ! locked ) );
 *   };
 *
 *   return (
 *     <div>
 *       <Button variant="secondary" onClick={ toggleLock }>
 *         Toggle scroll lock
 *       </Button>
 *       { isScrollLocked && <ScrollLock /> }
 *       <p>
 *         Scroll locked:
 *         <strong>{ isScrollLocked ? 'Yes' : 'No' }</strong>
 *       </p>
 *     </div>
 *   );
 * };
 * ```
 */

function ScrollLock() {
  (0,react.useEffect)(() => {
    if (lockCounter === 0) {
      setLocked(true);
    }

    ++lockCounter;
    return () => {
      if (lockCounter === 1) {
        setLocked(false);
      }

      --lockCounter;
    };
  }, []);
  return null;
}
/* harmony default export */ const scroll_lock = (ScrollLock);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/slot-fill-context.js
/* provided dependency */ var process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
// @ts-nocheck

/**
 * WordPress dependencies
 */


const SlotFillContext = (0,react.createContext)({
  slots: {},
  fills: {},
  registerSlot: () => {
    typeof process !== "undefined" && process.env && "production" !== "production" ? 0 : void 0;
  },
  updateSlot: () => {},
  unregisterSlot: () => {},
  registerFill: () => {},
  unregisterFill: () => {}
});
/* harmony default export */ const slot_fill_context = (SlotFillContext);
//# sourceMappingURL=slot-fill-context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/use-slot.js
// @ts-nocheck

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function useSlot(name) {
  const registry = (0,react.useContext)(slot_fill_context);
  const slot = registry.slots[name] || {};
  const slotFills = registry.fills[name];
  const fills = (0,react.useMemo)(() => slotFills || [], [slotFills]);
  const updateSlot = (0,react.useCallback)(fillProps => {
    registry.updateSlot(name, fillProps);
  }, [name, registry.updateSlot]);
  const unregisterSlot = (0,react.useCallback)(slotRef => {
    registry.unregisterSlot(name, slotRef);
  }, [name, registry.unregisterSlot]);
  const registerFill = (0,react.useCallback)(fillRef => {
    registry.registerFill(name, fillRef);
  }, [name, registry.registerFill]);
  const unregisterFill = (0,react.useCallback)(fillRef => {
    registry.unregisterFill(name, fillRef);
  }, [name, registry.unregisterFill]);
  return { ...slot,
    updateSlot,
    unregisterSlot,
    fills,
    registerFill,
    unregisterFill
  };
}
//# sourceMappingURL=use-slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/context.js
// @ts-nocheck

/**
 * WordPress dependencies
 */

const context_SlotFillContext = (0,react.createContext)({
  registerSlot: () => {},
  unregisterSlot: () => {},
  registerFill: () => {},
  unregisterFill: () => {},
  getSlot: () => {},
  getFills: () => {},
  subscribe: () => {}
});
/* harmony default export */ const context = (context_SlotFillContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/use-slot.js
// @ts-nocheck

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * React hook returning the active slot given a name.
 *
 * @param {string} name Slot name.
 * @return {Object} Slot object.
 */

const use_slot_useSlot = name => {
  const {
    getSlot,
    subscribe
  } = (0,react.useContext)(context);
  const [slot, setSlot] = (0,react.useState)(getSlot(name));
  (0,react.useEffect)(() => {
    setSlot(getSlot(name));
    const unsubscribe = subscribe(() => {
      setSlot(getSlot(name));
    });
    return unsubscribe;
  }, [name]);
  return slot;
};

/* harmony default export */ const use_slot = (use_slot_useSlot);
//# sourceMappingURL=use-slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/fill.js


// @ts-nocheck

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function FillComponent(_ref) {
  let {
    name,
    children,
    registerFill,
    unregisterFill
  } = _ref;
  const slot = use_slot(name);
  const ref = (0,react.useRef)({
    name,
    children
  });
  (0,react.useLayoutEffect)(() => {
    registerFill(name, ref.current);
    return () => unregisterFill(name, ref.current);
  }, []);
  (0,react.useLayoutEffect)(() => {
    ref.current.children = children;

    if (slot) {
      slot.forceUpdate();
    }
  }, [children]);
  (0,react.useLayoutEffect)(() => {
    if (name === ref.current.name) {
      // Ignore initial effect.
      return;
    }

    unregisterFill(ref.current.name, ref.current);
    ref.current.name = name;
    registerFill(name, ref.current);
  }, [name]);

  if (!slot || !slot.node) {
    return null;
  } // If a function is passed as a child, provide it with the fillProps.


  if (typeof children === 'function') {
    children = children(slot.props.fillProps);
  }

  return (0,react_dom.createPortal)(children, slot.node);
}

const Fill = props => (0,react.createElement)(context.Consumer, null, _ref2 => {
  let {
    registerFill,
    unregisterFill
  } = _ref2;
  return (0,react.createElement)(FillComponent, (0,helpers_esm_extends/* default */.A)({}, props, {
    registerFill: registerFill,
    unregisterFill: unregisterFill
  }));
});

/* harmony default export */ const fill = (Fill);
//# sourceMappingURL=fill.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/utils.js
var utils = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/utils.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/slot.js


// @ts-nocheck

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Whether the argument is a function.
 *
 * @param {*} maybeFunc The argument to check.
 * @return {boolean} True if the argument is a function, false otherwise.
 */

function isFunction(maybeFunc) {
  return typeof maybeFunc === 'function';
}

class SlotComponent extends react.Component {
  constructor() {
    super(...arguments);
    this.isUnmounted = false;
    this.bindNode = this.bindNode.bind(this);
  }

  componentDidMount() {
    const {
      registerSlot
    } = this.props;
    registerSlot(this.props.name, this);
  }

  componentWillUnmount() {
    const {
      unregisterSlot
    } = this.props;
    this.isUnmounted = true;
    unregisterSlot(this.props.name, this);
  }

  componentDidUpdate(prevProps) {
    const {
      name,
      unregisterSlot,
      registerSlot
    } = this.props;

    if (prevProps.name !== name) {
      unregisterSlot(prevProps.name);
      registerSlot(name, this);
    }
  }

  bindNode(node) {
    this.node = node;
  }

  forceUpdate() {
    if (this.isUnmounted) {
      return;
    }

    super.forceUpdate();
  }

  render() {
    var _getFills;

    const {
      children,
      name,
      fillProps = {},
      getFills
    } = this.props;
    const fills = ((_getFills = getFills(name, this)) !== null && _getFills !== void 0 ? _getFills : []).map(fill => {
      const fillChildren = isFunction(fill.children) ? fill.children(fillProps) : fill.children;
      return react.Children.map(fillChildren, (child, childIndex) => {
        if (!child || typeof child === 'string') {
          return child;
        }

        const childKey = child.key || childIndex;
        return (0,react.cloneElement)(child, {
          key: childKey
        });
      });
    }).filter( // In some cases fills are rendered only when some conditions apply.
    // This ensures that we only use non-empty fills when rendering, i.e.,
    // it allows us to render wrappers only when the fills are actually present.
    element => !(0,utils/* isEmptyElement */.s)(element));
    return (0,react.createElement)(react.Fragment, null, isFunction(children) ? children(fills) : fills);
  }

}

const Slot = props => (0,react.createElement)(context.Consumer, null, _ref => {
  let {
    registerSlot,
    unregisterSlot,
    getFills
  } = _ref;
  return (0,react.createElement)(SlotComponent, (0,helpers_esm_extends/* default */.A)({}, props, {
    registerSlot: registerSlot,
    unregisterSlot: unregisterSlot,
    getFills: getFills
  }));
});

/* harmony default export */ const slot = (Slot);
//# sourceMappingURL=slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/fill.js

// @ts-nocheck

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function useForceUpdate() {
  const [, setState] = (0,react.useState)({});
  const mounted = (0,react.useRef)(true);
  (0,react.useEffect)(() => {
    return () => {
      mounted.current = false;
    };
  }, []);
  return () => {
    if (mounted.current) {
      setState({});
    }
  };
}

function fill_Fill(_ref) {
  let {
    name,
    children
  } = _ref;
  const slot = useSlot(name);
  const ref = (0,react.useRef)({
    rerender: useForceUpdate()
  });
  (0,react.useEffect)(() => {
    // We register fills so we can keep track of their existance.
    // Some Slot implementations need to know if there're already fills
    // registered so they can choose to render themselves or not.
    slot.registerFill(ref);
    return () => {
      slot.unregisterFill(ref);
    };
  }, [slot.registerFill, slot.unregisterFill]);

  if (!slot.ref || !slot.ref.current) {
    return null;
  }

  if (typeof children === 'function') {
    children = children(slot.fillProps);
  } // When using a `Fill`, the `children` will be rendered in the document of the
  // `Slot`. This means that we need to wrap the `children` in a `StyleProvider`
  // to make sure we're referencing the right document/iframe (instead of the
  // context of the `Fill`'s parent).


  const wrappedChildren = (0,react.createElement)(style_provider, {
    document: slot.ref.current.ownerDocument
  }, children);
  return (0,react_dom.createPortal)(wrappedChildren, slot.ref.current);
}
//# sourceMappingURL=fill.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/slot.js


// @ts-nocheck

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function slot_Slot(_ref, forwardedRef) {
  let {
    name,
    fillProps = {},
    as: Component = 'div',
    ...props
  } = _ref;
  const registry = (0,react.useContext)(slot_fill_context);
  const ref = (0,react.useRef)();
  (0,react.useLayoutEffect)(() => {
    registry.registerSlot(name, ref, fillProps);
    return () => {
      registry.unregisterSlot(name, ref);
    }; // We are not including fillProps in the deps because we don't want to
    // unregister and register the slot whenever fillProps change, which would
    // cause the fill to be re-mounted. We are only considering the initial value
    // of fillProps.
  }, [registry.registerSlot, registry.unregisterSlot, name]); // fillProps may be an update that interacts with the layout, so we
  // useLayoutEffect.

  (0,react.useLayoutEffect)(() => {
    registry.updateSlot(name, fillProps);
  });
  return (0,react.createElement)(Component, (0,helpers_esm_extends/* default */.A)({
    ref: (0,use_merge_refs/* default */.A)([forwardedRef, ref])
  }, props));
}

/* harmony default export */ const bubbles_virtually_slot = ((0,react.forwardRef)(slot_Slot));
//# sourceMappingURL=slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/slot-fill/index.js


// @ts-nocheck

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */








function slot_fill_Fill(props) {
  // We're adding both Fills here so they can register themselves before
  // their respective slot has been registered. Only the Fill that has a slot
  // will render. The other one will return null.
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(fill, props), (0,react.createElement)(fill_Fill, props));
}
const slot_fill_Slot = (0,react.forwardRef)((_ref, ref) => {
  let {
    bubblesVirtually,
    ...props
  } = _ref;

  if (bubblesVirtually) {
    return (0,react.createElement)(bubbles_virtually_slot, (0,helpers_esm_extends/* default */.A)({}, props, {
      ref: ref
    }));
  }

  return (0,react.createElement)(slot, props);
});
function Provider(_ref2) {
  let {
    children,
    ...props
  } = _ref2;
  return createElement(SlotFillProvider, props, createElement(BubblesVirtuallySlotFillProvider, null, children));
}
function createSlotFill(name) {
  const FillComponent = props => (0,react.createElement)(slot_fill_Fill, (0,helpers_esm_extends/* default */.A)({
    name: name
  }, props));

  FillComponent.displayName = name + 'Fill';

  const SlotComponent = props => (0,react.createElement)(slot_fill_Slot, (0,helpers_esm_extends/* default */.A)({
    name: name
  }, props));

  SlotComponent.displayName = name + 'Slot';
  SlotComponent.__unstableName = name;
  return {
    Fill: FillComponent,
    Slot: SlotComponent
  };
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/popover/utils.js
/**
 * @typedef {import('../animate').AppearOrigin} AppearOrigin
 * @typedef {import('@floating-ui/react-dom').Placement} FloatingUIPlacement
 * @typedef {	'top left' | 'top center' | 'top right' | 'middle left' | 'middle center' | 'middle right' | 'bottom left' | 'bottom center' | 'bottom right' | 'bottom left' | 'bottom center' | 'bottom right' } LegacyPosition
 */

/**
 * Converts the `Popover`'s legacy "position" prop to the new "placement" prop
 * (used by `floating-ui`).
 *
 * @param {LegacyPosition} position The legacy position
 * @return {FloatingUIPlacement} The corresponding placement
 */
const positionToPlacement = position => {
  const [x, y, z] = position.split(' ');

  if (['top', 'bottom'].includes(x)) {
    let suffix = '';

    if (!!z && z === 'left' || y === 'right') {
      suffix = '-start';
    } else if (!!z && z === 'right' || y === 'left') {
      suffix = '-end';
    } // @ts-expect-error More TypeScript effort would be required to reconcile `string` and `Placement` types.


    return x + suffix;
  } // @ts-expect-error More TypeScript effort would be required to reconcile `string` and `Placement` types.


  return y;
};
/**
 * @typedef AnimationOrigin
 * @type {Object}
 * @property {number} originX A number between 0 and 1 (in CSS logical properties jargon, 0 is "start", 0.5 is "center", and 1 is "end")
 * @property {number} originY A number between 0 and 1 (0 is top, 0.5 is center, and 1 is bottom)
 */

/** @type {Object.<FloatingUIPlacement, {originX: number, originY: number}>} */

const PLACEMENT_TO_ANIMATION_ORIGIN = {
  top: {
    originX: 0.5,
    originY: 1
  },
  // open from bottom, center
  'top-start': {
    originX: 0,
    originY: 1
  },
  // open from bottom, left
  'top-end': {
    originX: 1,
    originY: 1
  },
  // open from bottom, right
  right: {
    originX: 0,
    originY: 0.5
  },
  // open from middle, left
  'right-start': {
    originX: 0,
    originY: 0
  },
  // open from top, left
  'right-end': {
    originX: 0,
    originY: 1
  },
  // open from bottom, left
  bottom: {
    originX: 0.5,
    originY: 0
  },
  // open from top, center
  'bottom-start': {
    originX: 0,
    originY: 0
  },
  // open from top, left
  'bottom-end': {
    originX: 1,
    originY: 0
  },
  // open from top, right
  left: {
    originX: 1,
    originY: 0.5
  },
  // open from middle, right
  'left-start': {
    originX: 1,
    originY: 0
  },
  // open from top, right
  'left-end': {
    originX: 1,
    originY: 1
  } // open from bottom, right

};
/**
 * Given the floating-ui `placement`, compute the framer-motion props for the
 * popover's entry animation.
 *
 * @param {FloatingUIPlacement} placement A placement string from floating ui
 * @return {import('framer-motion').MotionProps} The object containing the motion props
 */

const placementToMotionAnimationProps = placement => {
  const translateProp = placement.startsWith('top') || placement.startsWith('bottom') ? 'translateY' : 'translateX';
  const translateDirection = placement.startsWith('top') || placement.startsWith('left') ? 1 : -1;
  return {
    style: PLACEMENT_TO_ANIMATION_ORIGIN[placement],
    initial: {
      opacity: 0,
      scale: 0,
      [translateProp]: `${2 * translateDirection}em`
    },
    animate: {
      opacity: 1,
      scale: 1,
      [translateProp]: 0
    },
    transition: {
      duration: 0.1,
      ease: [0, 0, 0.2, 1]
    }
  };
};
/**
 * @typedef FrameOffset
 * @type {Object}
 * @property {number} x A numerical value representing the horizontal offset of the frame.
 * @property {number} y A numerical value representing the vertical offset of the frame.
 */

/**
 * Returns the offset of a document's frame element.
 *
 * @param {Document} document A document. This will usually be the document within an iframe.
 *
 * @return {FrameOffset|undefined} The offset of the document's frame element,
 *                                 or undefined if the document has no frame element.
 */

const getFrameOffset = document => {
  var _document$defaultView;

  const frameElement = document === null || document === void 0 ? void 0 : (_document$defaultView = document.defaultView) === null || _document$defaultView === void 0 ? void 0 : _document$defaultView.frameElement;

  if (!frameElement) {
    return;
  }

  const iframeRect = frameElement.getBoundingClientRect();
  return {
    x: iframeRect.left,
    y: iframeRect.top
  };
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/popover/index.js


// @ts-nocheck

/**
 * External dependencies
 */

 // eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */





/**
 * Name of slot in which popover should fill.
 *
 * @type {string}
 */

const SLOT_NAME = 'Popover'; // An SVG displaying a triangle facing down, filled with a solid
// color and bordered in such a way to create an arrow-like effect.
// Keeping the SVG's viewbox squared simplify the arrow positioning
// calculations.

const ArrowTriangle = props => (0,react.createElement)(svg/* SVG */.t4, (0,helpers_esm_extends/* default */.A)({}, props, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: `0 0 100 100`,
  className: "components-popover__triangle",
  role: "presentation"
}), (0,react.createElement)(svg/* Path */.wA, {
  className: "components-popover__triangle-bg",
  d: "M 0 0 L 50 50 L 100 0"
}), (0,react.createElement)(svg/* Path */.wA, {
  className: "components-popover__triangle-border",
  d: "M 0 0 L 50 50 L 100 0",
  vectorEffect: "non-scaling-stroke"
}));

const MaybeAnimatedWrapper = (0,react.forwardRef)((_ref, forwardedRef) => {
  let {
    style: receivedInlineStyles,
    placement,
    shouldAnimate = false,
    ...props
  } = _ref;
  const shouldReduceMotion = (0,use_reduced_motion/* useReducedMotion */.I)();
  const {
    style: motionInlineStyles,
    ...otherMotionProps
  } = (0,react.useMemo)(() => placementToMotionAnimationProps(placement), [placement]);

  if (shouldAnimate && !shouldReduceMotion) {
    return (0,react.createElement)(motion/* motion */.P.div, (0,helpers_esm_extends/* default */.A)({
      style: { ...motionInlineStyles,
        ...receivedInlineStyles
      }
    }, otherMotionProps, props, {
      ref: forwardedRef
    }));
  }

  return (0,react.createElement)("div", (0,helpers_esm_extends/* default */.A)({
    style: receivedInlineStyles
  }, props, {
    ref: forwardedRef
  }));
});
const slotNameContext = (0,react.createContext)();

const Popover = (_ref2, forwardedRef) => {
  let {
    range,
    animate = true,
    headerTitle,
    onClose,
    children,
    className,
    noArrow = true,
    isAlternate,
    position,
    placement: placementProp = 'bottom-start',
    offset: offsetProp = 0,
    focusOnMount = 'firstElement',
    anchorRef,
    anchorRect,
    getAnchorRect,
    expandOnMobile,
    onFocusOutside,
    __unstableSlotName = SLOT_NAME,
    __unstableObserveElement,
    __unstableForcePosition = false,
    __unstableShift = false,
    ...contentProps
  } = _ref2;

  if (range) {
    (0,deprecated_build_module/* default */.A)('range prop in Popover component', {
      since: '6.1',
      version: '6.3'
    });
  }

  const arrowRef = (0,react.useRef)(null);
  const anchorRefFallback = (0,react.useRef)(null);
  const isMobileViewport = (0,use_viewport_match/* default */.A)('medium', '<');
  const isExpanded = expandOnMobile && isMobileViewport;
  const hasArrow = !isExpanded && !noArrow;
  const normalizedPlacementFromProps = position ? positionToPlacement(position) : placementProp;
  const referenceOwnerDocument = (0,react.useMemo)(() => {
    var _documentToReturn;

    let documentToReturn;

    if (anchorRef !== null && anchorRef !== void 0 && anchorRef.top) {
      documentToReturn = anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.top.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.startContainer) {
      documentToReturn = anchorRef.startContainer.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.current) {
      documentToReturn = anchorRef.current.ownerDocument;
    } else if (anchorRef) {
      // This one should be deprecated.
      documentToReturn = anchorRef.ownerDocument;
    } else if (anchorRect && anchorRect !== null && anchorRect !== void 0 && anchorRect.ownerDocument) {
      documentToReturn = anchorRect.ownerDocument;
    } else if (getAnchorRect) {
      var _getAnchorRect;

      documentToReturn = (_getAnchorRect = getAnchorRect(anchorRefFallback.current)) === null || _getAnchorRect === void 0 ? void 0 : _getAnchorRect.ownerDocument;
    }

    return (_documentToReturn = documentToReturn) !== null && _documentToReturn !== void 0 ? _documentToReturn : document;
  }, [anchorRef, anchorRect, getAnchorRect]);
  /**
   * Offsets the position of the popover when the anchor is inside an iframe.
   *
   * Store the offset in a ref, due to constraints with floating-ui:
   * https://floating-ui.com/docs/react-dom#variables-inside-middleware-functions.
   */

  const frameOffsetRef = (0,react.useRef)(getFrameOffset(referenceOwnerDocument));
  /**
   * Store the offset prop in a ref, due to constraints with floating-ui:
   * https://floating-ui.com/docs/react-dom#variables-inside-middleware-functions.
   */

  const offsetRef = (0,react.useRef)(offsetProp);
  const middleware = [(0,floating_ui_core/* offset */.cY)(_ref3 => {
    let {
      placement: currentPlacement
    } = _ref3;

    if (!frameOffsetRef.current) {
      return offsetRef.current;
    }

    const isTopBottomPlacement = currentPlacement.includes('top') || currentPlacement.includes('bottom'); // The main axis should represent the gap between the
    // floating element and the reference element. The cross
    // axis is always perpendicular to the main axis.

    const mainAxis = isTopBottomPlacement ? 'y' : 'x';
    const crossAxis = mainAxis === 'x' ? 'y' : 'x'; // When the popover is before the reference, subtract the offset,
    // of the main axis else add it.

    const hasBeforePlacement = currentPlacement.includes('top') || currentPlacement.includes('left');
    const mainAxisModifier = hasBeforePlacement ? -1 : 1;
    return {
      mainAxis: offsetRef.current + frameOffsetRef.current[mainAxis] * mainAxisModifier,
      crossAxis: frameOffsetRef.current[crossAxis]
    };
  }), __unstableForcePosition ? undefined : (0,floating_ui_core/* flip */.UU)(), __unstableForcePosition ? undefined : (0,floating_ui_core/* size */.Ej)({
    apply(sizeProps) {
      const {
        availableHeight
      } = sizeProps;
      if (!refs.floating.current) return; // Reduce the height of the popover to the available space.

      Object.assign(refs.floating.current.firstChild.style, {
        maxHeight: `${availableHeight}px`,
        overflow: 'auto'
      });
    }

  }), __unstableShift ? (0,floating_ui_core/* shift */.BN)({
    crossAxis: true,
    limiter: (0,floating_ui_core/* limitShift */.ER)(),
    padding: 1 // Necessary to avoid flickering at the edge of the viewport.

  }) : undefined, hasArrow ? arrow({
    element: arrowRef
  }) : undefined].filter(m => !!m);

  const slotName = (0,react.useContext)(slotNameContext) || __unstableSlotName;

  const slot = useSlot(slotName);
  let onDialogClose;

  if (onClose || onFocusOutside) {
    onDialogClose = (type, event) => {
      // Ideally the popover should have just a single onClose prop and
      // not three props that potentially do the same thing.
      if (type === 'focus-outside' && onFocusOutside) {
        onFocusOutside(event);
      } else if (onClose) {
        onClose();
      }
    };
  }

  const [dialogRef, dialogProps] = (0,use_dialog/* default */.A)({
    focusOnMount,
    __unstableOnClose: onDialogClose,
    onClose: onDialogClose
  });
  const {
    // Positioning coordinates
    x,
    y,
    // Callback refs (not regular refs). This allows the position to be updated.
    // when either elements change.
    reference,
    floating,
    // Object with "regular" refs to both "reference" and "floating"
    refs,
    // Type of CSS position property to use (absolute or fixed)
    strategy,
    update,
    placement: computedPlacement,
    middlewareData: {
      arrow: arrowData = {}
    }
  } = useFloating({
    placement: normalizedPlacementFromProps,
    middleware
  });
  (0,react.useEffect)(() => {
    offsetRef.current = offsetProp;
    update();
  }, [offsetProp, update]); // Update the `reference`'s ref.
  //
  // In floating-ui's terms:
  // - "reference" refers to the popover's anchor element.
  // - "floating" refers the floating popover's element.
  // A floating element can also be positioned relative to a virtual element,
  // instead of a real one. A virtual element is represented by an object
  // with the `getBoundingClientRect()` function (like real elements).
  // See https://floating-ui.com/docs/virtual-elements for more info.

  (0,react.useLayoutEffect)(() => {
    let resultingReferenceRef;

    if (anchorRef !== null && anchorRef !== void 0 && anchorRef.top) {
      // Create a virtual element for the ref. The expectation is that
      // if anchorRef.top is defined, then anchorRef.bottom is defined too.
      resultingReferenceRef = {
        getBoundingClientRect() {
          const topRect = anchorRef.top.getBoundingClientRect();
          const bottomRect = anchorRef.bottom.getBoundingClientRect();
          return new window.DOMRect(topRect.x, topRect.y, topRect.width, bottomRect.bottom - topRect.top);
        }

      };
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.current) {
      // Standard React ref.
      resultingReferenceRef = anchorRef.current;
    } else if (anchorRef) {
      // If `anchorRef` holds directly the element's value (no `current` key)
      // This is a weird scenario and should be deprecated.
      resultingReferenceRef = anchorRef;
    } else if (anchorRect) {
      // Create a virtual element for the ref.
      resultingReferenceRef = {
        getBoundingClientRect() {
          return anchorRect;
        }

      };
    } else if (getAnchorRect) {
      // Create a virtual element for the ref.
      resultingReferenceRef = {
        getBoundingClientRect() {
          var _rect$x, _rect$y, _rect$width, _rect$height;

          const rect = getAnchorRect(anchorRefFallback.current);
          return new window.DOMRect((_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left, (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top, (_rect$width = rect.width) !== null && _rect$width !== void 0 ? _rect$width : rect.right - rect.left, (_rect$height = rect.height) !== null && _rect$height !== void 0 ? _rect$height : rect.bottom - rect.top);
        }

      };
    } else if (anchorRefFallback.current) {
      // If no explicit ref is passed via props, fall back to
      // anchoring to the popover's parent node.
      resultingReferenceRef = anchorRefFallback.current.parentNode;
    }

    if (!resultingReferenceRef) {
      return;
    }

    reference(resultingReferenceRef);

    if (!refs.floating.current) {
      return;
    }

    return (0,floating_ui_dom/* autoUpdate */.ll)(resultingReferenceRef, refs.floating.current, update); // 'reference' and 'refs.floating' are refs and don't need to be listed
    // as dependencies (see https://github.com/WordPress/gutenberg/pull/41612)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [anchorRef, anchorRect, getAnchorRect, update]); // This is only needed for a smooth transition when moving blocks.

  (0,react.useLayoutEffect)(() => {
    if (!__unstableObserveElement) {
      return;
    }

    const observer = new window.MutationObserver(update);
    observer.observe(__unstableObserveElement, {
      attributes: true
    });
    return () => {
      observer.disconnect();
    };
  }, [__unstableObserveElement, update]); // If the reference element is in a different ownerDocument (e.g. iFrame),
  // we need to manually update the floating's position as the reference's owner
  // document scrolls. Also update the frame offset if the view resizes.

  (0,react.useLayoutEffect)(() => {
    var _referenceOwnerDocume;

    if (referenceOwnerDocument === document) {
      frameOffsetRef.current = undefined;
      return;
    }

    const {
      defaultView
    } = referenceOwnerDocument;
    referenceOwnerDocument.addEventListener('scroll', update);
    let updateFrameOffset;
    const hasFrameElement = !!(referenceOwnerDocument !== null && referenceOwnerDocument !== void 0 && (_referenceOwnerDocume = referenceOwnerDocument.defaultView) !== null && _referenceOwnerDocume !== void 0 && _referenceOwnerDocume.frameElement);

    if (hasFrameElement) {
      updateFrameOffset = () => {
        frameOffsetRef.current = getFrameOffset(referenceOwnerDocument);
        update();
      };

      updateFrameOffset();
      defaultView.addEventListener('resize', updateFrameOffset);
    }

    return () => {
      referenceOwnerDocument.removeEventListener('scroll', update);

      if (updateFrameOffset) {
        defaultView.removeEventListener('resize', updateFrameOffset);
      }
    };
  }, [referenceOwnerDocument, update]);
  const mergedFloatingRef = (0,use_merge_refs/* default */.A)([floating, dialogRef, forwardedRef]); // Disable reason: We care to capture the _bubbled_ events from inputs
  // within popover as inferring close intent.

  let content = // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
  // eslint-disable-next-line jsx-a11y/no-static-element-interactions
  (0,react.createElement)(MaybeAnimatedWrapper, (0,helpers_esm_extends/* default */.A)({
    shouldAnimate: animate && !isExpanded,
    placement: computedPlacement,
    className: classnames_default()('components-popover', className, {
      'is-expanded': isExpanded,
      'is-alternate': isAlternate
    })
  }, contentProps, {
    ref: mergedFloatingRef
  }, dialogProps, {
    tabIndex: "-1",
    style: isExpanded ? undefined : {
      position: strategy,
      left: Number.isNaN(x) ? 0 : x,
      top: Number.isNaN(y) ? 0 : y
    }
  }), isExpanded && (0,react.createElement)(scroll_lock, null), isExpanded && (0,react.createElement)("div", {
    className: "components-popover__header"
  }, (0,react.createElement)("span", {
    className: "components-popover__header-title"
  }, headerTitle), (0,react.createElement)(build_module_button, {
    className: "components-popover__close",
    icon: library_close/* default */.A,
    onClick: onClose
  })), (0,react.createElement)("div", {
    className: "components-popover__content"
  }, children), hasArrow && (0,react.createElement)("div", {
    ref: arrowRef,
    className: ['components-popover__arrow', `is-${computedPlacement.split('-')[0]}`].join(' '),
    style: {
      left: Number.isFinite(arrowData === null || arrowData === void 0 ? void 0 : arrowData.x) ? `${arrowData.x}px` : '',
      top: Number.isFinite(arrowData === null || arrowData === void 0 ? void 0 : arrowData.y) ? `${arrowData.y}px` : ''
    }
  }, (0,react.createElement)(ArrowTriangle, null)));

  if (slot.ref) {
    content = (0,react.createElement)(slot_fill_Fill, {
      name: slotName
    }, content);
  }

  if (anchorRef || anchorRect) {
    return content;
  }

  return (0,react.createElement)("span", {
    ref: anchorRefFallback
  }, content);
};

const PopoverContainer = (0,react.forwardRef)(Popover);

function PopoverSlot(_ref4, ref) {
  let {
    name = SLOT_NAME
  } = _ref4;
  return (0,react.createElement)(slot_fill_Slot, {
    bubblesVirtually: true,
    name: name,
    className: "popover-slot",
    ref: ref
  });
}

PopoverContainer.Slot = (0,react.forwardRef)(PopoverSlot);
PopoverContainer.__unstableSlotNameProvider = slotNameContext.Provider;
/* harmony default export */ const popover = (PopoverContainer);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/shortcut/index.js


/**
 * Internal dependencies
 */
function Shortcut(props) {
  const {
    shortcut,
    className
  } = props;

  if (!shortcut) {
    return null;
  }

  let displayText;
  let ariaLabel;

  if (typeof shortcut === 'string') {
    displayText = shortcut;
  }

  if (shortcut !== null && typeof shortcut === 'object') {
    displayText = shortcut.display;
    ariaLabel = shortcut.ariaLabel;
  }

  return (0,react.createElement)("span", {
    className: className,
    "aria-label": ariaLabel
  }, displayText);
}

/* harmony default export */ const build_module_shortcut = (Shortcut);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tooltip/index.js

// @ts-nocheck

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Time over children to wait before showing tooltip
 *
 * @type {number}
 */

const TOOLTIP_DELAY = 700;
const eventCatcher = (0,react.createElement)("div", {
  className: "event-catcher"
});

const getDisabledElement = _ref => {
  let {
    eventHandlers,
    child,
    childrenWithPopover,
    mergedRefs
  } = _ref;
  return (0,react.cloneElement)((0,react.createElement)("span", {
    className: "disabled-element-wrapper"
  }, (0,react.cloneElement)(eventCatcher, eventHandlers), (0,react.cloneElement)(child, {
    children: childrenWithPopover,
    ref: mergedRefs
  })), { ...eventHandlers
  });
};

const getRegularElement = _ref2 => {
  let {
    child,
    eventHandlers,
    childrenWithPopover,
    mergedRefs
  } = _ref2;
  return (0,react.cloneElement)(child, { ...eventHandlers,
    children: childrenWithPopover,
    ref: mergedRefs
  });
};

const addPopoverToGrandchildren = _ref3 => {
  let {
    anchorRef,
    grandchildren,
    isOver,
    offset,
    position,
    shortcut,
    text
  } = _ref3;
  return (0,build_module_react/* concatChildren */.oG)(grandchildren, isOver && (0,react.createElement)(popover, {
    focusOnMount: false,
    position: position,
    className: "components-tooltip",
    "aria-hidden": "true",
    animate: false,
    offset: offset,
    anchorRef: anchorRef,
    __unstableShift: true
  }, text, (0,react.createElement)(build_module_shortcut, {
    className: "components-tooltip__shortcut",
    shortcut: shortcut
  })));
};

const emitToChild = (children, eventName, event) => {
  if (react.Children.count(children) !== 1) {
    return;
  }

  const child = react.Children.only(children); // If the underlying element is disabled, do not emit the event.

  if (child.props.disabled) {
    return;
  }

  if (typeof child.props[eventName] === 'function') {
    child.props[eventName](event);
  }
};

function Tooltip(props) {
  var _Children$toArray$;

  const {
    children,
    position = 'bottom middle',
    text,
    shortcut,
    delay = TOOLTIP_DELAY
  } = props;
  /**
   * Whether a mouse is currently pressed, used in determining whether
   * to handle a focus event as displaying the tooltip immediately.
   *
   * @type {boolean}
   */

  const [isMouseDown, setIsMouseDown] = (0,react.useState)(false);
  const [isOver, setIsOver] = (0,react.useState)(false);
  const delayedSetIsOver = (0,use_debounce/* default */.A)(setIsOver, delay); // Create a reference to the Tooltip's child, to be passed to the Popover
  // so that the Tooltip can be correctly positioned. Also, merge with the
  // existing ref for the first child, so that its ref is preserved.

  const childRef = (0,react.useRef)(null);
  const existingChildRef = (_Children$toArray$ = react.Children.toArray(children)[0]) === null || _Children$toArray$ === void 0 ? void 0 : _Children$toArray$.ref;
  const mergedChildRefs = (0,use_merge_refs/* default */.A)([childRef, existingChildRef]);

  const createMouseDown = event => {
    // In firefox, the mouse down event is also fired when the select
    // list is chosen.
    // Cancel further processing because re-rendering of child components
    // causes onChange to be triggered with the old value.
    // See https://github.com/WordPress/gutenberg/pull/42483
    if (event.target.tagName === 'OPTION') {
      return;
    } // Preserve original child callback behavior.


    emitToChild(children, 'onMouseDown', event); // On mouse down, the next `mouseup` should revert the value of the
    // instance property and remove its own event handler. The bind is
    // made on the document since the `mouseup` might not occur within
    // the bounds of the element.

    document.addEventListener('mouseup', cancelIsMouseDown);
    setIsMouseDown(true);
  };

  const createMouseUp = event => {
    // In firefox, the mouse up event is also fired when the select
    // list is chosen.
    // Cancel further processing because re-rendering of child components
    // causes onChange to be triggered with the old value.
    // See https://github.com/WordPress/gutenberg/pull/42483
    if (event.target.tagName === 'OPTION') {
      return;
    }

    emitToChild(children, 'onMouseUp', event);
    document.removeEventListener('mouseup', cancelIsMouseDown);
    setIsMouseDown(false);
  };

  const createMouseEvent = type => {
    if (type === 'mouseUp') return createMouseUp;
    if (type === 'mouseDown') return createMouseDown;
  };
  /**
   * Prebound `isInMouseDown` handler, created as a constant reference to
   * assure ability to remove in component unmount.
   *
   * @type {Function}
   */


  const cancelIsMouseDown = createMouseEvent('mouseUp');

  const createToggleIsOver = (eventName, isDelayed) => {
    return event => {
      // Preserve original child callback behavior.
      emitToChild(children, eventName, event); // Mouse events behave unreliably in React for disabled elements,
      // firing on mouseenter but not mouseleave.  Further, the default
      // behavior for disabled elements in some browsers is to ignore
      // mouse events. Don't bother trying to handle them.
      //
      // See: https://github.com/facebook/react/issues/4251

      if (event.currentTarget.disabled) {
        return;
      } // A focus event will occur as a result of a mouse click, but it
      // should be disambiguated between interacting with the button and
      // using an explicit focus shift as a cue to display the tooltip.


      if ('focus' === event.type && isMouseDown) {
        return;
      } // Needed in case unsetting is over while delayed set pending, i.e.
      // quickly blur/mouseleave before delayedSetIsOver is called.


      delayedSetIsOver.cancel();

      const _isOver = ['focus', 'mouseenter'].includes(event.type);

      if (_isOver === isOver) {
        return;
      }

      if (isDelayed) {
        delayedSetIsOver(_isOver);
      } else {
        setIsOver(_isOver);
      }
    };
  };

  const clearOnUnmount = () => {
    delayedSetIsOver.cancel();
    document.removeEventListener('mouseup', cancelIsMouseDown);
  };

  (0,react.useEffect)(() => clearOnUnmount, []);

  if (react.Children.count(children) !== 1) {
    if (false) {}

    return children;
  }

  const eventHandlers = {
    onMouseEnter: createToggleIsOver('onMouseEnter', true),
    onMouseLeave: createToggleIsOver('onMouseLeave'),
    onClick: createToggleIsOver('onClick'),
    onFocus: createToggleIsOver('onFocus'),
    onBlur: createToggleIsOver('onBlur'),
    onMouseDown: createMouseEvent('mouseDown')
  };
  const child = react.Children.only(children);
  const {
    children: grandchildren,
    disabled
  } = child.props;
  const getElementWithPopover = disabled ? getDisabledElement : getRegularElement;
  const popoverData = {
    anchorRef: childRef,
    isOver,
    offset: 4,
    position,
    shortcut,
    text
  };
  const childrenWithPopover = addPopoverToGrandchildren({
    grandchildren,
    ...popoverData
  });
  return getElementWithPopover({
    child,
    eventHandlers,
    childrenWithPopover,
    mergedRefs: mergedChildRefs
  });
}

/* harmony default export */ const tooltip = (Tooltip);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/dashicon/index.js



/**
 * @typedef OwnProps
 *
 * @property {import('./types').IconKey} icon        Icon name
 * @property {string}                    [className] Class name
 */

/** @typedef {import('react').ComponentPropsWithoutRef<'span'> & OwnProps} Props */

/**
 * @param {Props} props
 * @return {JSX.Element} Element
 */
function Dashicon(_ref) {
  let {
    icon,
    className,
    ...extraProps
  } = _ref;
  const iconClass = ['dashicon', 'dashicons', 'dashicons-' + icon, className].filter(Boolean).join(' ');
  return (0,react.createElement)("span", (0,helpers_esm_extends/* default */.A)({
    className: iconClass
  }, extraProps));
}

/* harmony default export */ const dashicon = (Dashicon);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/icon/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function Icon(_ref) {
  let {
    icon = null,
    size = 24,
    ...additionalProps
  } = _ref;

  if ('string' === typeof icon) {
    return (0,react.createElement)(dashicon, (0,helpers_esm_extends/* default */.A)({
      icon: icon
    }, additionalProps));
  }

  if ((0,react.isValidElement)(icon) && dashicon === icon.type) {
    return (0,react.cloneElement)(icon, { ...additionalProps
    });
  }

  if ('function' === typeof icon) {
    if (icon.prototype instanceof react.Component) {
      return (0,react.createElement)(icon, {
        size,
        ...additionalProps
      });
    }

    return icon({
      size,
      ...additionalProps
    });
  }

  if (icon && (icon.type === 'svg' || icon.type === svg/* SVG */.t4)) {
    const appliedProps = {
      width: size,
      height: size,
      ...icon.props,
      ...additionalProps
    };
    return (0,react.createElement)(svg/* SVG */.t4, appliedProps);
  }

  if ((0,react.isValidElement)(icon)) {
    return (0,react.cloneElement)(icon, {
      // @ts-ignore Just forwarding the size prop along
      size,
      ...additionalProps
    });
  }

  return icon;
}

/* harmony default export */ const build_module_icon = (Icon);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/context/context-system-provider.js
/* provided dependency */ var context_system_provider_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



const ComponentsContext = (0,react.createContext)(
/** @type {Record<string, any>} */
{});
const useComponentsContext = () => (0,react.useContext)(ComponentsContext);
/**
 * Runs an effect only on update (i.e., ignores the first render)
 *
 * @param {import('react').EffectCallback} effect
 * @param {import('react').DependencyList} deps
 */

function useUpdateEffect(effect, deps) {
  const mounted = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    if (mounted.current) {
      return effect();
    }

    mounted.current = true;
    return undefined;
  }, deps);
}
/**
 * Consolidates incoming ContextSystem values with a (potential) parent ContextSystem value.
 *
 * Note: This function will warn if it detects an un-memoized `value`
 *
 * @param {Object}              props
 * @param {Record<string, any>} props.value
 * @return {Record<string, any>} The consolidated value.
 */


function useContextSystemBridge(_ref) {
  let {
    value
  } = _ref;
  const parentContext = useComponentsContext();
  const valueRef = (0,react.useRef)(value);
  useUpdateEffect(() => {
    if ( // Objects are equivalent.
    (0,lodash.isEqual)(valueRef.current, value) && // But not the same reference.
    valueRef.current !== value) {
      typeof context_system_provider_process !== "undefined" && context_system_provider_process.env && "production" !== "production" ? 0 : void 0;
    }
  }, [value]); // `parentContext` will always be memoized (i.e., the result of this hook itself)
  // or the default value from when the `ComponentsContext` was originally
  // initialized (which will never change, it's a static variable)
  // so this memoization will prevent `merge` and `cloneDeep` from rerunning unless
  // the references to `value` change OR the `parentContext` has an actual material change
  // (because again, it's guaranteed to be memoized or a static reference to the empty object
  // so we know that the only changes for `parentContext` are material ones... i.e., why we
  // don't have to warn in the `useUpdateEffect` hook above for `parentContext` and we only
  // need to bother with the `value`). The `useUpdateEffect` above will ensure that we are
  // correctly warning when the `value` isn't being properly memoized. All of that to say
  // that this should be super safe to assume that `useMemo` will only run on actual
  // changes to the two dependencies, therefore saving us calls to `merge` and `cloneDeep`!

  const config = (0,react.useMemo)(() => {
    return (0,lodash.merge)((0,lodash.cloneDeep)(parentContext), value);
  }, [parentContext, value]);
  return config;
}
/**
 * A Provider component that can modify props for connected components within
 * the Context system.
 *
 * @example
 * ```jsx
 * <ContextSystemProvider value={{ Button: { size: 'small' }}}>
 *   <Button>...</Button>
 * </ContextSystemProvider>
 * ```
 *
 * @template {Record<string, any>} T
 * @param {Object}                    options
 * @param {import('react').ReactNode} options.children Children to render.
 * @param {T}                         options.value    Props to render into connected components.
 * @return {JSX.Element} A Provider wrapped component.
 */


const BaseContextSystemProvider = _ref2 => {
  let {
    children,
    value
  } = _ref2;
  const contextValue = useContextSystemBridge({
    value
  });
  return (0,react.createElement)(ComponentsContext.Provider, {
    value: contextValue
  }, children);
};

const ContextSystemProvider = (0,react.memo)(BaseContextSystemProvider);
//# sourceMappingURL=context-system-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/context/constants.js
const REACT_TYPEOF_KEY = '$$typeof';
const COMPONENT_NAMESPACE = 'data-wp-component';
const CONNECTED_NAMESPACE = 'data-wp-c16t';
const CONTEXT_COMPONENT_NAMESPACE = 'data-wp-c5tc8t';
/**
 * Special key where the connected namespaces are stored.
 * This is attached to Context connected components as a static property.
 */

const CONNECT_STATIC_NAMESPACE = '__contextSystemKey__';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/context/utils.js
/**
 * Internal dependencies
 */

/**
 * Creates a dedicated context namespace HTML attribute for components.
 * ns is short for "namespace"
 *
 * @example
 * ```jsx
 * <div {...ns('Container')} />
 * ```
 *
 * @param {string} componentName The name for the component.
 * @return {Record<string, any>} A props object with the namespaced HTML attribute.
 */

function getNamespace(componentName) {
  return {
    [COMPONENT_NAMESPACE]: componentName
  };
}
/**
 * Creates a dedicated connected context namespace HTML attribute for components.
 * ns is short for "namespace"
 *
 * @example
 * ```jsx
 * <div {...cns()} />
 * ```
 *
 * @return {Record<string, any>} A props object with the namespaced HTML attribute.
 */

function getConnectedNamespace() {
  return {
    [CONNECTED_NAMESPACE]: true
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/context/get-styled-class-name-from-key.js
/**
 * External dependencies
 */


/**
 * Generates the connected component CSS className based on the namespace.
 *
 * @param  namespace The name of the connected component.
 * @return The generated CSS className.
 */

function getStyledClassName(namespace) {
  const kebab = (0,lodash.kebabCase)(namespace);
  return `components-${kebab}`;
}

const getStyledClassNameFromKey = memize_default()(getStyledClassName);
//# sourceMappingURL=get-styled-class-name-from-key.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+utils@1.2.1/node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var emotion_utils_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+utils@1.2.1/node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+css@11.11.2/node_modules/@emotion/css/dist/emotion-css.esm.js + 1 modules
var emotion_css_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+css@11.11.2/node_modules/@emotion/css/dist/emotion-css.esm.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js
/**
 * External dependencies
 */

 // eslint-disable-next-line no-restricted-imports


/**
 * WordPress dependencies
 */



const isSerializedStyles = o => typeof o !== 'undefined' && o !== null && ['name', 'styles'].every(p => typeof o[p] !== 'undefined');
/**
 * Retrieve a `cx` function that knows how to handle `SerializedStyles`
 * returned by the `@emotion/react` `css` function in addition to what
 * `cx` normally knows how to handle. It also hooks into the Emotion
 * Cache, allowing `css` calls to work inside iframes.
 *
 * @example
 * import { css } from '@emotion/react';
 *
 * const styles = css`
 * 	color: red
 * `;
 *
 * function RedText( { className, ...props } ) {
 * 	const cx = useCx();
 *
 * 	const classes = cx(styles, className);
 *
 * 	return <span className={classes} {...props} />;
 * }
 */


const useCx = () => {
  const cache = (0,emotion_element_c39617d8_browser_esm._)();
  const cx = (0,react.useCallback)(function () {
    if (cache === null) {
      throw new Error('The `useCx` hook should be only used within a valid Emotion Cache Context');
    }

    for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {
      classNames[_key] = arguments[_key];
    }

    return (0,emotion_css_esm.cx)(...classNames.map(arg => {
      if (isSerializedStyles(arg)) {
        (0,emotion_utils_browser_esm/* insertStyles */.sk)(cache, arg, false);
        return `${cache.key}-${arg.name}`;
      }

      return arg;
    }));
  }, [cache]);
  return cx;
};
//# sourceMappingURL=use-cx.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/context/use-context-system.js
/* provided dependency */ var use_context_system_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





/**
 * @template TProps
 * @typedef {TProps & { className: string }} ConnectedProps
 */

/**
 * Custom hook that derives registered props from the Context system.
 * These derived props are then consolidated with incoming component props.
 *
 * @template {{ className?: string }} P
 * @param {P}      props     Incoming props from the component.
 * @param {string} namespace The namespace to register and to derive context props from.
 * @return {ConnectedProps<P>} The connected props.
 */

function useContextSystem(props, namespace) {
  const contextSystemProps = useComponentsContext();

  if (typeof namespace === 'undefined') {
    typeof use_context_system_process !== "undefined" && use_context_system_process.env && "production" !== "production" ? 0 : void 0;
  }

  const contextProps = (contextSystemProps === null || contextSystemProps === void 0 ? void 0 : contextSystemProps[namespace]) || {};
  /* eslint-disable jsdoc/no-undefined-types */

  /** @type {ConnectedProps<P>} */
  // @ts-ignore We fill in the missing properties below

  const finalComponentProps = { ...getConnectedNamespace(),
    ...getNamespace(namespace)
  };
  /* eslint-enable jsdoc/no-undefined-types */

  const {
    _overrides: overrideProps,
    ...otherContextProps
  } = contextProps;
  const initialMergedProps = Object.entries(otherContextProps).length ? Object.assign({}, otherContextProps, props) : props;
  const cx = useCx();
  const classes = cx(getStyledClassNameFromKey(namespace), props.className); // Provides the ability to customize the render of the component.

  const rendered = typeof initialMergedProps.renderChildren === 'function' ? initialMergedProps.renderChildren(initialMergedProps) : initialMergedProps.children;

  for (const key in initialMergedProps) {
    // @ts-ignore filling in missing props
    finalComponentProps[key] = initialMergedProps[key];
  }

  for (const key in overrideProps) {
    // @ts-ignore filling in missing props
    finalComponentProps[key] = overrideProps[key];
  } // Setting an `undefined` explicitly can cause unintended overwrites
  // when a `cloneElement()` is involved.


  if (rendered !== undefined) {
    // @ts-ignore
    finalComponentProps.children = rendered;
  }

  finalComponentProps.className = classes;
  return finalComponentProps;
}
//# sourceMappingURL=use-context-system.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/context/context-connect.js
/* provided dependency */ var context_connect_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Forwards ref (React.ForwardRef) and "Connects" (or registers) a component
 * within the Context system under a specified namespace.
 *
 * This is an (experimental) evolution of the initial connect() HOC.
 * The hope is that we can improve render performance by removing functional
 * component wrappers.
 *
 * @param  Component The component to register into the Context system.
 * @param  namespace The namespace to register the component under.
 * @param  options
 * @return The connected WordPressComponent
 */
function contextConnect(Component, namespace) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    memo: memoProp = false
  } = options;
  let WrappedComponent = (0,react.forwardRef)(Component);

  if (memoProp) {
    // @ts-ignore
    WrappedComponent = (0,react.memo)(WrappedComponent);
  }

  if (typeof namespace === 'undefined') {
    typeof context_connect_process !== "undefined" && context_connect_process.env && "production" !== "production" ? 0 : void 0;
  } // @ts-ignore internal property


  let mergedNamespace = WrappedComponent[CONNECT_STATIC_NAMESPACE] || [namespace];
  /**
   * Consolidate (merge) namespaces before attaching it to the WrappedComponent.
   */

  if (Array.isArray(namespace)) {
    mergedNamespace = [...mergedNamespace, ...namespace];
  }

  if (typeof namespace === 'string') {
    mergedNamespace = [...mergedNamespace, namespace];
  }

  WrappedComponent.displayName = namespace; // @ts-ignore internal property

  WrappedComponent[CONNECT_STATIC_NAMESPACE] = [...new Set(mergedNamespace)]; // @ts-ignore WordPressComponent property

  WrappedComponent.selector = `.${getStyledClassNameFromKey(namespace)}`; // @ts-ignore

  return WrappedComponent;
}
/**
 * Attempts to retrieve the connected namespace from a component.
 *
 * @param  Component The component to retrieve a namespace from.
 * @return The connected namespaces.
 */

function getConnectNamespace(Component) {
  if (!Component) return [];
  let namespaces = []; // @ts-ignore internal property

  if (Component[CONNECT_STATIC_NAMESPACE]) {
    // @ts-ignore internal property
    namespaces = Component[CONNECT_STATIC_NAMESPACE];
  } // @ts-ignore


  if (Component.type && Component.type[CONNECT_STATIC_NAMESPACE]) {
    // @ts-ignore
    namespaces = Component.type[CONNECT_STATIC_NAMESPACE];
  }

  return namespaces;
}
/**
 * Checks to see if a component is connected within the Context system.
 *
 * @param  Component The component to retrieve a namespace from.
 * @param  match     The namespace to check.
 */

function hasConnectNamespace(Component, match) {
  if (!Component) return false;

  if (typeof match === 'string') {
    return getConnectNamespace(Component).includes(match);
  }

  if (Array.isArray(match)) {
    return match.some(result => getConnectNamespace(Component).includes(result));
  }

  return false;
}
//# sourceMappingURL=context-connect.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/visually-hidden/styles.js
/**
 * External dependencies
 */
const visuallyHidden = {
  border: 0,
  clip: 'rect(1px, 1px, 1px, 1px)',
  WebkitClipPath: 'inset( 50% )',
  clipPath: 'inset( 50% )',
  height: '1px',
  margin: '-1px',
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  width: '1px',
  wordWrap: 'normal'
};
//# sourceMappingURL=styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@17.0.71_react@17.0.2__@types+react@17.0.71_react@17.0.2/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
var emotion_styled_base_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+styled@11.11.0_@emotion+react@11.11.1_@types+react@17.0.71_react@17.0.2__@types+react@17.0.71_react@17.0.2/node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/view/component.js


/**
 * External dependencies
 */

/**
 * `View` is a core component that renders everything in the library.
 * It is the principle component in the entire library.
 *
 * @example
 * ```jsx
 * import { View } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<View>
 * 			 Code is Poetry
 * 		</View>
 * 	);
 * }
 * ```
 *
 * @type {import('../ui/context').WordPressComponent<'div', { children?: import('react').ReactNode }, true>}
 */
// @ts-ignore
const View = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "em57xhy0"
} : 0)( true ? "" : 0);

View.selector = '.components-view';
View.displayName = 'View';
/* harmony default export */ const component = (View);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/visually-hidden/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedVisuallyHidden(props, forwardedRef) {
  const {
    style: styleProp,
    ...contextProps
  } = useContextSystem(props, 'VisuallyHidden');
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({
    ref: forwardedRef
  }, contextProps, {
    style: { ...visuallyHidden,
      ...(styleProp || {})
    }
  }));
}
/**
 * `VisuallyHidden` is a component used to render text intended to be visually
 * hidden, but will show for alternate devices, for example a screen reader.
 *
 * ```jsx
 * import { VisuallyHidden } from `@wordpress/components`;
 *
 * function Example() {
 *   return (
 *     <VisuallyHidden>
 *       <label>Code is Poetry</label>
 *     </VisuallyHidden>
 *   );
 * }
 * ```
 */


const VisuallyHidden = contextConnect(UnconnectedVisuallyHidden, 'VisuallyHidden');
/* harmony default export */ const visually_hidden_component = (VisuallyHidden);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/button/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const disabledEventsOnDisabledButton = ['onMouseDown', 'onClick'];

function useDeprecatedProps(_ref) {
  let {
    isDefault,
    isPrimary,
    isSecondary,
    isTertiary,
    isLink,
    variant,
    ...otherProps
  } = _ref;
  let computedVariant = variant;

  if (isPrimary) {
    var _computedVariant;

    (_computedVariant = computedVariant) !== null && _computedVariant !== void 0 ? _computedVariant : computedVariant = 'primary';
  }

  if (isTertiary) {
    var _computedVariant2;

    (_computedVariant2 = computedVariant) !== null && _computedVariant2 !== void 0 ? _computedVariant2 : computedVariant = 'tertiary';
  }

  if (isSecondary) {
    var _computedVariant3;

    (_computedVariant3 = computedVariant) !== null && _computedVariant3 !== void 0 ? _computedVariant3 : computedVariant = 'secondary';
  }

  if (isDefault) {
    var _computedVariant4;

    (0,deprecated_build_module/* default */.A)('Button isDefault prop', {
      since: '5.4',
      alternative: 'variant="secondary"',
      version: '6.2'
    });
    (_computedVariant4 = computedVariant) !== null && _computedVariant4 !== void 0 ? _computedVariant4 : computedVariant = 'secondary';
  }

  if (isLink) {
    var _computedVariant5;

    (_computedVariant5 = computedVariant) !== null && _computedVariant5 !== void 0 ? _computedVariant5 : computedVariant = 'link';
  }

  return { ...otherProps,
    variant: computedVariant
  };
}

function Button(props, ref) {
  const {
    href,
    target,
    isSmall,
    isPressed,
    isBusy,
    isDestructive,
    className,
    disabled,
    icon,
    iconPosition = 'left',
    iconSize,
    showTooltip,
    tooltipPosition,
    shortcut,
    label,
    children,
    text,
    variant,
    __experimentalIsFocusable: isFocusable,
    describedBy,
    ...additionalProps
  } = useDeprecatedProps(props);
  const instanceId = (0,use_instance_id/* default */.A)(Button, 'components-button__description');
  const classes = classnames_default()('components-button', className, {
    'is-secondary': variant === 'secondary',
    'is-primary': variant === 'primary',
    'is-small': isSmall,
    'is-tertiary': variant === 'tertiary',
    'is-pressed': isPressed,
    'is-busy': isBusy,
    'is-link': variant === 'link',
    'is-destructive': isDestructive,
    'has-text': !!icon && !!children,
    'has-icon': !!icon
  });
  const trulyDisabled = disabled && !isFocusable;
  const Tag = href !== undefined && !trulyDisabled ? 'a' : 'button';
  const tagProps = Tag === 'a' ? {
    href,
    target
  } : {
    type: 'button',
    disabled: trulyDisabled,
    'aria-pressed': isPressed
  };

  if (disabled && isFocusable) {
    // In this case, the button will be disabled, but still focusable and
    // perceivable by screen reader users.
    tagProps['aria-disabled'] = true;

    for (const disabledEvent of disabledEventsOnDisabledButton) {
      additionalProps[disabledEvent] = event => {
        event.stopPropagation();
        event.preventDefault();
      };
    }
  } // Should show the tooltip if...


  const shouldShowTooltip = !trulyDisabled && ( // An explicit tooltip is passed or...
  showTooltip && label || // There's a shortcut or...
  shortcut || // There's a label and...
  !!label && // The children are empty and...
  !(children !== null && children !== void 0 && children.length) && // The tooltip is not explicitly disabled.
  false !== showTooltip);
  const descriptionId = describedBy ? instanceId : null;
  const describedById = additionalProps['aria-describedby'] || descriptionId;
  const element = (0,react.createElement)(Tag, (0,helpers_esm_extends/* default */.A)({}, tagProps, additionalProps, {
    className: classes,
    "aria-label": additionalProps['aria-label'] || label,
    "aria-describedby": describedById,
    ref: ref
  }), icon && iconPosition === 'left' && (0,react.createElement)(build_module_icon, {
    icon: icon,
    size: iconSize
  }), text && (0,react.createElement)(react.Fragment, null, text), icon && iconPosition === 'right' && (0,react.createElement)(build_module_icon, {
    icon: icon,
    size: iconSize
  }), children);

  if (!shouldShowTooltip) {
    return (0,react.createElement)(react.Fragment, null, element, describedBy && (0,react.createElement)(visually_hidden_component, null, (0,react.createElement)("span", {
      id: descriptionId
    }, describedBy)));
  }

  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(tooltip, {
    text: children !== null && children !== void 0 && children.length && describedBy ? describedBy : label,
    shortcut: shortcut,
    position: tooltipPosition
  }, element), describedBy && (0,react.createElement)(visually_hidden_component, null, (0,react.createElement)("span", {
    id: descriptionId
  }, describedBy)));
}
/* harmony default export */ const build_module_button = ((0,react.forwardRef)(Button));
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Toolbar/ToolbarItem.js
var ToolbarItem = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Toolbar/ToolbarItem.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-item/index.js
/* provided dependency */ var toolbar_item_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function toolbar_item_ToolbarItem(_ref, ref) {
  let {
    children,
    as: Component,
    ...props
  } = _ref;
  const accessibleToolbarState = (0,react.useContext)(toolbar_context);

  if (typeof children !== 'function' && !Component) {
    typeof toolbar_item_process !== "undefined" && toolbar_item_process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  const allProps = { ...props,
    ref,
    'data-toolbar-item': true
  };

  if (!accessibleToolbarState) {
    if (Component) {
      return (0,react.createElement)(Component, allProps, children);
    }

    return children(allProps);
  }

  return (0,react.createElement)(ToolbarItem/* ToolbarItem */.T, (0,helpers_esm_extends/* default */.A)({}, accessibleToolbarState, allProps, {
    as: Component
  }), children);
}

/* harmony default export */ const toolbar_item = ((0,react.forwardRef)(toolbar_item_ToolbarItem));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-button/toolbar-button-container.js


const ToolbarButtonContainer = props => (0,react.createElement)("div", {
  className: props.className
}, props.children);

/* harmony default export */ const toolbar_button_container = (ToolbarButtonContainer);
//# sourceMappingURL=toolbar-button-container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-button/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






function ToolbarButton(_ref, ref) {
  let {
    containerClassName,
    className,
    extraProps,
    children,
    title,
    isActive,
    isDisabled,
    ...props
  } = _ref;
  const accessibleToolbarState = (0,react.useContext)(toolbar_context);

  if (!accessibleToolbarState) {
    return (0,react.createElement)(toolbar_button_container, {
      className: containerClassName
    }, (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
      ref: ref,
      icon: props.icon,
      label: title,
      shortcut: props.shortcut,
      "data-subscript": props.subscript,
      onClick: event => {
        event.stopPropagation();

        if (props.onClick) {
          props.onClick(event);
        }
      },
      className: classnames_default()('components-toolbar__control', className),
      isPressed: isActive,
      disabled: isDisabled,
      "data-toolbar-item": true
    }, extraProps, props), children));
  } // ToobarItem will pass all props to the render prop child, which will pass
  // all props to Button. This means that ToolbarButton has the same API as
  // Button.


  return (0,react.createElement)(toolbar_item, (0,helpers_esm_extends/* default */.A)({
    className: classnames_default()('components-toolbar-button', className)
  }, extraProps, props, {
    ref: ref
  }), toolbarItemProps => (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    label: title,
    isPressed: isActive,
    disabled: isDisabled
  }, toolbarItemProps), children));
}

/* harmony default export */ const toolbar_button = ((0,react.forwardRef)(ToolbarButton));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-group/toolbar-group-container.js



const ToolbarGroupContainer = _ref => {
  let {
    className,
    children,
    ...props
  } = _ref;
  return (0,react.createElement)("div", (0,helpers_esm_extends/* default */.A)({
    className: className
  }, props), children);
};

/* harmony default export */ const toolbar_group_container = (ToolbarGroupContainer);
//# sourceMappingURL=toolbar-group-container.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/index.js + 3 modules
var i18n_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@3.57.0/node_modules/@wordpress/keycodes/build-module/platform.js
/**
 * Return true if platform is MacOS.
 *
 * @param {Window?} _window window object by default; used for DI testing.
 *
 * @return {boolean} True if MacOS; false otherwise.
 */
function isAppleOS(_window = null) {
  if (!_window) {
    if (typeof window === 'undefined') {
      return false;
    }
    _window = window;
  }
  const {
    platform
  } = _window.navigator;
  return platform.indexOf('Mac') !== -1 || ['iPad', 'iPhone'].includes(platform);
}
//# sourceMappingURL=platform.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@3.57.0/node_modules/@wordpress/keycodes/build-module/index.js
/**
 * Note: The order of the modifier keys in many of the [foo]Shortcut()
 * functions in this file are intentional and should not be changed. They're
 * designed to fit with the standard menu keyboard shortcuts shown in the
 * user's platform.
 *
 * For example, on MacOS menu shortcuts will place Shift before Command, but
 * on Windows Control will usually come first. So don't provide your own
 * shortcut combos directly to keyboardShortcut().
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {typeof ALT | CTRL | COMMAND | SHIFT } WPModifierPart */

/** @typedef {'primary' | 'primaryShift' | 'primaryAlt' | 'secondary' | 'access' | 'ctrl' | 'alt' | 'ctrlShift' | 'shift' | 'shiftAlt' | 'undefined'} WPKeycodeModifier */

/**
 * An object of handler functions for each of the possible modifier
 * combinations. A handler will return a value for a given key.
 *
 * @template T
 *
 * @typedef {Record<WPKeycodeModifier, T>} WPModifierHandler
 */

/**
 * @template T
 *
 * @typedef {(character: string, isApple?: () => boolean) => T} WPKeyHandler
 */
/** @typedef {(event: import('react').KeyboardEvent<HTMLElement> | KeyboardEvent, character: string, isApple?: () => boolean) => boolean} WPEventKeyHandler */

/** @typedef {( isApple: () => boolean ) => WPModifierPart[]} WPModifier */

/**
 * Keycode for BACKSPACE key.
 */
const BACKSPACE = 8;

/**
 * Keycode for TAB key.
 */
const TAB = 9;

/**
 * Keycode for ENTER key.
 */
const ENTER = 13;

/**
 * Keycode for ESCAPE key.
 */
const ESCAPE = 27;

/**
 * Keycode for SPACE key.
 */
const SPACE = 32;

/**
 * Keycode for PAGEUP key.
 */
const PAGEUP = 33;

/**
 * Keycode for PAGEDOWN key.
 */
const PAGEDOWN = 34;

/**
 * Keycode for END key.
 */
const END = 35;

/**
 * Keycode for HOME key.
 */
const HOME = 36;

/**
 * Keycode for LEFT key.
 */
const LEFT = 37;

/**
 * Keycode for UP key.
 */
const UP = 38;

/**
 * Keycode for RIGHT key.
 */
const RIGHT = 39;

/**
 * Keycode for DOWN key.
 */
const DOWN = 40;

/**
 * Keycode for DELETE key.
 */
const DELETE = 46;

/**
 * Keycode for F10 key.
 */
const F10 = 121;

/**
 * Keycode for ALT key.
 */
const ALT = 'alt';

/**
 * Keycode for CTRL key.
 */
const CTRL = 'ctrl';

/**
 * Keycode for COMMAND/META key.
 */
const COMMAND = 'meta';

/**
 * Keycode for SHIFT key.
 */
const SHIFT = 'shift';

/**
 * Keycode for ZERO key.
 */
const ZERO = 48;


/**
 * Capitalise the first character of a string.
 * @param {string} string String to capitalise.
 * @return {string} Capitalised string.
 */
function capitaliseFirstCharacter(string) {
  return string.length < 2 ? string.toUpperCase() : string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Map the values of an object with a specified callback and return the result object.
 *
 * @template {{ [s: string]: any; } | ArrayLike<any>} T
 *
 * @param {T}                     object Object to map values of.
 * @param {( value: any ) => any} mapFn  Mapping function
 *
 * @return {any} Active modifier constants.
 */
function mapValues(object, mapFn) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, mapFn(value)]));
}

/**
 * Object that contains functions that return the available modifier
 * depending on platform.
 *
 * @type {WPModifierHandler< ( isApple: () => boolean ) => WPModifierPart[]>}
 */
const modifiers = {
  primary: _isApple => _isApple() ? [COMMAND] : [CTRL],
  primaryShift: _isApple => _isApple() ? [SHIFT, COMMAND] : [CTRL, SHIFT],
  primaryAlt: _isApple => _isApple() ? [ALT, COMMAND] : [CTRL, ALT],
  secondary: _isApple => _isApple() ? [SHIFT, ALT, COMMAND] : [CTRL, SHIFT, ALT],
  access: _isApple => _isApple() ? [CTRL, ALT] : [SHIFT, ALT],
  ctrl: () => [CTRL],
  alt: () => [ALT],
  ctrlShift: () => [CTRL, SHIFT],
  shift: () => [SHIFT],
  shiftAlt: () => [SHIFT, ALT],
  undefined: () => []
};

/**
 * An object that contains functions to get raw shortcuts.
 *
 * These are intended for user with the KeyboardShortcuts.
 *
 * @example
 * ```js
 * // Assuming macOS:
 * rawShortcut.primary( 'm' )
 * // "meta+m""
 * ```
 *
 * @type {WPModifierHandler<WPKeyHandler<string>>} Keyed map of functions to raw
 *                                                 shortcuts.
 */
const rawShortcut = mapValues(modifiers, ( /** @type {WPModifier} */modifier) => {
  return /** @type {WPKeyHandler<string>} */(character, _isApple = isAppleOS) => {
    return [...modifier(_isApple), character.toLowerCase()].join('+');
  };
});

/**
 * Return an array of the parts of a keyboard shortcut chord for display.
 *
 * @example
 * ```js
 * // Assuming macOS:
 * displayShortcutList.primary( 'm' );
 * // [ "⌘", "M" ]
 * ```
 *
 * @type {WPModifierHandler<WPKeyHandler<string[]>>} Keyed map of functions to
 *                                                   shortcut sequences.
 */
const displayShortcutList = mapValues(modifiers, ( /** @type {WPModifier} */modifier) => {
  return /** @type {WPKeyHandler<string[]>} */(character, _isApple = isAppleOS) => {
    const isApple = _isApple();
    const replacementKeyMap = {
      [ALT]: isApple ? '⌥' : 'Alt',
      [CTRL]: isApple ? '⌃' : 'Ctrl',
      // Make sure ⌃ is the U+2303 UP ARROWHEAD unicode character and not the caret character.
      [COMMAND]: '⌘',
      [SHIFT]: isApple ? '⇧' : 'Shift'
    };
    const modifierKeys = modifier(_isApple).reduce((accumulator, key) => {
      var _replacementKeyMap$ke;
      const replacementKey = (_replacementKeyMap$ke = replacementKeyMap[key]) !== null && _replacementKeyMap$ke !== void 0 ? _replacementKeyMap$ke : key;
      // If on the Mac, adhere to platform convention and don't show plus between keys.
      if (isApple) {
        return [...accumulator, replacementKey];
      }
      return [...accumulator, replacementKey, '+'];
    }, /** @type {string[]} */[]);
    return [...modifierKeys, capitaliseFirstCharacter(character)];
  };
});

/**
 * An object that contains functions to display shortcuts.
 *
 * @example
 * ```js
 * // Assuming macOS:
 * displayShortcut.primary( 'm' );
 * // "⌘M"
 * ```
 *
 * @type {WPModifierHandler<WPKeyHandler<string>>} Keyed map of functions to
 *                                                 display shortcuts.
 */
const displayShortcut = mapValues(displayShortcutList, ( /** @type {WPKeyHandler<string[]>} */shortcutList) => {
  return /** @type {WPKeyHandler<string>} */(character, _isApple = isAppleOS) => shortcutList(character, _isApple).join('');
});

/**
 * An object that contains functions to return an aria label for a keyboard
 * shortcut.
 *
 * @example
 * ```js
 * // Assuming macOS:
 * shortcutAriaLabel.primary( '.' );
 * // "Command + Period"
 * ```
 *
 * @type {WPModifierHandler<WPKeyHandler<string>>} Keyed map of functions to
 *                                                 shortcut ARIA labels.
 */
const shortcutAriaLabel = mapValues(modifiers, ( /** @type {WPModifier} */modifier) => {
  return /** @type {WPKeyHandler<string>} */(character, _isApple = isAppleOS) => {
    const isApple = _isApple();
    /** @type {Record<string,string>} */
    const replacementKeyMap = {
      [SHIFT]: 'Shift',
      [COMMAND]: isApple ? 'Command' : 'Control',
      [CTRL]: 'Control',
      [ALT]: isApple ? 'Option' : 'Alt',
      /* translators: comma as in the character ',' */
      ',': (0,i18n_build_module.__)('Comma'),
      /* translators: period as in the character '.' */
      '.': (0,i18n_build_module.__)('Period'),
      /* translators: backtick as in the character '`' */
      '`': (0,i18n_build_module.__)('Backtick'),
      /* translators: tilde as in the character '~' */
      '~': (0,i18n_build_module.__)('Tilde')
    };
    return [...modifier(_isApple), character].map(key => {
      var _replacementKeyMap$ke2;
      return capitaliseFirstCharacter((_replacementKeyMap$ke2 = replacementKeyMap[key]) !== null && _replacementKeyMap$ke2 !== void 0 ? _replacementKeyMap$ke2 : key);
    }).join(isApple ? ' ' : ' + ');
  };
});

/**
 * From a given KeyboardEvent, returns an array of active modifier constants for
 * the event.
 *
 * @param {import('react').KeyboardEvent<HTMLElement> | KeyboardEvent} event Keyboard event.
 *
 * @return {Array<WPModifierPart>} Active modifier constants.
 */
function getEventModifiers(event) {
  return /** @type {WPModifierPart[]} */[ALT, CTRL, COMMAND, SHIFT].filter(key => event[( /** @type {'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'} */
  `${key}Key`)]);
}

/**
 * An object that contains functions to check if a keyboard event matches a
 * predefined shortcut combination.
 *
 * @example
 * ```js
 * // Assuming an event for ⌘M key press:
 * isKeyboardEvent.primary( event, 'm' );
 * // true
 * ```
 *
 * @type {WPModifierHandler<WPEventKeyHandler>} Keyed map of functions
 *                                                       to match events.
 */
const isKeyboardEvent = mapValues(modifiers, ( /** @type {WPModifier} */getModifiers) => {
  return /** @type {WPEventKeyHandler} */(event, character, _isApple = isAppleOS) => {
    const mods = getModifiers(_isApple);
    const eventMods = getEventModifiers(event);
    /** @type {Record<string,string>} */
    const replacementWithShiftKeyMap = {
      Comma: ',',
      Backslash: '\\',
      // Windows returns `\` for both IntlRo and IntlYen.
      IntlRo: '\\',
      IntlYen: '\\'
    };
    const modsDiff = mods.filter(mod => !eventMods.includes(mod));
    const eventModsDiff = eventMods.filter(mod => !mods.includes(mod));
    if (modsDiff.length > 0 || eventModsDiff.length > 0) {
      return false;
    }
    let key = event.key.toLowerCase();
    if (!character) {
      return mods.includes( /** @type {WPModifierPart} */key);
    }
    if (event.altKey && character.length === 1) {
      key = String.fromCharCode(event.keyCode).toLowerCase();
    }

    // `event.key` returns the value of the key pressed, taking into the state of
    // modifier keys such as `Shift`. If the shift key is pressed, a different
    // value may be returned depending on the keyboard layout. It is necessary to
    // convert to the physical key value that don't take into account keyboard
    // layout or modifier key state.
    if (event.shiftKey && character.length === 1 && replacementWithShiftKeyMap[event.code]) {
      key = replacementWithShiftKeyMap[event.code];
    }

    // For backwards compatibility.
    if (character === 'del') {
      character = 'delete';
    }
    return key === character.toLowerCase();
  };
});
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+primitives@3.45.0/node_modules/@wordpress/primitives/build-module/svg/index.js
var build_module_svg = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.45.0/node_modules/@wordpress/primitives/build-module/svg/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/menu.js

/**
 * WordPress dependencies
 */

const menu = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M5 5v1.5h14V5H5zm0 7.8h14v-1.5H5v1.5zM5 19h14v-1.5H5V19z"
}));
/* harmony default export */ const library_menu = (menu);
//# sourceMappingURL=menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/dropdown/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function useObservableState(initialState, onStateChange) {
  const [state, setState] = (0,react.useState)(initialState);
  return [state, value => {
    setState(value);

    if (onStateChange) {
      onStateChange(value);
    }
  }];
}

function Dropdown(props) {
  const {
    renderContent,
    renderToggle,
    className,
    contentClassName,
    expandOnMobile,
    headerTitle,
    focusOnMount,
    position,
    popoverProps,
    onClose,
    onToggle,
    style
  } = props;
  const containerRef = (0,react.useRef)();
  const [isOpen, setIsOpen] = useObservableState(false, onToggle);
  (0,react.useEffect)(() => () => {
    if (onToggle && isOpen) {
      onToggle(false);
    }
  }, [onToggle, isOpen]);

  function toggle() {
    setIsOpen(!isOpen);
  }
  /**
   * Closes the popover when focus leaves it unless the toggle was pressed or
   * focus has moved to a separate dialog. The former is to let the toggle
   * handle closing the popover and the latter is to preserve presence in
   * case a dialog has opened, allowing focus to return when it's dismissed.
   */


  function closeIfFocusOutside() {
    const {
      ownerDocument
    } = containerRef.current;
    const dialog = ownerDocument.activeElement.closest('[role="dialog"]');

    if (!containerRef.current.contains(ownerDocument.activeElement) && (!dialog || dialog.contains(containerRef.current))) {
      close();
    }
  }

  function close() {
    if (onClose) {
      onClose();
    }

    setIsOpen(false);
  }

  const args = {
    isOpen,
    onToggle: toggle,
    onClose: close
  };
  const hasAnchorRef = !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.anchorRef) || !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.getAnchorRect) || !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.anchorRect);
  return (0,react.createElement)("div", {
    className: classnames_default()('components-dropdown', className),
    ref: containerRef // Some UAs focus the closest focusable parent when the toggle is
    // clicked. Making this div focusable ensures such UAs will focus
    // it and `closeIfFocusOutside` can tell if the toggle was clicked.
    ,
    tabIndex: "-1",
    style: style
  }, renderToggle(args), isOpen && (0,react.createElement)(popover, (0,helpers_esm_extends/* default */.A)({
    position: position,
    onClose: close,
    onFocusOutside: closeIfFocusOutside,
    expandOnMobile: expandOnMobile,
    headerTitle: headerTitle,
    focusOnMount: focusOnMount // This value is used to ensure that the dropdowns
    // align with the editor header by default.
    ,
    offset: 13,
    anchorRef: !hasAnchorRef ? containerRef : undefined
  }, popoverProps, {
    className: classnames_default()('components-dropdown__content', popoverProps ? popoverProps.className : undefined, contentClassName)
  }), renderContent(args)));
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/index.js + 2 modules
var dom_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/navigable-container/container.js


// @ts-nocheck

/**
 * WordPress dependencies
 */



const noop = () => {};

const MENU_ITEM_ROLES = ['menuitem', 'menuitemradio', 'menuitemcheckbox'];

function cycleValue(value, total, offset) {
  const nextValue = value + offset;

  if (nextValue < 0) {
    return total + nextValue;
  } else if (nextValue >= total) {
    return nextValue - total;
  }

  return nextValue;
}

class NavigableContainer extends react.Component {
  constructor() {
    super(...arguments);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.bindContainer = this.bindContainer.bind(this);
    this.getFocusableContext = this.getFocusableContext.bind(this);
    this.getFocusableIndex = this.getFocusableIndex.bind(this);
  }

  componentDidMount() {
    // We use DOM event listeners instead of React event listeners
    // because we want to catch events from the underlying DOM tree
    // The React Tree can be different from the DOM tree when using
    // portals. Block Toolbars for instance are rendered in a separate
    // React Trees.
    this.container.addEventListener('keydown', this.onKeyDown);
    this.container.addEventListener('focus', this.onFocus);
  }

  componentWillUnmount() {
    this.container.removeEventListener('keydown', this.onKeyDown);
    this.container.removeEventListener('focus', this.onFocus);
  }

  bindContainer(ref) {
    const {
      forwardedRef
    } = this.props;
    this.container = ref;

    if (typeof forwardedRef === 'function') {
      forwardedRef(ref);
    } else if (forwardedRef && 'current' in forwardedRef) {
      forwardedRef.current = ref;
    }
  }

  getFocusableContext(target) {
    const {
      onlyBrowserTabstops
    } = this.props;
    const finder = onlyBrowserTabstops ? dom_build_module/* focus */.XC.tabbable : dom_build_module/* focus */.XC.focusable;
    const focusables = finder.find(this.container);
    const index = this.getFocusableIndex(focusables, target);

    if (index > -1 && target) {
      return {
        index,
        target,
        focusables
      };
    }

    return null;
  }

  getFocusableIndex(focusables, target) {
    const directIndex = focusables.indexOf(target);

    if (directIndex !== -1) {
      return directIndex;
    }
  }

  onKeyDown(event) {
    if (this.props.onKeyDown) {
      this.props.onKeyDown(event);
    }

    const {
      getFocusableContext
    } = this;
    const {
      cycle = true,
      eventToOffset,
      onNavigate = noop,
      stopNavigationEvents
    } = this.props;
    const offset = eventToOffset(event); // eventToOffset returns undefined if the event is not handled by the component.

    if (offset !== undefined && stopNavigationEvents) {
      // Prevents arrow key handlers bound to the document directly interfering.
      event.stopImmediatePropagation(); // When navigating a collection of items, prevent scroll containers
      // from scrolling. The preventDefault also prevents Voiceover from
      // 'handling' the event, as voiceover will try to use arrow keys
      // for highlighting text.

      const targetRole = event.target.getAttribute('role');

      if (MENU_ITEM_ROLES.includes(targetRole)) {
        event.preventDefault();
      }
    }

    if (!offset) {
      return;
    }

    const context = getFocusableContext(event.target.ownerDocument.activeElement);

    if (!context) {
      return;
    }

    const {
      index,
      focusables
    } = context;
    const nextIndex = cycle ? cycleValue(index, focusables.length, offset) : index + offset;

    if (nextIndex >= 0 && nextIndex < focusables.length) {
      focusables[nextIndex].focus();
      onNavigate(nextIndex, focusables[nextIndex]);
    }
  }

  render() {
    const {
      children,
      stopNavigationEvents,
      eventToOffset,
      onNavigate,
      onKeyDown,
      cycle,
      onlyBrowserTabstops,
      forwardedRef,
      ...restProps
    } = this.props;
    return (0,react.createElement)("div", (0,helpers_esm_extends/* default */.A)({
      ref: this.bindContainer
    }, restProps), children);
  }

}

const forwardedNavigableContainer = (props, ref) => {
  return (0,react.createElement)(NavigableContainer, (0,helpers_esm_extends/* default */.A)({}, props, {
    forwardedRef: ref
  }));
};

forwardedNavigableContainer.displayName = 'NavigableContainer';
/* harmony default export */ const container = ((0,react.forwardRef)(forwardedNavigableContainer));
//# sourceMappingURL=container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/navigable-container/menu.js


// @ts-nocheck

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function NavigableMenu(_ref, ref) {
  let {
    role = 'menu',
    orientation = 'vertical',
    ...rest
  } = _ref;

  const eventToOffset = evt => {
    const {
      keyCode
    } = evt;
    let next = [DOWN];
    let previous = [UP];

    if (orientation === 'horizontal') {
      next = [RIGHT];
      previous = [LEFT];
    }

    if (orientation === 'both') {
      next = [RIGHT, DOWN];
      previous = [LEFT, UP];
    }

    if (next.includes(keyCode)) {
      return 1;
    } else if (previous.includes(keyCode)) {
      return -1;
    } else if ([DOWN, UP, LEFT, RIGHT].includes(keyCode)) {
      // Key press should be handled, e.g. have event propagation and
      // default behavior handled by NavigableContainer but not result
      // in an offset.
      return 0;
    }
  };

  return (0,react.createElement)(container, (0,helpers_esm_extends/* default */.A)({
    ref: ref,
    stopNavigationEvents: true,
    onlyBrowserTabstops: false,
    role: role,
    "aria-orientation": role === 'presentation' ? null : orientation,
    eventToOffset: eventToOffset
  }, rest));
}
/* harmony default export */ const navigable_container_menu = ((0,react.forwardRef)(NavigableMenu));
//# sourceMappingURL=menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/dropdown-menu/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function mergeProps() {
  let defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const mergedProps = { ...defaultProps,
    ...props
  };

  if (props.className && defaultProps.className) {
    mergedProps.className = classnames_default()(props.className, defaultProps.className);
  }

  return mergedProps;
}
/**
 * Whether the argument is a function.
 *
 * @param {*} maybeFunc The argument to check.
 * @return {boolean} True if the argument is a function, false otherwise.
 */


function dropdown_menu_isFunction(maybeFunc) {
  return typeof maybeFunc === 'function';
}

function DropdownMenu(dropdownMenuProps) {
  const {
    children,
    className,
    controls,
    icon = library_menu,
    label,
    popoverProps,
    toggleProps,
    menuProps,
    disableOpenOnArrowDown = false,
    text,
    noIcons
  } = dropdownMenuProps;

  if (!(controls !== null && controls !== void 0 && controls.length) && !dropdown_menu_isFunction(children)) {
    return null;
  } // Normalize controls to nested array of objects (sets of controls)


  let controlSets;

  if (controls !== null && controls !== void 0 && controls.length) {
    controlSets = controls;

    if (!Array.isArray(controlSets[0])) {
      controlSets = [controlSets];
    }
  }

  const mergedPopoverProps = mergeProps({
    className: 'components-dropdown-menu__popover'
  }, popoverProps);
  return (0,react.createElement)(Dropdown, {
    className: classnames_default()('components-dropdown-menu', className),
    popoverProps: mergedPopoverProps,
    renderToggle: _ref => {
      var _toggleProps$showTool;

      let {
        isOpen,
        onToggle
      } = _ref;

      const openOnArrowDown = event => {
        if (disableOpenOnArrowDown) {
          return;
        }

        if (!isOpen && event.keyCode === DOWN) {
          event.preventDefault();
          onToggle();
        }
      };

      const mergedToggleProps = mergeProps({
        className: classnames_default()('components-dropdown-menu__toggle', {
          'is-opened': isOpen
        })
      }, toggleProps);
      return (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({}, mergedToggleProps, {
        icon: icon,
        onClick: event => {
          onToggle(event);

          if (mergedToggleProps.onClick) {
            mergedToggleProps.onClick(event);
          }
        },
        onKeyDown: event => {
          openOnArrowDown(event);

          if (mergedToggleProps.onKeyDown) {
            mergedToggleProps.onKeyDown(event);
          }
        },
        "aria-haspopup": "true",
        "aria-expanded": isOpen,
        label: label,
        text: text,
        showTooltip: (_toggleProps$showTool = toggleProps === null || toggleProps === void 0 ? void 0 : toggleProps.showTooltip) !== null && _toggleProps$showTool !== void 0 ? _toggleProps$showTool : true
      }), mergedToggleProps.children);
    },
    renderContent: props => {
      var _controlSets;

      const mergedMenuProps = mergeProps({
        'aria-label': label,
        className: classnames_default()('components-dropdown-menu__menu', {
          'no-icons': noIcons
        })
      }, menuProps);
      return (0,react.createElement)(navigable_container_menu, (0,helpers_esm_extends/* default */.A)({}, mergedMenuProps, {
        role: "menu"
      }), dropdown_menu_isFunction(children) ? children(props) : null, (_controlSets = controlSets) === null || _controlSets === void 0 ? void 0 : _controlSets.flatMap((controlSet, indexOfSet) => controlSet.map((control, indexOfControl) => (0,react.createElement)(build_module_button, {
        key: [indexOfSet, indexOfControl].join(),
        onClick: event => {
          event.stopPropagation();
          props.onClose();

          if (control.onClick) {
            control.onClick();
          }
        },
        className: classnames_default()('components-dropdown-menu__menu-item', {
          'has-separator': indexOfSet > 0 && indexOfControl === 0,
          'is-active': control.isActive,
          'is-icon-only': !control.title
        }),
        icon: control.icon,
        label: control.label,
        "aria-checked": control.role === 'menuitemcheckbox' || control.role === 'menuitemradio' ? control.isActive : undefined,
        role: control.role === 'menuitemcheckbox' || control.role === 'menuitemradio' ? control.role : 'menuitem',
        disabled: control.isDisabled
      }, control.title))));
    }
  });
}

/* harmony default export */ const dropdown_menu = (DropdownMenu);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-group/toolbar-group-collapsed.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





function ToolbarGroupCollapsed(_ref) {
  let {
    controls = [],
    toggleProps,
    ...props
  } = _ref;
  // It'll contain state if `ToolbarGroup` is being used within
  // `<Toolbar label="label" />`
  const accessibleToolbarState = (0,react.useContext)(toolbar_context);

  const renderDropdownMenu = internalToggleProps => (0,react.createElement)(dropdown_menu, (0,helpers_esm_extends/* default */.A)({
    controls: controls,
    toggleProps: { ...internalToggleProps,
      'data-toolbar-item': true
    }
  }, props));

  if (accessibleToolbarState) {
    return (0,react.createElement)(toolbar_item, toggleProps, renderDropdownMenu);
  }

  return renderDropdownMenu(toggleProps);
}

/* harmony default export */ const toolbar_group_collapsed = (ToolbarGroupCollapsed);
//# sourceMappingURL=toolbar-group-collapsed.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-group/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/**
 * Renders a collapsible group of controls
 *
 * The `controls` prop accepts an array of sets. A set is an array of controls.
 * Controls have the following shape:
 *
 * ```
 * {
 *   icon: string,
 *   title: string,
 *   subscript: string,
 *   onClick: Function,
 *   isActive: boolean,
 *   isDisabled: boolean
 * }
 * ```
 *
 * For convenience it is also possible to pass only an array of controls. It is
 * then assumed this is the only set.
 *
 * Either `controls` or `children` is required, otherwise this components
 * renders nothing.
 *
 * @param {Object}    props               Component props.
 * @param {Array}     [props.controls]    The controls to render in this toolbar.
 * @param {WPElement} [props.children]    Any other things to render inside the toolbar besides the controls.
 * @param {string}    [props.className]   Class to set on the container div.
 * @param {boolean}   [props.isCollapsed] Turns ToolbarGroup into a dropdown menu.
 * @param {string}    [props.title]       ARIA label for dropdown menu if is collapsed.
 */

function ToolbarGroup(_ref) {
  var _controlSets;

  let {
    controls = [],
    children,
    className,
    isCollapsed,
    title,
    ...props
  } = _ref;
  // It'll contain state if `ToolbarGroup` is being used within
  // `<Toolbar label="label" />`
  const accessibleToolbarState = (0,react.useContext)(toolbar_context);

  if ((!controls || !controls.length) && !children) {
    return null;
  }

  const finalClassName = classnames_default()( // Unfortunately, there's legacy code referencing to `.components-toolbar`
  // So we can't get rid of it
  accessibleToolbarState ? 'components-toolbar-group' : 'components-toolbar', className); // Normalize controls to nested array of objects (sets of controls)

  let controlSets = controls;

  if (!Array.isArray(controlSets[0])) {
    controlSets = [controlSets];
  }

  if (isCollapsed) {
    return (0,react.createElement)(toolbar_group_collapsed, (0,helpers_esm_extends/* default */.A)({
      label: title,
      controls: controlSets,
      className: finalClassName,
      children: children
    }, props));
  }

  return (0,react.createElement)(toolbar_group_container, (0,helpers_esm_extends/* default */.A)({
    className: finalClassName
  }, props), (_controlSets = controlSets) === null || _controlSets === void 0 ? void 0 : _controlSets.flatMap((controlSet, indexOfSet) => controlSet.map((control, indexOfControl) => (0,react.createElement)(toolbar_button, (0,helpers_esm_extends/* default */.A)({
    key: [indexOfSet, indexOfControl].join(),
    containerClassName: indexOfSet > 0 && indexOfControl === 0 ? 'has-left-divider' : null
  }, control)))), children);
}

/* harmony default export */ const toolbar_group = (ToolbarGroup);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/use-memo-one@1.1.3_react@17.0.2/node_modules/use-memo-one/dist/use-memo-one.esm.js
var use_memo_one_esm = __webpack_require__("../../node_modules/.pnpm/use-memo-one@1.1.3_react@17.0.2/node_modules/use-memo-one/dist/use-memo-one.esm.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+priority-queue@2.47.0/node_modules/@wordpress/priority-queue/build-module/index.js + 1 modules
var priority_queue_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+priority-queue@2.47.0/node_modules/@wordpress/priority-queue/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@4.24.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js + 2 modules
var is_shallow_equal_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+is-shallow-equal@4.24.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-isomorphic-layout-effect/index.js
var use_isomorphic_layout_effect = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-isomorphic-layout-effect/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/default-registry.js
var default_registry = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/default-registry.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/context.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const Context = (0,react.createContext)(default_registry/* default */.A);
const {
  Consumer,
  Provider: context_Provider
} = Context;
/**
 * A custom react Context consumer exposing the provided `registry` to
 * children components. Used along with the RegistryProvider.
 *
 * You can read more about the react context api here:
 * https://reactjs.org/docs/context.html#contextprovider
 *
 * @example
 * ```js
 * import {
 *   RegistryProvider,
 *   RegistryConsumer,
 *   createRegistry
 * } from '@wordpress/data';
 *
 * const registry = createRegistry( {} );
 *
 * const App = ( { props } ) => {
 *   return <RegistryProvider value={ registry }>
 *     <div>Hello There</div>
 *     <RegistryConsumer>
 *       { ( registry ) => (
 *         <ComponentUsingRegistry
 *         		{ ...props }
 *         	  registry={ registry }
 *       ) }
 *     </RegistryConsumer>
 *   </RegistryProvider>
 * }
 * ```
 */

const RegistryConsumer = Consumer;
/**
 * A custom Context provider for exposing the provided `registry` to children
 * components via a consumer.
 *
 * See <a name="#RegistryConsumer">RegistryConsumer</a> documentation for
 * example.
 */

/* harmony default export */ const registry_provider_context = (context_Provider);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * A custom react hook exposing the registry context for use.
 *
 * This exposes the `registry` value provided via the
 * <a href="#RegistryProvider">Registry Provider</a> to a component implementing
 * this hook.
 *
 * It acts similarly to the `useContext` react hook.
 *
 * Note: Generally speaking, `useRegistry` is a low level hook that in most cases
 * won't be needed for implementation. Most interactions with the `@wordpress/data`
 * API can be performed via the `useSelect` hook,  or the `withSelect` and
 * `withDispatch` higher order components.
 *
 * @example
 * ```js
 * import {
 *   RegistryProvider,
 *   createRegistry,
 *   useRegistry,
 * } from '@wordpress/data';
 *
 * const registry = createRegistry( {} );
 *
 * const SomeChildUsingRegistry = ( props ) => {
 *   const registry = useRegistry();
 *   // ...logic implementing the registry in other react hooks.
 * };
 *
 *
 * const ParentProvidingRegistry = ( props ) => {
 *   return <RegistryProvider value={ registry }>
 *     <SomeChildUsingRegistry { ...props } />
 *   </RegistryProvider>
 * };
 * ```
 *
 * @return {Function}  A custom react hook exposing the registry context value.
 */

function use_registry_useRegistry() {
  return (0,react.useContext)(Context);
}
//# sourceMappingURL=use-registry.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/async-mode-provider/context.js
/**
 * WordPress dependencies
 */

const context_Context = (0,react.createContext)(false);
const {
  Consumer: context_Consumer,
  Provider: async_mode_provider_context_Provider
} = context_Context;
const AsyncModeConsumer = (/* unused pure expression or super */ null && (context_Consumer));
/**
 * Context Provider Component used to switch the data module component rerendering
 * between Sync and Async modes.
 *
 * @example
 *
 * ```js
 * import { useSelect, AsyncModeProvider } from '@wordpress/data';
 * import { store as blockEditorStore } from '@wordpress/block-editor';
 *
 * function BlockCount() {
 *   const count = useSelect( ( select ) => {
 *     return select( blockEditorStore ).getBlockCount()
 *   }, [] );
 *
 *   return count;
 * }
 *
 * function App() {
 *   return (
 *     <AsyncModeProvider value={ true }>
 *       <BlockCount />
 *     </AsyncModeProvider>
 *   );
 * }
 * ```
 *
 * In this example, the BlockCount component is rerendered asynchronously.
 * It means if a more critical task is being performed (like typing in an input),
 * the rerendering is delayed until the browser becomes IDLE.
 * It is possible to nest multiple levels of AsyncModeProvider to fine-tune the rendering behavior.
 *
 * @param {boolean} props.value Enable Async Mode.
 * @return {WPComponent} The component to be rendered.
 */

/* harmony default export */ const async_mode_provider_context = (async_mode_provider_context_Provider);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/async-mode-provider/use-async-mode.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function use_async_mode_useAsyncMode() {
  return (0,react.useContext)(context_Context);
}
//# sourceMappingURL=use-async-mode.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/use-select/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const use_select_noop = () => {};

const renderQueue = (0,priority_queue_build_module/* createQueue */.y)();
/**
 * @typedef {import('../../types').StoreDescriptor<C>} StoreDescriptor
 * @template C
 */

/**
 * @typedef {import('../../types').ReduxStoreConfig<State,Actions,Selectors>} ReduxStoreConfig
 * @template State,Actions,Selectors
 */

/**
 * @typedef {import('../../types').UseSelectReturn<T>} UseSelectReturn
 * @template T
 */

/** @typedef {import('../../types').MapSelect} MapSelect */

/**
 * Custom react hook for retrieving props from registered selectors.
 *
 * In general, this custom React hook follows the
 * [rules of hooks](https://reactjs.org/docs/hooks-rules.html).
 *
 * @template {MapSelect | StoreDescriptor<any>} T
 * @param {T}         mapSelect Function called on every state change. The returned value is
 *                              exposed to the component implementing this hook. The function
 *                              receives the `registry.select` method on the first argument
 *                              and the `registry` on the second argument.
 *                              When a store key is passed, all selectors for the store will be
 *                              returned. This is only meant for usage of these selectors in event
 *                              callbacks, not for data needed to create the element tree.
 * @param {unknown[]} deps      If provided, this memoizes the mapSelect so the same `mapSelect` is
 *                              invoked on every state change unless the dependencies change.
 *
 * @example
 * ```js
 * import { useSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function HammerPriceDisplay( { currency } ) {
 *   const price = useSelect( ( select ) => {
 *     return select( myCustomStore ).getPrice( 'hammer', currency );
 *   }, [ currency ] );
 *   return new Intl.NumberFormat( 'en-US', {
 *     style: 'currency',
 *     currency,
 *   } ).format( price );
 * }
 *
 * // Rendered in the application:
 * // <HammerPriceDisplay currency="USD" />
 * ```
 *
 * In the above example, when `HammerPriceDisplay` is rendered into an
 * application, the price will be retrieved from the store state using the
 * `mapSelect` callback on `useSelect`. If the currency prop changes then
 * any price in the state for that currency is retrieved. If the currency prop
 * doesn't change and other props are passed in that do change, the price will
 * not change because the dependency is just the currency.
 *
 * When data is only used in an event callback, the data should not be retrieved
 * on render, so it may be useful to get the selectors function instead.
 *
 * **Don't use `useSelect` this way when calling the selectors in the render
 * function because your component won't re-render on a data change.**
 *
 * ```js
 * import { useSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function Paste( { children } ) {
 *   const { getSettings } = useSelect( myCustomStore );
 *   function onPaste() {
 *     // Do something with the settings.
 *     const settings = getSettings();
 *   }
 *   return <div onPaste={ onPaste }>{ children }</div>;
 * }
 * ```
 * @return {UseSelectReturn<T>} A custom react hook.
 */

function use_select_useSelect(mapSelect, deps) {
  const hasMappingFunction = 'function' === typeof mapSelect; // If we're recalling a store by its name or by
  // its descriptor then we won't be caching the
  // calls to `mapSelect` because we won't be calling it.

  if (!hasMappingFunction) {
    deps = [];
  } // Because of the "rule of hooks" we have to call `useCallback`
  // on every invocation whether or not we have a real function
  // for `mapSelect`. we'll create this intermediate variable to
  // fulfill that need and then reference it with our "real"
  // `_mapSelect` if we can.


  const callbackMapper = (0,react.useCallback)(hasMappingFunction ? mapSelect : use_select_noop, deps);

  const _mapSelect = hasMappingFunction ? callbackMapper : null;

  const registry = use_registry_useRegistry();
  const isAsync = use_async_mode_useAsyncMode();
  const latestRegistry = (0,react.useRef)(registry);
  const latestMapSelect = (0,react.useRef)();
  const latestIsAsync = (0,react.useRef)(isAsync);
  const latestMapOutput = (0,react.useRef)();
  const latestMapOutputError = (0,react.useRef)(); // Keep track of the stores being selected in the _mapSelect function,
  // and only subscribe to those stores later.

  const listeningStores = (0,react.useRef)([]);
  const wrapSelect = (0,react.useCallback)(callback => registry.__unstableMarkListeningStores(() => callback(registry.select, registry), listeningStores), [registry]); // Generate a "flag" for used in the effect dependency array.
  // It's different than just using `mapSelect` since deps could be undefined,
  // in that case, we would still want to memoize it.

  const depsChangedFlag = (0,react.useMemo)(() => ({}), deps || []);
  let mapOutput;
  let selectorRan = false;

  if (_mapSelect) {
    mapOutput = latestMapOutput.current;
    const hasReplacedRegistry = latestRegistry.current !== registry;
    const hasReplacedMapSelect = latestMapSelect.current !== _mapSelect;
    const hasLeftAsyncMode = latestIsAsync.current && !isAsync;
    const lastMapSelectFailed = !!latestMapOutputError.current;

    if (hasReplacedRegistry || hasReplacedMapSelect || hasLeftAsyncMode || lastMapSelectFailed) {
      try {
        mapOutput = wrapSelect(_mapSelect);
        selectorRan = true;
      } catch (error) {
        let errorMessage = `An error occurred while running 'mapSelect': ${error.message}`;

        if (latestMapOutputError.current) {
          errorMessage += `\nThe error may be correlated with this previous error:\n`;
          errorMessage += `${latestMapOutputError.current.stack}\n\n`;
          errorMessage += 'Original stack trace:';
        } // eslint-disable-next-line no-console


        console.error(errorMessage);
      }
    }
  }

  (0,use_isomorphic_layout_effect/* default */.A)(() => {
    if (!hasMappingFunction) {
      return;
    }

    latestRegistry.current = registry;
    latestMapSelect.current = _mapSelect;
    latestIsAsync.current = isAsync;

    if (selectorRan) {
      latestMapOutput.current = mapOutput;
    }

    latestMapOutputError.current = undefined;
  }); // React can sometimes clear the `useMemo` cache.
  // We use the cache-stable `useMemoOne` to avoid
  // losing queues.

  const queueContext = (0,use_memo_one_esm/* useMemoOne */.MA)(() => ({
    queue: true
  }), [registry]);
  const [, forceRender] = (0,react.useReducer)(s => s + 1, 0);
  const isMounted = (0,react.useRef)(false);
  (0,use_isomorphic_layout_effect/* default */.A)(() => {
    if (!hasMappingFunction) {
      return;
    }

    const onStoreChange = () => {
      try {
        const newMapOutput = wrapSelect(latestMapSelect.current);

        if ((0,is_shallow_equal_build_module/* default */.Ay)(latestMapOutput.current, newMapOutput)) {
          return;
        }

        latestMapOutput.current = newMapOutput;
      } catch (error) {
        latestMapOutputError.current = error;
      }

      forceRender();
    };

    const onChange = () => {
      if (!isMounted.current) {
        return;
      }

      if (latestIsAsync.current) {
        renderQueue.add(queueContext, onStoreChange);
      } else {
        onStoreChange();
      }
    }; // Catch any possible state changes during mount before the subscription
    // could be set.


    onStoreChange();
    const unsubscribers = listeningStores.current.map(storeName => registry.__unstableSubscribeStore(storeName, onChange));
    isMounted.current = true;
    return () => {
      // The return value of the subscribe function could be undefined if the store is a custom generic store.
      unsubscribers.forEach(unsubscribe => unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe());
      renderQueue.cancel(queueContext);
      isMounted.current = false;
    }; // If you're tempted to eliminate the spread dependencies below don't do it!
    // We're passing these in from the calling function and want to make sure we're
    // examining every individual value inside the `deps` array.
  }, [registry, wrapSelect, hasMappingFunction, depsChangedFlag]);
  (0,react.useDebugValue)(mapOutput);
  return hasMappingFunction ? mapOutput : registry.select(mapSelect);
}
/**
 * A variant of the `useSelect` hook that has the same API, but will throw a
 * suspense Promise if any of the called selectors is in an unresolved state.
 *
 * @param {Function} mapSelect Function called on every state change. The
 *                             returned value is exposed to the component
 *                             using this hook. The function receives the
 *                             `registry.suspendSelect` method as the first
 *                             argument and the `registry` as the second one.
 * @param {Array}    deps      A dependency array used to memoize the `mapSelect`
 *                             so that the same `mapSelect` is invoked on every
 *                             state change unless the dependencies change.
 *
 * @return {Object} Data object returned by the `mapSelect` function.
 */

function useSuspenseSelect(mapSelect, deps) {
  const _mapSelect = useCallback(mapSelect, deps);

  const registry = useRegistry();
  const isAsync = useAsyncMode();
  const latestRegistry = useRef(registry);
  const latestMapSelect = useRef();
  const latestIsAsync = useRef(isAsync);
  const latestMapOutput = useRef();
  const latestMapOutputError = useRef(); // Keep track of the stores being selected in the `mapSelect` function,
  // and only subscribe to those stores later.

  const listeningStores = useRef([]);
  const wrapSelect = useCallback(callback => registry.__unstableMarkListeningStores(() => callback(registry.suspendSelect, registry), listeningStores), [registry]); // Generate a "flag" for used in the effect dependency array.
  // It's different than just using `mapSelect` since deps could be undefined,
  // in that case, we would still want to memoize it.

  const depsChangedFlag = useMemo(() => ({}), deps || []);
  let mapOutput = latestMapOutput.current;
  let mapOutputError = latestMapOutputError.current;
  const hasReplacedRegistry = latestRegistry.current !== registry;
  const hasReplacedMapSelect = latestMapSelect.current !== _mapSelect;
  const hasLeftAsyncMode = latestIsAsync.current && !isAsync;
  let selectorRan = false;

  if (hasReplacedRegistry || hasReplacedMapSelect || hasLeftAsyncMode) {
    try {
      mapOutput = wrapSelect(_mapSelect);
      selectorRan = true;
    } catch (error) {
      mapOutputError = error;
    }
  }

  useIsomorphicLayoutEffect(() => {
    latestRegistry.current = registry;
    latestMapSelect.current = _mapSelect;
    latestIsAsync.current = isAsync;

    if (selectorRan) {
      latestMapOutput.current = mapOutput;
    }

    latestMapOutputError.current = mapOutputError;
  }); // React can sometimes clear the `useMemo` cache.
  // We use the cache-stable `useMemoOne` to avoid
  // losing queues.

  const queueContext = useMemoOne(() => ({
    queue: true
  }), [registry]);
  const [, forceRender] = useReducer(s => s + 1, 0);
  const isMounted = useRef(false);
  useIsomorphicLayoutEffect(() => {
    const onStoreChange = () => {
      try {
        const newMapOutput = wrapSelect(latestMapSelect.current);

        if (isShallowEqual(latestMapOutput.current, newMapOutput)) {
          return;
        }

        latestMapOutput.current = newMapOutput;
      } catch (error) {
        latestMapOutputError.current = error;
      }

      forceRender();
    };

    const onChange = () => {
      if (!isMounted.current) {
        return;
      }

      if (latestIsAsync.current) {
        renderQueue.add(queueContext, onStoreChange);
      } else {
        onStoreChange();
      }
    }; // catch any possible state changes during mount before the subscription
    // could be set.


    onStoreChange();
    const unsubscribers = listeningStores.current.map(storeName => registry.__unstableSubscribeStore(storeName, onChange));
    isMounted.current = true;
    return () => {
      // The return value of the subscribe function could be undefined if the store is a custom generic store.
      unsubscribers.forEach(unsubscribe => unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe());
      renderQueue.cancel(queueContext);
      isMounted.current = false;
    };
  }, [registry, wrapSelect, depsChangedFlag]);

  if (mapOutputError) {
    throw mapOutputError;
  }

  return mapOutput;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-controls/groups.js
/**
 * WordPress dependencies
 */

const BlockControlsDefault = createSlotFill('BlockControls');
const BlockControlsBlock = createSlotFill('BlockControlsBlock');
const BlockControlsInline = createSlotFill('BlockFormatControls');
const BlockControlsOther = createSlotFill('BlockControlsOther');
const BlockControlsParent = createSlotFill('BlockControlsParent');
const groups = {
  default: BlockControlsDefault,
  block: BlockControlsBlock,
  inline: BlockControlsInline,
  other: BlockControlsOther,
  parent: BlockControlsParent
};
/* harmony default export */ const block_controls_groups = (groups);
//# sourceMappingURL=groups.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js + 9 modules
var redux_store = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/index.js
var data_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.47.0/node_modules/@wordpress/i18n/build-module/index.js + 3 modules
var _wordpress_i18n_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@4.47.0/node_modules/@wordpress/i18n/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/defaults.js
/**
 * WordPress dependencies
 */

const PREFERENCES_DEFAULTS = {
  insertUsage: {}
};
/**
 * The default editor settings
 *
 * @typedef {Object} SETTINGS_DEFAULT
 * @property {boolean}       alignWide                              Enable/Disable Wide/Full Alignments
 * @property {boolean}       supportsLayout                         Enable/disable layouts support in container blocks.
 * @property {boolean}       imageEditing                           Image Editing settings set to false to disable.
 * @property {Array}         imageSizes                             Available image sizes
 * @property {number}        maxWidth                               Max width to constraint resizing
 * @property {boolean|Array} allowedBlockTypes                      Allowed block types
 * @property {boolean}       hasFixedToolbar                        Whether or not the editor toolbar is fixed
 * @property {boolean}       focusMode                              Whether the focus mode is enabled or not
 * @property {Array}         styles                                 Editor Styles
 * @property {boolean}       keepCaretInsideBlock                   Whether caret should move between blocks in edit mode
 * @property {string}        bodyPlaceholder                        Empty post placeholder
 * @property {string}        titlePlaceholder                       Empty title placeholder
 * @property {boolean}       canLockBlocks                          Whether the user can manage Block Lock state
 * @property {boolean}       codeEditingEnabled                     Whether or not the user can switch to the code editor
 * @property {boolean}       generateAnchors                        Enable/Disable auto anchor generation for Heading blocks
 * @property {boolean}       __experimentalCanUserUseUnfilteredHTML Whether the user should be able to use unfiltered HTML or the HTML should be filtered e.g., to remove elements considered insecure like iframes.
 * @property {boolean}       __experimentalBlockDirectory           Whether the user has enabled the Block Directory
 * @property {Array}         __experimentalBlockPatterns            Array of objects representing the block patterns
 * @property {Array}         __experimentalBlockPatternCategories   Array of objects representing the block pattern categories
 * @property {boolean}       __unstableGalleryWithImageBlocks       Whether the user has enabled the refactored gallery block which uses InnerBlocks
 */

const SETTINGS_DEFAULTS = {
  alignWide: false,
  supportsLayout: true,
  // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  colors: [{
    name: (0,_wordpress_i18n_build_module.__)('Black'),
    slug: 'black',
    color: '#000000'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Cyan bluish gray'),
    slug: 'cyan-bluish-gray',
    color: '#abb8c3'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('White'),
    slug: 'white',
    color: '#ffffff'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Pale pink'),
    slug: 'pale-pink',
    color: '#f78da7'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Vivid red'),
    slug: 'vivid-red',
    color: '#cf2e2e'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Luminous vivid orange'),
    slug: 'luminous-vivid-orange',
    color: '#ff6900'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Luminous vivid amber'),
    slug: 'luminous-vivid-amber',
    color: '#fcb900'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Light green cyan'),
    slug: 'light-green-cyan',
    color: '#7bdcb5'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Vivid green cyan'),
    slug: 'vivid-green-cyan',
    color: '#00d084'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Pale cyan blue'),
    slug: 'pale-cyan-blue',
    color: '#8ed1fc'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Vivid cyan blue'),
    slug: 'vivid-cyan-blue',
    color: '#0693e3'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Vivid purple'),
    slug: 'vivid-purple',
    color: '#9b51e0'
  }],
  // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  fontSizes: [{
    name: (0,_wordpress_i18n_build_module._x)('Small', 'font size name'),
    size: 13,
    slug: 'small'
  }, {
    name: (0,_wordpress_i18n_build_module._x)('Normal', 'font size name'),
    size: 16,
    slug: 'normal'
  }, {
    name: (0,_wordpress_i18n_build_module._x)('Medium', 'font size name'),
    size: 20,
    slug: 'medium'
  }, {
    name: (0,_wordpress_i18n_build_module._x)('Large', 'font size name'),
    size: 36,
    slug: 'large'
  }, {
    name: (0,_wordpress_i18n_build_module._x)('Huge', 'font size name'),
    size: 42,
    slug: 'huge'
  }],
  // Image default size slug.
  imageDefaultSize: 'large',
  imageSizes: [{
    slug: 'thumbnail',
    name: (0,_wordpress_i18n_build_module.__)('Thumbnail')
  }, {
    slug: 'medium',
    name: (0,_wordpress_i18n_build_module.__)('Medium')
  }, {
    slug: 'large',
    name: (0,_wordpress_i18n_build_module.__)('Large')
  }, {
    slug: 'full',
    name: (0,_wordpress_i18n_build_module.__)('Full Size')
  }],
  // Allow plugin to disable Image Editor if need be.
  imageEditing: true,
  // This is current max width of the block inner area
  // It's used to constraint image resizing and this value could be overridden later by themes
  maxWidth: 580,
  // Allowed block types for the editor, defaulting to true (all supported).
  allowedBlockTypes: true,
  // Maximum upload size in bytes allowed for the site.
  maxUploadFileSize: 0,
  // List of allowed mime types and file extensions.
  allowedMimeTypes: null,
  // Allows to disable block locking interface.
  canLockBlocks: true,
  __experimentalCanUserUseUnfilteredHTML: false,
  __experimentalBlockDirectory: false,
  __mobileEnablePageTemplates: false,
  __experimentalBlockPatterns: [],
  __experimentalBlockPatternCategories: [],
  __unstableGalleryWithImageBlocks: false,
  generateAnchors: false,
  // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  gradients: [{
    name: (0,_wordpress_i18n_build_module.__)('Vivid cyan blue to vivid purple'),
    gradient: 'linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)',
    slug: 'vivid-cyan-blue-to-vivid-purple'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Light green cyan to vivid green cyan'),
    gradient: 'linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)',
    slug: 'light-green-cyan-to-vivid-green-cyan'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Luminous vivid amber to luminous vivid orange'),
    gradient: 'linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)',
    slug: 'luminous-vivid-amber-to-luminous-vivid-orange'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Luminous vivid orange to vivid red'),
    gradient: 'linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)',
    slug: 'luminous-vivid-orange-to-vivid-red'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Very light gray to cyan bluish gray'),
    gradient: 'linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)',
    slug: 'very-light-gray-to-cyan-bluish-gray'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Cool to warm spectrum'),
    gradient: 'linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)',
    slug: 'cool-to-warm-spectrum'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Blush light purple'),
    gradient: 'linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)',
    slug: 'blush-light-purple'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Blush bordeaux'),
    gradient: 'linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)',
    slug: 'blush-bordeaux'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Luminous dusk'),
    gradient: 'linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)',
    slug: 'luminous-dusk'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Pale ocean'),
    gradient: 'linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)',
    slug: 'pale-ocean'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Electric grass'),
    gradient: 'linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)',
    slug: 'electric-grass'
  }, {
    name: (0,_wordpress_i18n_build_module.__)('Midnight'),
    gradient: 'linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)',
    slug: 'midnight'
  }],
  __unstableResolvedAssets: {
    styles: [],
    scripts: []
  }
};
//# sourceMappingURL=defaults.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/array.js
/**
 * External dependencies
 */

/**
 * Insert one or multiple elements into a given position of an array.
 *
 * @param {Array}  array    Source array.
 * @param {*}      elements Elements to insert.
 * @param {number} index    Insert Position.
 *
 * @return {Array} Result.
 */

function insertAt(array, elements, index) {
  return [...array.slice(0, index), ...(0,lodash.castArray)(elements), ...array.slice(index)];
}
/**
 * Moves an element in an array.
 *
 * @param {Array}  array Source array.
 * @param {number} from  Source index.
 * @param {number} to    Destination index.
 * @param {number} count Number of elements to move.
 *
 * @return {Array} Result.
 */

function moveTo(array, from, to) {
  let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  const withoutMovedElements = [...array];
  withoutMovedElements.splice(from, count);
  return insertAt(withoutMovedElements, array.slice(from, from + count), to);
}
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/reducer.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const identity = x => x;
/**
 * Given an array of blocks, returns an object where each key is a nesting
 * context, the value of which is an array of block client IDs existing within
 * that nesting context.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */


function mapBlockOrder(blocks) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  const result = {
    [rootClientId]: []
  };
  blocks.forEach(block => {
    const {
      clientId,
      innerBlocks
    } = block;
    result[rootClientId].push(clientId);
    Object.assign(result, mapBlockOrder(innerBlocks, clientId));
  });
  return result;
}
/**
 * Given an array of blocks, returns an object where each key contains
 * the clientId of the block and the value is the parent of the block.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */


function mapBlockParents(blocks) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return blocks.reduce((result, block) => Object.assign(result, {
    [block.clientId]: rootClientId
  }, mapBlockParents(block.innerBlocks, block.clientId)), {});
}
/**
 * Helper method to iterate through all blocks, recursing into inner blocks,
 * applying a transformation function to each one.
 * Returns a flattened object with the transformed blocks.
 *
 * @param {Array}    blocks    Blocks to flatten.
 * @param {Function} transform Transforming function to be applied to each block.
 *
 * @return {Object} Flattened object.
 */


function flattenBlocks(blocks) {
  let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  const result = {};
  const stack = [...blocks];

  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result[block.clientId] = transform(block);
  }

  return result;
}
/**
 * Given an array of blocks, returns an object containing all blocks, without
 * attributes, recursing into inner blocks. Keys correspond to the block client
 * ID, the value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Object} Flattened block attributes object.
 */


function getFlattenedBlocksWithoutAttributes(blocks) {
  return flattenBlocks(blocks, block => (0,lodash.omit)(block, 'attributes'));
}
/**
 * Given an array of blocks, returns an object containing all block attributes,
 * recursing into inner blocks. Keys correspond to the block client ID, the
 * value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Object} Flattened block attributes object.
 */


function getFlattenedBlockAttributes(blocks) {
  return flattenBlocks(blocks, block => block.attributes);
}
/**
 * Returns an object against which it is safe to perform mutating operations,
 * given the original object and its current working copy.
 *
 * @param {Object} original Original object.
 * @param {Object} working  Working object.
 *
 * @return {Object} Mutation-safe object.
 */


function getMutateSafeObject(original, working) {
  if (original === working) {
    return { ...original
    };
  }

  return working;
}
/**
 * Returns true if the two object arguments have the same keys, or false
 * otherwise.
 *
 * @param {Object} a First object.
 * @param {Object} b Second object.
 *
 * @return {boolean} Whether the two objects have the same keys.
 */


function hasSameKeys(a, b) {
  return (0,lodash.isEqual)(Object.keys(a), Object.keys(b));
}
/**
 * Returns true if, given the currently dispatching action and the previously
 * dispatched action, the two actions are updating the same block attribute, or
 * false otherwise.
 *
 * @param {Object} action     Currently dispatching action.
 * @param {Object} lastAction Previously dispatched action.
 *
 * @return {boolean} Whether actions are updating the same block attribute.
 */

function isUpdatingSameBlockAttribute(action, lastAction) {
  return action.type === 'UPDATE_BLOCK_ATTRIBUTES' && lastAction !== undefined && lastAction.type === 'UPDATE_BLOCK_ATTRIBUTES' && (0,lodash.isEqual)(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
}

function buildBlockTree(state, blocks) {
  const result = {};
  const stack = [...blocks];
  const flattenedBlocks = [...blocks];

  while (stack.length) {
    const block = stack.shift();
    stack.push(...block.innerBlocks);
    flattenedBlocks.push(...block.innerBlocks);
  } // Create objects before mutating them, that way it's always defined.


  for (const block of flattenedBlocks) {
    result[block.clientId] = {};
  }

  for (const block of flattenedBlocks) {
    result[block.clientId] = Object.assign(result[block.clientId], { ...state.byClientId[block.clientId],
      attributes: state.attributes[block.clientId],
      innerBlocks: block.innerBlocks.map(subBlock => result[subBlock.clientId])
    });
  }

  return result;
}

function updateParentInnerBlocksInTree(state, tree, updatedClientIds) {
  let updateChildrenOfUpdatedClientIds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const uncontrolledParents = new Set([]);
  const controlledParents = new Set();

  for (const clientId of updatedClientIds) {
    let current = updateChildrenOfUpdatedClientIds ? clientId : state.parents[clientId];

    do {
      if (state.controlledInnerBlocks[current]) {
        // Should stop on controlled blocks.
        // If we reach a controlled parent, break out of the loop.
        controlledParents.add(current);
        break;
      } else {
        // Else continue traversing up through parents.
        uncontrolledParents.add(current);
        current = state.parents[current];
      }
    } while (current !== undefined);
  } // To make sure the order of assignments doesn't matter,
  // we first create empty objects and mutates the inner blocks later.


  for (const clientId of uncontrolledParents) {
    tree[clientId] = { ...tree[clientId]
    };
  }

  for (const clientId of uncontrolledParents) {
    tree[clientId].innerBlocks = (state.order[clientId] || []).map(subClientId => tree[subClientId]);
  } // Controlled parent blocks, need a dedicated key for their inner blocks
  // to be used when doing getBlocks( controlledBlockClientId ).


  for (const clientId of controlledParents) {
    tree['controlled||' + clientId] = {
      innerBlocks: (state.order[clientId] || []).map(subClientId => tree[subClientId])
    };
  }

  return tree;
}
/**
 * Higher-order reducer intended to compute full block objects key for each block in the post.
 * This is a denormalization to optimize the performance of the getBlock selectors and avoid
 * recomputing the block objects and avoid heavy memoization.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockTree = reducer => function () {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;
  const newState = reducer(state, action);

  if (newState === state) {
    return state;
  }

  newState.tree = state.tree ? state.tree : {};

  switch (action.type) {
    case 'RECEIVE_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        const subTree = buildBlockTree(newState, action.blocks);
        newState.tree = updateParentInnerBlocksInTree(newState, { ...newState.tree,
          ...subTree
        }, action.rootClientId ? [action.rootClientId] : [''], true);
        break;
      }

    case 'UPDATE_BLOCK':
      newState.tree = updateParentInnerBlocksInTree(newState, { ...newState.tree,
        [action.clientId]: { ...newState.tree[action.clientId],
          ...newState.byClientId[action.clientId],
          attributes: newState.attributes[action.clientId]
        }
      }, [action.clientId], false);
      break;

    case 'UPDATE_BLOCK_ATTRIBUTES':
      {
        const newSubTree = action.clientIds.reduce((result, clientId) => {
          result[clientId] = { ...newState.tree[clientId],
            attributes: newState.attributes[clientId]
          };
          return result;
        }, {});
        newState.tree = updateParentInnerBlocksInTree(newState, { ...newState.tree,
          ...newSubTree
        }, action.clientIds, false);
        break;
      }

    case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      {
        const subTree = buildBlockTree(newState, action.blocks);
        newState.tree = updateParentInnerBlocksInTree(newState, { ...(0,lodash.omit)(newState.tree, action.replacedClientIds.concat( // Controlled inner blocks are only removed
          // if the block doesn't move to another position
          // otherwise their content will be lost.
          action.replacedClientIds.filter(clientId => !subTree[clientId]).map(clientId => 'controlled||' + clientId))),
          ...subTree
        }, action.blocks.map(b => b.clientId), false); // If there are no replaced blocks, it means we're removing blocks so we need to update their parent.

        const parentsOfRemovedBlocks = [];

        for (const clientId of action.clientIds) {
          if (state.parents[clientId] !== undefined && (state.parents[clientId] === '' || newState.byClientId[state.parents[clientId]])) {
            parentsOfRemovedBlocks.push(state.parents[clientId]);
          }
        }

        newState.tree = updateParentInnerBlocksInTree(newState, newState.tree, parentsOfRemovedBlocks, true);
        break;
      }

    case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      const parentsOfRemovedBlocks = [];

      for (const clientId of action.clientIds) {
        if (state.parents[clientId] !== undefined && (state.parents[clientId] === '' || newState.byClientId[state.parents[clientId]])) {
          parentsOfRemovedBlocks.push(state.parents[clientId]);
        }
      }

      newState.tree = updateParentInnerBlocksInTree(newState, (0,lodash.omit)(newState.tree, action.removedClientIds.concat(action.removedClientIds.map(clientId => 'controlled||' + clientId))), parentsOfRemovedBlocks, true);
      break;

    case 'MOVE_BLOCKS_TO_POSITION':
      {
        const updatedBlockUids = [];

        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        } else {
          updatedBlockUids.push('');
        }

        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }

        newState.tree = updateParentInnerBlocksInTree(newState, newState.tree, updatedBlockUids, true);
        break;
      }

    case 'MOVE_BLOCKS_UP':
    case 'MOVE_BLOCKS_DOWN':
      {
        const updatedBlockUids = [action.rootClientId ? action.rootClientId : ''];
        newState.tree = updateParentInnerBlocksInTree(newState, newState.tree, updatedBlockUids, true);
        break;
      }

    case 'SAVE_REUSABLE_BLOCK_SUCCESS':
      {
        const updatedBlockUids = Object.keys((0,lodash.omitBy)(newState.attributes, (attributes, clientId) => {
          return newState.byClientId[clientId].name !== 'core/block' || attributes.ref !== action.updatedId;
        }));
        newState.tree = updateParentInnerBlocksInTree(newState, { ...newState.tree,
          ...updatedBlockUids.reduce((result, clientId) => {
            result[clientId] = { ...newState.byClientId[clientId],
              attributes: newState.attributes[clientId],
              innerBlocks: newState.tree[clientId].innerBlocks
            };
            return result;
          }, {})
        }, updatedBlockUids, false);
      }
  }

  return newState;
};
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isPersistentChange` property value corresponding to whether a change in
 * state can be considered as persistent. All changes are considered persistent
 * except when updating the same block attribute as in the previous action.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withPersistentBlockChange(reducer) {
  let lastAction;
  let markNextChangeAsNotPersistent = false;
  return (state, action) => {
    let nextState = reducer(state, action);
    const isExplicitPersistentChange = action.type === 'MARK_LAST_CHANGE_AS_PERSISTENT' || markNextChangeAsNotPersistent; // Defer to previous state value (or default) unless changing or
    // explicitly marking as persistent.

    if (state === nextState && !isExplicitPersistentChange) {
      var _state$isPersistentCh;

      markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
      const nextIsPersistentChange = (_state$isPersistentCh = state === null || state === void 0 ? void 0 : state.isPersistentChange) !== null && _state$isPersistentCh !== void 0 ? _state$isPersistentCh : true;

      if (state.isPersistentChange === nextIsPersistentChange) {
        return state;
      }

      return { ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }

    nextState = { ...nextState,
      isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
    }; // In comparing against the previous action, consider only those which
    // would have qualified as one which would have been ignored or not
    // have resulted in a changed state.

    lastAction = action;
    markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
    return nextState;
  };
}
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isIgnoredChange` property value corresponding to whether a change in state
 * can be considered as ignored. A change is considered ignored when the result
 * of an action not incurred by direct user interaction.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withIgnoredBlockChange(reducer) {
  /**
   * Set of action types for which a blocks state change should be ignored.
   *
   * @type {Set}
   */
  const IGNORED_ACTION_TYPES = new Set(['RECEIVE_BLOCKS']);
  return (state, action) => {
    const nextState = reducer(state, action);

    if (nextState !== state) {
      nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
    }

    return nextState;
  };
}
/**
 * Higher-order reducer targeting the combined blocks reducer, augmenting
 * block client IDs in remove action to include cascade of inner blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withInnerBlocksRemoveCascade = reducer => (state, action) => {
  // Gets all children which need to be removed.
  const getAllChildren = clientIds => {
    let result = clientIds;

    for (let i = 0; i < result.length; i++) {
      if (!state.order[result[i]] || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i]]) {
        continue;
      }

      if (result === clientIds) {
        result = [...result];
      }

      result.push(...state.order[result[i]]);
    }

    return result;
  };

  if (state) {
    switch (action.type) {
      case 'REMOVE_BLOCKS':
        action = { ...action,
          type: 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          removedClientIds: getAllChildren(action.clientIds)
        };
        break;

      case 'REPLACE_BLOCKS':
        action = { ...action,
          type: 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          replacedClientIds: getAllChildren(action.clientIds)
        };
        break;
    }
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `RESET_BLOCKS` action. When dispatched, this action will replace all
 * blocks that exist in the post, leaving blocks that exist only in state (e.g.
 * reusable blocks and blocks controlled by inner blocks controllers) alone.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockReset = reducer => (state, action) => {
  if (action.type === 'RESET_BLOCKS') {
    const newState = { ...state,
      byClientId: getFlattenedBlocksWithoutAttributes(action.blocks),
      attributes: getFlattenedBlockAttributes(action.blocks),
      order: mapBlockOrder(action.blocks),
      parents: mapBlockParents(action.blocks),
      controlledInnerBlocks: {},
      visibility: {}
    };
    const subTree = buildBlockTree(newState, action.blocks);
    newState.tree = { ...subTree,
      // Root.
      '': {
        innerBlocks: action.blocks.map(subBlock => subTree[subBlock.clientId])
      }
    };
    return newState;
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `REPLACE_INNER_BLOCKS` action. When dispatched, this action the state
 * should become equivalent to the execution of a `REMOVE_BLOCKS` action
 * containing all the child's of the root block followed by the execution of
 * `INSERT_BLOCKS` with the new blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withReplaceInnerBlocks = reducer => (state, action) => {
  if (action.type !== 'REPLACE_INNER_BLOCKS') {
    return reducer(state, action);
  } // Finds every nested inner block controller. We must check the action blocks
  // and not just the block parent state because some inner block controllers
  // should be deleted if specified, whereas others should not be deleted. If
  // a controlled should not be deleted, then we need to avoid deleting its
  // inner blocks from the block state because its inner blocks will not be
  // attached to the block in the action.


  const nestedControllers = {};

  if (Object.keys(state.controlledInnerBlocks).length) {
    const stack = [...action.blocks];

    while (stack.length) {
      const {
        innerBlocks,
        ...block
      } = stack.shift();
      stack.push(...innerBlocks);

      if (!!state.controlledInnerBlocks[block.clientId]) {
        nestedControllers[block.clientId] = true;
      }
    }
  } // The `keepControlledInnerBlocks` prop will keep the inner blocks of the
  // marked block in the block state so that they can be reattached to the
  // marked block when we re-insert everything a few lines below.


  let stateAfterBlocksRemoval = state;

  if (state.order[action.rootClientId]) {
    stateAfterBlocksRemoval = reducer(stateAfterBlocksRemoval, {
      type: 'REMOVE_BLOCKS',
      keepControlledInnerBlocks: nestedControllers,
      clientIds: state.order[action.rootClientId]
    });
  }

  let stateAfterInsert = stateAfterBlocksRemoval;

  if (action.blocks.length) {
    stateAfterInsert = reducer(stateAfterInsert, { ...action,
      type: 'INSERT_BLOCKS',
      index: 0
    }); // We need to re-attach the controlled inner blocks to the blocks tree and
    // preserve their block order. Otherwise, an inner block controller's blocks
    // will be deleted entirely from its entity.

    stateAfterInsert.order = { ...stateAfterInsert.order,
      ...(0,lodash.reduce)(nestedControllers, (result, value, key) => {
        if (state.order[key]) {
          result[key] = state.order[key];
        }

        return result;
      }, {})
    };
    stateAfterInsert.tree = { ...stateAfterInsert.tree,
      ...(0,lodash.reduce)(nestedControllers, (result, value, _key) => {
        const key = `controlled||${_key}`;

        if (state.tree[key]) {
          result[key] = state.tree[key];
        }

        return result;
      }, {})
    };
  }

  return stateAfterInsert;
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `SAVE_REUSABLE_BLOCK_SUCCESS` action. This action can't be handled by
 * regular reducers and needs a higher-order reducer since it needs access to
 * both `byClientId` and `attributes` simultaneously.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withSaveReusableBlock = reducer => (state, action) => {
  if (state && action.type === 'SAVE_REUSABLE_BLOCK_SUCCESS') {
    const {
      id,
      updatedId
    } = action; // If a temporary reusable block is saved, we swap the temporary id with the final one.

    if (id === updatedId) {
      return state;
    }

    state = { ...state
    };
    state.attributes = (0,lodash.mapValues)(state.attributes, (attributes, clientId) => {
      const {
        name
      } = state.byClientId[clientId];

      if (name === 'core/block' && attributes.ref === id) {
        return { ...attributes,
          ref: updatedId
        };
      }

      return attributes;
    });
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which removes blocks from state when switching parent block controlled state.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withResetControlledBlocks = reducer => (state, action) => {
  if (action.type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
    // when switching a block from controlled to uncontrolled or inverse,
    // we need to remove its content first.
    const tempState = reducer(state, {
      type: 'REPLACE_INNER_BLOCKS',
      rootClientId: action.clientId,
      blocks: []
    });
    return reducer(tempState, action);
  }

  return reducer(state, action);
};
/**
 * Reducer returning the blocks state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */


const blocks = (0,lodash.flow)(data_build_module/* combineReducers */.HY, withSaveReusableBlock, // Needs to be before withBlockCache.
withBlockTree, // Needs to be before withInnerBlocksRemoveCascade.
withInnerBlocksRemoveCascade, withReplaceInnerBlocks, // Needs to be after withInnerBlocksRemoveCascade.
withBlockReset, withPersistentBlockChange, withIgnoredBlockChange, withResetControlledBlocks)({
  byClientId() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        return { ...state,
          ...getFlattenedBlocksWithoutAttributes(action.blocks)
        };

      case 'UPDATE_BLOCK':
        // Ignore updates if block isn't known.
        if (!state[action.clientId]) {
          return state;
        } // Do nothing if only attributes change.


        const changes = (0,lodash.omit)(action.updates, 'attributes');

        if ((0,lodash.isEmpty)(changes)) {
          return state;
        }

        return { ...state,
          [action.clientId]: { ...state[action.clientId],
            ...changes
          }
        };

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        if (!action.blocks) {
          return state;
        }

        return { ...(0,lodash.omit)(state, action.replacedClientIds),
          ...getFlattenedBlocksWithoutAttributes(action.blocks)
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return (0,lodash.omit)(state, action.removedClientIds);
    }

    return state;
  },

  attributes() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        return { ...state,
          ...getFlattenedBlockAttributes(action.blocks)
        };

      case 'UPDATE_BLOCK':
        // Ignore updates if block isn't known or there are no attribute changes.
        if (!state[action.clientId] || !action.updates.attributes) {
          return state;
        }

        return { ...state,
          [action.clientId]: { ...state[action.clientId],
            ...action.updates.attributes
          }
        };

      case 'UPDATE_BLOCK_ATTRIBUTES':
        {
          // Avoid a state change if none of the block IDs are known.
          if (action.clientIds.every(id => !state[id])) {
            return state;
          }

          const next = action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
            [id]: (0,lodash.reduce)(action.uniqueByBlock ? action.attributes[id] : action.attributes, (result, value, key) => {
              // Consider as updates only changed values.
              if (value !== result[key]) {
                result = getMutateSafeObject(state[id], result);
                result[key] = value;
              }

              return result;
            }, state[id])
          }), {});

          if (action.clientIds.every(id => next[id] === state[id])) {
            return state;
          }

          return { ...state,
            ...next
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        if (!action.blocks) {
          return state;
        }

        return { ...(0,lodash.omit)(state, action.replacedClientIds),
          ...getFlattenedBlockAttributes(action.blocks)
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return (0,lodash.omit)(state, action.removedClientIds);
    }

    return state;
  },

  order() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case 'RECEIVE_BLOCKS':
        {
          const blockOrder = mapBlockOrder(action.blocks);
          return { ...state,
            ...(0,lodash.omit)(blockOrder, ''),
            '': ((state === null || state === void 0 ? void 0 : state['']) || []).concat(blockOrder[''])
          };
        }

      case 'INSERT_BLOCKS':
        {
          const {
            rootClientId = ''
          } = action;
          const subState = state[rootClientId] || [];
          const mappedBlocks = mapBlockOrder(action.blocks, rootClientId);
          const {
            index = subState.length
          } = action;
          return { ...state,
            ...mappedBlocks,
            [rootClientId]: insertAt(subState, mappedBlocks[rootClientId], index)
          };
        }

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          const {
            fromRootClientId = '',
            toRootClientId = '',
            clientIds
          } = action;
          const {
            index = state[toRootClientId].length
          } = action; // Moving inside the same parent block.

          if (fromRootClientId === toRootClientId) {
            const subState = state[toRootClientId];
            const fromIndex = subState.indexOf(clientIds[0]);
            return { ...state,
              [toRootClientId]: moveTo(state[toRootClientId], fromIndex, index, clientIds.length)
            };
          } // Moving from a parent block to another.


          return { ...state,
            [fromRootClientId]: (0,lodash.without)(state[fromRootClientId], ...clientIds),
            [toRootClientId]: insertAt(state[toRootClientId], clientIds, index)
          };
        }

      case 'MOVE_BLOCKS_UP':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = (0,lodash.first)(clientIds);
          const subState = state[rootClientId];

          if (!subState.length || firstClientId === (0,lodash.first)(subState)) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          return { ...state,
            [rootClientId]: moveTo(subState, firstIndex, firstIndex - 1, clientIds.length)
          };
        }

      case 'MOVE_BLOCKS_DOWN':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = (0,lodash.first)(clientIds);
          const lastClientId = (0,lodash.last)(clientIds);
          const subState = state[rootClientId];

          if (!subState.length || lastClientId === (0,lodash.last)(subState)) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          return { ...state,
            [rootClientId]: moveTo(subState, firstIndex, firstIndex + 1, clientIds.length)
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const {
            clientIds
          } = action;

          if (!action.blocks) {
            return state;
          }

          const mappedBlocks = mapBlockOrder(action.blocks);
          return (0,lodash.flow)([nextState => (0,lodash.omit)(nextState, action.replacedClientIds), nextState => ({ ...nextState,
            ...(0,lodash.omit)(mappedBlocks, '')
          }), nextState => (0,lodash.mapValues)(nextState, subState => (0,lodash.reduce)(subState, (result, clientId) => {
            if (clientId === clientIds[0]) {
              return [...result, ...mappedBlocks['']];
            }

            if (clientIds.indexOf(clientId) === -1) {
              result.push(clientId);
            }

            return result;
          }, []))])(state);
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return (0,lodash.flow)([// Remove inner block ordering for removed blocks.
        nextState => (0,lodash.omit)(nextState, action.removedClientIds), // Remove deleted blocks from other blocks' orderings.
        nextState => (0,lodash.mapValues)(nextState, subState => (0,lodash.without)(subState, ...action.removedClientIds))])(state);
    }

    return state;
  },

  // While technically redundant data as the inverse of `order`, it serves as
  // an optimization for the selectors which derive the ancestry of a block.
  parents() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case 'RECEIVE_BLOCKS':
        return { ...state,
          ...mapBlockParents(action.blocks)
        };

      case 'INSERT_BLOCKS':
        return { ...state,
          ...mapBlockParents(action.blocks, action.rootClientId || '')
        };

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          return { ...state,
            ...action.clientIds.reduce((accumulator, id) => {
              accumulator[id] = action.toRootClientId || '';
              return accumulator;
            }, {})
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return { ...(0,lodash.omit)(state, action.replacedClientIds),
          ...mapBlockParents(action.blocks, state[action.clientIds[0]])
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return (0,lodash.omit)(state, action.removedClientIds);
    }

    return state;
  },

  controlledInnerBlocks() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let {
      type,
      clientId,
      hasControlledInnerBlocks
    } = arguments.length > 1 ? arguments[1] : undefined;

    if (type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
      return { ...state,
        [clientId]: hasControlledInnerBlocks
      };
    }

    return state;
  },

  visibility() {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : undefined;

    if (action.type === 'SET_BLOCK_VISIBILITY') {
      return { ...state,
        ...action.updates
      };
    }

    return state;
  }

});
/**
 * Reducer returning typing state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isTyping() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'START_TYPING':
      return true;

    case 'STOP_TYPING':
      return false;
  }

  return state;
}
/**
 * Reducer returning dragged block client id.
 *
 * @param {string[]} state  Current state.
 * @param {Object}   action Dispatched action.
 *
 * @return {string[]} Updated state.
 */

function draggedBlocks() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'START_DRAGGING_BLOCKS':
      return action.clientIds;

    case 'STOP_DRAGGING_BLOCKS':
      return [];
  }

  return state;
}
/**
 * Internal helper reducer for selectionStart and selectionEnd. Can hold a block
 * selection, represented by an object with property clientId.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function selectionHelper() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'CLEAR_SELECTED_BLOCK':
      {
        if (state.clientId) {
          return {};
        }

        return state;
      }

    case 'SELECT_BLOCK':
      if (action.clientId === state.clientId) {
        return state;
      }

      return {
        clientId: action.clientId
      };

    case 'REPLACE_INNER_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }

        return {
          clientId: action.blocks[0].clientId
        };
      }

    case 'REMOVE_BLOCKS':
      if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }

      return {};

    case 'REPLACE_BLOCKS':
      {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }

        const blockToSelect = action.blocks[action.indexToSelect] || action.blocks[action.blocks.length - 1];

        if (!blockToSelect) {
          return {};
        }

        if (blockToSelect.clientId === state.clientId) {
          return state;
        }

        return {
          clientId: blockToSelect.clientId
        };
      }
  }

  return state;
}
/**
 * Reducer returning the selection state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */


function selection() {
  var _state$selectionStart, _state$selectionEnd, _state$selectionStart2, _state$selectionEnd2;

  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'SELECTION_CHANGE':
      if (action.clientId) {
        return {
          selectionStart: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.startOffset
          },
          selectionEnd: {
            clientId: action.clientId,
            attributeKey: action.attributeKey,
            offset: action.endOffset
          }
        };
      }

      return {
        selectionStart: action.start || state.selectionStart,
        selectionEnd: action.end || state.selectionEnd
      };

    case 'RESET_SELECTION':
      const {
        selectionStart,
        selectionEnd
      } = action;
      return {
        selectionStart,
        selectionEnd
      };

    case 'MULTI_SELECT':
      const {
        start,
        end
      } = action;

      if (start === ((_state$selectionStart = state.selectionStart) === null || _state$selectionStart === void 0 ? void 0 : _state$selectionStart.clientId) && end === ((_state$selectionEnd = state.selectionEnd) === null || _state$selectionEnd === void 0 ? void 0 : _state$selectionEnd.clientId)) {
        return state;
      }

      return {
        selectionStart: {
          clientId: start
        },
        selectionEnd: {
          clientId: end
        }
      };

    case 'RESET_BLOCKS':
      const startClientId = state === null || state === void 0 ? void 0 : (_state$selectionStart2 = state.selectionStart) === null || _state$selectionStart2 === void 0 ? void 0 : _state$selectionStart2.clientId;
      const endClientId = state === null || state === void 0 ? void 0 : (_state$selectionEnd2 = state.selectionEnd) === null || _state$selectionEnd2 === void 0 ? void 0 : _state$selectionEnd2.clientId; // Do nothing if there's no selected block.

      if (!startClientId && !endClientId) {
        return state;
      } // If the start of the selection won't exist after reset, remove selection.


      if (!action.blocks.some(block => block.clientId === startClientId)) {
        return {
          selectionStart: {},
          selectionEnd: {}
        };
      } // If the end of the selection won't exist after reset, collapse selection.


      if (!action.blocks.some(block => block.clientId === endClientId)) {
        return { ...state,
          selectionEnd: state.selectionStart
        };
      }

  }

  return {
    selectionStart: selectionHelper(state.selectionStart, action),
    selectionEnd: selectionHelper(state.selectionEnd, action)
  };
}
/**
 * Reducer returning whether the user is multi-selecting.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isMultiSelecting() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'START_MULTI_SELECT':
      return true;

    case 'STOP_MULTI_SELECT':
      return false;
  }

  return state;
}
/**
 * Reducer returning whether selection is enabled.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isSelectionEnabled() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'TOGGLE_SELECTION':
      return action.isSelectionEnabled;
  }

  return state;
}
/**
 * Reducer returning the initial block selection.
 *
 * Currently this in only used to restore the selection after block deletion and
 * pasting new content.This reducer should eventually be removed in favour of setting
 * selection directly.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {number|null} Initial position: 0, -1 or null.
 */

function initialPosition() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  if (action.type === 'REPLACE_BLOCKS' && action.initialPosition !== undefined) {
    return action.initialPosition;
  } else if (['MULTI_SELECT', 'SELECT_BLOCK', 'RESET_SELECTION', 'INSERT_BLOCKS', 'REPLACE_INNER_BLOCKS'].includes(action.type)) {
    return action.initialPosition;
  }

  return state;
}
function blocksMode() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  if (action.type === 'TOGGLE_BLOCK_MODE') {
    const {
      clientId
    } = action;
    return { ...state,
      [clientId]: state[clientId] && state[clientId] === 'html' ? 'visual' : 'html'
    };
  }

  return state;
}
/**
 * Reducer returning the block insertion point visibility, either null if there
 * is not an explicit insertion point assigned, or an object of its `index` and
 * `rootClientId`.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function insertionPoint() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'SHOW_INSERTION_POINT':
      const {
        rootClientId,
        index,
        __unstableWithInserter
      } = action;
      return {
        rootClientId,
        index,
        __unstableWithInserter
      };

    case 'HIDE_INSERTION_POINT':
      return null;
  }

  return state;
}
/**
 * Reducer returning whether the post blocks match the defined template or not.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function template() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    isValid: true
  };
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'SET_TEMPLATE_VALIDITY':
      return { ...state,
        isValid: action.isValid
      };
  }

  return state;
}
/**
 * Reducer returning the editor setting.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function settings() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SETTINGS_DEFAULTS;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'UPDATE_SETTINGS':
      return { ...state,
        ...action.settings
      };
  }

  return state;
}
/**
 * Reducer returning the user preferences.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */

function preferences() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PREFERENCES_DEFAULTS;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
      return action.blocks.reduce((prevState, block) => {
        const {
          attributes,
          name: blockName
        } = block;
        const match = (0,data_build_module/* select */.Lt)(build_module/* store */.M_).getActiveBlockVariation(blockName, attributes); // If a block variation match is found change the name to be the same with the
        // one that is used for block variations in the Inserter (`getItemFromVariation`).

        let id = match !== null && match !== void 0 && match.name ? `${blockName}/${match.name}` : blockName;
        const insert = {
          name: id
        };

        if (blockName === 'core/block') {
          insert.ref = attributes.ref;
          id += '/' + attributes.ref;
        }

        return { ...prevState,
          insertUsage: { ...prevState.insertUsage,
            [id]: {
              time: action.time,
              count: prevState.insertUsage[id] ? prevState.insertUsage[id].count + 1 : 1,
              insert
            }
          }
        };
      }, state);
  }

  return state;
}
/**
 * Reducer returning an object where each key is a block client ID, its value
 * representing the settings for its nested blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

const blockListSettings = function () {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    // Even if the replaced blocks have the same client ID, our logic
    // should correct the state.
    case 'REPLACE_BLOCKS':
    case 'REMOVE_BLOCKS':
      {
        return (0,lodash.omit)(state, action.clientIds);
      }

    case 'UPDATE_BLOCK_LIST_SETTINGS':
      {
        const {
          clientId
        } = action;

        if (!action.settings) {
          if (state.hasOwnProperty(clientId)) {
            return (0,lodash.omit)(state, clientId);
          }

          return state;
        }

        if ((0,lodash.isEqual)(state[clientId], action.settings)) {
          return state;
        }

        return { ...state,
          [clientId]: action.settings
        };
      }
  }

  return state;
};
/**
 * Reducer returning whether the navigation mode is enabled or not.
 *
 * @param {string} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */

function isNavigationMode() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  // Let inserting block always trigger Edit mode.
  if (action.type === 'INSERT_BLOCKS') {
    return false;
  }

  if (action.type === 'SET_NAVIGATION_MODE') {
    return action.isNavigationMode;
  }

  return state;
}
/**
 * Reducer returning whether the block moving mode is enabled or not.
 *
 * @param {string|null} state  Current state.
 * @param {Object}      action Dispatched action.
 *
 * @return {string|null} Updated state.
 */

function hasBlockMovingClientId() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  // Let inserting block always trigger Edit mode.
  if (action.type === 'SET_BLOCK_MOVING_MODE') {
    return action.hasBlockMovingClientId;
  }

  if (action.type === 'SET_NAVIGATION_MODE') {
    return null;
  }

  return state;
}
/**
 * Reducer return an updated state representing the most recent block attribute
 * update. The state is structured as an object where the keys represent the
 * client IDs of blocks, the values a subset of attributes from the most recent
 * block update. The state is always reset to null if the last action is
 * anything other than an attributes update.
 *
 * @param {Object<string,Object>} state  Current state.
 * @param {Object}                action Action object.
 *
 * @return {[string,Object]} Updated state.
 */

function lastBlockAttributesChange(state, action) {
  switch (action.type) {
    case 'UPDATE_BLOCK':
      if (!action.updates.attributes) {
        break;
      }

      return {
        [action.clientId]: action.updates.attributes
      };

    case 'UPDATE_BLOCK_ATTRIBUTES':
      return action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
        [id]: action.uniqueByBlock ? action.attributes[id] : action.attributes
      }), {});
  }

  return null;
}
/**
 * Reducer returning automatic change state.
 *
 * @param {?string} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function automaticChangeStatus(state, action) {
  switch (action.type) {
    case 'MARK_AUTOMATIC_CHANGE':
      return 'pending';

    case 'MARK_AUTOMATIC_CHANGE_FINAL':
      if (state === 'pending') {
        return 'final';
      }

      return;

    case 'SELECTION_CHANGE':
      // As long as the state is not final, ignore any selection changes.
      if (state !== 'final') {
        return state;
      }

      return;
    // Undoing an automatic change should still be possible after mouse
    // move or after visibility change.

    case 'SET_BLOCK_VISIBILITY':
    case 'START_TYPING':
    case 'STOP_TYPING':
      return state;
  } // Reset the state by default (for any action not handled).

}
/**
 * Reducer returning current highlighted block.
 *
 * @param {boolean} state  Current highlighted block.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function highlightedBlock(state, action) {
  switch (action.type) {
    case 'TOGGLE_BLOCK_HIGHLIGHT':
      const {
        clientId,
        isHighlighted
      } = action;

      if (isHighlighted) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }

      return state;

    case 'SELECT_BLOCK':
      if (action.clientId !== state) {
        return null;
      }

  }

  return state;
}
/**
 * Reducer returning the block insertion event list state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function lastBlockInserted() {
  var _action$meta;

  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'INSERT_BLOCKS':
      if (!action.blocks.length) {
        return state;
      }

      const clientId = action.blocks[0].clientId;
      const source = (_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : _action$meta.source;
      return {
        clientId,
        source
      };

    case 'RESET_BLOCKS':
      return {};
  }

  return state;
}
/* harmony default export */ const reducer = ((0,data_build_module/* combineReducers */.HY)({
  blocks,
  isTyping,
  draggedBlocks,
  selection,
  isMultiSelecting,
  isSelectionEnabled,
  initialPosition,
  blocksMode,
  blockListSettings,
  insertionPoint,
  template,
  settings,
  preferences,
  lastBlockAttributesChange,
  isNavigationMode,
  hasBlockMovingClientId,
  automaticChangeStatus,
  highlightedBlock,
  lastBlockInserted
}));
//# sourceMappingURL=reducer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js
var rememo = __webpack_require__("../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/platform.js
/**
 * Parts of this source were derived and modified from react-native-web,
 * released under the MIT license.
 *
 * Copyright (c) 2016-present, Nicolas Gallagher.
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 */
const Platform = {
  OS: 'web',
  select: spec => 'web' in spec ? spec.web : spec.default,
  isWeb: true
};
/**
 * Component used to detect the current Platform being used.
 * Use Platform.OS === 'web' to detect if running on web enviroment.
 *
 * This is the same concept as the React Native implementation.
 *
 * @see https://facebook.github.io/react-native/docs/platform-specific-code#platform-module
 *
 * Here is an example of how to use the select method:
 * @example
 * ```js
 * import { Platform } from '@wordpress/element';
 *
 * const placeholderLabel = Platform.select( {
 *   native: __( 'Add media' ),
 *   web: __( 'Drag images, upload new ones or select files from your library.' ),
 * } );
 * ```
 */

/* harmony default export */ const platform = (Platform);
//# sourceMappingURL=platform.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/symbol.js

/**
 * WordPress dependencies
 */

const symbol = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M21.3 10.8l-5.6-5.6c-.7-.7-1.8-.7-2.5 0l-5.6 5.6c-.7.7-.7 1.8 0 2.5l5.6 5.6c.3.3.8.5 1.2.5s.9-.2 1.2-.5l5.6-5.6c.8-.7.8-1.9.1-2.5zm-1 1.4l-5.6 5.6c-.1.1-.3.1-.4 0l-5.6-5.6c-.1-.1-.1-.3 0-.4l5.6-5.6s.1-.1.2-.1.1 0 .2.1l5.6 5.6c.1.1.1.3 0 .4zm-16.6-.4L10 5.5l-1-1-6.3 6.3c-.7.7-.7 1.8 0 2.5L9 19.5l1.1-1.1-6.3-6.3c-.2 0-.2-.2-.1-.3z"
}));
/* harmony default export */ const library_symbol = (symbol);
//# sourceMappingURL=symbol.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/store/reducer.js
/**
 * WordPress dependencies
 */

/**
 * Reducer managing the format types
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function formatTypes() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ADD_FORMAT_TYPES':
      return { ...state,
        // Key format types by their name.
        ...action.formatTypes.reduce((newFormatTypes, type) => ({ ...newFormatTypes,
          [type.name]: type
        }), {})
      };

    case 'REMOVE_FORMAT_TYPES':
      return Object.fromEntries(Object.entries(state).filter(_ref => {
        let [key] = _ref;
        return !action.names.includes(key);
      }));
  }

  return state;
}
/* harmony default export */ const store_reducer = ((0,data_build_module/* combineReducers */.HY)({
  formatTypes
}));
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/store/selectors.js
/**
 * External dependencies
 */

/**
 * Returns all the available format types.
 *
 * @param {Object} state Data state.
 *
 * @return {Array} Format types.
 */

const getFormatTypes = (0,rememo/* default */.A)(state => Object.values(state.formatTypes), state => [state.formatTypes]);
/**
 * Returns a format type by name.
 *
 * @param {Object} state Data state.
 * @param {string} name  Format type name.
 *
 * @return {Object?} Format type.
 */

function getFormatType(state, name) {
  return state.formatTypes[name];
}
/**
 * Gets the format type, if any, that can handle a bare element (without a
 * data-format-type attribute), given the tag name of this element.
 *
 * @param {Object} state              Data state.
 * @param {string} bareElementTagName The tag name of the element to find a
 *                                    format type for.
 * @return {?Object} Format type.
 */

function getFormatTypeForBareElement(state, bareElementTagName) {
  return getFormatTypes(state).find(_ref => {
    let {
      className,
      tagName
    } = _ref;
    return className === null && bareElementTagName === tagName;
  });
}
/**
 * Gets the format type, if any, that can handle an element, given its classes.
 *
 * @param {Object} state            Data state.
 * @param {string} elementClassName The classes of the element to find a format
 *                                  type for.
 * @return {?Object} Format type.
 */

function getFormatTypeForClassName(state, elementClassName) {
  return getFormatTypes(state).find(_ref2 => {
    let {
      className
    } = _ref2;

    if (className === null) {
      return false;
    }

    return ` ${elementClassName} `.indexOf(` ${className} `) >= 0;
  });
}
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/store/actions.js
/**
 * Returns an action object used in signalling that format types have been
 * added.
 *
 * @param {Array|Object} formatTypes Format types received.
 *
 * @return {Object} Action object.
 */
function addFormatTypes(formatTypes) {
  return {
    type: 'ADD_FORMAT_TYPES',
    formatTypes: Array.isArray(formatTypes) ? formatTypes : [formatTypes]
  };
}
/**
 * Returns an action object used to remove a registered format type.
 *
 * @param {string|Array} names Format name.
 *
 * @return {Object} Action object.
 */

function removeFormatTypes(names) {
  return {
    type: 'REMOVE_FORMAT_TYPES',
    names: Array.isArray(names) ? names : [names]
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const STORE_NAME = 'core/rich-text';
/**
 * Store definition for the rich-text namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const store = (0,redux_store/* default */.A)(STORE_NAME, {
  reducer: store_reducer,
  selectors: selectors_namespaceObject,
  actions: actions_namespaceObject
});
(0,data_build_module/* register */.kz)(store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/create-element.js
/**
 * Parse the given HTML into a body element.
 *
 * Note: The current implementation will return a shared reference, reset on
 * each call to `createElement`. Therefore, you should not hold a reference to
 * the value to operate upon asynchronously, as it may have unexpected results.
 *
 * @param {HTMLDocument} document The HTML document to use to parse.
 * @param {string}       html     The HTML to parse.
 *
 * @return {HTMLBodyElement} Body element with parsed HTML.
 */
function create_element_createElement(_ref, html) {
  let {
    implementation
  } = _ref;

  // Because `createHTMLDocument` is an expensive operation, and with this
  // function being internal to `rich-text` (full control in avoiding a risk
  // of asynchronous operations on the shared reference), a single document
  // is reused and reset for each call to the function.
  if (!create_element_createElement.body) {
    create_element_createElement.body = implementation.createHTMLDocument('').body;
  }

  create_element_createElement.body.innerHTML = html;
  return create_element_createElement.body;
}
//# sourceMappingURL=create-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/concat.js
/**
 * Internal dependencies
 */


/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Concats a pair of rich text values. Not that this mutates `a` and does NOT
 * normalise formats!
 *
 * @param {Object} a Value to mutate.
 * @param {Object} b Value to add read from.
 *
 * @return {Object} `a`, mutated.
 */

function mergePair(a, b) {
  a.formats = a.formats.concat(b.formats);
  a.replacements = a.replacements.concat(b.replacements);
  a.text += b.text;
  return a;
}
/**
 * Combine all Rich Text values into one. This is similar to
 * `String.prototype.concat`.
 *
 * @param {...RichTextValue} values Objects to combine.
 *
 * @return {RichTextValue} A new value combining all given records.
 */

function concat() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  return normaliseFormats(values.reduce(mergePair, create()));
}
//# sourceMappingURL=concat.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/special-characters.js
/**
 * Line separator character, used for multiline text.
 */
const LINE_SEPARATOR = '\u2028';
/**
 * Object replacement character, used as a placeholder for objects.
 */

const OBJECT_REPLACEMENT_CHARACTER = '\ufffc';
/**
 * Zero width non-breaking space, used as padding in the editable DOM tree when
 * it is empty otherwise.
 */

const ZWNBSP = '\ufeff';
//# sourceMappingURL=special-characters.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/create.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





/**
 * @typedef {Object} RichTextFormat
 *
 * @property {string} type Format type.
 */

/**
 * @typedef {Array<RichTextFormat>} RichTextFormatList
 */

/**
 * @typedef {Object} RichTextValue
 *
 * @property {string}                    text         Text.
 * @property {Array<RichTextFormatList>} formats      Formats.
 * @property {Array<RichTextFormat>}     replacements Replacements.
 * @property {number|undefined}          start        Selection start.
 * @property {number|undefined}          end          Selection end.
 */

function createEmptyValue() {
  return {
    formats: [],
    replacements: [],
    text: ''
  };
}

function toFormat(_ref) {
  let {
    type,
    attributes
  } = _ref;
  let formatType;

  if (attributes && attributes.class) {
    formatType = (0,data_build_module/* select */.Lt)(store).getFormatTypeForClassName(attributes.class);

    if (formatType) {
      // Preserve any additional classes.
      attributes.class = ` ${attributes.class} `.replace(` ${formatType.className} `, ' ').trim();

      if (!attributes.class) {
        delete attributes.class;
      }
    }
  }

  if (!formatType) {
    formatType = (0,data_build_module/* select */.Lt)(store).getFormatTypeForBareElement(type);
  }

  if (!formatType) {
    return attributes ? {
      type,
      attributes
    } : {
      type
    };
  }

  if (formatType.__experimentalCreatePrepareEditableTree && !formatType.__experimentalCreateOnChangeEditableValue) {
    return null;
  }

  if (!attributes) {
    return {
      type: formatType.name
    };
  }

  const registeredAttributes = {};
  const unregisteredAttributes = {};
  const _attributes = { ...attributes
  };

  for (const key in formatType.attributes) {
    const name = formatType.attributes[key];
    registeredAttributes[key] = _attributes[name];

    if (formatType.__unstableFilterAttributeValue) {
      registeredAttributes[key] = formatType.__unstableFilterAttributeValue(key, registeredAttributes[key]);
    } // delete the attribute and what's left is considered
    // to be unregistered.


    delete _attributes[name];

    if (typeof registeredAttributes[key] === 'undefined') {
      delete registeredAttributes[key];
    }
  }

  for (const name in _attributes) {
    unregisteredAttributes[name] = attributes[name];
  }

  return {
    type: formatType.name,
    attributes: registeredAttributes,
    unregisteredAttributes
  };
}
/**
 * Create a RichText value from an `Element` tree (DOM), an HTML string or a
 * plain text string, with optionally a `Range` object to set the selection. If
 * called without any input, an empty value will be created. If
 * `multilineTag` is provided, any content of direct children whose type matches
 * `multilineTag` will be separated by two newlines. The optional functions can
 * be used to filter out content.
 *
 * A value will have the following shape, which you are strongly encouraged not
 * to modify without the use of helper functions:
 *
 * ```js
 * {
 *   text: string,
 *   formats: Array,
 *   replacements: Array,
 *   ?start: number,
 *   ?end: number,
 * }
 * ```
 *
 * As you can see, text and formatting are separated. `text` holds the text,
 * including any replacement characters for objects and lines. `formats`,
 * `objects` and `lines` are all sparse arrays of the same length as `text`. It
 * holds information about the formatting at the relevant text indices. Finally
 * `start` and `end` state which text indices are selected. They are only
 * provided if a `Range` was given.
 *
 * @param {Object}  [$1]                          Optional named arguments.
 * @param {Element} [$1.element]                  Element to create value from.
 * @param {string}  [$1.text]                     Text to create value from.
 * @param {string}  [$1.html]                     HTML to create value from.
 * @param {Range}   [$1.range]                    Range to create value from.
 * @param {string}  [$1.multilineTag]             Multiline tag if the structure is
 *                                                multiline.
 * @param {Array}   [$1.multilineWrapperTags]     Tags where lines can be found if
 *                                                nesting is possible.
 * @param {boolean} [$1.preserveWhiteSpace]       Whether or not to collapse white
 *                                                space characters.
 * @param {boolean} [$1.__unstableIsEditableTree]
 *
 * @return {RichTextValue} A rich text value.
 */


function create_create() {
  let {
    element,
    text,
    html,
    range,
    multilineTag,
    multilineWrapperTags,
    __unstableIsEditableTree: isEditableTree,
    preserveWhiteSpace
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (typeof text === 'string' && text.length > 0) {
    return {
      formats: Array(text.length),
      replacements: Array(text.length),
      text
    };
  }

  if (typeof html === 'string' && html.length > 0) {
    // It does not matter which document this is, we're just using it to
    // parse.
    element = create_element_createElement(document, html);
  }

  if (typeof element !== 'object') {
    return createEmptyValue();
  }

  if (!multilineTag) {
    return createFromElement({
      element,
      range,
      isEditableTree,
      preserveWhiteSpace
    });
  }

  return createFromMultilineElement({
    element,
    range,
    multilineTag,
    multilineWrapperTags,
    isEditableTree,
    preserveWhiteSpace
  });
}
/**
 * Helper to accumulate the value's selection start and end from the current
 * node and range.
 *
 * @param {Object} accumulator Object to accumulate into.
 * @param {Node}   node        Node to create value with.
 * @param {Range}  range       Range to create value with.
 * @param {Object} value       Value that is being accumulated.
 */

function accumulateSelection(accumulator, node, range, value) {
  if (!range) {
    return;
  }

  const {
    parentNode
  } = node;
  const {
    startContainer,
    startOffset,
    endContainer,
    endOffset
  } = range;
  const currentLength = accumulator.text.length; // Selection can be extracted from value.

  if (value.start !== undefined) {
    accumulator.start = currentLength + value.start; // Range indicates that the current node has selection.
  } else if (node === startContainer && node.nodeType === node.TEXT_NODE) {
    accumulator.start = currentLength + startOffset; // Range indicates that the current node is selected.
  } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset]) {
    accumulator.start = currentLength; // Range indicates that the selection is after the current node.
  } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset - 1]) {
    accumulator.start = currentLength + value.text.length; // Fallback if no child inside handled the selection.
  } else if (node === startContainer) {
    accumulator.start = currentLength;
  } // Selection can be extracted from value.


  if (value.end !== undefined) {
    accumulator.end = currentLength + value.end; // Range indicates that the current node has selection.
  } else if (node === endContainer && node.nodeType === node.TEXT_NODE) {
    accumulator.end = currentLength + endOffset; // Range indicates that the current node is selected.
  } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset - 1]) {
    accumulator.end = currentLength + value.text.length; // Range indicates that the selection is before the current node.
  } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset]) {
    accumulator.end = currentLength; // Fallback if no child inside handled the selection.
  } else if (node === endContainer) {
    accumulator.end = currentLength + endOffset;
  }
}
/**
 * Adjusts the start and end offsets from a range based on a text filter.
 *
 * @param {Node}     node   Node of which the text should be filtered.
 * @param {Range}    range  The range to filter.
 * @param {Function} filter Function to use to filter the text.
 *
 * @return {Object|void} Object containing range properties.
 */


function filterRange(node, range, filter) {
  if (!range) {
    return;
  }

  const {
    startContainer,
    endContainer
  } = range;
  let {
    startOffset,
    endOffset
  } = range;

  if (node === startContainer) {
    startOffset = filter(node.nodeValue.slice(0, startOffset)).length;
  }

  if (node === endContainer) {
    endOffset = filter(node.nodeValue.slice(0, endOffset)).length;
  }

  return {
    startContainer,
    startOffset,
    endContainer,
    endOffset
  };
}
/**
 * Collapse any whitespace used for HTML formatting to one space character,
 * because it will also be displayed as such by the browser.
 *
 * @param {string} string
 */


function collapseWhiteSpace(string) {
  return string.replace(/[\n\r\t]+/g, ' ');
}
/**
 * Removes reserved characters used by rich-text (zero width non breaking spaces added by `toTree` and object replacement characters).
 *
 * @param {string} string
 */


function removeReservedCharacters(string) {
  // with the global flag, note that we should create a new regex each time OR reset lastIndex state.
  return string.replace(new RegExp(`[${ZWNBSP}${OBJECT_REPLACEMENT_CHARACTER}]`, 'gu'), '');
}
/**
 * Creates a Rich Text value from a DOM element and range.
 *
 * @param {Object}  $1                        Named argements.
 * @param {Element} [$1.element]              Element to create value from.
 * @param {Range}   [$1.range]                Range to create value from.
 * @param {string}  [$1.multilineTag]         Multiline tag if the structure is
 *                                            multiline.
 * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if
 *                                            nesting is possible.
 * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white
 *                                            space characters.
 * @param {Array}   [$1.currentWrapperTags]
 * @param {boolean} [$1.isEditableTree]
 *
 * @return {RichTextValue} A rich text value.
 */

function createFromElement(_ref2) {
  let {
    element,
    range,
    multilineTag,
    multilineWrapperTags,
    currentWrapperTags = [],
    isEditableTree,
    preserveWhiteSpace
  } = _ref2;
  const accumulator = createEmptyValue();

  if (!element) {
    return accumulator;
  }

  if (!element.hasChildNodes()) {
    accumulateSelection(accumulator, element, range, createEmptyValue());
    return accumulator;
  }

  const length = element.childNodes.length; // Optimise for speed.

  for (let index = 0; index < length; index++) {
    const node = element.childNodes[index];
    const type = node.nodeName.toLowerCase();

    if (node.nodeType === node.TEXT_NODE) {
      let filter = removeReservedCharacters;

      if (!preserveWhiteSpace) {
        filter = string => removeReservedCharacters(collapseWhiteSpace(string));
      }

      const text = filter(node.nodeValue);
      range = filterRange(node, range, filter);
      accumulateSelection(accumulator, node, range, {
        text
      }); // Create a sparse array of the same length as `text`, in which
      // formats can be added.

      accumulator.formats.length += text.length;
      accumulator.replacements.length += text.length;
      accumulator.text += text;
      continue;
    }

    if (node.nodeType !== node.ELEMENT_NODE) {
      continue;
    }

    if (isEditableTree && ( // Ignore any placeholders.
    node.getAttribute('data-rich-text-placeholder') || // Ignore any line breaks that are not inserted by us.
    type === 'br' && !node.getAttribute('data-rich-text-line-break'))) {
      accumulateSelection(accumulator, node, range, createEmptyValue());
      continue;
    }

    if (type === 'script') {
      const value = {
        formats: [,],
        replacements: [{
          type,
          attributes: {
            'data-rich-text-script': node.getAttribute('data-rich-text-script') || encodeURIComponent(node.innerHTML)
          }
        }],
        text: OBJECT_REPLACEMENT_CHARACTER
      };
      accumulateSelection(accumulator, node, range, value);
      mergePair(accumulator, value);
      continue;
    }

    if (type === 'br') {
      accumulateSelection(accumulator, node, range, createEmptyValue());
      mergePair(accumulator, create_create({
        text: '\n'
      }));
      continue;
    }

    const format = toFormat({
      type,
      attributes: getAttributes({
        element: node
      })
    });

    if (multilineWrapperTags && multilineWrapperTags.indexOf(type) !== -1) {
      const value = createFromMultilineElement({
        element: node,
        range,
        multilineTag,
        multilineWrapperTags,
        currentWrapperTags: [...currentWrapperTags, format],
        isEditableTree,
        preserveWhiteSpace
      });
      accumulateSelection(accumulator, node, range, value);
      mergePair(accumulator, value);
      continue;
    }

    const value = createFromElement({
      element: node,
      range,
      multilineTag,
      multilineWrapperTags,
      isEditableTree,
      preserveWhiteSpace
    });
    accumulateSelection(accumulator, node, range, value);

    if (!format) {
      mergePair(accumulator, value);
    } else if (value.text.length === 0) {
      if (format.attributes) {
        mergePair(accumulator, {
          formats: [,],
          replacements: [format],
          text: OBJECT_REPLACEMENT_CHARACTER
        });
      }
    } else {
      // Indices should share a reference to the same formats array.
      // Only create a new reference if `formats` changes.
      function mergeFormats(formats) {
        if (mergeFormats.formats === formats) {
          return mergeFormats.newFormats;
        }

        const newFormats = formats ? [format, ...formats] : [format];
        mergeFormats.formats = formats;
        mergeFormats.newFormats = newFormats;
        return newFormats;
      } // Since the formats parameter can be `undefined`, preset
      // `mergeFormats` with a new reference.


      mergeFormats.newFormats = [format];
      mergePair(accumulator, { ...value,
        formats: Array.from(value.formats, mergeFormats)
      });
    }
  }

  return accumulator;
}
/**
 * Creates a rich text value from a DOM element and range that should be
 * multiline.
 *
 * @param {Object}  $1                        Named argements.
 * @param {Element} [$1.element]              Element to create value from.
 * @param {Range}   [$1.range]                Range to create value from.
 * @param {string}  [$1.multilineTag]         Multiline tag if the structure is
 *                                            multiline.
 * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if
 *                                            nesting is possible.
 * @param {Array}   [$1.currentWrapperTags]   Whether to prepend a line
 *                                            separator.
 * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white
 *                                            space characters.
 * @param {boolean} [$1.isEditableTree]
 *
 * @return {RichTextValue} A rich text value.
 */


function createFromMultilineElement(_ref3) {
  let {
    element,
    range,
    multilineTag,
    multilineWrapperTags,
    currentWrapperTags = [],
    isEditableTree,
    preserveWhiteSpace
  } = _ref3;
  const accumulator = createEmptyValue();

  if (!element || !element.hasChildNodes()) {
    return accumulator;
  }

  const length = element.children.length; // Optimise for speed.

  for (let index = 0; index < length; index++) {
    const node = element.children[index];

    if (node.nodeName.toLowerCase() !== multilineTag) {
      continue;
    }

    const value = createFromElement({
      element: node,
      range,
      multilineTag,
      multilineWrapperTags,
      currentWrapperTags,
      isEditableTree,
      preserveWhiteSpace
    }); // Multiline value text should be separated by a line separator.

    if (index !== 0 || currentWrapperTags.length > 0) {
      mergePair(accumulator, {
        formats: [,],
        replacements: currentWrapperTags.length > 0 ? [currentWrapperTags] : [,],
        text: LINE_SEPARATOR
      });
    }

    accumulateSelection(accumulator, node, range, value);
    mergePair(accumulator, value);
  }

  return accumulator;
}
/**
 * Gets the attributes of an element in object shape.
 *
 * @param {Object}  $1         Named argements.
 * @param {Element} $1.element Element to get attributes from.
 *
 * @return {Object|void} Attribute object or `undefined` if the element has no
 *                       attributes.
 */


function getAttributes(_ref4) {
  let {
    element
  } = _ref4;

  if (!element.hasAttributes()) {
    return;
  }

  const length = element.attributes.length;
  let accumulator; // Optimise for speed.

  for (let i = 0; i < length; i++) {
    const {
      name,
      value
    } = element.attributes[i];

    if (name.indexOf('data-rich-text-') === 0) {
      continue;
    }

    const safeName = /^on/i.test(name) ? 'data-disable-rich-text-' + name : name;
    accumulator = accumulator || {};
    accumulator[safeName] = value;
  }

  return accumulator;
}
//# sourceMappingURL=create.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/is-format-equal.js
/** @typedef {import('./create').RichTextFormat} RichTextFormat */

/**
 * Optimised equality check for format objects.
 *
 * @param {?RichTextFormat} format1 Format to compare.
 * @param {?RichTextFormat} format2 Format to compare.
 *
 * @return {boolean} True if formats are equal, false if not.
 */
function isFormatEqual(format1, format2) {
  // Both not defined.
  if (format1 === format2) {
    return true;
  } // Either not defined.


  if (!format1 || !format2) {
    return false;
  }

  if (format1.type !== format2.type) {
    return false;
  }

  const attributes1 = format1.attributes;
  const attributes2 = format2.attributes; // Both not defined.

  if (attributes1 === attributes2) {
    return true;
  } // Either not defined.


  if (!attributes1 || !attributes2) {
    return false;
  }

  const keys1 = Object.keys(attributes1);
  const keys2 = Object.keys(attributes2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  const length = keys1.length; // Optimise for speed.

  for (let i = 0; i < length; i++) {
    const name = keys1[i];

    if (attributes1[name] !== attributes2[name]) {
      return false;
    }
  }

  return true;
}
//# sourceMappingURL=is-format-equal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/normalise-formats.js
/**
 * Internal dependencies
 */

/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Normalises formats: ensures subsequent adjacent equal formats have the same
 * reference.
 *
 * @param {RichTextValue} value Value to normalise formats of.
 *
 * @return {RichTextValue} New value with normalised formats.
 */

function normalise_formats_normaliseFormats(value) {
  const newFormats = value.formats.slice();
  newFormats.forEach((formatsAtIndex, index) => {
    const formatsAtPreviousIndex = newFormats[index - 1];

    if (formatsAtPreviousIndex) {
      const newFormatsAtIndex = formatsAtIndex.slice();
      newFormatsAtIndex.forEach((format, formatIndex) => {
        const previousFormat = formatsAtPreviousIndex[formatIndex];

        if (isFormatEqual(format, previousFormat)) {
          newFormatsAtIndex[formatIndex] = previousFormat;
        }
      });
      newFormats[index] = newFormatsAtIndex;
    }
  });
  return { ...value,
    formats: newFormats
  };
}
//# sourceMappingURL=normalise-formats.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/insert.js
/**
 * Internal dependencies
 */


/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Insert a Rich Text value, an HTML string, or a plain text string, into a
 * Rich Text value at the given `startIndex`. Any content between `startIndex`
 * and `endIndex` will be removed. Indices are retrieved from the selection if
 * none are provided.
 *
 * @param {RichTextValue}        value         Value to modify.
 * @param {RichTextValue|string} valueToInsert Value to insert.
 * @param {number}               [startIndex]  Start index.
 * @param {number}               [endIndex]    End index.
 *
 * @return {RichTextValue} A new value with the value inserted.
 */

function insert(value, valueToInsert) {
  let startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : value.start;
  let endIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : value.end;
  const {
    formats,
    replacements,
    text
  } = value;

  if (typeof valueToInsert === 'string') {
    valueToInsert = create_create({
      text: valueToInsert
    });
  }

  const index = startIndex + valueToInsert.text.length;
  return normalise_formats_normaliseFormats({
    formats: formats.slice(0, startIndex).concat(valueToInsert.formats, formats.slice(endIndex)),
    replacements: replacements.slice(0, startIndex).concat(valueToInsert.replacements, replacements.slice(endIndex)),
    text: text.slice(0, startIndex) + valueToInsert.text + text.slice(endIndex),
    start: index,
    end: index
  });
}
//# sourceMappingURL=insert.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/remove.js
/**
 * Internal dependencies
 */


/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Remove content from a Rich Text value between the given `startIndex` and
 * `endIndex`. Indices are retrieved from the selection if none are provided.
 *
 * @param {RichTextValue} value        Value to modify.
 * @param {number}        [startIndex] Start index.
 * @param {number}        [endIndex]   End index.
 *
 * @return {RichTextValue} A new value with the content removed.
 */

function remove(value, startIndex, endIndex) {
  return insert(value, create_create(), startIndex, endIndex);
}
//# sourceMappingURL=remove.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+escape-html@2.47.0/node_modules/@wordpress/escape-html/build-module/index.js + 1 modules
var escape_html_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+escape-html@2.47.0/node_modules/@wordpress/escape-html/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/get-active-formats.js
/** @typedef {import('./create').RichTextValue} RichTextValue */

/** @typedef {import('./create').RichTextFormatList} RichTextFormatList */

/**
 * Gets the all format objects at the start of the selection.
 *
 * @param {RichTextValue} value                Value to inspect.
 * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no
 *                                             active formats.
 *
 * @return {RichTextFormatList} Active format objects.
 */
function getActiveFormats(_ref) {
  let {
    formats,
    start,
    end,
    activeFormats
  } = _ref;
  let EMPTY_ACTIVE_FORMATS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (start === undefined) {
    return EMPTY_ACTIVE_FORMATS;
  }

  if (start === end) {
    // For a collapsed caret, it is possible to override the active formats.
    if (activeFormats) {
      return activeFormats;
    }

    const formatsBefore = formats[start - 1] || EMPTY_ACTIVE_FORMATS;
    const formatsAfter = formats[start] || EMPTY_ACTIVE_FORMATS; // By default, select the lowest amount of formats possible (which means
    // the caret is positioned outside the format boundary). The user can
    // then use arrow keys to define `activeFormats`.

    if (formatsBefore.length < formatsAfter.length) {
      return formatsBefore;
    }

    return formatsAfter;
  }

  return formats[start] || EMPTY_ACTIVE_FORMATS;
}
//# sourceMappingURL=get-active-formats.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/get-format-type.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */

/**
 * Returns a registered format type.
 *
 * @param {string} name Format name.
 *
 * @return {RichTextFormatType|undefined} Format type.
 */

function get_format_type_getFormatType(name) {
  return (0,data_build_module/* select */.Lt)(store).getFormatType(name);
}
//# sourceMappingURL=get-format-type.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/to-tree.js
/**
 * Internal dependencies
 */




function restoreOnAttributes(attributes, isEditableTree) {
  if (isEditableTree) {
    return attributes;
  }

  const newAttributes = {};

  for (const key in attributes) {
    let newKey = key;

    if (key.startsWith('data-disable-rich-text-')) {
      newKey = key.slice('data-disable-rich-text-'.length);
    }

    newAttributes[newKey] = attributes[key];
  }

  return newAttributes;
}
/**
 * Converts a format object to information that can be used to create an element
 * from (type, attributes and object).
 *
 * @param {Object}  $1                        Named parameters.
 * @param {string}  $1.type                   The format type.
 * @param {Object}  $1.attributes             The format attributes.
 * @param {Object}  $1.unregisteredAttributes The unregistered format
 *                                            attributes.
 * @param {boolean} $1.object                 Whether or not it is an object
 *                                            format.
 * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary
 *                                            class.
 * @param {boolean} $1.isEditableTree
 *
 * @return {Object} Information to be used for element creation.
 */


function fromFormat(_ref) {
  let {
    type,
    attributes,
    unregisteredAttributes,
    object,
    boundaryClass,
    isEditableTree
  } = _ref;
  const formatType = get_format_type_getFormatType(type);
  let elementAttributes = {};

  if (boundaryClass) {
    elementAttributes['data-rich-text-format-boundary'] = 'true';
  }

  if (!formatType) {
    if (attributes) {
      elementAttributes = { ...attributes,
        ...elementAttributes
      };
    }

    return {
      type,
      attributes: restoreOnAttributes(elementAttributes, isEditableTree),
      object
    };
  }

  elementAttributes = { ...unregisteredAttributes,
    ...elementAttributes
  };

  for (const name in attributes) {
    const key = formatType.attributes ? formatType.attributes[name] : false;

    if (key) {
      elementAttributes[key] = attributes[name];
    } else {
      elementAttributes[name] = attributes[name];
    }
  }

  if (formatType.className) {
    if (elementAttributes.class) {
      elementAttributes.class = `${formatType.className} ${elementAttributes.class}`;
    } else {
      elementAttributes.class = formatType.className;
    }
  }

  return {
    type: formatType.tagName,
    object: formatType.object,
    attributes: restoreOnAttributes(elementAttributes, isEditableTree)
  };
}
/**
 * Checks if both arrays of formats up until a certain index are equal.
 *
 * @param {Array}  a     Array of formats to compare.
 * @param {Array}  b     Array of formats to compare.
 * @param {number} index Index to check until.
 */


function isEqualUntil(a, b, index) {
  do {
    if (a[index] !== b[index]) {
      return false;
    }
  } while (index--);

  return true;
}

function toTree(_ref2) {
  let {
    value,
    multilineTag,
    preserveWhiteSpace,
    createEmpty,
    append,
    getLastChild,
    getParent,
    isText,
    getText,
    remove,
    appendText,
    onStartIndex,
    onEndIndex,
    isEditableTree,
    placeholder
  } = _ref2;
  const {
    formats,
    replacements,
    text,
    start,
    end
  } = value;
  const formatsLength = formats.length + 1;
  const tree = createEmpty();
  const multilineFormat = {
    type: multilineTag
  };
  const activeFormats = getActiveFormats(value);
  const deepestActiveFormat = activeFormats[activeFormats.length - 1];
  let lastSeparatorFormats;
  let lastCharacterFormats;
  let lastCharacter; // If we're building a multiline tree, start off with a multiline element.

  if (multilineTag) {
    append(append(tree, {
      type: multilineTag
    }), '');
    lastCharacterFormats = lastSeparatorFormats = [multilineFormat];
  } else {
    append(tree, '');
  }

  for (let i = 0; i < formatsLength; i++) {
    const character = text.charAt(i);
    const shouldInsertPadding = isEditableTree && ( // Pad the line if the line is empty.
    !lastCharacter || lastCharacter === LINE_SEPARATOR || // Pad the line if the previous character is a line break, otherwise
    // the line break won't be visible.
    lastCharacter === '\n');
    let characterFormats = formats[i]; // Set multiline tags in queue for building the tree.

    if (multilineTag) {
      if (character === LINE_SEPARATOR) {
        characterFormats = lastSeparatorFormats = (replacements[i] || []).reduce((accumulator, format) => {
          accumulator.push(format, multilineFormat);
          return accumulator;
        }, [multilineFormat]);
      } else {
        characterFormats = [...lastSeparatorFormats, ...(characterFormats || [])];
      }
    }

    let pointer = getLastChild(tree);

    if (shouldInsertPadding && character === LINE_SEPARATOR) {
      let node = pointer;

      while (!isText(node)) {
        node = getLastChild(node);
      }

      append(getParent(node), ZWNBSP);
    } // Set selection for the start of line.


    if (lastCharacter === LINE_SEPARATOR) {
      let node = pointer;

      while (!isText(node)) {
        node = getLastChild(node);
      }

      if (onStartIndex && start === i) {
        onStartIndex(tree, node);
      }

      if (onEndIndex && end === i) {
        onEndIndex(tree, node);
      }
    }

    if (characterFormats) {
      characterFormats.forEach((format, formatIndex) => {
        if (pointer && lastCharacterFormats && // Reuse the last element if all formats remain the same.
        isEqualUntil(characterFormats, lastCharacterFormats, formatIndex) && ( // Do not reuse the last element if the character is a
        // line separator.
        character !== LINE_SEPARATOR || characterFormats.length - 1 !== formatIndex)) {
          pointer = getLastChild(pointer);
          return;
        }

        const {
          type,
          attributes,
          unregisteredAttributes
        } = format;
        const boundaryClass = isEditableTree && character !== LINE_SEPARATOR && format === deepestActiveFormat;
        const parent = getParent(pointer);
        const newNode = append(parent, fromFormat({
          type,
          attributes,
          unregisteredAttributes,
          boundaryClass,
          isEditableTree
        }));

        if (isText(pointer) && getText(pointer).length === 0) {
          remove(pointer);
        }

        pointer = append(newNode, '');
      });
    } // No need for further processing if the character is a line separator.


    if (character === LINE_SEPARATOR) {
      lastCharacterFormats = characterFormats;
      lastCharacter = character;
      continue;
    } // If there is selection at 0, handle it before characters are inserted.


    if (i === 0) {
      if (onStartIndex && start === 0) {
        onStartIndex(tree, pointer);
      }

      if (onEndIndex && end === 0) {
        onEndIndex(tree, pointer);
      }
    }

    if (character === OBJECT_REPLACEMENT_CHARACTER) {
      var _replacements$i;

      if (!isEditableTree && ((_replacements$i = replacements[i]) === null || _replacements$i === void 0 ? void 0 : _replacements$i.type) === 'script') {
        pointer = append(getParent(pointer), fromFormat({
          type: 'script',
          isEditableTree
        }));
        append(pointer, {
          html: decodeURIComponent(replacements[i].attributes['data-rich-text-script'])
        });
      } else {
        pointer = append(getParent(pointer), fromFormat({ ...replacements[i],
          object: true,
          isEditableTree
        }));
      } // Ensure pointer is text node.


      pointer = append(getParent(pointer), '');
    } else if (!preserveWhiteSpace && character === '\n') {
      pointer = append(getParent(pointer), {
        type: 'br',
        attributes: isEditableTree ? {
          'data-rich-text-line-break': 'true'
        } : undefined,
        object: true
      }); // Ensure pointer is text node.

      pointer = append(getParent(pointer), '');
    } else if (!isText(pointer)) {
      pointer = append(getParent(pointer), character);
    } else {
      appendText(pointer, character);
    }

    if (onStartIndex && start === i + 1) {
      onStartIndex(tree, pointer);
    }

    if (onEndIndex && end === i + 1) {
      onEndIndex(tree, pointer);
    }

    if (shouldInsertPadding && i === text.length) {
      append(getParent(pointer), ZWNBSP);

      if (placeholder && text.length === 0) {
        append(getParent(pointer), {
          type: 'span',
          attributes: {
            'data-rich-text-placeholder': placeholder,
            // Necessary to prevent the placeholder from catching
            // selection. The placeholder is also not editable after
            // all.
            contenteditable: 'false',
            style: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;'
          }
        });
      }
    }

    lastCharacterFormats = characterFormats;
    lastCharacter = character;
  }

  return tree;
}
//# sourceMappingURL=to-tree.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/to-html-string.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/** @typedef {import('./create').RichTextValue} RichTextValue */

/**
 * Create an HTML string from a Rich Text value. If a `multilineTag` is
 * provided, text separated by a line separator will be wrapped in it.
 *
 * @param {Object}        $1                      Named argements.
 * @param {RichTextValue} $1.value                Rich text value.
 * @param {string}        [$1.multilineTag]       Multiline tag.
 * @param {boolean}       [$1.preserveWhiteSpace] Whether or not to use newline
 *                                                characters for line breaks.
 *
 * @return {string} HTML string.
 */

function toHTMLString(_ref) {
  let {
    value,
    multilineTag,
    preserveWhiteSpace
  } = _ref;
  const tree = toTree({
    value,
    multilineTag,
    preserveWhiteSpace,
    createEmpty,
    append,
    getLastChild,
    getParent,
    isText,
    getText,
    remove: to_html_string_remove,
    appendText
  });
  return createChildrenHTML(tree.children);
}

function createEmpty() {
  return {};
}

function getLastChild(_ref2) {
  let {
    children
  } = _ref2;
  return children && children[children.length - 1];
}

function append(parent, object) {
  if (typeof object === 'string') {
    object = {
      text: object
    };
  }

  object.parent = parent;
  parent.children = parent.children || [];
  parent.children.push(object);
  return object;
}

function appendText(object, text) {
  object.text += text;
}

function getParent(_ref3) {
  let {
    parent
  } = _ref3;
  return parent;
}

function isText(_ref4) {
  let {
    text
  } = _ref4;
  return typeof text === 'string';
}

function getText(_ref5) {
  let {
    text
  } = _ref5;
  return text;
}

function to_html_string_remove(object) {
  const index = object.parent.children.indexOf(object);

  if (index !== -1) {
    object.parent.children.splice(index, 1);
  }

  return object;
}

function createElementHTML(_ref6) {
  let {
    type,
    attributes,
    object,
    children
  } = _ref6;
  let attributeString = '';

  for (const key in attributes) {
    if (!(0,escape_html_build_module/* isValidAttributeName */.i8)(key)) {
      continue;
    }

    attributeString += ` ${key}="${(0,escape_html_build_module/* escapeAttribute */.Gj)(attributes[key])}"`;
  }

  if (object) {
    return `<${type}${attributeString}>`;
  }

  return `<${type}${attributeString}>${createChildrenHTML(children)}</${type}>`;
}

function createChildrenHTML() {
  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return children.map(child => {
    if (child.html !== undefined) {
      return child.html;
    }

    return child.text === undefined ? createElementHTML(child) : (0,escape_html_build_module/* escapeEditableHTML */.jG)(child.text);
  }).join('');
}
//# sourceMappingURL=to-html-string.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+rich-text@5.20.0_react@17.0.2/node_modules/@wordpress/rich-text/build-module/index.js






























//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/utils.js
/**
 * Helper function that maps attribute definition properties to the
 * ones used by RichText utils like `create, toHTMLString, etc..`.
 *
 * @param {Object} attributeDefinition A block's attribute definition object.
 * @return {Object} The mapped object.
 */
function mapRichTextSettings(attributeDefinition) {
  const {
    multiline: multilineTag,
    __unstableMultilineWrapperTags: multilineWrapperTags,
    __unstablePreserveWhiteSpace: preserveWhiteSpace
  } = attributeDefinition;
  return {
    multilineTag,
    multilineWrapperTags,
    preserveWhiteSpace
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/selectors.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */


/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */
// Module constants.

const MILLISECONDS_PER_HOUR = 3600 * 1000;
const MILLISECONDS_PER_DAY = 24 * 3600 * 1000;
const MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Array}
 */

const EMPTY_ARRAY = [];
/**
 * Returns a block's name given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {string} Block name.
 */

function getBlockName(state, clientId) {
  const block = state.blocks.byClientId[clientId];
  const socialLinkName = 'core/social-link';

  if (platform.OS !== 'web' && (block === null || block === void 0 ? void 0 : block.name) === socialLinkName) {
    const attributes = state.blocks.attributes[clientId];
    const {
      service
    } = attributes;
    return service ? `${socialLinkName}-${service}` : socialLinkName;
  }

  return block ? block.name : null;
}
/**
 * Returns whether a block is valid or not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Is Valid.
 */

function isBlockValid(state, clientId) {
  const block = state.blocks.byClientId[clientId];
  return !!block && block.isValid;
}
/**
 * Returns a block's attributes given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object?} Block attributes.
 */

function getBlockAttributes(state, clientId) {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return state.blocks.attributes[clientId];
}
/**
 * Returns a block given its client ID. This is a parsed copy of the block,
 * containing its `blockName`, `clientId`, and current `attributes` state. This
 * is not the block's registration settings, which must be retrieved from the
 * blocks module registration store.
 *
 * getBlock recurses through its inner blocks until all its children blocks have
 * been retrieved. Note that getBlock will not return the child inner blocks of
 * an inner block controller. This is because an inner block controller syncs
 * itself with its own entity, and should therefore not be included with the
 * blocks of a different entity. For example, say you call `getBlocks( TP )` to
 * get the blocks of a template part. If another template part is a child of TP,
 * then the nested template part's child blocks will not be returned. This way,
 * the template block itself is considered part of the parent, but the children
 * are not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Parsed block object.
 */

function getBlock(state, clientId) {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return state.blocks.tree[clientId];
}
const __unstableGetBlockWithoutInnerBlocks = (0,rememo/* default */.A)((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: getBlockAttributes(state, clientId)
  };
}, (state, clientId) => [state.blocks.byClientId[clientId], state.blocks.attributes[clientId]]);
/**
 * Returns all block objects for the current post being edited as an array in
 * the order they appear in the post. Note that this will exclude child blocks
 * of nested inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

function getBlocks(state, rootClientId) {
  var _state$blocks$tree$tr;

  const treeKey = !rootClientId || !areInnerBlocksControlled(state, rootClientId) ? rootClientId || '' : 'controlled||' + rootClientId;
  return ((_state$blocks$tree$tr = state.blocks.tree[treeKey]) === null || _state$blocks$tree$tr === void 0 ? void 0 : _state$blocks$tree$tr.innerBlocks) || EMPTY_ARRAY;
}
/**
 * Returns a stripped down block object containing only its client ID,
 * and its inner blocks' client IDs.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} Client IDs of the post blocks.
 */

const __unstableGetClientIdWithClientIdsTree = (0,rememo/* default */.A)((state, clientId) => ({
  clientId,
  innerBlocks: __unstableGetClientIdsTree(state, clientId)
}), state => [state.blocks.order]);
/**
 * Returns the block tree represented in the block-editor store from the
 * given root, consisting of stripped down block objects containing only
 * their client IDs, and their inner blocks' client IDs.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Client IDs of the post blocks.
 */

const __unstableGetClientIdsTree = (0,rememo/* default */.A)(function (state) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return (0,lodash.map)(getBlockOrder(state, rootClientId), clientId => __unstableGetClientIdWithClientIdsTree(state, clientId));
}, state => [state.blocks.order]);
/**
 * Returns an array containing the clientIds of all descendants of the blocks
 * given. Returned ids are ordered first by the order of the ids given, then
 * by the order that they appear in the editor.
 *
 * @param {Object} state     Global application state.
 * @param {Array}  clientIds Array of blocks to inspect.
 *
 * @return {Array} ids of descendants.
 */

const getClientIdsOfDescendants = (0,rememo/* default */.A)((state, clientIds) => {
  const collectedIds = [];

  for (const givenId of clientIds) {
    for (const descendantId of getBlockOrder(state, givenId)) {
      collectedIds.push(descendantId, ...getClientIdsOfDescendants(state, [descendantId]));
    }
  }

  return collectedIds;
}, state => [state.blocks.order]);
/**
 * Returns an array containing the clientIds of the top-level blocks and
 * their descendants of any depth (for nested blocks). Ids are returned
 * in the same order that they appear in the editor.
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} ids of top-level and descendant blocks.
 */

const getClientIdsWithDescendants = (0,rememo/* default */.A)(state => {
  const collectedIds = [];

  for (const topLevelId of getBlockOrder(state)) {
    collectedIds.push(topLevelId, ...getClientIdsOfDescendants(state, [topLevelId]));
  }

  return collectedIds;
}, state => [state.blocks.order]);
/**
 * Returns the total number of blocks, or the total number of blocks with a specific name in a post.
 * The number returned includes nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if specified only blocks of that type will be counted.
 *
 * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.
 */

const getGlobalBlockCount = (0,rememo/* default */.A)((state, blockName) => {
  const clientIds = getClientIdsWithDescendants(state);

  if (!blockName) {
    return clientIds.length;
  }

  return (0,lodash.reduce)(clientIds, (accumulator, clientId) => {
    const block = state.blocks.byClientId[clientId];
    return block.name === blockName ? accumulator + 1 : accumulator;
  }, 0);
}, state => [state.blocks.order, state.blocks.byClientId]);
/**
 * Returns all global blocks that match a blockName. Results include nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if not specified, returns an empty array.
 *
 * @return {Array} Array of clientIds of blocks with name equal to blockName.
 */

const __experimentalGetGlobalBlocksByName = (0,rememo/* default */.A)((state, blockName) => {
  if (!blockName) {
    return EMPTY_ARRAY;
  }

  const clientIds = getClientIdsWithDescendants(state);
  const foundBlocks = clientIds.filter(clientId => {
    const block = state.blocks.byClientId[clientId];
    return block.name === blockName;
  });
  return foundBlocks.length > 0 ? foundBlocks : EMPTY_ARRAY;
}, state => [state.blocks.order, state.blocks.byClientId]);
/**
 * Given an array of block client IDs, returns the corresponding array of block
 * objects.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which blocks are to be returned.
 *
 * @return {WPBlock[]} Block objects.
 */

const getBlocksByClientId = (0,rememo/* default */.A)((state, clientIds) => (0,lodash.map)((0,lodash.castArray)(clientIds), clientId => getBlock(state, clientId)), (state, clientIds) => (0,lodash.map)((0,lodash.castArray)(clientIds), clientId => state.blocks.tree[clientId]));
/**
 * Returns the number of blocks currently present in the post.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Number of blocks in the post.
 */

function getBlockCount(state, rootClientId) {
  return getBlockOrder(state, rootClientId).length;
}
/**
 * Returns the current selection start block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection start information.
 */

function getSelectionStart(state) {
  return state.selection.selectionStart;
}
/**
 * Returns the current selection end block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection end information.
 */

function getSelectionEnd(state) {
  return state.selection.selectionEnd;
}
/**
 * Returns the current block selection start. This value may be null, and it
 * may represent either a singular block selection or multi-selection start.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection start.
 */

function getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}
/**
 * Returns the current block selection end. This value may be null, and it
 * may represent either a singular block selection or multi-selection end.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection end.
 */

function getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}
/**
 * Returns the number of blocks currently selected in the post.
 *
 * @param {Object} state Global application state.
 *
 * @return {number} Number of blocks selected in the post.
 */

function getSelectedBlockCount(state) {
  const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;

  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }

  return state.selection.selectionStart.clientId ? 1 : 0;
}
/**
 * Returns true if there is a single selected block, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether a single block is selected.
 */

function hasSelectedBlock(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}
/**
 * Returns the currently selected block client ID, or null if there is no
 * selected block.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Selected block client ID.
 */

function getSelectedBlockClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  const {
    clientId
  } = selectionStart;

  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }

  return clientId;
}
/**
 * Returns the currently selected block, or null if there is no selected block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?Object} Selected block.
 */

function getSelectedBlock(state) {
  const clientId = getSelectedBlockClientId(state);
  return clientId ? getBlock(state, clientId) : null;
}
/**
 * Given a block client ID, returns the root block from which the block is
 * nested, an empty string for top-level blocks, or null if the block does not
 * exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {?string} Root client ID, if exists
 */

function getBlockRootClientId(state, clientId) {
  return state.blocks.parents[clientId] !== undefined ? state.blocks.parents[clientId] : null;
}
/**
 * Given a block client ID, returns the list of all its parents from top to bottom.
 *
 * @param {Object}  state     Editor state.
 * @param {string}  clientId  Block from which to find root client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParents = (0,rememo/* default */.A)(function (state, clientId) {
  let ascending = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const parents = [];
  let current = clientId;

  while (!!state.blocks.parents[current]) {
    current = state.blocks.parents[current];
    parents.push(current);
  }

  return ascending ? parents : parents.reverse();
}, state => [state.blocks.parents]);
/**
 * Given a block client ID and a block name, returns the list of all its parents
 * from top to bottom, filtered by the given name(s). For example, if passed
 * 'core/group' as the blockName, it will only return parents which are group
 * blocks. If passed `[ 'core/group', 'core/cover']`, as the blockName, it will
 * return parents which are group blocks and parents which are cover blocks.
 *
 * @param {Object}          state     Editor state.
 * @param {string}          clientId  Block from which to find root client ID.
 * @param {string|string[]} blockName Block name(s) to filter.
 * @param {boolean}         ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParentsByBlockName = (0,rememo/* default */.A)(function (state, clientId, blockName) {
  let ascending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const parents = getBlockParents(state, clientId, ascending);
  return (0,lodash.map)((0,lodash.filter)((0,lodash.map)(parents, id => ({
    id,
    name: getBlockName(state, id)
  })), _ref => {
    let {
      name
    } = _ref;

    if (Array.isArray(blockName)) {
      return blockName.includes(name);
    }

    return name === blockName;
  }), _ref2 => {
    let {
      id
    } = _ref2;
    return id;
  });
}, state => [state.blocks.parents]);
/**
 * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {string} Root client ID
 */

function getBlockHierarchyRootClientId(state, clientId) {
  let current = clientId;
  let parent;

  do {
    parent = current;
    current = state.blocks.parents[current];
  } while (current);

  return parent;
}
/**
 * Given a block client ID, returns the lowest common ancestor with selected client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find common ancestor client ID.
 *
 * @return {string} Common ancestor client ID or undefined
 */

function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  const selectedId = getSelectedBlockClientId(state);
  const clientParents = [...getBlockParents(state, clientId), clientId];
  const selectedParents = [...getBlockParents(state, selectedId), selectedId];
  let lowestCommonAncestor;
  const maxDepth = Math.min(clientParents.length, selectedParents.length);

  for (let index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }

  return lowestCommonAncestor;
}
/**
 * Returns the client ID of the block adjacent one at the given reference
 * startClientId and modifier directionality. Defaults start startClientId to
 * the selected block, and direction as next block. Returns null if there is no
 * adjacent block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 * @param {?number} modifier      Directionality multiplier (1 next, -1
 *                                previous).
 *
 * @return {?string} Return the client ID of the block, or null if none exists.
 */

function getAdjacentBlockClientId(state, startClientId) {
  let modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  // Default to selected block.
  if (startClientId === undefined) {
    startClientId = getSelectedBlockClientId(state);
  } // Try multi-selection starting at extent based on modifier.


  if (startClientId === undefined) {
    if (modifier < 0) {
      startClientId = getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = getLastMultiSelectedBlockClientId(state);
    }
  } // Validate working start client ID.


  if (!startClientId) {
    return null;
  } // Retrieve start block root client ID, being careful to allow the falsey
  // empty string top-level root by explicitly testing against null.


  const rootClientId = getBlockRootClientId(state, startClientId);

  if (rootClientId === null) {
    return null;
  }

  const {
    order
  } = state.blocks;
  const orderSet = order[rootClientId];
  const index = orderSet.indexOf(startClientId);
  const nextIndex = index + 1 * modifier; // Block was first in set and we're attempting to get previous.

  if (nextIndex < 0) {
    return null;
  } // Block was last in set and we're attempting to get next.


  if (nextIndex === orderSet.length) {
    return null;
  } // Assume incremented index is within the set.


  return orderSet[nextIndex];
}
/**
 * Returns the previous block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no previous
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}
/**
 * Returns the next block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no next
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}
/* eslint-disable jsdoc/valid-types */

/**
 * Returns the initial caret position for the selected block.
 * This position is to used to position the caret properly when the selected block changes.
 * If the current block is not a RichText, having initial position set to 0 means "focus block"
 *
 * @param {Object} state Global application state.
 *
 * @return {0|-1|null} Initial position.
 */

function getSelectedBlocksInitialCaretPosition(state) {
  /* eslint-enable jsdoc/valid-types */
  return state.initialPosition;
}
/**
 * Returns the current selection set of block client IDs (multiselection or single selection).
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

const getSelectedBlockClientIds = (0,rememo/* default */.A)(state => {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === undefined || selectionEnd.clientId === undefined) {
    return EMPTY_ARRAY;
  }

  if (selectionStart.clientId === selectionEnd.clientId) {
    return [selectionStart.clientId];
  } // Retrieve root client ID to aid in retrieving relevant nested block
  // order, being careful to allow the falsey empty string top-level root
  // by explicitly testing against null.


  const rootClientId = getBlockRootClientId(state, selectionStart.clientId);

  if (rootClientId === null) {
    return EMPTY_ARRAY;
  }

  const blockOrder = getBlockOrder(state, rootClientId);
  const startIndex = blockOrder.indexOf(selectionStart.clientId);
  const endIndex = blockOrder.indexOf(selectionEnd.clientId);

  if (startIndex > endIndex) {
    return blockOrder.slice(endIndex, startIndex + 1);
  }

  return blockOrder.slice(startIndex, endIndex + 1);
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the current multi-selection set of block client IDs, or an empty
 * array if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

function getMultiSelectedBlockClientIds(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return EMPTY_ARRAY;
  }

  return getSelectedBlockClientIds(state);
}
/**
 * Returns the current multi-selection set of blocks, or an empty array if
 * there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block objects.
 */

const getMultiSelectedBlocks = (0,rememo/* default */.A)(state => {
  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);

  if (!multiSelectedBlockClientIds.length) {
    return EMPTY_ARRAY;
  }

  return multiSelectedBlockClientIds.map(clientId => getBlock(state, clientId));
}, state => [...getSelectedBlockClientIds.getDependants(state), state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns the client ID of the first block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} First block client ID in the multi-selection set.
 */

function getFirstMultiSelectedBlockClientId(state) {
  return (0,lodash.first)(getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns the client ID of the last block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Last block client ID in the multi-selection set.
 */

function getLastMultiSelectedBlockClientId(state) {
  return (0,lodash.last)(getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns true if a multi-selection exists, and the block corresponding to the
 * specified client ID is the first block of the multi-selection set, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is first in multi-selection.
 */

function isFirstMultiSelectedBlock(state, clientId) {
  return getFirstMultiSelectedBlockClientId(state) === clientId;
}
/**
 * Returns true if the client ID occurs within the block multi-selection, or
 * false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is in multi-selection set.
 */

function isBlockMultiSelected(state, clientId) {
  return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}
/**
 * Returns true if an ancestor of the block is multi-selected, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether an ancestor of the block is in multi-selection
 *                   set.
 */

const isAncestorMultiSelected = (0,rememo/* default */.A)((state, clientId) => {
  let ancestorClientId = clientId;
  let isMultiSelected = false;

  while (ancestorClientId && !isMultiSelected) {
    ancestorClientId = getBlockRootClientId(state, ancestorClientId);
    isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
  }

  return isMultiSelected;
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the client ID of the block which begins the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the first client ID in the selection.
 *
 * @see getFirstMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block beginning multi-selection.
 */

function getMultiSelectedBlocksStartClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionStart.clientId || null;
}
/**
 * Returns the client ID of the block which ends the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the last client ID in the selection.
 *
 * @see getLastMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block ending multi-selection.
 */

function getMultiSelectedBlocksEndClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionEnd.clientId || null;
}
/**
 * Returns true if the selection is not partial.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether the selection is mergeable.
 */

function __unstableIsFullySelected(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !selectionAnchor.attributeKey && !selectionFocus.attributeKey && typeof selectionAnchor.offset === 'undefined' && typeof selectionFocus.offset === 'undefined';
}
/**
 * Returns true if the selection is collapsed.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether the selection is collapsed.
 */

function __unstableIsSelectionCollapsed(state) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);
  return !!selectionAnchor && !!selectionFocus && selectionAnchor.clientId === selectionFocus.clientId && selectionAnchor.attributeKey === selectionFocus.attributeKey && selectionAnchor.offset === selectionFocus.offset;
}
/**
 * Check whether the selection is mergeable.
 *
 * @param {Object}  state     Editor state.
 * @param {boolean} isForward Whether to merge forwards.
 *
 * @return {boolean} Whether the selection is mergeable.
 */

function __unstableIsSelectionMergeable(state, isForward) {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state); // It's not mergeable if the start and end are within the same block.

  if (selectionAnchor.clientId === selectionFocus.clientId) return false; // It's not mergeable if there's no rich text selection.

  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') return false;
  const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
  const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId); // It's not mergeable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return false;
  }

  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  let selectionStart, selectionEnd;

  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }

  const targetBlockClientId = isForward ? selectionEnd.clientId : selectionStart.clientId;
  const blockToMergeClientId = isForward ? selectionStart.clientId : selectionEnd.clientId;
  const targetBlock = getBlock(state, targetBlockClientId);
  const targetBlockType = (0,build_module/* getBlockType */.E7)(targetBlock.name);
  if (!targetBlockType.merge) return false;
  const blockToMerge = getBlock(state, blockToMergeClientId); // It's mergeable if the blocks are of the same type.

  if (blockToMerge.name === targetBlock.name) return true; // If the blocks are of a different type, try to transform the block being
  // merged into the same type of block.

  const blocksToMerge = (0,build_module/* switchToBlockType */.bh)(blockToMerge, targetBlock.name);
  return blocksToMerge && blocksToMerge.length;
}
/**
 * Get partial selected blocks with their content updated
 * based on the selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object[]} Updated partial selected blocks.
 */

const __unstableGetSelectedBlocksWithPartialSelection = state => {
  const selectionAnchor = getSelectionStart(state);
  const selectionFocus = getSelectionEnd(state);

  if (selectionAnchor.clientId === selectionFocus.clientId) {
    return EMPTY_ARRAY;
  } // Can't split if the selection is not set.


  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') {
    return EMPTY_ARRAY;
  }

  const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
  const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId); // It's not splittable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return EMPTY_ARRAY;
  }

  const blockOrder = getBlockOrder(state, anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  const [selectionStart, selectionEnd] = anchorIndex > focusIndex ? [selectionFocus, selectionAnchor] : [selectionAnchor, selectionFocus];
  const blockA = getBlock(state, selectionStart.clientId);
  const blockAType = (0,build_module/* getBlockType */.E7)(blockA.name);
  const blockB = getBlock(state, selectionEnd.clientId);
  const blockBType = (0,build_module/* getBlockType */.E7)(blockB.name);
  const htmlA = blockA.attributes[selectionStart.attributeKey];
  const htmlB = blockB.attributes[selectionEnd.attributeKey];
  const attributeDefinitionA = blockAType.attributes[selectionStart.attributeKey];
  const attributeDefinitionB = blockBType.attributes[selectionEnd.attributeKey];
  let valueA = create_create({
    html: htmlA,
    ...mapRichTextSettings(attributeDefinitionA)
  });
  let valueB = create_create({
    html: htmlB,
    ...mapRichTextSettings(attributeDefinitionB)
  });
  valueA = remove(valueA, 0, selectionStart.offset);
  valueB = remove(valueB, selectionEnd.offset, valueB.text.length);
  return [{ ...blockA,
    attributes: { ...blockA.attributes,
      [selectionStart.attributeKey]: toHTMLString({
        value: valueA,
        ...mapRichTextSettings(attributeDefinitionA)
      })
    }
  }, { ...blockB,
    attributes: { ...blockB.attributes,
      [selectionEnd.attributeKey]: toHTMLString({
        value: valueB,
        ...mapRichTextSettings(attributeDefinitionB)
      })
    }
  }];
};
/**
 * Returns an array containing all block client IDs in the editor in the order
 * they appear. Optionally accepts a root client ID of the block list for which
 * the order should be returned, defaulting to the top-level block order.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array} Ordered client IDs of editor blocks.
 */

function getBlockOrder(state, rootClientId) {
  return state.blocks.order[rootClientId || ''] || EMPTY_ARRAY;
}
/**
 * Returns the index at which the block corresponding to the specified client
 * ID occurs within the block order, or `-1` if the block does not exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {number} Index at which block exists in order.
 */

function getBlockIndex(state, clientId) {
  const rootClientId = getBlockRootClientId(state, clientId);
  return getBlockOrder(state, rootClientId).indexOf(clientId);
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected and no multi-selection exists, or false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and multi-selection exists.
 */

function isBlockSelected(state, clientId) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }

  return selectionStart.clientId === clientId;
}
/**
 * Returns true if one of the block's inner blocks is selected.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block as an inner block selected
 */

function hasSelectedInnerBlock(state, clientId) {
  let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0,lodash.some)(getBlockOrder(state, clientId), innerClientId => isBlockSelected(state, innerClientId) || isBlockMultiSelected(state, innerClientId) || deep && hasSelectedInnerBlock(state, innerClientId, deep));
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected but isn't the last of the selected blocks. Here "last"
 * refers to the block sequence in the document, _not_ the sequence of
 * multi-selection, which is why `state.selectionEnd` isn't used.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and not the last in the
 *                   selection.
 */

function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }

  const clientIds = getMultiSelectedBlockClientIds(state);
  const index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}
/**
 * Returns true if a multi-selection has been made, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether multi-selection has been made.
 */

function hasMultiSelection(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return selectionStart.clientId !== selectionEnd.clientId;
}
/**
 * Whether in the process of multi-selecting or not. This flag is only true
 * while the multi-selection is being selected (by mouse move), and is false
 * once the multi-selection has been settled.
 *
 * @see hasMultiSelection
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if multi-selecting, false if not.
 */

function selectors_isMultiSelecting(state) {
  return state.isMultiSelecting;
}
/**
 * Selector that returns if multi-selection is enabled or not.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.
 */

function selectors_isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}
/**
 * Returns the block's editing mode, defaulting to "visual" if not explicitly
 * assigned.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Block editing mode.
 */

function getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || 'visual';
}
/**
 * Returns true if the user is typing, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is typing.
 */

function selectors_isTyping(state) {
  return state.isTyping;
}
/**
 * Returns true if the user is dragging blocks, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging blocks.
 */

function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}
/**
 * Returns the client ids of any blocks being directly dragged.
 *
 * This does not include children of a parent being dragged.
 *
 * @param {Object} state Global application state.
 *
 * @return {string[]} Array of dragged block client ids.
 */

function getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}
/**
 * Returns whether the block is being dragged.
 *
 * Only returns true if the block is being directly dragged,
 * not if the block is a child of a parent being dragged.
 * See `isAncestorBeingDragged` for child blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block is being dragged.
 */

function isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}
/**
 * Returns whether a parent/ancestor of the block is being dragged.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block's ancestor is being dragged.
 */

function isAncestorBeingDragged(state, clientId) {
  // Return early if no blocks are being dragged rather than
  // the more expensive check for parents.
  if (!isDraggingBlocks(state)) {
    return false;
  }

  const parents = getBlockParents(state, clientId);
  return (0,lodash.some)(parents, parentClientId => isBlockBeingDragged(state, parentClientId));
}
/**
 * Returns true if the caret is within formatted text, or false otherwise.
 *
 * @deprecated
 *
 * @return {boolean} Whether the caret is within formatted text.
 */

function isCaretWithinFormattedText() {
  (0,deprecated_build_module/* default */.A)('wp.data.select( "core/block-editor" ).isCaretWithinFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return false;
}
/**
 * Returns the insertion point, the index at which the new inserted block would
 * be placed. Defaults to the last index.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} Insertion point object with `rootClientId`, `index`.
 */

function getBlockInsertionPoint(state) {
  let rootClientId, index;
  const {
    insertionPoint,
    selection: {
      selectionEnd
    }
  } = state;

  if (insertionPoint !== null) {
    return insertionPoint;
  }

  const {
    clientId
  } = selectionEnd;

  if (clientId) {
    rootClientId = getBlockRootClientId(state, clientId) || undefined;
    index = getBlockIndex(state, selectionEnd.clientId) + 1;
  } else {
    index = getBlockOrder(state).length;
  }

  return {
    rootClientId,
    index
  };
}
/**
 * Returns true if we should show the block insertion point.
 *
 * @param {Object} state Global application state.
 *
 * @return {?boolean} Whether the insertion point is visible or not.
 */

function isBlockInsertionPointVisible(state) {
  return state.insertionPoint !== null;
}
/**
 * Returns whether the blocks matches the template or not.
 *
 * @param {boolean} state
 * @return {?boolean} Whether the template is valid or not.
 */

function isValidTemplate(state) {
  return state.template.isValid;
}
/**
 * Returns the defined block template
 *
 * @param {boolean} state
 *
 * @return {?Array} Block Template.
 */

function getTemplate(state) {
  return state.settings.template;
}
/**
 * Returns the defined block template lock. Optionally accepts a root block
 * client ID as context, otherwise defaulting to the global context.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional block root client ID.
 *
 * @return {?string} Block Template Lock
 */

function getTemplateLock(state, rootClientId) {
  if (!rootClientId) {
    return state.settings.templateLock;
  }

  const blockListSettings = getBlockListSettings(state, rootClientId);

  if (!blockListSettings) {
    return null;
  }

  return blockListSettings.templateLock;
}

const checkAllowList = function (list, item) {
  let defaultResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (typeof list === 'boolean') {
    return list;
  }

  if (Array.isArray(list)) {
    // TODO: when there is a canonical way to detect that we are editing a post
    // the following check should be changed to something like:
    // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
    if (list.includes('core/post-content') && item === null) {
      return true;
    }

    return list.includes(item);
  }

  return defaultResult;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 * This function is not exported and not memoized because using a memoized selector
 * inside another memoized selector is just a waste of time.
 *
 * @param {Object}        state        Editor state.
 * @param {string|Object} blockName    The block type object, e.g., the response
 *                                     from the block directory; or a string name of
 *                                     an installed block type, e.g.' core/paragraph'.
 * @param {?string}       rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockTypeUnmemoized = function (state, blockName) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  let blockType;

  if (blockName && 'object' === typeof blockName) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = (0,build_module/* getBlockType */.E7)(blockName);
  }

  if (!blockType) {
    return false;
  }

  const {
    allowedBlockTypes
  } = getSettings(state);
  const isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);

  if (!isBlockAllowedInEditor) {
    return false;
  }

  const isLocked = !!getTemplateLock(state, rootClientId);

  if (isLocked) {
    return false;
  }

  const parentBlockListSettings = getBlockListSettings(state, rootClientId); // The parent block doesn't have settings indicating it doesn't support
  // inner blocks, return false.

  if (rootClientId && parentBlockListSettings === undefined) {
    return false;
  }

  const parentAllowedBlocks = parentBlockListSettings === null || parentBlockListSettings === void 0 ? void 0 : parentBlockListSettings.allowedBlocks;
  const hasParentAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
  const blockAllowedParentBlocks = blockType.parent;
  const parentName = getBlockName(state, rootClientId);
  const hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);
  let hasBlockAllowedAncestor = true;
  const blockAllowedAncestorBlocks = blockType.ancestor;

  if (blockAllowedAncestorBlocks) {
    const ancestors = [rootClientId, ...getBlockParents(state, rootClientId)];
    hasBlockAllowedAncestor = (0,lodash.some)(ancestors, ancestorClientId => checkAllowList(blockAllowedAncestorBlocks, getBlockName(state, ancestorClientId)));
  }

  const canInsert = hasBlockAllowedAncestor && (hasParentAllowedBlock === null && hasBlockAllowedParent === null || hasParentAllowedBlock === true || hasBlockAllowedParent === true);

  if (!canInsert) {
    return canInsert;
  }
  /**
   * This filter is an ad-hoc solution to prevent adding template parts inside post content.
   * Conceptually, having a filter inside a selector is bad pattern so this code will be
   * replaced by a declarative API that doesn't the following drawbacks:
   *
   * Filters are not reactive: Upon switching between "template mode" and non "template mode",
   * the filter and selector won't necessarily be executed again. For now, it doesn't matter much
   * because you can't switch between the two modes while the inserter stays open.
   *
   * Filters are global: Once they're defined, they will affect all editor instances and all registries.
   * An ideal API would only affect specific editor instances.
   */


  return (0,hooks_build_module/* applyFilters */.W5)('blockEditor.__unstableCanInsertBlockType', canInsert, blockType, rootClientId, {
    // Pass bound selectors of the current registry. If we're in a nested
    // context, the data will differ from the one selected from the root
    // registry.
    getBlock: getBlock.bind(null, state),
    getBlockParentsByBlockName: getBlockParentsByBlockName.bind(null, state)
  });
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockType = (0,rememo/* default */.A)(canInsertBlockTypeUnmemoized, (state, blockName, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId], state.settings.allowedBlockTypes, state.settings.templateLock]);
/**
 * Determines if the given blocks are allowed to be inserted into the block
 * list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be inserted.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be inserted.
 */

function canInsertBlocks(state, clientIds) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return clientIds.every(id => canInsertBlockType(state, getBlockName(state, id), rootClientId));
}
/**
 * Determines if the given block is allowed to be deleted.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     The block client Id.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block is allowed to be removed.
 */

function canRemoveBlock(state, clientId) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  const attributes = getBlockAttributes(state, clientId); // attributes can be null if the block is already deleted.

  if (attributes === null) {
    return true;
  }

  const {
    lock
  } = attributes;
  const parentIsLocked = !!getTemplateLock(state, rootClientId); // If we don't have a lock on the blockType level, we defer to the parent templateLock.

  if (lock === undefined || (lock === null || lock === void 0 ? void 0 : lock.remove) === undefined) {
    return !parentIsLocked;
  } // When remove is true, it means we cannot remove it.


  return !(lock !== null && lock !== void 0 && lock.remove);
}
/**
 * Determines if the given blocks are allowed to be removed.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be removed.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be removed.
 */

function canRemoveBlocks(state, clientIds) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return clientIds.every(clientId => canRemoveBlock(state, clientId, rootClientId));
}
/**
 * Determines if the given block is allowed to be moved.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     The block client Id.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block is allowed to be moved.
 */

function canMoveBlock(state, clientId) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  const attributes = getBlockAttributes(state, clientId);

  if (attributes === null) {
    return;
  }

  const {
    lock
  } = attributes;
  const parentIsLocked = getTemplateLock(state, rootClientId) === 'all'; // If we don't have a lock on the blockType level, we defer to the parent templateLock.

  if (lock === undefined || (lock === null || lock === void 0 ? void 0 : lock.move) === undefined) {
    return !parentIsLocked;
  } // When move is true, it means we cannot move it.


  return !(lock !== null && lock !== void 0 && lock.move);
}
/**
 * Determines if the given blocks are allowed to be moved.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be moved.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be moved.
 */

function canMoveBlocks(state, clientIds) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return clientIds.every(clientId => canMoveBlock(state, clientId, rootClientId));
}
/**
 * Determines if the given block is allowed to be edited.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId The block client Id.
 *
 * @return {boolean} Whether the given block is allowed to be edited.
 */

function canEditBlock(state, clientId) {
  const attributes = getBlockAttributes(state, clientId);

  if (attributes === null) {
    return true;
  }

  const {
    lock
  } = attributes; // When the edit is true, we cannot edit the block.

  return !(lock !== null && lock !== void 0 && lock.edit);
}
/**
 * Determines if the given block type can be locked/unlocked by a user.
 *
 * @param {Object}          state      Editor state.
 * @param {(string|Object)} nameOrType Block name or type object.
 *
 * @return {boolean} Whether a given block type can be locked/unlocked.
 */

function canLockBlockType(state, nameOrType) {
  var _state$settings;

  if (!(0,build_module/* hasBlockSupport */.pN)(nameOrType, 'lock', true)) {
    return false;
  } // Use block editor settings as the default value.


  return !!((_state$settings = state.settings) !== null && _state$settings !== void 0 && _state$settings.canLockBlocks);
}
/**
 * Returns information about how recently and frequently a block has been inserted.
 *
 * @param {Object} state Global application state.
 * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'
 *
 * @return {?{ time: number, count: number }} An object containing `time` which is when the last
 *                                            insert occurred as a UNIX epoch, and `count` which is
 *                                            the number of inserts that have occurred.
 */

function getInsertUsage(state, id) {
  var _state$preferences$in, _state$preferences$in2;

  return (_state$preferences$in = (_state$preferences$in2 = state.preferences.insertUsage) === null || _state$preferences$in2 === void 0 ? void 0 : _state$preferences$in2[id]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
}
/**
 * Returns whether we can show a block type in the inserter
 *
 * @param {Object}  state        Global State
 * @param {Object}  blockType    BlockType
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be shown in the inserter.
 */


const canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
  if (!(0,build_module/* hasBlockSupport */.pN)(blockType, 'inserter', true)) {
    return false;
  }

  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};
/**
 * Return a function to be used to tranform a block variation to an inserter item
 *
 * @param {Object} state Global State
 * @param {Object} item  Denormalized inserter item
 * @return {Function} Function to transform a block variation to inserter item
 */


const getItemFromVariation = (state, item) => variation => {
  const variationId = `${item.id}/${variation.name}`;
  const {
    time,
    count = 0
  } = getInsertUsage(state, variationId) || {};
  return { ...item,
    id: variationId,
    icon: variation.icon || item.icon,
    title: variation.title || item.title,
    description: variation.description || item.description,
    category: variation.category || item.category,
    // If `example` is explicitly undefined for the variation, the preview will not be shown.
    example: variation.hasOwnProperty('example') ? variation.example : item.example,
    initialAttributes: { ...item.initialAttributes,
      ...variation.attributes
    },
    innerBlocks: variation.innerBlocks,
    keywords: variation.keywords || item.keywords,
    frecency: calculateFrecency(time, count)
  };
};
/**
 * Returns the calculated frecency.
 *
 * 'frecency' is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * @param {number} time  When the last insert occurred as a UNIX epoch
 * @param {number} count The number of inserts that have occurred.
 *
 * @return {number} The calculated frecency.
 */


const calculateFrecency = (time, count) => {
  if (!time) {
    return count;
  } // The selector is cached, which means Date.now() is the last time that the
  // relevant state changed. This suits our needs.


  const duration = Date.now() - time;

  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;

    case duration < MILLISECONDS_PER_DAY:
      return count * 2;

    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;

    default:
      return count / 4;
  }
};
/**
 * Returns a function that accepts a block type and builds an item to be shown
 * in a specific context. It's used for building items for Inserter and available
 * block Transfroms list.
 *
 * @param {Object} state              Editor state.
 * @param {Object} options            Options object for handling the building of a block type.
 * @param {string} options.buildScope The scope for which the item is going to be used.
 * @return {Function} Function returns an item to be shown in a specific context (Inserter|Transforms list).
 */


const buildBlockTypeItem = (state, _ref3) => {
  let {
    buildScope = 'inserter'
  } = _ref3;
  return blockType => {
    const id = blockType.name;
    let isDisabled = false;

    if (!(0,build_module/* hasBlockSupport */.pN)(blockType.name, 'multiple', true)) {
      isDisabled = (0,lodash.some)(getBlocksByClientId(state, getClientIdsWithDescendants(state)), {
        name: blockType.name
      });
    }

    const {
      time,
      count = 0
    } = getInsertUsage(state, id) || {};
    const blockItemBase = {
      id,
      name: blockType.name,
      title: blockType.title,
      icon: blockType.icon,
      isDisabled,
      frecency: calculateFrecency(time, count)
    };
    if (buildScope === 'transform') return blockItemBase;
    const inserterVariations = (0,build_module/* getBlockVariations */.oO)(blockType.name, 'inserter');
    return { ...blockItemBase,
      initialAttributes: {},
      description: blockType.description,
      category: blockType.category,
      keywords: blockType.keywords,
      variations: inserterVariations,
      example: blockType.example,
      utility: 1 // Deprecated.

    };
  };
};
/**
 * Determines the items that appear in the inserter. Includes both static
 * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).
 *
 * Each item object contains what's necessary to display a button in the
 * inserter and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'utility' and 'frecency'.
 *
 * @param    {Object}   state             Editor state.
 * @param    {?string}  rootClientId      Optional root client ID of block list.
 *
 * @return {WPEditorInserterItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorInserterItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {Object}   initialAttributes Attributes to pass to the newly created block.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {string}   category          Block category that the item is associated with.
 * @property {string[]} keywords          Keywords that can be searched to find this item.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */


const getInserterItems = (0,rememo/* default */.A)(function (state) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
    buildScope: 'inserter'
  });
  /*
   * Matches block comment delimiters amid serialized content.
   *
   * @see `tokenizer` in `@wordpress/block-serialization-default-parser`
   * package
   *
   * blockParserTokenizer differs from the original tokenizer in the
   * following ways:
   *
   * - removed global flag (/g)
   * - prepended ^\s*
   *
   */

  const blockParserTokenizer = /^\s*<!--\s+(\/)?wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/;

  const buildReusableBlockInserterItem = reusableBlock => {
    let icon = library_symbol;
    /*
     * Instead of always displaying a generic "symbol" icon for every
     * reusable block, try to use an icon that represents the first
     * outermost block contained in the reusable block. This requires
     * scanning the serialized form of the reusable block to find its
     * first block delimiter, then looking up the corresponding block
     * type, if available.
     */

    if (platform.OS === 'web') {
      const content = typeof reusableBlock.content.raw === 'string' ? reusableBlock.content.raw : reusableBlock.content;
      const rawBlockMatch = content.match(blockParserTokenizer);

      if (rawBlockMatch) {
        const [,, namespace = 'core/', blockName] = rawBlockMatch;
        const referencedBlockType = (0,build_module/* getBlockType */.E7)(namespace + blockName);

        if (referencedBlockType) {
          icon = referencedBlockType.icon;
        }
      }
    }

    const id = `core/block/${reusableBlock.id}`;
    const {
      time,
      count = 0
    } = getInsertUsage(state, id) || {};
    const frecency = calculateFrecency(time, count);
    return {
      id,
      name: 'core/block',
      initialAttributes: {
        ref: reusableBlock.id
      },
      title: reusableBlock.title.raw,
      icon,
      category: 'reusable',
      keywords: [],
      isDisabled: false,
      utility: 1,
      // Deprecated.
      frecency
    };
  };

  const blockTypeInserterItems = (0,build_module/* getBlockTypes */.li)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeInserterItem);
  const reusableBlockInserterItems = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) ? getReusableBlocks(state).map(buildReusableBlockInserterItem) : [];
  const items = blockTypeInserterItems.reduce((accumulator, item) => {
    const {
      variations = []
    } = item; // Exclude any block type item that is to be replaced by a default variation.

    if (!variations.some(_ref4 => {
      let {
        isDefault
      } = _ref4;
      return isDefault;
    })) {
      accumulator.push(item);
    }

    if (variations.length) {
      const variationMapper = getItemFromVariation(state, item);
      accumulator.push(...variations.map(variationMapper));
    }

    return accumulator;
  }, []); // Ensure core blocks are prioritized in the returned results,
  // because third party blocks can be registered earlier than
  // the core blocks (usually by using the `init` action),
  // thus affecting the display order.
  // We don't sort reusable blocks as they are handled differently.

  const groupByType = (blocks, block) => {
    const {
      core,
      noncore
    } = blocks;
    const type = block.name.startsWith('core/') ? core : noncore;
    type.push(block);
    return blocks;
  };

  const {
    core: coreItems,
    noncore: nonCoreItems
  } = items.reduce(groupByType, {
    core: [],
    noncore: []
  });
  const sortedBlockTypes = [...coreItems, ...nonCoreItems];
  return [...sortedBlockTypes, ...reusableBlockInserterItems];
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.blocks.order, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), (0,build_module/* getBlockTypes */.li)()]);
/**
 * Determines the items that appear in the available block transforms list.
 *
 * Each item object contains what's necessary to display a menu item in the
 * transform list and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'frecency'.
 *
 * @param    {Object}          state        Editor state.
 * @param    {Object|Object[]} blocks       Block object or array objects.
 * @param    {?string}         rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorTransformItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorTransformItem
 * @property {string}          id           Unique identifier for the item.
 * @property {string}          name         The type of block to create.
 * @property {string}          title        Title of the item, as it appears in the inserter.
 * @property {string}          icon         Dashicon for the item, as it appears in the inserter.
 * @property {boolean}         isDisabled   Whether or not the user should be prevented from inserting
 *                                          this item.
 * @property {number}          frecency     Heuristic that combines frequency and recency.
 */

const getBlockTransformItems = (0,rememo/* default */.A)(function (state, blocks) {
  var _itemsByName$sourceBl;

  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  const normalizedBlocks = (0,lodash.castArray)(blocks);
  const [sourceBlock] = normalizedBlocks;
  const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
    buildScope: 'transform'
  });
  const blockTypeTransformItems = (0,build_module/* getBlockTypes */.li)().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeTransformItem);
  const itemsByName = Object.fromEntries(Object.entries(blockTypeTransformItems).map(_ref5 => {
    let [, value] = _ref5;
    return [value.name, value];
  })); // Consider unwraping the highest priority.

  itemsByName['*'] = {
    frecency: +Infinity,
    id: '*',
    isDisabled: false,
    name: '*',
    title: (0,_wordpress_i18n_build_module.__)('Unwrap'),
    icon: (_itemsByName$sourceBl = itemsByName[sourceBlock === null || sourceBlock === void 0 ? void 0 : sourceBlock.name]) === null || _itemsByName$sourceBl === void 0 ? void 0 : _itemsByName$sourceBl.icon
  };
  const possibleTransforms = (0,build_module/* getPossibleBlockTransformations */.Fk)(normalizedBlocks).reduce((accumulator, block) => {
    if (block === '*') {
      accumulator.push(itemsByName['*']);
    } else if (itemsByName[block === null || block === void 0 ? void 0 : block.name]) {
      accumulator.push(itemsByName[block.name]);
    }

    return accumulator;
  }, []);
  return (0,lodash.orderBy)(possibleTransforms, block => itemsByName[block.name].frecency, 'desc');
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, (0,build_module/* getBlockTypes */.li)()]);
/**
 * Determines whether there are items to show in the inserter.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Items that appear in inserter.
 */

const hasInserterItems = (0,rememo/* default */.A)(function (state) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  const hasBlockType = (0,lodash.some)((0,build_module/* getBlockTypes */.li)(), blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));

  if (hasBlockType) {
    return true;
  }

  const hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && getReusableBlocks(state).length > 0;
  return hasReusableBlock;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), (0,build_module/* getBlockTypes */.li)()]);
/**
 * Returns the list of allowed inserter blocks for inner blocks children
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array?} The list of allowed block types.
 */

const __experimentalGetAllowedBlocks = (0,rememo/* default */.A)(function (state) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (!rootClientId) {
    return;
  }

  return (0,lodash.filter)((0,build_module/* getBlockTypes */.li)(), blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, (0,build_module/* getBlockTypes */.li)()]);
/**
 * Returns the block to be directly inserted by the block appender.
 *
 * @param    {Object}         state            Editor state.
 * @param    {?string}        rootClientId     Optional root client ID of block list.
 *
 * @return {?WPDirectInsertBlock}              The block type to be directly inserted.
 *
 * @typedef {Object} WPDirectInsertBlock
 * @property {string}         name             The type of block.
 * @property {?Object}        attributes       Attributes to pass to the newly created block.
 * @property {?Array<string>} attributesToCopy Attributes to be copied from adjecent blocks when inserted.
 */

const __experimentalGetDirectInsertBlock = (0,rememo/* default */.A)(function (state) {
  var _state$blockListSetti, _state$blockListSetti2;

  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (!rootClientId) {
    return;
  }

  const defaultBlock = (_state$blockListSetti = state.blockListSettings[rootClientId]) === null || _state$blockListSetti === void 0 ? void 0 : _state$blockListSetti.__experimentalDefaultBlock;
  const directInsert = (_state$blockListSetti2 = state.blockListSettings[rootClientId]) === null || _state$blockListSetti2 === void 0 ? void 0 : _state$blockListSetti2.__experimentalDirectInsert;

  if (!defaultBlock || !directInsert) {
    return;
  }

  if (typeof directInsert === 'function') {
    return directInsert(getBlock(state, rootClientId)) ? defaultBlock : null;
  }

  return defaultBlock;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.tree[rootClientId]]);

const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (typeof allowedBlockTypes === 'boolean') {
    return allowedBlockTypes;
  }

  const blocksQueue = [...blocks];

  while (blocksQueue.length > 0) {
    var _block$innerBlocks;

    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(allowedBlockTypes, block.name || block.blockName, true);

    if (!isAllowed) {
      return false;
    }

    (_block$innerBlocks = block.innerBlocks) === null || _block$innerBlocks === void 0 ? void 0 : _block$innerBlocks.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }

  return true;
};

const __experimentalGetParsedPattern = (0,rememo/* default */.A)((state, patternName) => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const pattern = patterns.find(_ref6 => {
    let {
      name
    } = _ref6;
    return name === patternName;
  });

  if (!pattern) {
    return null;
  }

  return { ...pattern,
    blocks: (0,build_module/* parse */.qg)(pattern.content, {
      __unstableSkipMigrationLogs: true
    })
  };
}, state => [state.settings.__experimentalBlockPatterns]);
const getAllAllowedPatterns = (0,rememo/* default */.A)(state => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const {
    allowedBlockTypes
  } = getSettings(state);
  const parsedPatterns = patterns.filter(_ref7 => {
    let {
      inserter = true
    } = _ref7;
    return !!inserter;
  }).map(_ref8 => {
    let {
      name
    } = _ref8;
    return __experimentalGetParsedPattern(state, name);
  });
  const allowedPatterns = parsedPatterns.filter(_ref9 => {
    let {
      blocks
    } = _ref9;
    return checkAllowListRecursive(blocks, allowedBlockTypes);
  });
  return allowedPatterns;
}, state => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes]);
/**
 * Returns the list of allowed patterns for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array?} The list of allowed patterns.
 */

const __experimentalGetAllowedPatterns = (0,rememo/* default */.A)(function (state) {
  let rootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  const availableParsedPatterns = getAllAllowedPatterns(state);
  const patternsAllowed = (0,lodash.filter)(availableParsedPatterns, _ref10 => {
    let {
      blocks
    } = _ref10;
    return blocks.every(_ref11 => {
      let {
        name
      } = _ref11;
      return canInsertBlockType(state, name, rootClientId);
    });
  });
  return patternsAllowed;
}, (state, rootClientId) => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId]]);
/**
 * Returns the list of patterns based on their declared `blockTypes`
 * and a block's name.
 * Patterns can use `blockTypes` to integrate in work flows like
 * suggesting appropriate patterns in a Placeholder state(during insertion)
 * or blocks transformations.
 *
 * @param {Object}          state        Editor state.
 * @param {string|string[]} blockNames   Block's name or array of block names to find matching pattens.
 * @param {?string}         rootClientId Optional target root client ID.
 *
 * @return {Array} The list of matched block patterns based on declared `blockTypes` and block name.
 */

const __experimentalGetPatternsByBlockTypes = (0,rememo/* default */.A)(function (state, blockNames) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!blockNames) return EMPTY_ARRAY;

  const patterns = __experimentalGetAllowedPatterns(state, rootClientId);

  const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
  return patterns.filter(pattern => {
    var _pattern$blockTypes, _pattern$blockTypes$s;

    return pattern === null || pattern === void 0 ? void 0 : (_pattern$blockTypes = pattern.blockTypes) === null || _pattern$blockTypes === void 0 ? void 0 : (_pattern$blockTypes$s = _pattern$blockTypes.some) === null || _pattern$blockTypes$s === void 0 ? void 0 : _pattern$blockTypes$s.call(_pattern$blockTypes, blockName => normalizedBlockNames.includes(blockName));
  });
}, (state, rootClientId) => [...__experimentalGetAllowedPatterns.getDependants(state, rootClientId)]);
/**
 * Determines the items that appear in the available pattern transforms list.
 *
 * For now we only handle blocks without InnerBlocks and take into account
 * the `__experimentalRole` property of blocks' attributes for the transformation.
 *
 * We return the first set of possible eligible block patterns,
 * by checking the `blockTypes` property. We still have to recurse through
 * block pattern's blocks and try to find matches from the selected blocks.
 * Now this happens in the consumer to avoid heavy operations in the selector.
 *
 * @param {Object}   state        Editor state.
 * @param {Object[]} blocks       The selected blocks.
 * @param {?string}  rootClientId Optional root client ID of block list.
 *
 * @return {WPBlockPattern[]} Items that are eligible for a pattern transformation.
 */

const __experimentalGetPatternTransformItems = (0,rememo/* default */.A)(function (state, blocks) {
  let rootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!blocks) return EMPTY_ARRAY;
  /**
   * For now we only handle blocks without InnerBlocks and take into account
   * the `__experimentalRole` property of blocks' attributes for the transformation.
   * Note that the blocks have been retrieved through `getBlock`, which doesn't
   * return the inner blocks of an inner block controller, so we still need
   * to check for this case too.
   */

  if (blocks.some(_ref12 => {
    let {
      clientId,
      innerBlocks
    } = _ref12;
    return innerBlocks.length || areInnerBlocksControlled(state, clientId);
  })) {
    return EMPTY_ARRAY;
  } // Create a Set of the selected block names that is used in patterns filtering.


  const selectedBlockNames = Array.from(new Set(blocks.map(_ref13 => {
    let {
      name
    } = _ref13;
    return name;
  })));
  /**
   * Here we will return first set of possible eligible block patterns,
   * by checking the `blockTypes` property. We still have to recurse through
   * block pattern's blocks and try to find matches from the selected blocks.
   * Now this happens in the consumer to avoid heavy operations in the selector.
   */

  return __experimentalGetPatternsByBlockTypes(state, selectedBlockNames, rootClientId);
}, (state, rootClientId) => [...__experimentalGetPatternsByBlockTypes.getDependants(state, rootClientId)]);
/**
 * Returns the Block List settings of a block, if any exist.
 *
 * @param {Object}  state    Editor state.
 * @param {?string} clientId Block client ID.
 *
 * @return {?Object} Block settings of the block if set.
 */

function getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}
/**
 * Returns the editor settings.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor settings object.
 */

function getSettings(state) {
  return state.settings;
}
/**
 * Returns true if the most recent block change is be considered persistent, or
 * false otherwise. A persistent change is one committed by BlockEditorProvider
 * via its `onChange` callback, in addition to `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was persistent.
 */

function isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}
/**
 * Returns the block list settings for an array of blocks, if any exist.
 *
 * @param {Object} state     Editor state.
 * @param {Array}  clientIds Block client IDs.
 *
 * @return {Object} An object where the keys are client ids and the values are
 *                  a block list setting object.
 */

const __experimentalGetBlockListSettingsForBlocks = (0,rememo/* default */.A)(function (state) {
  let clientIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
    if (!state.blockListSettings[clientId]) {
      return blockListSettingsForBlocks;
    }

    return { ...blockListSettingsForBlocks,
      [clientId]: state.blockListSettings[clientId]
    };
  }, {});
}, state => [state.blockListSettings]);
/**
 * Returns the title of a given reusable block
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {string} The reusable block saved title.
 */

const __experimentalGetReusableBlockTitle = (0,rememo/* default */.A)((state, ref) => {
  var _reusableBlock$title;

  const reusableBlock = (0,lodash.find)(getReusableBlocks(state), block => block.id === ref);

  if (!reusableBlock) {
    return null;
  }

  return (_reusableBlock$title = reusableBlock.title) === null || _reusableBlock$title === void 0 ? void 0 : _reusableBlock$title.raw;
}, state => [getReusableBlocks(state)]);
/**
 * Returns true if the most recent block change is be considered ignored, or
 * false otherwise. An ignored change is one not to be committed by
 * BlockEditorProvider, neither via `onChange` nor `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was ignored.
 */

function __unstableIsLastBlockChangeIgnored(state) {
  // TODO: Removal Plan: Changes incurred by RECEIVE_BLOCKS should not be
  // ignored if in-fact they result in a change in blocks state. The current
  // need to ignore changes not a result of user interaction should be
  // accounted for in the refactoring of reusable blocks as occurring within
  // their own separate block editor / state (#7119).
  return state.blocks.isIgnoredChange;
}
/**
 * Returns the block attributes changed as a result of the last dispatched
 * action.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object<string,Object>} Subsets of block attributes changed, keyed
 *                                 by block client ID.
 */

function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}
/**
 * Returns the available reusable blocks
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} Reusable blocks
 */

function getReusableBlocks(state) {
  var _state$settings$__exp, _state$settings2;

  return (_state$settings$__exp = state === null || state === void 0 ? void 0 : (_state$settings2 = state.settings) === null || _state$settings2 === void 0 ? void 0 : _state$settings2.__experimentalReusableBlocks) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : EMPTY_ARRAY;
}
/**
 * Returns whether the navigation mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Is navigation mode enabled.
 */


function selectors_isNavigationMode(state) {
  return state.isNavigationMode;
}
/**
 * Returns whether block moving mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {string} Client Id of moving block.
 */

function selectors_hasBlockMovingClientId(state) {
  return state.hasBlockMovingClientId;
}
/**
 * Returns true if the last change was an automatic change, false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the last change was automatic.
 */

function didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}
/**
 * Returns true if the current highlighted block matches the block clientId.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} Whether the block is currently highlighted.
 */

function isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}
/**
 * Checks if a given block has controlled inner blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} True if the block has controlled inner blocks.
 */

function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}
/**
 * Returns the clientId for the first 'active' block of a given array of block names.
 * A block is 'active' if it (or a child) is the selected block.
 * Returns the first match moving up the DOM from the selected block.
 *
 * @param {Object}   state            Global application state.
 * @param {string[]} validBlocksNames The names of block types to check for.
 *
 * @return {string} The matching block's clientId.
 */

const __experimentalGetActiveBlockIdByBlockNames = (0,rememo/* default */.A)((state, validBlockNames) => {
  if (!validBlockNames.length) {
    return null;
  } // Check if selected block is a valid entity area.


  const selectedBlockClientId = getSelectedBlockClientId(state);

  if (validBlockNames.includes(getBlockName(state, selectedBlockClientId))) {
    return selectedBlockClientId;
  } // Check if first selected block is a child of a valid entity area.


  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
  const entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);

  if (entityAreaParents) {
    // Last parent closest/most interior.
    return (0,lodash.last)(entityAreaParents);
  }

  return null;
}, (state, validBlockNames) => [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames]);
/**
 * Tells if the block with the passed clientId was just inserted.
 *
 * @param {Object}  state    Global application state.
 * @param {Object}  clientId Client Id of the block.
 * @param {?string} source   Optional insertion source of the block.
 * @return {boolean} True if the block matches the last block inserted from the specified source.
 */

function wasBlockJustInserted(state, clientId, source) {
  const {
    lastBlockInserted
  } = state;
  return lastBlockInserted.clientId === clientId && lastBlockInserted.source === source;
}
/**
 * Tells if the block is visible on the canvas or not.
 *
 * @param {Object} state    Global application state.
 * @param {Object} clientId Client Id of the block.
 * @return {boolean} True if the block is visible.
 */

function isBlockVisible(state, clientId) {
  var _state$blocks$visibil, _state$blocks$visibil2;

  return (_state$blocks$visibil = (_state$blocks$visibil2 = state.blocks.visibility) === null || _state$blocks$visibil2 === void 0 ? void 0 : _state$blocks$visibil2[clientId]) !== null && _state$blocks$visibil !== void 0 ? _state$blocks$visibil : true;
}
/**
 * Returns the list of all hidden blocks.
 *
 * @param {Object} state Global application state.
 * @return {[string]} List of hidden blocks.
 */

const __unstableGetVisibleBlocks = (0,rememo/* default */.A)(state => {
  return new Set(Object.keys(state.blocks.visibility).filter(key => state.blocks.visibility[key]));
}, state => [state.blocks.visibility]);
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom-ready@3.47.0/node_modules/@wordpress/dom-ready/build-module/index.js
/**
 * @typedef {() => void} Callback
 *
 * TODO: Remove this typedef and inline `() => void` type.
 *
 * This typedef is used so that a descriptive type is provided in our
 * automatically generated documentation.
 *
 * An in-line type `() => void` would be preferable, but the generated
 * documentation is `null` in that case.
 *
 * @see https://github.com/WordPress/gutenberg/issues/18045
 */

/**
 * Specify a function to execute when the DOM is fully loaded.
 *
 * @param {Callback} callback A function to execute after the DOM is ready.
 *
 * @example
 * ```js
 * import domReady from '@wordpress/dom-ready';
 *
 * domReady( function() {
 * 	//do something after DOM loads.
 * } );
 * ```
 *
 * @return {void}
 */
function domReady(callback) {
  if (typeof document === 'undefined') {
    return;
  }
  if (document.readyState === 'complete' ||
  // DOMContentLoaded + Images/Styles/etc loaded, so we call directly.
  document.readyState === 'interactive' // DOMContentLoaded fires at this point, so we call directly.
  ) {
    return void callback();
  }

  // DOMContentLoaded has not fired yet, delay callback until then.
  document.addEventListener('DOMContentLoaded', callback);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+a11y@3.47.0/node_modules/@wordpress/a11y/build-module/add-intro-text.js
/**
 * WordPress dependencies
 */


/**
 * Build the explanatory text to be placed before the aria live regions.
 *
 * This text is initially hidden from assistive technologies by using a `hidden`
 * HTML attribute which is then removed once a message fills the aria-live regions.
 *
 * @return {HTMLParagraphElement} The explanatory text HTML element.
 */
function addIntroText() {
  const introText = document.createElement('p');
  introText.id = 'a11y-speak-intro-text';
  introText.className = 'a11y-speak-intro-text';
  introText.textContent = (0,_wordpress_i18n_build_module.__)('Notifications');
  introText.setAttribute('style', 'position: absolute;' + 'margin: -1px;' + 'padding: 0;' + 'height: 1px;' + 'width: 1px;' + 'overflow: hidden;' + 'clip: rect(1px, 1px, 1px, 1px);' + '-webkit-clip-path: inset(50%);' + 'clip-path: inset(50%);' + 'border: 0;' + 'word-wrap: normal !important;');
  introText.setAttribute('hidden', 'hidden');
  const {
    body
  } = document;
  if (body) {
    body.appendChild(introText);
  }
  return introText;
}
//# sourceMappingURL=add-intro-text.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+a11y@3.47.0/node_modules/@wordpress/a11y/build-module/add-container.js
/**
 * Build the live regions markup.
 *
 * @param {string} [ariaLive] Value for the 'aria-live' attribute; default: 'polite'.
 *
 * @return {HTMLDivElement} The ARIA live region HTML element.
 */
function addContainer(ariaLive = 'polite') {
  const container = document.createElement('div');
  container.id = `a11y-speak-${ariaLive}`;
  container.className = 'a11y-speak-region';
  container.setAttribute('style', 'position: absolute;' + 'margin: -1px;' + 'padding: 0;' + 'height: 1px;' + 'width: 1px;' + 'overflow: hidden;' + 'clip: rect(1px, 1px, 1px, 1px);' + '-webkit-clip-path: inset(50%);' + 'clip-path: inset(50%);' + 'border: 0;' + 'word-wrap: normal !important;');
  container.setAttribute('aria-live', ariaLive);
  container.setAttribute('aria-relevant', 'additions text');
  container.setAttribute('aria-atomic', 'true');
  const {
    body
  } = document;
  if (body) {
    body.appendChild(container);
  }
  return container;
}
//# sourceMappingURL=add-container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+a11y@3.47.0/node_modules/@wordpress/a11y/build-module/clear.js
/**
 * Clears the a11y-speak-region elements and hides the explanatory text.
 */
function clear() {
  const regions = document.getElementsByClassName('a11y-speak-region');
  const introText = document.getElementById('a11y-speak-intro-text');
  for (let i = 0; i < regions.length; i++) {
    regions[i].textContent = '';
  }

  // Make sure the explanatory text is hidden from assistive technologies.
  if (introText) {
    introText.setAttribute('hidden', 'hidden');
  }
}
//# sourceMappingURL=clear.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+a11y@3.47.0/node_modules/@wordpress/a11y/build-module/filter-message.js
let previousMessage = '';

/**
 * Filter the message to be announced to the screenreader.
 *
 * @param {string} message The message to be announced.
 *
 * @return {string} The filtered message.
 */
function filterMessage(message) {
  /*
   * Strip HTML tags (if any) from the message string. Ideally, messages should
   * be simple strings, carefully crafted for specific use with A11ySpeak.
   * When re-using already existing strings this will ensure simple HTML to be
   * stripped out and replaced with a space. Browsers will collapse multiple
   * spaces natively.
   */
  message = message.replace(/<[^<>]+>/g, ' ');

  /*
   * Safari + VoiceOver don't announce repeated, identical strings. We use
   * a `no-break space` to force them to think identical strings are different.
   */
  if (previousMessage === message) {
    message += '\u00A0';
  }
  previousMessage = message;
  return message;
}
//# sourceMappingURL=filter-message.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+a11y@3.47.0/node_modules/@wordpress/a11y/build-module/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/**
 * Create the live regions.
 */
function setup() {
  const introText = document.getElementById('a11y-speak-intro-text');
  const containerAssertive = document.getElementById('a11y-speak-assertive');
  const containerPolite = document.getElementById('a11y-speak-polite');
  if (introText === null) {
    addIntroText();
  }
  if (containerAssertive === null) {
    addContainer('assertive');
  }
  if (containerPolite === null) {
    addContainer('polite');
  }
}

/**
 * Run setup on domReady.
 */
domReady(setup);

/**
 * Allows you to easily announce dynamic interface updates to screen readers using ARIA live regions.
 * This module is inspired by the `speak` function in `wp-a11y.js`.
 *
 * @param {string} message    The message to be announced by assistive technologies.
 * @param {string} [ariaLive] The politeness level for aria-live; default: 'polite'.
 *
 * @example
 * ```js
 * import { speak } from '@wordpress/a11y';
 *
 * // For polite messages that shouldn't interrupt what screen readers are currently announcing.
 * speak( 'The message you want to send to the ARIA live region' );
 *
 * // For assertive messages that should interrupt what screen readers are currently announcing.
 * speak( 'The message you want to send to the ARIA live region', 'assertive' );
 * ```
 */
function speak(message, ariaLive) {
  /*
   * Clear previous messages to allow repeated strings being read out and hide
   * the explanatory text from assistive technologies.
   */
  clear();
  message = filterMessage(message);
  const introText = document.getElementById('a11y-speak-intro-text');
  const containerAssertive = document.getElementById('a11y-speak-assertive');
  const containerPolite = document.getElementById('a11y-speak-polite');
  if (containerAssertive && ariaLive === 'assertive') {
    containerAssertive.textContent = message;
  } else if (containerPolite) {
    containerPolite.textContent = message;
  }

  /*
   * Make the explanatory text available to assistive technologies by removing
   * the 'hidden' HTML attribute.
   */
  if (introText) {
    introText.removeAttribute('hidden');
  }
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/selection.js
/**
 * A robust way to retain selection position through various
 * transforms is to insert a special character at the position and
 * then recover it.
 */
const START_OF_SELECTED_AREA = '\u0086';
/**
 * Retrieve the block attribute that contains the selection position.
 *
 * @param {Object} blockAttributes Block attributes.
 * @return {string|void} The name of the block attribute that was previously selected.
 */

function retrieveSelectedAttribute(blockAttributes) {
  if (!blockAttributes) {
    return;
  }

  return Object.keys(blockAttributes).find(name => {
    const value = blockAttributes[name];
    return typeof value === 'string' && value.indexOf(START_OF_SELECTED_AREA) !== -1;
  });
}
//# sourceMappingURL=selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/actions.js
/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const actions_castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
/**
 * Action which will insert a default block insert action if there
 * are no other blocks at the root of the editor. This action should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */


const ensureDefaultBlock = () => _ref => {
  let {
    select,
    dispatch
  } = _ref;
  // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.
  const count = select.getBlockCount();

  if (count > 0) {
    return;
  } // If there's an custom appender, don't insert default block.
  // We have to remember to manually move the focus elsewhere to
  // prevent it from being lost though.


  const {
    __unstableHasCustomAppender
  } = select.getSettings();

  if (__unstableHasCustomAppender) {
    return;
  }

  dispatch.insertDefaultBlock();
};
/**
 * Action that resets blocks state to the specified array of blocks, taking precedence
 * over any other content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 */


const resetBlocks = blocks => _ref2 => {
  let {
    dispatch
  } = _ref2;
  dispatch({
    type: 'RESET_BLOCKS',
    blocks
  });
  dispatch(validateBlocksToTemplate(blocks));
};
/**
 * Block validity is a function of blocks state (at the point of a
 * reset) and the template setting. As a compromise to its placement
 * across distinct parts of state, it is implemented here as a side-
 * effect of the block reset action.
 *
 * @param {Array} blocks Array of blocks.
 */

const validateBlocksToTemplate = blocks => _ref3 => {
  let {
    select,
    dispatch
  } = _ref3;
  const template = select.getTemplate();
  const templateLock = select.getTemplateLock(); // Unlocked templates are considered always valid because they act
  // as default values only.

  const isBlocksValidToTemplate = !template || templateLock !== 'all' || (0,build_module/* doBlocksMatchTemplate */.V6)(blocks, template); // Update if validity has changed.

  const isValidTemplate = select.isValidTemplate();

  if (isBlocksValidToTemplate !== isValidTemplate) {
    dispatch.setTemplateValidity(isBlocksValidToTemplate);
    return isBlocksValidToTemplate;
  }
};
/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

/**
 * A selection object.
 *
 * @typedef {Object} WPSelection
 *
 * @property {WPBlockSelection} start The selection start.
 * @property {WPBlockSelection} end   The selection end.
 */

/* eslint-disable jsdoc/valid-types */

/**
 * Returns an action object used in signalling that selection state should be
 * reset to the specified selection.
 *
 * @param {WPBlockSelection} selectionStart  The selection start.
 * @param {WPBlockSelection} selectionEnd    The selection end.
 * @param {0|-1|null}        initialPosition Initial block position.
 *
 * @return {Object} Action object.
 */

function resetSelection(selectionStart, selectionEnd, initialPosition) {
  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'RESET_SELECTION',
    selectionStart,
    selectionEnd,
    initialPosition
  };
}
/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @deprecated
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */

function receiveBlocks(blocks) {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/block-editor" ).receiveBlocks', {
    since: '5.9',
    alternative: 'resetBlocks or insertBlocks'
  });
  return {
    type: 'RECEIVE_BLOCKS',
    blocks
  };
}
/**
 * Action that updates attributes of multiple blocks with the specified client IDs.
 *
 * @param {string|string[]} clientIds     Block client IDs.
 * @param {Object}          attributes    Block attributes to be merged. Should be keyed by clientIds if
 *                                        uniqueByBlock is true.
 * @param {boolean}         uniqueByBlock true if each block in clientIds array has a unique set of attributes
 * @return {Object} Action object.
 */

function updateBlockAttributes(clientIds, attributes) {
  let uniqueByBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientIds: actions_castArray(clientIds),
    attributes,
    uniqueByBlock
  };
}
/**
 * Action that updates the block with the specified client ID.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */

function updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId,
    updates
  };
}
/* eslint-disable jsdoc/valid-types */

/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}    clientId        Block client ID.
 * @param {0|-1|null} initialPosition Optional initial position. Pass as -1 to
 *                                    reflect reverse selection.
 *
 * @return {Object} Action object.
 */

function selectBlock(clientId) {
  let initialPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'SELECT_BLOCK',
    initialPosition,
    clientId
  };
}
/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

const selectPreviousBlock = clientId => _ref4 => {
  let {
    select,
    dispatch
  } = _ref4;
  const previousBlockClientId = select.getPreviousBlockClientId(clientId);

  if (previousBlockClientId) {
    dispatch.selectBlock(previousBlockClientId, -1);
  }
};
/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

const selectNextBlock = clientId => _ref5 => {
  let {
    select,
    dispatch
  } = _ref5;
  const nextBlockClientId = select.getNextBlockClientId(clientId);

  if (nextBlockClientId) {
    dispatch.selectBlock(nextBlockClientId);
  }
};
/**
 * Action that starts block multi-selection.
 *
 * @return {Object} Action object.
 */

function startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}
/**
 * Action that stops block multi-selection.
 *
 * @return {Object} Action object.
 */

function stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}
/**
 * Action that changes block multi-selection.
 *
 * @param {string}      start                         First block of the multi selection.
 * @param {string}      end                           Last block of the multiselection.
 * @param {number|null} __experimentalInitialPosition Optional initial position. Pass as null to skip focus within editor canvas.
 */

const multiSelect = function (start, end) {
  let __experimentalInitialPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return _ref6 => {
    let {
      select,
      dispatch
    } = _ref6;
    const startBlockRootClientId = select.getBlockRootClientId(start);
    const endBlockRootClientId = select.getBlockRootClientId(end); // Only allow block multi-selections at the same level.

    if (startBlockRootClientId !== endBlockRootClientId) {
      return;
    }

    dispatch({
      type: 'MULTI_SELECT',
      start,
      end,
      initialPosition: __experimentalInitialPosition
    });
    const blockCount = select.getSelectedBlockCount();
    speak((0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %s: number of selected blocks */
    (0,_wordpress_i18n_build_module._n)('%s block selected.', '%s blocks selected.', blockCount), blockCount), 'assertive');
  };
};
/**
 * Action that clears the block selection.
 *
 * @return {Object} Action object.
 */

function clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}
/**
 * Action that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */

function toggleSelection() {
  let isSelectionEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled
  };
}

function getBlocksWithDefaultStylesApplied(blocks, blockEditorSettings) {
  var _blockEditorSettings$, _blockEditorSettings$2;

  const preferredStyleVariations = (_blockEditorSettings$ = blockEditorSettings === null || blockEditorSettings === void 0 ? void 0 : (_blockEditorSettings$2 = blockEditorSettings.__experimentalPreferredStyleVariations) === null || _blockEditorSettings$2 === void 0 ? void 0 : _blockEditorSettings$2.value) !== null && _blockEditorSettings$ !== void 0 ? _blockEditorSettings$ : {};
  return blocks.map(block => {
    var _block$attributes;

    const blockName = block.name;

    if (!(0,build_module/* hasBlockSupport */.pN)(blockName, 'defaultStylePicker', true)) {
      return block;
    }

    if (!preferredStyleVariations[blockName]) {
      return block;
    }

    const className = (_block$attributes = block.attributes) === null || _block$attributes === void 0 ? void 0 : _block$attributes.className;

    if (className !== null && className !== void 0 && className.includes('is-style-')) {
      return block;
    }

    const {
      attributes = {}
    } = block;
    const blockStyle = preferredStyleVariations[blockName];
    return { ...block,
      attributes: { ...attributes,
        className: `${className || ''} is-style-${blockStyle}`.trim()
      }
    };
  });
}
/* eslint-disable jsdoc/valid-types */

/**
 * Action that replaces given blocks with one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds       Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks          Replacement block(s).
 * @param {number}            indexToSelect   Index of replacement block to select.
 * @param {0|-1|null}         initialPosition Index of caret after in the selected block after the operation.
 * @param {?Object}           meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */


const replaceBlocks = function (clientIds, blocks, indexToSelect) {
  let initialPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  let meta = arguments.length > 4 ? arguments[4] : undefined;
  return _ref7 => {
    let {
      select,
      dispatch
    } = _ref7;

    /* eslint-enable jsdoc/valid-types */
    clientIds = actions_castArray(clientIds);
    blocks = getBlocksWithDefaultStylesApplied(actions_castArray(blocks), select.getSettings());
    const rootClientId = select.getBlockRootClientId(clientIds[0]); // Replace is valid if the new blocks can be inserted in the root block.

    for (let index = 0; index < blocks.length; index++) {
      const block = blocks[index];
      const canInsertBlock = select.canInsertBlockType(block.name, rootClientId);

      if (!canInsertBlock) {
        return;
      }
    }

    dispatch({
      type: 'REPLACE_BLOCKS',
      clientIds,
      blocks,
      time: Date.now(),
      indexToSelect,
      initialPosition,
      meta
    });
    dispatch(ensureDefaultBlock());
  };
};
/**
 * Action that replaces a single block with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */

function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}
/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */

const createOnMove = type => (clientIds, rootClientId) => _ref8 => {
  let {
    select,
    dispatch
  } = _ref8;
  // If one of the blocks is locked or the parent is locked, we cannot move any block.
  const canMoveBlocks = select.canMoveBlocks(clientIds, rootClientId);

  if (!canMoveBlocks) {
    return;
  }

  dispatch({
    type,
    clientIds: actions_castArray(clientIds),
    rootClientId
  });
};

const moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
const moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');
/**
 * Action that moves given blocks to a new position.
 *
 * @param {?string} clientIds        The client IDs of the blocks.
 * @param {?string} fromRootClientId Root client ID source.
 * @param {?string} toRootClientId   Root client ID destination.
 * @param {number}  index            The index to move the blocks to.
 */

const moveBlocksToPosition = function (clientIds) {
  let fromRootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let toRootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  let index = arguments.length > 3 ? arguments[3] : undefined;
  return _ref9 => {
    let {
      select,
      dispatch
    } = _ref9;
    const canMoveBlocks = select.canMoveBlocks(clientIds, fromRootClientId); // If one of the blocks is locked or the parent is locked, we cannot move any block.

    if (!canMoveBlocks) {
      return;
    } // If moving inside the same root block the move is always possible.


    if (fromRootClientId !== toRootClientId) {
      const canRemoveBlocks = select.canRemoveBlocks(clientIds, fromRootClientId); // If we're moving to another block, it means we're deleting blocks from
      // the original block, so we need to check if removing is possible.

      if (!canRemoveBlocks) {
        return;
      }

      const canInsertBlocks = select.canInsertBlocks(clientIds, toRootClientId); // If moving to other parent block, the move is possible if we can insert a block of the same type inside the new parent block.

      if (!canInsertBlocks) {
        return;
      }
    }

    dispatch({
      type: 'MOVE_BLOCKS_TO_POSITION',
      fromRootClientId,
      toRootClientId,
      clientIds,
      index
    });
  };
};
/**
 * Action that moves given block to a new position.
 *
 * @param {?string} clientId         The client ID of the block.
 * @param {?string} fromRootClientId Root client ID source.
 * @param {?string} toRootClientId   Root client ID destination.
 * @param {number}  index            The index to move the block to.
 */

function moveBlockToPosition(clientId) {
  let fromRootClientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let toRootClientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  let index = arguments.length > 3 ? arguments[3] : undefined;
  return moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index);
}
/**
 * Action that inserts a single block, optionally at a specific index respective a root block list.
 *
 * @param {Object}   block           Block object to insert.
 * @param {?number}  index           Index at which block should be inserted.
 * @param {?string}  rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 * @param {?Object}  meta            Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */

function insertBlock(block, index, rootClientId, updateSelection, meta) {
  return insertBlocks([block], index, rootClientId, updateSelection, 0, meta);
}
/* eslint-disable jsdoc/valid-types */

/**
 * Action that inserts an array of blocks, optionally at a specific index respective a root block list.
 *
 * @param {Object[]}  blocks          Block objects to insert.
 * @param {?number}   index           Index at which block should be inserted.
 * @param {?string}   rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean}  updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 * @param {0|-1|null} initialPosition Initial focus position. Setting it to null prevent focusing the inserted block.
 * @param {?Object}   meta            Optional Meta values to be passed to the action object.
 * @return {Object} Action object.
 */

const insertBlocks = function (blocks, index, rootClientId) {
  let updateSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  let initialPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  let meta = arguments.length > 5 ? arguments[5] : undefined;
  return _ref10 => {
    let {
      select,
      dispatch
    } = _ref10;

    /* eslint-enable jsdoc/valid-types */
    if (initialPosition !== null && typeof initialPosition === 'object') {
      meta = initialPosition;
      initialPosition = 0;
      (0,deprecated_build_module/* default */.A)("meta argument in wp.data.dispatch('core/block-editor')", {
        since: '5.8',
        hint: 'The meta argument is now the 6th argument of the function'
      });
    }

    blocks = getBlocksWithDefaultStylesApplied(actions_castArray(blocks), select.getSettings());
    const allowedBlocks = [];

    for (const block of blocks) {
      const isValid = select.canInsertBlockType(block.name, rootClientId);

      if (isValid) {
        allowedBlocks.push(block);
      }
    }

    if (allowedBlocks.length) {
      dispatch({
        type: 'INSERT_BLOCKS',
        blocks: allowedBlocks,
        index,
        rootClientId,
        time: Date.now(),
        updateSelection,
        initialPosition: updateSelection ? initialPosition : null,
        meta
      });
    }
  };
};
/**
 * Action that shows the insertion point.
 *
 * @param {?string} rootClientId      Optional root client ID of block list on
 *                                    which to insert.
 * @param {?number} index             Index at which block should be inserted.
 * @param {Object}  __unstableOptions Whether or not to show an inserter button.
 *
 * @return {Object} Action object.
 */

function showInsertionPoint(rootClientId, index) {
  let __unstableOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  const {
    __unstableWithInserter
  } = __unstableOptions;
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId,
    index,
    __unstableWithInserter
  };
}
/**
 * Action that hides the insertion point.
 *
 * @return {Object} Action object.
 */

function hideInsertionPoint() {
  return {
    type: 'HIDE_INSERTION_POINT'
  };
}
/**
 * Action that resets the template validity.
 *
 * @param {boolean} isValid template validity flag.
 *
 * @return {Object} Action object.
 */

function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid
  };
}
/**
 * Action that synchronizes the template with the list of blocks.
 *
 * @return {Object} Action object.
 */

const synchronizeTemplate = () => _ref11 => {
  let {
    select,
    dispatch
  } = _ref11;
  dispatch({
    type: 'SYNCHRONIZE_TEMPLATE'
  });
  const blocks = select.getBlocks();
  const template = select.getTemplate();
  const updatedBlockList = (0,build_module/* synchronizeBlocksWithTemplate */.Nk)(blocks, template);
  dispatch.resetBlocks(updatedBlockList);
};
/**
 * Delete the current selection.
 *
 * @param {boolean} isForward
 */

const __unstableDeleteSelection = isForward => _ref12 => {
  let {
    registry,
    select,
    dispatch
  } = _ref12;
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  if (selectionAnchor.clientId === selectionFocus.clientId) return; // It's not mergeable if there's no rich text selection.

  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') return false;
  const anchorRootClientId = select.getBlockRootClientId(selectionAnchor.clientId);
  const focusRootClientId = select.getBlockRootClientId(selectionFocus.clientId); // It's not mergeable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return;
  }

  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  let selectionStart, selectionEnd;

  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }

  const targetSelection = isForward ? selectionEnd : selectionStart;
  const targetBlock = select.getBlock(targetSelection.clientId);
  const targetBlockType = (0,build_module/* getBlockType */.E7)(targetBlock.name);

  if (!targetBlockType.merge) {
    return;
  }

  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockAType = (0,build_module/* getBlockType */.E7)(blockA.name);
  const blockB = select.getBlock(selectionB.clientId);
  const blockBType = (0,build_module/* getBlockType */.E7)(blockB.name);
  const htmlA = blockA.attributes[selectionA.attributeKey];
  const htmlB = blockB.attributes[selectionB.attributeKey];
  const attributeDefinitionA = blockAType.attributes[selectionA.attributeKey];
  const attributeDefinitionB = blockBType.attributes[selectionB.attributeKey];
  let valueA = create_create({
    html: htmlA,
    ...mapRichTextSettings(attributeDefinitionA)
  });
  let valueB = create_create({
    html: htmlB,
    ...mapRichTextSettings(attributeDefinitionB)
  });
  valueA = remove(valueA, selectionA.offset, valueA.text.length);
  valueB = insert(valueB, START_OF_SELECTED_AREA, 0, selectionB.offset); // Clone the blocks so we don't manipulate the original.

  const cloneA = (0,build_module/* cloneBlock */.JB)(blockA, {
    [selectionA.attributeKey]: toHTMLString({
      value: valueA,
      ...mapRichTextSettings(attributeDefinitionA)
    })
  });
  const cloneB = (0,build_module/* cloneBlock */.JB)(blockB, {
    [selectionB.attributeKey]: toHTMLString({
      value: valueB,
      ...mapRichTextSettings(attributeDefinitionB)
    })
  });
  const followingBlock = isForward ? cloneA : cloneB; // We can only merge blocks with similar types
  // thus, we transform the block to merge first

  const blocksWithTheSameType = blockA.name === blockB.name ? [followingBlock] : (0,build_module/* switchToBlockType */.bh)(followingBlock, targetBlockType.name); // If the block types can not match, do nothing

  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  }

  let updatedAttributes;

  if (isForward) {
    const blockToMerge = blocksWithTheSameType.pop();
    updatedAttributes = targetBlockType.merge(blockToMerge.attributes, cloneB.attributes);
  } else {
    const blockToMerge = blocksWithTheSameType.shift();
    updatedAttributes = targetBlockType.merge(cloneA.attributes, blockToMerge.attributes);
  }

  const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
  const convertedHtml = updatedAttributes[newAttributeKey];
  const convertedValue = create_create({
    html: convertedHtml,
    ...mapRichTextSettings(targetBlockType.attributes[newAttributeKey])
  });
  const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
  const newValue = remove(convertedValue, newOffset, newOffset + 1);
  const newHtml = toHTMLString({
    value: newValue,
    ...mapRichTextSettings(targetBlockType.attributes[newAttributeKey])
  });
  updatedAttributes[newAttributeKey] = newHtml;
  const selectedBlockClientIds = select.getSelectedBlockClientIds();
  const replacement = [...(isForward ? blocksWithTheSameType : []), { // Preserve the original client ID.
    ...targetBlock,
    attributes: { ...targetBlock.attributes,
      ...updatedAttributes
    }
  }, ...(isForward ? [] : blocksWithTheSameType)];
  registry.batch(() => {
    dispatch.selectionChange(targetBlock.clientId, newAttributeKey, newOffset, newOffset);
    dispatch.replaceBlocks(selectedBlockClientIds, replacement, 0, // If we don't pass the `indexToSelect` it will default to the last block.
    select.getSelectedBlocksInitialCaretPosition());
  });
};
/**
 * Split the current selection.
 */

const __unstableSplitSelection = () => _ref13 => {
  let {
    select,
    dispatch
  } = _ref13;
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  if (selectionAnchor.clientId === selectionFocus.clientId) return; // Can't split if the selection is not set.

  if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === 'undefined' || typeof selectionFocus.offset === 'undefined') return;
  const anchorRootClientId = select.getBlockRootClientId(selectionAnchor.clientId);
  const focusRootClientId = select.getBlockRootClientId(selectionFocus.clientId); // It's not splittable if the selection doesn't start and end in the same
  // block list. Maybe in the future it should be allowed.

  if (anchorRootClientId !== focusRootClientId) {
    return;
  }

  const blockOrder = select.getBlockOrder(anchorRootClientId);
  const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
  const focusIndex = blockOrder.indexOf(selectionFocus.clientId); // Reassign selection start and end based on order.

  let selectionStart, selectionEnd;

  if (anchorIndex > focusIndex) {
    selectionStart = selectionFocus;
    selectionEnd = selectionAnchor;
  } else {
    selectionStart = selectionAnchor;
    selectionEnd = selectionFocus;
  }

  const selectionA = selectionStart;
  const selectionB = selectionEnd;
  const blockA = select.getBlock(selectionA.clientId);
  const blockAType = (0,build_module/* getBlockType */.E7)(blockA.name);
  const blockB = select.getBlock(selectionB.clientId);
  const blockBType = (0,build_module/* getBlockType */.E7)(blockB.name);
  const htmlA = blockA.attributes[selectionA.attributeKey];
  const htmlB = blockB.attributes[selectionB.attributeKey];
  const attributeDefinitionA = blockAType.attributes[selectionA.attributeKey];
  const attributeDefinitionB = blockBType.attributes[selectionB.attributeKey];
  let valueA = create_create({
    html: htmlA,
    ...mapRichTextSettings(attributeDefinitionA)
  });
  let valueB = create_create({
    html: htmlB,
    ...mapRichTextSettings(attributeDefinitionB)
  });
  valueA = remove(valueA, selectionA.offset, valueA.text.length);
  valueB = remove(valueB, 0, selectionB.offset);
  dispatch.replaceBlocks(select.getSelectedBlockClientIds(), [{ // Preserve the original client ID.
    ...blockA,
    attributes: { ...blockA.attributes,
      [selectionA.attributeKey]: toHTMLString({
        value: valueA,
        ...mapRichTextSettings(attributeDefinitionA)
      })
    }
  }, (0,build_module/* createBlock */.Wv)((0,build_module/* getDefaultBlockName */.K$)()), { // Preserve the original client ID.
    ...blockB,
    attributes: { ...blockB.attributes,
      [selectionB.attributeKey]: toHTMLString({
        value: valueB,
        ...mapRichTextSettings(attributeDefinitionB)
      })
    }
  }], 1, // If we don't pass the `indexToSelect` it will default to the last block.
  select.getSelectedBlocksInitialCaretPosition());
};
/**
 * Expand the selection to cover the entire blocks, removing partial selection.
 */

const __unstableExpandSelection = () => _ref14 => {
  let {
    select,
    dispatch
  } = _ref14;
  const selectionAnchor = select.getSelectionStart();
  const selectionFocus = select.getSelectionEnd();
  dispatch.selectionChange({
    start: {
      clientId: selectionAnchor.clientId
    },
    end: {
      clientId: selectionFocus.clientId
    }
  });
};
/**
 * Action that merges two blocks.
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 */

const mergeBlocks = (firstBlockClientId, secondBlockClientId) => _ref15 => {
  let {
    registry,
    select,
    dispatch
  } = _ref15;
  const blocks = [firstBlockClientId, secondBlockClientId];
  dispatch({
    type: 'MERGE_BLOCKS',
    blocks
  });
  const [clientIdA, clientIdB] = blocks;
  const blockA = select.getBlock(clientIdA);
  const blockAType = (0,build_module/* getBlockType */.E7)(blockA.name);
  if (!blockAType) return;
  const blockB = select.getBlock(clientIdB);

  if (blockAType && !blockAType.merge) {
    // If there's no merge function defined, attempt merging inner
    // blocks.
    const blocksWithTheSameType = (0,build_module/* switchToBlockType */.bh)(blockB, blockAType.name); // Only focus the previous block if it's not mergeable.

    if ((blocksWithTheSameType === null || blocksWithTheSameType === void 0 ? void 0 : blocksWithTheSameType.length) !== 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }

    const [blockWithSameType] = blocksWithTheSameType;

    if (blockWithSameType.innerBlocks.length < 1) {
      dispatch.selectBlock(blockA.clientId);
      return;
    }

    registry.batch(() => {
      dispatch.insertBlocks(blockWithSameType.innerBlocks, undefined, clientIdA);
      dispatch.removeBlock(clientIdB);
      dispatch.selectBlock(blockWithSameType.innerBlocks[0].clientId);
    });
    return;
  }

  const blockBType = (0,build_module/* getBlockType */.E7)(blockB.name);
  const {
    clientId,
    attributeKey,
    offset
  } = select.getSelectionStart();
  const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
  const attributeDefinition = selectedBlockType.attributes[attributeKey];
  const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== undefined && offset !== undefined && // We cannot restore text selection if the RichText identifier
  // is not a defined block attribute key. This can be the case if the
  // fallback intance ID is used to store selection (and no RichText
  // identifier is set), or when the identifier is wrong.
  !!attributeDefinition;

  if (!attributeDefinition) {
    if (typeof attributeKey === 'number') {
      window.console.error(`RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`);
    } else {
      window.console.error('The RichText identifier prop does not match any attributes defined by the block.');
    }
  } // Clone the blocks so we don't insert the character in a "live" block.


  const cloneA = (0,build_module/* cloneBlock */.JB)(blockA);
  const cloneB = (0,build_module/* cloneBlock */.JB)(blockB);

  if (canRestoreTextSelection) {
    const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
    const html = selectedBlock.attributes[attributeKey];
    const value = insert(create_create({
      html,
      ...mapRichTextSettings(attributeDefinition)
    }), START_OF_SELECTED_AREA, offset, offset);
    selectedBlock.attributes[attributeKey] = toHTMLString({
      value,
      ...mapRichTextSettings(attributeDefinition)
    });
  } // We can only merge blocks with similar types
  // thus, we transform the block to merge first.


  const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : (0,build_module/* switchToBlockType */.bh)(cloneB, blockA.name); // If the block types can not match, do nothing.

  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  } // Calling the merge to update the attributes and remove the block to be merged.


  const updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);

  if (canRestoreTextSelection) {
    const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const convertedValue = create_create({
      html: convertedHtml,
      ...mapRichTextSettings(blockAType.attributes[newAttributeKey])
    });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = remove(convertedValue, newOffset, newOffset + 1);
    const newHtml = toHTMLString({
      value: newValue,
      ...mapRichTextSettings(blockAType.attributes[newAttributeKey])
    });
    updatedAttributes[newAttributeKey] = newHtml;
    dispatch.selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);
  }

  dispatch.replaceBlocks([blockA.clientId, blockB.clientId], [{ ...blockA,
    attributes: { ...blockA.attributes,
      ...updatedAttributes
    }
  }, ...blocksWithTheSameType.slice(1)], 0 // If we don't pass the `indexToSelect` it will default to the last block.
  );
};
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block should be
 *                                         selected when a block is removed.
 */

const removeBlocks = function (clientIds) {
  let selectPrevious = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return _ref16 => {
    let {
      select,
      dispatch
    } = _ref16;

    if (!clientIds || !clientIds.length) {
      return;
    }

    clientIds = actions_castArray(clientIds);
    const rootClientId = select.getBlockRootClientId(clientIds[0]);
    const canRemoveBlocks = select.canRemoveBlocks(clientIds, rootClientId);

    if (!canRemoveBlocks) {
      return;
    }

    if (selectPrevious) {
      dispatch.selectPreviousBlock(clientIds[0]);
    }

    dispatch({
      type: 'REMOVE_BLOCKS',
      clientIds
    }); // To avoid a focus loss when removing the last block, assure there is
    // always a default block if the last of the blocks have been removed.

    dispatch(ensureDefaultBlock());
  };
};
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */

function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}
/* eslint-disable jsdoc/valid-types */

/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}    rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]}  blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean}  updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to false.
 * @param {0|-1|null} initialPosition Initial block position.
 * @return {Object} Action object.
 */

function replaceInnerBlocks(rootClientId, blocks) {
  let updateSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let initialPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  /* eslint-enable jsdoc/valid-types */
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId,
    blocks,
    updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}
/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */

function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId
  };
}
/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */

function startTyping() {
  return {
    type: 'START_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */

function stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has begun to drag blocks.
 *
 * @param {string[]} clientIds An array of client ids being dragged
 *
 * @return {Object} Action object.
 */

function startDraggingBlocks() {
  let clientIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    type: 'START_DRAGGING_BLOCKS',
    clientIds
  };
}
/**
 * Returns an action object used in signalling that the user has stopped dragging blocks.
 *
 * @return {Object} Action object.
 */

function stopDraggingBlocks() {
  return {
    type: 'STOP_DRAGGING_BLOCKS'
  };
}
/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @deprecated
 *
 * @return {Object} Action object.
 */

function enterFormattedText() {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/block-editor" ).enterFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return {
    type: 'DO_NOTHING'
  };
}
/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @deprecated
 *
 * @return {Object} Action object.
 */

function exitFormattedText() {
  (0,deprecated_build_module/* default */.A)('wp.data.dispatch( "core/block-editor" ).exitFormattedText', {
    since: '6.1',
    version: '6.3'
  });
  return {
    type: 'DO_NOTHING'
  };
}
/**
 * Action that changes the position of the user caret.
 *
 * @param {string|WPSelection} clientId     The selected block client ID.
 * @param {string}             attributeKey The selected block attribute key.
 * @param {number}             startOffset  The start offset.
 * @param {number}             endOffset    The end offset.
 *
 * @return {Object} Action object.
 */

function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  if (typeof clientId === 'string') {
    return {
      type: 'SELECTION_CHANGE',
      clientId,
      attributeKey,
      startOffset,
      endOffset
    };
  }

  return {
    type: 'SELECTION_CHANGE',
    ...clientId
  };
}
/**
 * Action that adds a new block of the default type to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block.
 */

const insertDefaultBlock = (attributes, rootClientId, index) => _ref17 => {
  let {
    dispatch
  } = _ref17;
  // Abort if there is no default block type (if it has been unregistered).
  const defaultBlockName = (0,build_module/* getDefaultBlockName */.K$)();

  if (!defaultBlockName) {
    return;
  }

  const block = (0,build_module/* createBlock */.Wv)(defaultBlockName, attributes);
  return dispatch.insertBlock(block, index, rootClientId);
};
/**
 * Action that changes the nested settings of a given block.
 *
 * @param {string} clientId Client ID of the block whose nested setting are
 *                          being received.
 * @param {Object} settings Object with the new settings for the nested block.
 *
 * @return {Object} Action object
 */

function updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId,
    settings
  };
}
/**
 * Action that updates the block editor settings.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */

function updateSettings(settings) {
  return {
    type: 'UPDATE_SETTINGS',
    settings
  };
}
/**
 * Action that signals that a temporary reusable block has been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */

function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id,
    updatedId
  };
}
/**
 * Action that marks the last block change explicitly as persistent.
 *
 * @return {Object} Action object.
 */

function __unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}
/**
 * Action that signals that the next block change should be marked explicitly as not persistent.
 *
 * @return {Object} Action object.
 */

function __unstableMarkNextChangeAsNotPersistent() {
  return {
    type: 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT'
  };
}
/**
 * Action that marks the last block change as an automatic change, meaning it was not
 * performed by the user, and can be undone using the `Escape` and `Backspace` keys.
 * This action must be called after the change was made, and any actions that are a
 * consequence of it, so it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 */

const __unstableMarkAutomaticChange = () => _ref18 => {
  let {
    dispatch
  } = _ref18;
  dispatch({
    type: 'MARK_AUTOMATIC_CHANGE'
  });
  const {
    requestIdleCallback = cb => setTimeout(cb, 100)
  } = window;
  requestIdleCallback(() => {
    dispatch({
      type: 'MARK_AUTOMATIC_CHANGE_FINAL'
    });
  });
};
/**
 * Action that enables or disables the navigation mode.
 *
 * @param {string} isNavigationMode Enable/Disable navigation mode.
 */

const setNavigationMode = function () {
  let isNavigationMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return _ref19 => {
    let {
      dispatch
    } = _ref19;
    dispatch({
      type: 'SET_NAVIGATION_MODE',
      isNavigationMode
    });

    if (isNavigationMode) {
      speak((0,_wordpress_i18n_build_module.__)('You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter.'));
    } else {
      speak((0,_wordpress_i18n_build_module.__)('You are currently in edit mode. To return to the navigation mode, press Escape.'));
    }
  };
};
/**
 * Action that enables or disables the block moving mode.
 *
 * @param {string|null} hasBlockMovingClientId Enable/Disable block moving mode.
 */

const setBlockMovingClientId = function () {
  let hasBlockMovingClientId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return _ref20 => {
    let {
      dispatch
    } = _ref20;
    dispatch({
      type: 'SET_BLOCK_MOVING_MODE',
      hasBlockMovingClientId
    });

    if (hasBlockMovingClientId) {
      speak((0,_wordpress_i18n_build_module.__)('Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block.'));
    }
  };
};
/**
 * Action that duplicates a list of blocks.
 *
 * @param {string[]} clientIds
 * @param {boolean}  updateSelection
 */

const duplicateBlocks = function (clientIds) {
  let updateSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return _ref21 => {
    let {
      select,
      dispatch
    } = _ref21;

    if (!clientIds || !clientIds.length) {
      return;
    } // Return early if blocks don't exist.


    const blocks = select.getBlocksByClientId(clientIds);

    if (blocks.some(block => !block)) {
      return;
    } // Return early if blocks don't support multiple usage.


    const blockNames = blocks.map(block => block.name);

    if (blockNames.some(blockName => !(0,build_module/* hasBlockSupport */.pN)(blockName, 'multiple', true))) {
      return;
    }

    const rootClientId = select.getBlockRootClientId(clientIds[0]);
    const clientIdsArray = actions_castArray(clientIds);
    const lastSelectedIndex = select.getBlockIndex(clientIdsArray[clientIdsArray.length - 1]);
    const clonedBlocks = blocks.map(block => (0,build_module/* __experimentalCloneSanitizedBlock */.Eb)(block));
    dispatch.insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);

    if (clonedBlocks.length > 1 && updateSelection) {
      dispatch.multiSelect(clonedBlocks[0].clientId, clonedBlocks[clonedBlocks.length - 1].clientId);
    }

    return clonedBlocks.map(block => block.clientId);
  };
};
/**
 * Action that inserts an empty block before a given block.
 *
 * @param {string} clientId
 */

const insertBeforeBlock = clientId => _ref22 => {
  let {
    select,
    dispatch
  } = _ref22;

  if (!clientId) {
    return;
  }

  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = select.getBlockIndex(clientId);
  return dispatch.insertDefaultBlock({}, rootClientId, firstSelectedIndex);
};
/**
 * Action that inserts an empty block after a given block.
 *
 * @param {string} clientId
 */

const insertAfterBlock = clientId => _ref23 => {
  let {
    select,
    dispatch
  } = _ref23;

  if (!clientId) {
    return;
  }

  const rootClientId = select.getBlockRootClientId(clientId);
  const isLocked = select.getTemplateLock(rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = select.getBlockIndex(clientId);
  return dispatch.insertDefaultBlock({}, rootClientId, firstSelectedIndex + 1);
};
/**
 * Action that toggles the highlighted block state.
 *
 * @param {string}  clientId      The block's clientId.
 * @param {boolean} isHighlighted The highlight state.
 */

function toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: 'TOGGLE_BLOCK_HIGHLIGHT',
    clientId,
    isHighlighted
  };
}
/**
 * Action that "flashes" the block with a given `clientId` by rhythmically highlighting it.
 *
 * @param {string} clientId Target block client ID.
 */

const flashBlock = clientId => async _ref24 => {
  let {
    dispatch
  } = _ref24;
  dispatch(toggleBlockHighlight(clientId, true));
  await new Promise(resolve => setTimeout(resolve, 150));
  dispatch(toggleBlockHighlight(clientId, false));
};
/**
 * Action that sets whether a block has controlled inner blocks.
 *
 * @param {string}  clientId                 The block's clientId.
 * @param {boolean} hasControlledInnerBlocks True if the block's inner blocks are controlled.
 */

function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: 'SET_HAS_CONTROLLED_INNER_BLOCKS',
    hasControlledInnerBlocks,
    clientId
  };
}
/**
 * Action that sets whether given blocks are visible on the canvas.
 *
 * @param {Record<string,boolean>} updates For each block's clientId, its new visibility setting.
 */

function setBlockVisibility(updates) {
  return {
    type: 'SET_BLOCK_VISIBILITY',
    updates
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/constants.js
const constants_STORE_NAME = 'core/block-editor';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





/**
 * Block editor data store configuration.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore
 */

const storeConfig = {
  reducer: reducer,
  selectors: store_selectors_namespaceObject,
  actions: store_actions_namespaceObject
};
/**
 * Store definition for the block editor namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 */

const store_store = (0,redux_store/* default */.A)(constants_STORE_NAME, { ...storeConfig,
  persist: ['preferences']
}); // Ideally we'd use register instead of register stores.

(0,data_build_module/* registerStore */.ti)(constants_STORE_NAME, { ...storeConfig,
  persist: ['preferences']
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-edit/context.js
/**
 * WordPress dependencies
 */

const DEFAULT_BLOCK_EDIT_CONTEXT = {
  name: '',
  isSelected: false
};
const block_edit_context_Context = (0,react.createContext)(DEFAULT_BLOCK_EDIT_CONTEXT);
const {
  Provider: block_edit_context_Provider
} = block_edit_context_Context;

/**
 * A hook that returns the block edit context.
 *
 * @return {Object} Block edit context
 */

function context_useBlockEditContext() {
  return (0,react.useContext)(block_edit_context_Context);
}
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/use-display-block-controls/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function useDisplayBlockControls() {
  const {
    isSelected,
    clientId,
    name
  } = context_useBlockEditContext();
  return use_select_useSelect(select => {
    if (isSelected) {
      return true;
    }

    const {
      getBlockName,
      isFirstMultiSelectedBlock,
      getMultiSelectedBlockClientIds
    } = select(store_store);

    if (isFirstMultiSelectedBlock(clientId)) {
      return getMultiSelectedBlockClientIds().every(id => getBlockName(id) === name);
    }

    return false;
  }, [clientId, isSelected, name]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-controls/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function useBlockControlsFill(group, shareWithChildBlocks) {
  const isDisplayed = useDisplayBlockControls();
  const {
    clientId
  } = context_useBlockEditContext();
  const isParentDisplayed = use_select_useSelect(select => {
    const {
      getBlockName,
      hasSelectedInnerBlock
    } = select(store_store);
    const {
      hasBlockSupport
    } = select(build_module/* store */.M_);
    return shareWithChildBlocks && hasBlockSupport(getBlockName(clientId), '__experimentalExposeControlsToChildren', false) && hasSelectedInnerBlock(clientId);
  }, [shareWithChildBlocks, clientId]);

  if (isDisplayed) {
    var _groups$group;

    return (_groups$group = block_controls_groups[group]) === null || _groups$group === void 0 ? void 0 : _groups$group.Fill;
  }

  if (isParentDisplayed) {
    return block_controls_groups.parent.Fill;
  }

  return null;
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function BlockControlsFill(_ref) {
  let {
    group = 'default',
    controls,
    children,
    __experimentalShareWithChildBlocks = false
  } = _ref;
  const Fill = useBlockControlsFill(group, __experimentalShareWithChildBlocks);

  if (!Fill) {
    return null;
  }

  return (0,react.createElement)(style_provider, {
    document: document
  }, (0,react.createElement)(Fill, null, fillProps => {
    // Children passed to BlockControlsFill will not have access to any
    // React Context whose Provider is part of the BlockControlsSlot tree.
    // So we re-create the Provider in this subtree.
    const value = !(0,lodash.isEmpty)(fillProps) ? fillProps : null;
    return (0,react.createElement)(toolbar_context.Provider, {
      value: value
    }, group === 'default' && (0,react.createElement)(toolbar_group, {
      controls: controls
    }), children);
  }));
}
//# sourceMappingURL=fill.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-controls/slot.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function BlockControlsSlot(_ref) {
  let {
    group = 'default',
    ...props
  } = _ref;
  const accessibleToolbarState = (0,react.useContext)(toolbar_context);
  const Slot = block_controls_groups[group].Slot;
  const slot = useSlot(Slot.__unstableName);
  const hasFills = Boolean(slot.fills && slot.fills.length);

  if (!hasFills) {
    return null;
  }

  if (group === 'default') {
    return (0,react.createElement)(Slot, (0,esm_extends/* default */.A)({}, props, {
      bubblesVirtually: true,
      fillProps: accessibleToolbarState
    }));
  }

  return (0,react.createElement)(toolbar_group, null, (0,react.createElement)(Slot, (0,esm_extends/* default */.A)({}, props, {
    bubblesVirtually: true,
    fillProps: accessibleToolbarState
  })));
}
//# sourceMappingURL=slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-controls/index.js



/**
 * Internal dependencies
 */


const BlockControls = BlockControlsFill;
BlockControls.Slot = BlockControlsSlot; // This is just here for backward compatibility.

const BlockFormatControls = props => {
  return (0,react.createElement)(BlockControlsFill, (0,esm_extends/* default */.A)({
    group: "inline"
  }, props));
};

BlockFormatControls.Slot = props => {
  return (0,react.createElement)(BlockControlsSlot, (0,esm_extends/* default */.A)({
    group: "inline"
  }, props));
};

/* harmony default export */ const block_controls = (BlockControls);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar-dropdown-menu/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





function ToolbarDropdownMenu(props, ref) {
  const accessibleToolbarState = (0,react.useContext)(toolbar_context);

  if (!accessibleToolbarState) {
    return (0,react.createElement)(dropdown_menu, props);
  } // ToobarItem will pass all props to the render prop child, which will pass
  // all props to the toggle of DropdownMenu. This means that ToolbarDropdownMenu
  // has the same API as DropdownMenu.


  return (0,react.createElement)(toolbar_item, (0,helpers_esm_extends/* default */.A)({
    ref: ref
  }, props.toggleProps), toolbarItemProps => (0,react.createElement)(dropdown_menu, (0,helpers_esm_extends/* default */.A)({}, props, {
    popoverProps: {
      isAlternate: true,
      ...props.popoverProps
    },
    toggleProps: toolbarItemProps
  })));
}

/* harmony default export */ const toolbar_dropdown_menu = ((0,react.forwardRef)(ToolbarDropdownMenu));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/menu-group/index.js

// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



function MenuGroup(props) {
  const {
    children,
    className = '',
    label,
    hideSeparator
  } = props;
  const instanceId = (0,use_instance_id/* default */.A)(MenuGroup);

  if (!react.Children.count(children)) {
    return null;
  }

  const labelId = `components-menu-group-label-${instanceId}`;
  const classNames = classnames_default()(className, 'components-menu-group', {
    'has-hidden-separator': hideSeparator
  });
  return (0,react.createElement)("div", {
    className: classNames
  }, label && (0,react.createElement)("div", {
    className: "components-menu-group__label",
    id: labelId,
    "aria-hidden": "true"
  }, label), (0,react.createElement)("div", {
    role: "group",
    "aria-labelledby": label ? labelId : null
  }, children));
}
/* harmony default export */ const menu_group = (MenuGroup);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/menu-item/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function MenuItem(props, ref) {
  let {
    children,
    info,
    className,
    icon,
    iconPosition = 'right',
    shortcut,
    isSelected,
    role = 'menuitem',
    ...buttonProps
  } = props;
  className = classnames_default()('components-menu-item__button', className);

  if (info) {
    children = (0,react.createElement)("span", {
      className: "components-menu-item__info-wrapper"
    }, (0,react.createElement)("span", {
      className: "components-menu-item__item"
    }, children), (0,react.createElement)("span", {
      className: "components-menu-item__info"
    }, info));
  }

  if (icon && typeof icon !== 'string') {
    icon = (0,react.cloneElement)(icon, {
      className: classnames_default()('components-menu-items__item-icon', {
        'has-icon-right': iconPosition === 'right'
      })
    });
  }

  return (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    ref: ref // Make sure aria-checked matches spec https://www.w3.org/TR/wai-aria-1.1/#aria-checked
    ,
    "aria-checked": role === 'menuitemcheckbox' || role === 'menuitemradio' ? isSelected : undefined,
    role: role,
    icon: iconPosition === 'left' ? icon : undefined,
    className: className
  }, buttonProps), (0,react.createElement)("span", {
    className: "components-menu-item__item"
  }, children), (0,react.createElement)(build_module_shortcut, {
    className: "components-menu-item__shortcut",
    shortcut: shortcut
  }), icon && iconPosition === 'right' && (0,react.createElement)(build_module_icon, {
    icon: icon
  }));
}
/* harmony default export */ const menu_item = ((0,react.forwardRef)(MenuItem));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/justify-left.js

/**
 * WordPress dependencies
 */

const justifyLeft = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z"
}));
/* harmony default export */ const justify_left = (justifyLeft);
//# sourceMappingURL=justify-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/justify-center.js

/**
 * WordPress dependencies
 */

const justifyCenter = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M12.5 15v5H11v-5H4V9h7V4h1.5v5h7v6h-7Z"
}));
/* harmony default export */ const justify_center = (justifyCenter);
//# sourceMappingURL=justify-center.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/justify-right.js

/**
 * WordPress dependencies
 */

const justifyRight = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ const justify_right = (justifyRight);
//# sourceMappingURL=justify-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/justify-space-between.js

/**
 * WordPress dependencies
 */

const justifySpaceBetween = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ const justify_space_between = (justifySpaceBetween);
//# sourceMappingURL=justify-space-between.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/arrow-right.js

/**
 * WordPress dependencies
 */

const arrowRight = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "m14.5 6.5-1 1 3.7 3.7H4v1.6h13.2l-3.7 3.7 1 1 5.6-5.5z"
}));
/* harmony default export */ const arrow_right = (arrowRight);
//# sourceMappingURL=arrow-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/arrow-down.js

/**
 * WordPress dependencies
 */

const arrowDown = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "m16.5 13.5-3.7 3.7V4h-1.5v13.2l-3.8-3.7-1 1 5.5 5.6 5.5-5.6z"
}));
/* harmony default export */ const arrow_down = (arrowDown);
//# sourceMappingURL=arrow-down.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@17.0.71_react@17.0.2/node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var emotion_react_browser_esm = __webpack_require__("../../node_modules/.pnpm/@emotion+react@11.11.1_@types+react@17.0.71_react@17.0.2/node_modules/@emotion/react/dist/emotion-react.browser.esm.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/utils/use-responsive-value.js
/**
 * WordPress dependencies
 */

const breakpoints = ['40em', '52em', '64em'];
const useBreakpointIndex = function () {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    defaultIndex = 0
  } = options;

  if (typeof defaultIndex !== 'number') {
    throw new TypeError(`Default breakpoint index should be a number. Got: ${defaultIndex}, ${typeof defaultIndex}`);
  } else if (defaultIndex < 0 || defaultIndex > breakpoints.length - 1) {
    throw new RangeError(`Default breakpoint index out of range. Theme has ${breakpoints.length} breakpoints, got index ${defaultIndex}`);
  }

  const [value, setValue] = (0,react.useState)(defaultIndex);
  (0,react.useEffect)(() => {
    const getIndex = () => breakpoints.filter(bp => {
      return typeof window !== 'undefined' ? window.matchMedia(`screen and (min-width: ${bp})`).matches : false;
    }).length;

    const onResize = () => {
      const newValue = getIndex();

      if (value !== newValue) {
        setValue(newValue);
      }
    };

    onResize();

    if (typeof window !== 'undefined') {
      window.addEventListener('resize', onResize);
    }

    return () => {
      if (typeof window !== 'undefined') {
        window.removeEventListener('resize', onResize);
      }
    };
  }, [value]);
  return value;
};
function useResponsiveValue(values) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const index = useBreakpointIndex(options); // Allow calling the function with a "normal" value without having to check on the outside.

  if (!Array.isArray(values) && typeof values !== 'function') return values;
  const array = values || [];
  /* eslint-disable jsdoc/no-undefined-types */

  return (
    /** @type {T[]} */
    array[
    /* eslint-enable jsdoc/no-undefined-types */
    index >= array.length ? array.length - 1 : index]
  );
}
//# sourceMappingURL=use-responsive-value.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/utils/space.js
/**
 * The argument value for the `space()` utility function.
 *
 * When this is a number or a numeric string, it will be interpreted as a
 * multiplier for the grid base value (4px). For example, `space( 2 )` will be 8px.
 *
 * Otherwise, it will be interpreted as a literal CSS length value. For example,
 * `space( 'auto' )` will be 'auto', and `space( '2px' )` will be 2px.
 */
const GRID_BASE = '4px';
/**
 * A function that handles numbers, numeric strings, and unit values.
 *
 * When given a number or a numeric string, it will return the grid-based
 * value as a factor of GRID_BASE, defined above.
 *
 * When given a unit value or one of the named CSS values like `auto`,
 * it will simply return the value back.
 *
 * @param  value A number, numeric string, or a unit value.
 */

function space(value) {
  var _window$CSS, _window$CSS$supports;

  if (typeof value === 'undefined') {
    return undefined;
  } // Handle empty strings, if it's the number 0 this still works.


  if (!value) {
    return '0';
  }

  const asInt = typeof value === 'number' ? value : Number(value); // Test if the input has a unit, was NaN, or was one of the named CSS values (like `auto`), in which case just use that value.

  if (typeof window !== 'undefined' && (_window$CSS = window.CSS) !== null && _window$CSS !== void 0 && (_window$CSS$supports = _window$CSS.supports) !== null && _window$CSS$supports !== void 0 && _window$CSS$supports.call(_window$CSS, 'margin', value.toString()) || Number.isNaN(asInt)) {
    return value.toString();
  }

  return `calc(${GRID_BASE} * ${value})`;
}
//# sourceMappingURL=space.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/styles.js
function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

const Flex =  true ? {
  name: "zjik7",
  styles: "display:flex"
} : 0;
const Item =  true ? {
  name: "qgaee5",
  styles: "display:block;max-height:100%;max-width:100%;min-height:0;min-width:0"
} : 0;
const block =  true ? {
  name: "82a6rk",
  styles: "flex:1"
} : 0;
/**
 * Workaround to optimize DOM rendering.
 * We'll enhance alignment with naive parent flex assumptions.
 *
 * Trade-off:
 * Far less DOM less. However, UI rendering is not as reliable.
 */

/**
 * Improves stability of width/height rendering.
 * https://github.com/ItsJonQ/g2/pull/149
 */

const ItemsColumn =  true ? {
  name: "13nosa1",
  styles: ">*{min-height:0;}"
} : 0;
const ItemsRow =  true ? {
  name: "1pwxzk4",
  styles: ">*{min-width:0;}"
} : 0;
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/rtl.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


const LOWER_LEFT_REGEXP = new RegExp(/-left/g);
const LOWER_RIGHT_REGEXP = new RegExp(/-right/g);
const UPPER_LEFT_REGEXP = new RegExp(/Left/g);
const UPPER_RIGHT_REGEXP = new RegExp(/Right/g);
/**
 * Flips a CSS property from left <-> right.
 *
 * @param {string} key The CSS property name.
 *
 * @return {string} The flipped CSS property name, if applicable.
 */

function getConvertedKey(key) {
  if (key === 'left') {
    return 'right';
  }

  if (key === 'right') {
    return 'left';
  }

  if (LOWER_LEFT_REGEXP.test(key)) {
    return key.replace(LOWER_LEFT_REGEXP, '-right');
  }

  if (LOWER_RIGHT_REGEXP.test(key)) {
    return key.replace(LOWER_RIGHT_REGEXP, '-left');
  }

  if (UPPER_LEFT_REGEXP.test(key)) {
    return key.replace(UPPER_LEFT_REGEXP, 'Right');
  }

  if (UPPER_RIGHT_REGEXP.test(key)) {
    return key.replace(UPPER_RIGHT_REGEXP, 'Left');
  }

  return key;
}
/**
 * An incredibly basic ltr -> rtl converter for style properties
 *
 * @param {import('react').CSSProperties} ltrStyles
 *
 * @return {import('react').CSSProperties} Converted ltr -> rtl styles
 */


const convertLTRToRTL = function () {
  let ltrStyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.fromEntries(Object.entries(ltrStyles).map(_ref => {
    let [key, value] = _ref;
    return [getConvertedKey(key), value];
  }));
};
/**
 * A higher-order function that create an incredibly basic ltr -> rtl style converter for CSS objects.
 *
 * @param {import('react').CSSProperties} ltrStyles   Ltr styles. Converts and renders from ltr -> rtl styles, if applicable.
 * @param {import('react').CSSProperties} [rtlStyles] Rtl styles. Renders if provided.
 *
 * @return {() => import('@emotion/react').SerializedStyles} A function to output CSS styles for Emotion's renderer
 */

function rtl() {
  let ltrStyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let rtlStyles = arguments.length > 1 ? arguments[1] : undefined;
  return () => {
    if (rtlStyles) {
      // @ts-ignore: `css` types are wrong, it can accept an object: https://emotion.sh/docs/object-styles#with-css
      return (0,i18n_build_module/* isRTL */.V8)() ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(rtlStyles,  true ? "" : 0) : /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(ltrStyles,  true ? "" : 0);
    } // @ts-ignore: `css` types are wrong, it can accept an object: https://emotion.sh/docs/object-styles#with-css


    return (0,i18n_build_module/* isRTL */.V8)() ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(convertLTRToRTL(ltrStyles),  true ? "" : 0) : /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(ltrStyles,  true ? "" : 0);
  };
}
/**
 * Call this in the `useMemo` dependency array to ensure that subsequent renders will
 * cause rtl styles to update based on the `isRTL` return value even if all other dependencies
 * remain the same.
 *
 * @example
 * const styles = useMemo( () => {
 *   return css`
 *     ${ rtl( { marginRight: '10px' } ) }
 *   `;
 * }, [ rtl.watch() ] );
 */

rtl.watch = () => (0,i18n_build_module/* isRTL */.V8)();
//# sourceMappingURL=rtl.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/flex/hook.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







function hook_useDeprecatedProps(props) {
  const {
    isReversed,
    ...otherProps
  } = props;

  if (typeof isReversed !== 'undefined') {
    (0,deprecated_build_module/* default */.A)('Flex isReversed', {
      alternative: 'Flex direction="row-reverse" or "column-reverse"',
      since: '5.9'
    });
    return { ...otherProps,
      direction: isReversed ? 'row-reverse' : 'row'
    };
  }

  return otherProps;
}

function useFlex(props) {
  const {
    align = 'center',
    className,
    direction: directionProp = 'row',
    expanded = true,
    gap = 2,
    justify = 'space-between',
    wrap = false,
    ...otherProps
  } = useContextSystem(hook_useDeprecatedProps(props), 'Flex');
  const directionAsArray = Array.isArray(directionProp) ? directionProp : [directionProp];
  const direction = useResponsiveValue(directionAsArray);
  const isColumn = typeof direction === 'string' && !!direction.includes('column');
  const isReverse = typeof direction === 'string' && direction.includes('reverse');
  const cx = useCx();
  const rtlWatchResult = rtl.watch();
  const classes = (0,react.useMemo)(() => {
    const sx = {};
    sx.Base = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      alignItems: isColumn ? 'normal' : align,
      flexDirection: direction,
      flexWrap: wrap ? 'wrap' : undefined,
      justifyContent: justify,
      height: isColumn && expanded ? '100%' : undefined,
      width: !isColumn && expanded ? '100%' : undefined,
      marginBottom: wrap ? `calc(${space(gap)} * -1)` : undefined
    },  true ? "" : 0,  true ? "" : 0);
    /**
     * Workaround to optimize DOM rendering.
     * We'll enhance alignment with naive parent flex assumptions.
     *
     * Trade-off:
     * Far less DOM less. However, UI rendering is not as reliable.
     */

    sx.Items = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(">*+*:not( marquee ){margin-top:", isColumn ? space(gap) : undefined, ";", rtl({
      marginLeft: !isColumn && !isReverse ? space(gap) : undefined,
      marginRight: !isColumn && isReverse ? space(gap) : undefined
    })(), ";}" + ( true ? "" : 0),  true ? "" : 0);
    sx.WrapItems = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(">*:not( marquee ){margin-bottom:", space(gap), ";", rtl({
      marginLeft: !isColumn && isReverse ? space(gap) : undefined,
      marginRight: !isColumn && !isReverse ? space(gap) : undefined
    })(), ";}>*:last-child:not( marquee ){", rtl({
      marginLeft: !isColumn && isReverse ? 0 : undefined,
      marginRight: !isColumn && !isReverse ? 0 : undefined
    })(), ";}" + ( true ? "" : 0),  true ? "" : 0);
    return cx(Flex, sx.Base, wrap ? sx.WrapItems : sx.Items, isColumn ? ItemsColumn : ItemsRow, className); // rtlWatchResult is needed to refresh styles when the writing direction changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [align, className, cx, direction, expanded, gap, isColumn, isReverse, justify, wrap, rtlWatchResult]);
  return { ...otherProps,
    className: classes,
    isColumn
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/context.js
/**
 * WordPress dependencies
 */

const FlexContext = (0,react.createContext)({
  flexItemDisplay: undefined
});
const useFlexContext = () => (0,react.useContext)(FlexContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/flex/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function UnconnectedFlex(props, forwardedRef) {
  const {
    children,
    isColumn,
    ...otherProps
  } = useFlex(props);
  return (0,react.createElement)(FlexContext.Provider, {
    value: {
      flexItemDisplay: isColumn ? 'block' : undefined
    }
  }, (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, otherProps, {
    ref: forwardedRef
  }), children));
}
/**
 * `Flex` is a primitive layout component that adaptively aligns child content
 * horizontally or vertically. `Flex` powers components like `HStack` and
 * `VStack`.
 *
 * `Flex` is used with any of its two sub-components, `FlexItem` and
 * `FlexBlock`.
 *
 * ```jsx
 * import { Flex, FlexBlock, FlexItem } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <Flex>
 *       <FlexItem>
 *         <p>Code</p>
 *       </FlexItem>
 *       <FlexBlock>
 *         <p>Poetry</p>
 *       </FlexBlock>
 *     </Flex>
 *   );
 * }
 * ```
 */


const component_Flex = contextConnect(UnconnectedFlex, 'Flex');
/* harmony default export */ const flex_component = (component_Flex);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/flex-item/hook.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





function useFlexItem(props) {
  const {
    className,
    display: displayProp,
    isBlock = false,
    ...otherProps
  } = useContextSystem(props, 'FlexItem');
  const sx = {};
  const contextDisplay = useFlexContext().flexItemDisplay;
  sx.Base = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    display: displayProp || contextDisplay
  },  true ? "" : 0,  true ? "" : 0);
  const cx = useCx();
  const classes = cx(Item, sx.Base, isBlock && block, className);
  return { ...otherProps,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/flex-item/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedFlexItem(props, forwardedRef) {
  const flexItemProps = useFlexItem(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, flexItemProps, {
    ref: forwardedRef
  }));
}
/**
 * `FlexItem` is a primitive layout component that aligns content within layout
 * containers like `Flex`.
 *
 * ```jsx
 * import { Flex, FlexItem } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <Flex>
 *       <FlexItem>...</FlexItem>
 *     </Flex>
 *   );
 * }
 * ```
 */


const FlexItem = contextConnect(UnconnectedFlexItem, 'FlexItem');
/* harmony default export */ const flex_item_component = (FlexItem);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/form-toggle/index.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const form_toggle_noop = () => {};
/**
 * FormToggle switches a single setting on or off.
 *
 * ```jsx
 * import { FormToggle } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyFormToggle = () => {
 *   const [ isChecked, setChecked ] = useState( true );
 *
 *   return (
 *     <FormToggle
 *       checked={ isChecked }
 *       onChange={ () => setChecked( ( state ) => ! state ) }
 *     />
 *   );
 * };
 * ```
 */

function FormToggle( // ref is omitted until we have `WordPressComponentPropsWithoutRef` or add
// ref forwarding to FormToggle.
props) {
  const {
    className,
    checked,
    id,
    disabled,
    onChange = form_toggle_noop,
    ...additionalProps
  } = props;
  const wrapperClasses = classnames_default()('components-form-toggle', className, {
    'is-checked': checked,
    'is-disabled': disabled
  });
  return (0,react.createElement)("span", {
    className: wrapperClasses
  }, (0,react.createElement)("input", (0,helpers_esm_extends/* default */.A)({
    className: "components-form-toggle__input",
    id: id,
    type: "checkbox",
    checked: checked,
    onChange: onChange,
    disabled: disabled
  }, additionalProps)), (0,react.createElement)("span", {
    className: "components-form-toggle__track"
  }), (0,react.createElement)("span", {
    className: "components-form-toggle__thumb"
  }));
}
/* harmony default export */ const form_toggle = (FormToggle);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/font-values.js
/* harmony default export */ const font_values = ({
  'default.fontFamily': "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif",
  'default.fontSize': '13px',
  'helpText.fontSize': '12px',
  mobileTextMinFontSize: '16px'
});
//# sourceMappingURL=font-values.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/font.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 *
 * @param {keyof FONT} value Path of value from `FONT`
 * @return {string} Font rule value
 */

function font(value) {
  return (0,lodash.get)(font_values, value, '');
}
//# sourceMappingURL=font.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/box-sizing.js
function box_sizing_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

const boxSizingReset =  true ? {
  name: "kv6lnz",
  styles: "box-sizing:border-box;*,*::before,*::after{box-sizing:inherit;}"
} : 0;
//# sourceMappingURL=box-sizing.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/base-label.js
function base_label_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */
 // This is a very low-level mixin which you shouldn't have to use directly.
// Try to use BaseControl's StyledLabel or BaseControl.VisualLabel if you can.

const baseLabelTypography =  true ? {
  name: "9amh4a",
  styles: "font-size:11px;font-weight:500;line-height:1.4;text-transform:uppercase"
} : 0;
//# sourceMappingURL=base-label.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs
var node_modules_colord = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs
var names = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/colors.js
/**
 * External dependencies
 */


(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
/**
 * Generating a CSS compliant rgba() color value.
 *
 * @param {string} hexValue The hex value to convert to rgba().
 * @param {number} alpha    The alpha value for opacity.
 * @return {string} The converted rgba() color value.
 *
 * @example
 * rgba( '#000000', 0.5 )
 * // rgba(0, 0, 0, 0.5)
 */

function rgba() {
  let hexValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return (0,node_modules_colord/* colord */.Mj)(hexValue).alpha(alpha).toRgbString();
}
//# sourceMappingURL=colors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/colors-values.js
/**
 * Internal dependencies
 */

const white = '#fff'; // Matches the grays in @wordpress/base-styles

const GRAY = {
  900: '#1e1e1e',
  800: '#2f2f2f',

  /** Meets 4.6:1 text contrast against white. */
  700: '#757575',

  /** Meets 3:1 UI or large text contrast against white. */
  600: '#949494',
  400: '#ccc',

  /** Used for most borders. */
  300: '#ddd',

  /** Used sparingly for light borders. */
  200: '#e0e0e0',

  /** Used for light gray backgrounds. */
  100: '#f0f0f0'
};
const DARK_GRAY = {
  500: '#555d66',
  // Use this most of the time for dark items.
  300: '#6c7781',
  // Lightest gray that can be used for AA text contrast.
  150: '#8d96a0' // Lightest gray that can be used for AA non-text contrast.

};
const LIGHT_GRAY = {
  800: '#b5bcc2',
  600: '#d7dade',
  400: '#e8eaeb',
  // Good for "readonly" input fields and special text selection.
  300: '#edeff0',
  200: '#f3f4f5'
}; // Matches @wordpress/base-styles

const ALERT = {
  yellow: '#f0b849',
  red: '#d94f4f',
  green: '#4ab866'
}; // Matches @wordpress/base-styles

const ADMIN = {
  theme: 'var( --wp-admin-theme-color, #007cba)',
  themeDark10: 'var( --wp-admin-theme-color-darker-10, #006ba1)'
};
const UI = {
  theme: ADMIN.theme,
  background: white,
  backgroundDisabled: LIGHT_GRAY[200],
  // TODO: Replace with WordPress gray
  border: GRAY[700],
  borderHover: GRAY[700],
  borderFocus: ADMIN.themeDark10,
  borderDisabled: GRAY[400],
  textDisabled: DARK_GRAY[150],
  // TODO: Replace with WordPress gray
  textDark: white,
  // Matches @wordpress/base-styles
  darkGrayPlaceholder: rgba(GRAY[900], 0.62),
  lightGrayPlaceholder: rgba(white, 0.65)
};
const COLORS = Object.freeze({
  /**
   * @deprecated Try to use `gray` instead.
   */
  darkGray: DARK_GRAY,

  /**
   * The main gray color object.
   */
  gray: GRAY,

  /**
   * @deprecated Try to use `gray` instead.
   */
  lightGray: LIGHT_GRAY,
  white,
  alert: ALERT,
  ui: UI
});
/* harmony default export */ const colors_values = ((/* unused pure expression or super */ null && (COLORS)));
//# sourceMappingURL=colors-values.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/base-control/styles/base-control-styles.js


function base_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const Wrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ej5x27r4"
} : 0)("font-family:", font('default.fontFamily'), ";font-size:", font('default.fontSize'), ";", boxSizingReset, ";" + ( true ? "" : 0));

const deprecatedMarginField = _ref2 => {
  let {
    __nextHasNoMarginBottom = false
  } = _ref2;
  return !__nextHasNoMarginBottom && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin-bottom:", space(2), ";" + ( true ? "" : 0),  true ? "" : 0);
};

const StyledField = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ej5x27r3"
} : 0)(deprecatedMarginField, " .components-panel__row &{margin-bottom:inherit;}" + ( true ? "" : 0));
const labelStyles = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(baseLabelTypography, ";display:inline-block;margin-bottom:", space(2), ";padding:0;" + ( true ? "" : 0),  true ? "" : 0);
const StyledLabel = (0,emotion_styled_base_browser_esm/* default */.A)("label",  true ? {
  target: "ej5x27r2"
} : 0)(labelStyles, ";" + ( true ? "" : 0));

var _ref =  true ? {
  name: "11yad0w",
  styles: "margin-bottom:revert"
} : 0;

const deprecatedMarginHelp = _ref3 => {
  let {
    __nextHasNoMarginBottom = false
  } = _ref3;
  return !__nextHasNoMarginBottom && _ref;
};

const StyledHelp = (0,emotion_styled_base_browser_esm/* default */.A)("p",  true ? {
  target: "ej5x27r1"
} : 0)("margin-top:", space(2), ";margin-bottom:0;font-size:", font('helpText.fontSize'), ";font-style:normal;color:", COLORS.gray[700], ";", deprecatedMarginHelp, ";" + ( true ? "" : 0));
const StyledVisualLabel = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "ej5x27r0"
} : 0)(labelStyles, ";" + ( true ? "" : 0));
//# sourceMappingURL=base-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/base-control/index.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




/**
 * `BaseControl` is a component used to generate labels and help text for components handling user inputs.
 *
 * @example
 * // Render a `BaseControl` for a textarea input
 * import { BaseControl } from '@wordpress/components';
 *
 * // The `id` prop is necessary to accessibly associate the label with the textarea
 * const MyBaseControl = () => (
 *   <BaseControl id="textarea-1" label="Text" help="Enter some text" __nextHasNoMarginBottom={ true }>
 *     <textarea id="textarea-1" />
 *   </BaseControl>
 * );
 */
const BaseControl = _ref => {
  let {
    __nextHasNoMarginBottom = false,
    id,
    label,
    hideLabelFromVision = false,
    help,
    className,
    children
  } = _ref;
  return (0,react.createElement)(Wrapper, {
    className: classnames_default()('components-base-control', className)
  }, (0,react.createElement)(StyledField, {
    className: "components-base-control__field" // TODO: Official deprecation for this should start after all internal usages have been migrated
    ,
    __nextHasNoMarginBottom: __nextHasNoMarginBottom
  }, label && id && (hideLabelFromVision ? (0,react.createElement)(visually_hidden_component, {
    as: "label",
    htmlFor: id
  }, label) : (0,react.createElement)(StyledLabel, {
    className: "components-base-control__label",
    htmlFor: id
  }, label)), label && !id && (hideLabelFromVision ? (0,react.createElement)(visually_hidden_component, {
    as: "label"
  }, label) : (0,react.createElement)(BaseControl.VisualLabel, null, label)), children), !!help && (0,react.createElement)(StyledHelp, {
    id: id ? id + '__help' : undefined,
    className: "components-base-control__help",
    __nextHasNoMarginBottom: __nextHasNoMarginBottom
  }, help));
};
/**
 * `BaseControl.VisualLabel` is used to render a purely visual label inside a `BaseControl` component.
 *
 * It should only be used in cases where the children being rendered inside `BaseControl` are already accessibly labeled,
 * e.g., a button, but we want an additional visual label for that section equivalent to the labels `BaseControl` would
 * otherwise use if the `label` prop was passed.
 *
 * @example
 * import { BaseControl } from '@wordpress/components';
 *
 * const MyBaseControl = () => (
 * 	<BaseControl help="This button is already accessibly labeled.">
 * 		<BaseControl.VisualLabel>Author</BaseControl.VisualLabel>
 * 		<Button>Select an author</Button>
 * 	</BaseControl>
 * );
 */

const VisualLabel = _ref2 => {
  let {
    className,
    children,
    ...props
  } = _ref2;
  return (0,react.createElement)(StyledVisualLabel, (0,helpers_esm_extends/* default */.A)({}, props, {
    className: classnames_default()('components-base-control__label', className)
  }), children);
};
BaseControl.VisualLabel = VisualLabel;
/* harmony default export */ const base_control = (BaseControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function ToggleControl(_ref) {
  let {
    label,
    checked,
    help,
    className,
    onChange,
    disabled
  } = _ref;

  function onChangeToggle(event) {
    onChange(event.target.checked);
  }

  const instanceId = (0,use_instance_id/* default */.A)(ToggleControl);
  const id = `inspector-toggle-control-${instanceId}`;
  let describedBy, helpLabel;

  if (help) {
    describedBy = id + '__help';
    helpLabel = typeof help === 'function' ? help(checked) : help;
  }

  return (0,react.createElement)(base_control, {
    id: id,
    help: helpLabel,
    className: classnames_default()('components-toggle-control', className)
  }, (0,react.createElement)(form_toggle, {
    id: id,
    checked: checked,
    onChange: onChangeToggle,
    "aria-describedby": describedBy,
    disabled: disabled
  }), (0,react.createElement)("label", {
    htmlFor: id,
    className: "components-toggle-control__label"
  }, label));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/layouts/utils.js
/**
 * WordPress dependencies
 */

/**
 * Utility to generate the proper CSS selector for layout styles.
 *
 * @param {string} selectors CSS selector, also supports multiple comma-separated selectors.
 * @param {string} append    The string to append.
 *
 * @return {string} - CSS selector.
 */

function appendSelectors(selectors) {
  let append = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  // Ideally we shouldn't need the `.editor-styles-wrapper` increased specificity here
  // The problem though is that we have a `.editor-styles-wrapper p { margin: reset; }` style
  // it's used to reset the default margin added by wp-admin to paragraphs
  // so we need this to be higher speficity otherwise, it won't be applied to paragraphs inside containers
  // When the post editor is fully iframed, this extra classname could be removed.
  return selectors.split(',').map(subselector => `.editor-styles-wrapper ${subselector}${append ? ` ${append}` : ''}`).join(',');
}
/**
 * Get generated blockGap CSS rules based on layout definitions provided in theme.json
 * Falsy values in the layout definition's spacingStyles rules will be swapped out
 * with the provided `blockGapValue`.
 *
 * @param {string} selector          The CSS selector to target for the generated rules.
 * @param {Object} layoutDefinitions Layout definitions object from theme.json.
 * @param {string} layoutType        The layout type (e.g. `default` or `flex`).
 * @param {string} blockGapValue     The current blockGap value to be applied.
 * @return {string} The generated CSS rules.
 */

function getBlockGapCSS(selector, layoutDefinitions, layoutType, blockGapValue) {
  var _layoutDefinitions$la, _layoutDefinitions$la2;

  let output = '';

  if (layoutDefinitions !== null && layoutDefinitions !== void 0 && (_layoutDefinitions$la = layoutDefinitions[layoutType]) !== null && _layoutDefinitions$la !== void 0 && (_layoutDefinitions$la2 = _layoutDefinitions$la.spacingStyles) !== null && _layoutDefinitions$la2 !== void 0 && _layoutDefinitions$la2.length && blockGapValue) {
    layoutDefinitions[layoutType].spacingStyles.forEach(gapStyle => {
      output += `${appendSelectors(selector, gapStyle.selector.trim())} { `;
      output += Object.entries(gapStyle.rules).map(_ref => {
        let [cssProperty, value] = _ref;
        return `${cssProperty}: ${value ? value : blockGapValue}`;
      }).join('; ');
      output += '; }';
    });
  }

  return output;
}
/**
 * Helper method to assign contextual info to clarify
 * alignment settings.
 *
 * Besides checking if `contentSize` and `wideSize` have a
 * value, we now show this information only if their values
 * are not a `css var`. This needs to change when parsing
 * css variables land.
 *
 * @see https://github.com/WordPress/gutenberg/pull/34710#issuecomment-918000752
 *
 * @param {Object} layout The layout object.
 * @return {Object} An object with contextual info per alignment.
 */

function getAlignmentsInfo(layout) {
  const {
    contentSize,
    wideSize
  } = layout;
  const alignmentInfo = {};
  const sizeRegex = /^(?!0)\d+(px|em|rem|vw|vh|%)?$/i;

  if (sizeRegex.test(contentSize)) {
    // translators: %s: container size (i.e. 600px etc)
    alignmentInfo.none = (0,_wordpress_i18n_build_module/* sprintf */.nv)((0,_wordpress_i18n_build_module.__)('Max %s wide'), contentSize);
  }

  if (sizeRegex.test(wideSize)) {
    // translators: %s: container size (i.e. 600px etc)
    alignmentInfo.wide = (0,_wordpress_i18n_build_module/* sprintf */.nv)((0,_wordpress_i18n_build_module.__)('Max %s wide'), wideSize);
  }

  return alignmentInfo;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/unit-control/utils.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

const isWeb = platform.OS === 'web';
const allUnits = {
  px: {
    value: 'px',
    label: isWeb ? 'px' : (0,i18n_build_module.__)('Pixels (px)'),
    a11yLabel: (0,i18n_build_module.__)('Pixels (px)'),
    step: 1
  },
  '%': {
    value: '%',
    label: isWeb ? '%' : (0,i18n_build_module.__)('Percentage (%)'),
    a11yLabel: (0,i18n_build_module.__)('Percent (%)'),
    step: 0.1
  },
  em: {
    value: 'em',
    label: isWeb ? 'em' : (0,i18n_build_module.__)('Relative to parent font size (em)'),
    a11yLabel: (0,i18n_build_module._x)('ems', 'Relative to parent font size (em)'),
    step: 0.01
  },
  rem: {
    value: 'rem',
    label: isWeb ? 'rem' : (0,i18n_build_module.__)('Relative to root font size (rem)'),
    a11yLabel: (0,i18n_build_module._x)('rems', 'Relative to root font size (rem)'),
    step: 0.01
  },
  vw: {
    value: 'vw',
    label: isWeb ? 'vw' : (0,i18n_build_module.__)('Viewport width (vw)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport width (vw)'),
    step: 0.1
  },
  vh: {
    value: 'vh',
    label: isWeb ? 'vh' : (0,i18n_build_module.__)('Viewport height (vh)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport height (vh)'),
    step: 0.1
  },
  vmin: {
    value: 'vmin',
    label: isWeb ? 'vmin' : (0,i18n_build_module.__)('Viewport smallest dimension (vmin)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport smallest dimension (vmin)'),
    step: 0.1
  },
  vmax: {
    value: 'vmax',
    label: isWeb ? 'vmax' : (0,i18n_build_module.__)('Viewport largest dimension (vmax)'),
    a11yLabel: (0,i18n_build_module.__)('Viewport largest dimension (vmax)'),
    step: 0.1
  },
  ch: {
    value: 'ch',
    label: isWeb ? 'ch' : (0,i18n_build_module.__)('Width of the zero (0) character (ch)'),
    a11yLabel: (0,i18n_build_module.__)('Width of the zero (0) character (ch)'),
    step: 0.01
  },
  ex: {
    value: 'ex',
    label: isWeb ? 'ex' : (0,i18n_build_module.__)('x-height of the font (ex)'),
    a11yLabel: (0,i18n_build_module.__)('x-height of the font (ex)'),
    step: 0.01
  },
  cm: {
    value: 'cm',
    label: isWeb ? 'cm' : (0,i18n_build_module.__)('Centimeters (cm)'),
    a11yLabel: (0,i18n_build_module.__)('Centimeters (cm)'),
    step: 0.001
  },
  mm: {
    value: 'mm',
    label: isWeb ? 'mm' : (0,i18n_build_module.__)('Millimeters (mm)'),
    a11yLabel: (0,i18n_build_module.__)('Millimeters (mm)'),
    step: 0.1
  },
  in: {
    value: 'in',
    label: isWeb ? 'in' : (0,i18n_build_module.__)('Inches (in)'),
    a11yLabel: (0,i18n_build_module.__)('Inches (in)'),
    step: 0.001
  },
  pc: {
    value: 'pc',
    label: isWeb ? 'pc' : (0,i18n_build_module.__)('Picas (pc)'),
    a11yLabel: (0,i18n_build_module.__)('Picas (pc)'),
    step: 1
  },
  pt: {
    value: 'pt',
    label: isWeb ? 'pt' : (0,i18n_build_module.__)('Points (pt)'),
    a11yLabel: (0,i18n_build_module.__)('Points (pt)'),
    step: 1
  }
};
/**
 * An array of all available CSS length units.
 */

const ALL_CSS_UNITS = Object.values(allUnits);
/**
 * Units of measurements. `a11yLabel` is used by screenreaders.
 */

const CSS_UNITS = [allUnits.px, allUnits['%'], allUnits.em, allUnits.rem, allUnits.vw, allUnits.vh];
const DEFAULT_UNIT = allUnits.px;
/**
 * Handles legacy value + unit handling.
 * This component use to manage both incoming value and units separately.
 *
 * Moving forward, ideally the value should be a string that contains both
 * the value and unit, example: '10px'
 *
 * @param  rawValue     The raw value as a string (may or may not contain the unit)
 * @param  fallbackUnit The unit used as a fallback, if not unit is detected in the `value`
 * @param  allowedUnits Units to derive from.
 * @return The extracted quantity and unit. The quantity can be `undefined` in case the raw value
 * could not be parsed to a number correctly. The unit can be `undefined` in case the unit parse
 * from the raw value could not be matched against the list of allowed units.
 */

function getParsedQuantityAndUnit(rawValue, fallbackUnit, allowedUnits) {
  const initialValue = fallbackUnit ? `${rawValue !== null && rawValue !== void 0 ? rawValue : ''}${fallbackUnit}` : rawValue;
  return parseQuantityAndUnitFromRawValue(initialValue, allowedUnits);
}
/**
 * Checks if units are defined.
 *
 * @param  units List of units.
 * @return Whether the list actually contains any units.
 */

function hasUnits(units) {
  // Although the `isArray` check shouldn't be necessary (given the signature of
  // this typed function), it's better to stay on the side of caution, since
  // this function may be called from un-typed environments.
  return Array.isArray(units) && !!units.length;
}
/**
 * Parses a quantity and unit from a raw string value, given a list of allowed
 * units and otherwise falling back to the default unit.
 *
 * @param  rawValue     The raw value as a string (may or may not contain the unit)
 * @param  allowedUnits Units to derive from.
 * @return The extracted quantity and unit. The quantity can be `undefined` in case the raw value
 * could not be parsed to a number correctly. The unit can be `undefined` in case the unit parsed
 * from the raw value could not be matched against the list of allowed units.
 */

function parseQuantityAndUnitFromRawValue(rawValue) {
  var _trimmedValue, _unitMatch$;

  let allowedUnits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALL_CSS_UNITS;
  let trimmedValue;
  let quantityToReturn;

  if (typeof rawValue !== 'undefined' || rawValue === null) {
    trimmedValue = `${rawValue}`.trim();
    const parsedQuantity = parseFloat(trimmedValue);
    quantityToReturn = !isFinite(parsedQuantity) ? undefined : parsedQuantity;
  }

  const unitMatch = (_trimmedValue = trimmedValue) === null || _trimmedValue === void 0 ? void 0 : _trimmedValue.match(/[\d.\-\+]*\s*(.*)/);
  const matchedUnit = unitMatch === null || unitMatch === void 0 ? void 0 : (_unitMatch$ = unitMatch[1]) === null || _unitMatch$ === void 0 ? void 0 : _unitMatch$.toLowerCase();
  let unitToReturn;

  if (hasUnits(allowedUnits)) {
    const match = allowedUnits.find(item => item.value === matchedUnit);
    unitToReturn = match === null || match === void 0 ? void 0 : match.value;
  } else {
    unitToReturn = DEFAULT_UNIT.value;
  }

  return [quantityToReturn, unitToReturn];
}
/**
 * Parses quantity and unit from a raw value. Validates parsed value, using fallback
 * value if invalid.
 *
 * @param  rawValue         The next value.
 * @param  allowedUnits     Units to derive from.
 * @param  fallbackQuantity The fallback quantity, used in case it's not possible to parse a valid quantity from the raw value.
 * @param  fallbackUnit     The fallback unit, used in case it's not possible to parse a valid unit from the raw value.
 * @return The extracted quantity and unit. The quantity can be `undefined` in case the raw value
 * could not be parsed to a number correctly, and the `fallbackQuantity` was also `undefined`. The
 * unit can be `undefined` only if the unit parsed from the raw value could not be matched against
 * the list of allowed units, the `fallbackQuantity` is also `undefined` and the list of
 * `allowedUnits` is passed empty.
 */

function getValidParsedQuantityAndUnit(rawValue, allowedUnits, fallbackQuantity, fallbackUnit) {
  const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(rawValue, allowedUnits); // The parsed value from `parseQuantityAndUnitFromRawValue` should now be
  // either a real number or undefined. If undefined, use the fallback value.

  const quantityToReturn = parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : fallbackQuantity; // If no unit is parsed from the raw value, or if the fallback unit is not
  // defined, use the first value from the list of allowed units as fallback.

  let unitToReturn = parsedUnit || fallbackUnit;

  if (!unitToReturn && hasUnits(allowedUnits)) {
    unitToReturn = allowedUnits[0].value;
  }

  return [quantityToReturn, unitToReturn];
}
/**
 * Takes a unit value and finds the matching accessibility label for the
 * unit abbreviation.
 *
 * @param  unit Unit value (example: `px`)
 * @return a11y label for the unit abbreviation
 */

function getAccessibleLabelForUnit(unit) {
  const match = ALL_CSS_UNITS.find(item => item.value === unit);
  return match !== null && match !== void 0 && match.a11yLabel ? match === null || match === void 0 ? void 0 : match.a11yLabel : match === null || match === void 0 ? void 0 : match.value;
}
/**
 * Filters available units based on values defined a list of allowed unit values.
 *
 * @param  allowedUnitValues Collection of allowed unit value strings.
 * @param  availableUnits    Collection of available unit objects.
 * @return Filtered units.
 */

function filterUnitsWithSettings() {
  let allowedUnitValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let availableUnits = arguments.length > 1 ? arguments[1] : undefined;
  // Although the `isArray` check shouldn't be necessary (given the signature of
  // this typed function), it's better to stay on the side of caution, since
  // this function may be called from un-typed environments.
  return Array.isArray(availableUnits) ? availableUnits.filter(unit => allowedUnitValues.includes(unit.value)) : [];
}
/**
 * Custom hook to retrieve and consolidate units setting from add_theme_support().
 * TODO: ideally this hook shouldn't be needed
 * https://github.com/WordPress/gutenberg/pull/31822#discussion_r633280823
 *
 * @param  args                An object containing units, settingPath & defaultUnits.
 * @param  args.units          Collection of all potentially available units.
 * @param  args.availableUnits Collection of unit value strings for filtering available units.
 * @param  args.defaultValues  Collection of default values for defined units. Example: `{ px: 350, em: 15 }`.
 *
 * @return Filtered list of units, with their default values updated following the `defaultValues`
 * argument's property.
 */

const useCustomUnits = _ref => {
  let {
    units = ALL_CSS_UNITS,
    availableUnits = [],
    defaultValues
  } = _ref;
  const customUnitsToReturn = filterUnitsWithSettings(availableUnits, units);

  if (defaultValues) {
    customUnitsToReturn.forEach((unit, i) => {
      if (defaultValues[unit.value]) {
        const [parsedDefaultValue] = parseQuantityAndUnitFromRawValue(defaultValues[unit.value]);
        customUnitsToReturn[i].default = parsedDefaultValue;
      }
    });
  }

  return customUnitsToReturn;
};
/**
 * Get available units with the unit for the currently selected value
 * prepended if it is not available in the list of units.
 *
 * This is useful to ensure that the current value's unit is always
 * accurately displayed in the UI, even if the intention is to hide
 * the availability of that unit.
 *
 * @param  rawValue   Selected value to parse.
 * @param  legacyUnit Legacy unit value, if rawValue needs it appended.
 * @param  units      List of available units.
 *
 * @return A collection of units containing the unit for the current value.
 */

function getUnitsWithCurrentUnit(rawValue, legacyUnit) {
  let units = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALL_CSS_UNITS;
  const unitsToReturn = Array.isArray(units) ? [...units] : [];
  const [, currentUnit] = getParsedQuantityAndUnit(rawValue, legacyUnit, ALL_CSS_UNITS);

  if (currentUnit && !unitsToReturn.some(unit => unit.value === currentUnit)) {
    if (allUnits[currentUnit]) {
      unitsToReturn.unshift(allUnits[currentUnit]);
    }
  }

  return unitsToReturn;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/flex-block/hook.js
/**
 * Internal dependencies
 */


function useFlexBlock(props) {
  const otherProps = useContextSystem(props, 'FlexBlock');
  const flexItemProps = useFlexItem({
    isBlock: true,
    ...otherProps
  });
  return flexItemProps;
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/flex/flex-block/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedFlexBlock(props, forwardedRef) {
  const flexBlockProps = useFlexBlock(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, flexBlockProps, {
    ref: forwardedRef
  }));
}
/**
 * `FlexBlock` is a primitive layout component that adaptively resizes content
 * within layout containers like `Flex`.
 *
 * ```jsx
 * import { Flex, FlexBlock } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <Flex>
 *       <FlexBlock>...</FlexBlock>
 *     </Flex>
 *   );
 * }
 * ```
 */


const FlexBlock = contextConnect(UnconnectedFlexBlock, 'FlexBlock');
/* harmony default export */ const flex_block_component = (FlexBlock);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@use-gesture+react@10.3.0_react@17.0.2/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js + 3 modules
var use_gesture_react_esm = __webpack_require__("../../node_modules/.pnpm/@use-gesture+react@10.3.0_react@17.0.2/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/reducer/actions.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */
const CHANGE = 'CHANGE';
const COMMIT = 'COMMIT';
const CONTROL = 'CONTROL';
const DRAG_END = 'DRAG_END';
const DRAG_START = 'DRAG_START';
const DRAG = 'DRAG';
const INVALIDATE = 'INVALIDATE';
const PRESS_DOWN = 'PRESS_DOWN';
const PRESS_ENTER = 'PRESS_ENTER';
const PRESS_UP = 'PRESS_UP';
const RESET = 'RESET';
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/config-values.js
/**
 * Internal dependencies
 */


const CONTROL_HEIGHT = '36px';
const CONTROL_PADDING_X = '12px';
const CONTROL_PROPS = {
  controlSurfaceColor: COLORS.white,
  controlTextActiveColor: COLORS.ui.theme,
  controlPaddingX: CONTROL_PADDING_X,
  controlPaddingXLarge: `calc(${CONTROL_PADDING_X} * 1.3334)`,
  controlPaddingXSmall: `calc(${CONTROL_PADDING_X} / 1.3334)`,
  controlBackgroundColor: COLORS.white,
  controlBorderRadius: '2px',
  controlBorderColor: COLORS.gray[700],
  controlBoxShadow: 'transparent',
  controlBorderColorHover: COLORS.gray[700],
  controlBoxShadowFocus: `0 0 0 0.5px ${COLORS.ui.theme}`,
  controlDestructiveBorderColor: COLORS.alert.red,
  controlHeight: CONTROL_HEIGHT,
  controlHeightXSmall: `calc( ${CONTROL_HEIGHT} * 0.6 )`,
  controlHeightSmall: `calc( ${CONTROL_HEIGHT} * 0.8 )`,
  controlHeightLarge: `calc( ${CONTROL_HEIGHT} * 1.2 )`,
  controlHeightXLarge: `calc( ${CONTROL_HEIGHT} * 1.4 )`
};
const TOGGLE_GROUP_CONTROL_PROPS = {
  toggleGroupControlBackgroundColor: CONTROL_PROPS.controlBackgroundColor,
  toggleGroupControlBorderColor: COLORS.ui.border,
  toggleGroupControlBackdropBackgroundColor: CONTROL_PROPS.controlSurfaceColor,
  toggleGroupControlBackdropBorderColor: COLORS.ui.border,
  toggleGroupControlBackdropBoxShadow: 'transparent',
  toggleGroupControlButtonColorActive: CONTROL_PROPS.controlBackgroundColor
}; // Using Object.assign to avoid creating circular references when emitting
// TypeScript type declarations.

/* harmony default export */ const config_values = (Object.assign({}, CONTROL_PROPS, TOGGLE_GROUP_CONTROL_PROPS, {
  colorDivider: 'rgba(0, 0, 0, 0.1)',
  colorScrollbarThumb: 'rgba(0, 0, 0, 0.2)',
  colorScrollbarThumbHover: 'rgba(0, 0, 0, 0.5)',
  colorScrollbarTrack: 'rgba(0, 0, 0, 0.04)',
  elevationIntensity: 1,
  radiusBlockUi: '2px',
  borderWidth: '1px',
  borderWidthFocus: '1.5px',
  borderWidthTab: '4px',
  spinnerSize: 16,
  fontSize: '13px',
  fontSizeH1: 'calc(2.44 * 13px)',
  fontSizeH2: 'calc(1.95 * 13px)',
  fontSizeH3: 'calc(1.56 * 13px)',
  fontSizeH4: 'calc(1.25 * 13px)',
  fontSizeH5: '13px',
  fontSizeH6: 'calc(0.8 * 13px)',
  fontSizeInputMobile: '16px',
  fontSizeMobile: '15px',
  fontSizeSmall: 'calc(0.92 * 13px)',
  fontSizeXSmall: 'calc(0.75 * 13px)',
  fontLineHeightBase: '1.2',
  fontWeight: 'normal',
  fontWeightHeading: '600',
  gridBase: '4px',
  cardBorderRadius: '2px',
  cardPaddingXSmall: `${space(2)}`,
  cardPaddingSmall: `${space(4)}`,
  cardPaddingMedium: `${space(4)} ${space(6)}`,
  cardPaddingLarge: `${space(6)} ${space(8)}`,
  surfaceBackgroundColor: COLORS.white,
  surfaceBackgroundSubtleColor: '#F3F3F3',
  surfaceBackgroundTintColor: '#F5F5F5',
  surfaceBorderColor: 'rgba(0, 0, 0, 0.1)',
  surfaceBorderBoldColor: 'rgba(0, 0, 0, 0.15)',
  surfaceBorderSubtleColor: 'rgba(0, 0, 0, 0.05)',
  surfaceBackgroundTertiaryColor: COLORS.white,
  surfaceColor: COLORS.white,
  transitionDuration: '200ms',
  transitionDurationFast: '160ms',
  transitionDurationFaster: '120ms',
  transitionDurationFastest: '100ms',
  transitionTimingFunction: 'cubic-bezier(0.08, 0.52, 0.52, 1)',
  transitionTimingFunctionControl: 'cubic-bezier(0.12, 0.8, 0.32, 1)'
}));
//# sourceMappingURL=config-values.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/truncate/styles.js
function styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

const Truncate =  true ? {
  name: "hdknak",
  styles: "display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
} : 0;
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/values.js
/* eslint-disable jsdoc/valid-types */

/**
 * Determines if a value is null or undefined.
 *
 * @template T
 *
 * @param {T | null | undefined} value The value to check.
 * @return {value is T} Whether value is not null or undefined.
 */
function isValueDefined(value) {
  return value !== undefined && value !== null;
}
/* eslint-enable jsdoc/valid-types */

/* eslint-disable jsdoc/valid-types */

/**
 * Determines if a value is empty, null, or undefined.
 *
 * @template T
 *
 * @param {T | "" | null | undefined} value The value to check.
 * @return {value is T} Whether value is empty.
 */

function isValueEmpty(value) {
  const isEmptyString = value === '';
  return !isValueDefined(value) || isEmptyString;
}
/* eslint-enable jsdoc/valid-types */

/**
 * Get the first defined/non-null value from an array.
 *
 * @template T
 *
 * @param {Array<T | null | undefined>} values        Values to derive from.
 * @param {T}                           fallbackValue Fallback value if there are no defined values.
 * @return {T} A defined value or the fallback value.
 */

function getDefinedValue() {
  var _values$find;

  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let fallbackValue = arguments.length > 1 ? arguments[1] : undefined;
  return (_values$find = values.find(isValueDefined)) !== null && _values$find !== void 0 ? _values$find : fallbackValue;
}
/**
 * @param {string} [locale]
 * @return {[RegExp, RegExp]} The delimiter and decimal regexp
 */

const getDelimiterAndDecimalRegex = locale => {
  const formatted = Intl.NumberFormat(locale).format(1000.1);
  const delimiter = formatted[1];
  const decimal = formatted[formatted.length - 2];
  return [new RegExp(`\\${delimiter}`, 'g'), new RegExp(`\\${decimal}`, 'g')];
}; // https://en.wikipedia.org/wiki/Decimal_separator#Current_standards


const INTERNATIONAL_THOUSANDS_DELIMITER = / /g;
const ARABIC_NUMERAL_LOCALES = (/* unused pure expression or super */ null && (['ar', 'fa', 'ur', 'ckb', 'ps']));
const EASTERN_ARABIC_NUMBERS = /([۰-۹]|[٠-٩])/g;
/**
 * Checks to see if a value is a numeric value (`number` or `string`).
 *
 * Intentionally ignores whether the thousands delimiters are only
 * in the thousands marks.
 *
 * @param {any}    value
 * @param {string} [locale]
 * @return {boolean} Whether value is numeric.
 */

function isValueNumeric(value) {
  let locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.navigator.language;

  if (ARABIC_NUMERAL_LOCALES.some(l => locale.startsWith(l))) {
    locale = 'en-GB';

    if (EASTERN_ARABIC_NUMBERS.test(value)) {
      value = value.replace(/[٠-٩]/g, (
      /** @type {string} */
      d) => '٠١٢٣٤٥٦٧٨٩'.indexOf(d)).replace(/[۰-۹]/g, (
      /** @type {string} */
      d) => '۰۱۲۳۴۵۶۷۸۹'.indexOf(d)).replace(/٬/g, ',').replace(/٫/g, '.');
    }
  }

  const [delimiterRegexp, decimalRegexp] = getDelimiterAndDecimalRegex(locale);
  const valueToCheck = typeof value === 'string' ? value.replace(delimiterRegexp, '').replace(decimalRegexp, '.').replace(INTERNATIONAL_THOUSANDS_DELIMITER, '') : value;
  return !isNaN(parseFloat(valueToCheck)) && isFinite(valueToCheck);
}
//# sourceMappingURL=values.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/truncate/utils.js
/**
 * Internal dependencies
 */

const TRUNCATE_ELLIPSIS = '…';
const TRUNCATE_TYPE = {
  auto: 'auto',
  head: 'head',
  middle: 'middle',
  tail: 'tail',
  none: 'none'
};
const TRUNCATE_DEFAULT_PROPS = {
  ellipsis: TRUNCATE_ELLIPSIS,
  ellipsizeMode: TRUNCATE_TYPE.auto,
  limit: 0,
  numberOfLines: 0
}; // Source
// https://github.com/kahwee/truncate-middle

function truncateMiddle(word, headLength, tailLength, ellipsis) {
  if (typeof word !== 'string') {
    return '';
  }

  const wordLength = word.length; // Setting default values
  // eslint-disable-next-line no-bitwise

  const frontLength = ~~headLength; // Will cast to integer
  // eslint-disable-next-line no-bitwise

  const backLength = ~~tailLength;
  /* istanbul ignore next */

  const truncateStr = isValueDefined(ellipsis) ? ellipsis : TRUNCATE_ELLIPSIS;

  if (frontLength === 0 && backLength === 0 || frontLength >= wordLength || backLength >= wordLength || frontLength + backLength >= wordLength) {
    return word;
  } else if (backLength === 0) {
    return word.slice(0, frontLength) + truncateStr;
  }

  return word.slice(0, frontLength) + truncateStr + word.slice(wordLength - backLength);
}
function truncateContent() {
  let words = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  let props = arguments.length > 1 ? arguments[1] : undefined;
  const mergedProps = { ...TRUNCATE_DEFAULT_PROPS,
    ...props
  };
  const {
    ellipsis,
    ellipsizeMode,
    limit
  } = mergedProps;

  if (ellipsizeMode === TRUNCATE_TYPE.none) {
    return words;
  }

  let truncateHead;
  let truncateTail;

  switch (ellipsizeMode) {
    case TRUNCATE_TYPE.head:
      truncateHead = 0;
      truncateTail = limit;
      break;

    case TRUNCATE_TYPE.middle:
      truncateHead = Math.floor(limit / 2);
      truncateTail = Math.floor(limit / 2);
      break;

    default:
      truncateHead = limit;
      truncateTail = 0;
  }

  const truncatedContent = ellipsizeMode !== TRUNCATE_TYPE.auto ? truncateMiddle(words, truncateHead, truncateTail, ellipsis) : words;
  return truncatedContent;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/truncate/hook.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function useTruncate(props) {
  const {
    className,
    children,
    ellipsis = TRUNCATE_ELLIPSIS,
    ellipsizeMode = TRUNCATE_TYPE.auto,
    limit = 0,
    numberOfLines = 0,
    ...otherProps
  } = useContextSystem(props, 'Truncate');
  const cx = useCx();
  const truncatedContent = truncateContent(typeof children === 'string' ? children : '', {
    ellipsis,
    ellipsizeMode,
    limit,
    numberOfLines
  });
  const shouldTruncate = ellipsizeMode === TRUNCATE_TYPE.auto;
  const classes = (0,react.useMemo)(() => {
    const truncateLines = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("-webkit-box-orient:vertical;-webkit-line-clamp:", numberOfLines, ";display:-webkit-box;overflow:hidden;" + ( true ? "" : 0),  true ? "" : 0);
    return cx(shouldTruncate && !numberOfLines && Truncate, shouldTruncate && !!numberOfLines && truncateLines, className);
  }, [className, cx, numberOfLines, shouldTruncate]);
  return { ...otherProps,
    className: classes,
    children: truncatedContent
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/utils/colors.js
/**
 * External dependencies
 */



/** @type {HTMLDivElement} */

let colorComputationNode;
(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
/**
 * @return {HTMLDivElement | undefined} The HTML element for color computation.
 */

function getColorComputationNode() {
  if (typeof document === 'undefined') return;

  if (!colorComputationNode) {
    // Create a temporary element for style computation.
    const el = document.createElement('div');
    el.setAttribute('data-g2-color-computation-node', ''); // Inject for window computed style.

    document.body.appendChild(el);
    colorComputationNode = el;
  }

  return colorComputationNode;
}
/**
 * @param {string | unknown} value
 *
 * @return {boolean} Whether the value is a valid color.
 */


function isColor(value) {
  if (typeof value !== 'string') return false;
  const test = (0,node_modules_colord/* colord */.Mj)(value);
  return test.isValid();
}
/**
 * Retrieves the computed background color. This is useful for getting the
 * value of a CSS variable color.
 *
 * @param {string | unknown} backgroundColor The background color to compute.
 *
 * @return {string} The computed background color.
 */


function _getComputedBackgroundColor(backgroundColor) {
  var _window;

  if (typeof backgroundColor !== 'string') return '';
  if (isColor(backgroundColor)) return backgroundColor;
  if (!backgroundColor.includes('var(')) return '';
  if (typeof document === 'undefined') return ''; // Attempts to gracefully handle CSS variables color values.

  const el = getColorComputationNode();
  if (!el) return '';
  el.style.background = backgroundColor; // Grab the style.

  const computedColor = (_window = window) === null || _window === void 0 ? void 0 : _window.getComputedStyle(el).background; // Reset.

  el.style.background = '';
  return computedColor || '';
}

const getComputedBackgroundColor = memize_default()(_getComputedBackgroundColor);
/**
 * Get the text shade optimized for readability, based on a background color.
 *
 * @param {string | unknown} backgroundColor The background color.
 *
 * @return {string} The optimized text color (black or white).
 */

function getOptimalTextColor(backgroundColor) {
  const background = getComputedBackgroundColor(backgroundColor);
  return (0,node_modules_colord/* colord */.Mj)(background).isLight() ? '#000000' : '#ffffff';
}
/**
 * Get the text shade optimized for readability, based on a background color.
 *
 * @param {string | unknown} backgroundColor The background color.
 *
 * @return {string} The optimized text shade (dark or light).
 */

function getOptimalTextShade(backgroundColor) {
  const result = getOptimalTextColor(backgroundColor);
  return result === '#000000' ? 'dark' : 'light';
}
//# sourceMappingURL=colors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text/styles.js
function text_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


const Text = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", COLORS.gray[900], ";line-height:", config_values.fontLineHeightBase, ";margin:0;" + ( true ? "" : 0),  true ? "" : 0);
const styles_block =  true ? {
  name: "4zleql",
  styles: "display:block"
} : 0;
const positive = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", COLORS.alert.green, ";" + ( true ? "" : 0),  true ? "" : 0);
const destructive = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", COLORS.alert.red, ";" + ( true ? "" : 0),  true ? "" : 0);
const muted = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", COLORS.gray[700], ";" + ( true ? "" : 0),  true ? "" : 0);
const highlighterText = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("mark{background:", COLORS.alert.yellow, ";border-radius:2px;box-shadow:0 0 0 1px rgba( 0, 0, 0, 0.05 ) inset,0 -1px 0 rgba( 0, 0, 0, 0.1 ) inset;}" + ( true ? "" : 0),  true ? "" : 0);
const upperCase =  true ? {
  name: "50zrmy",
  styles: "text-transform:uppercase"
} : 0;
//# sourceMappingURL=styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/highlight-words-core@1.2.2/node_modules/highlight-words-core/dist/index.js
var dist = __webpack_require__("../../node_modules/.pnpm/highlight-words-core@1.2.2/node_modules/highlight-words-core/dist/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text/utils.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Source:
 * https://github.com/bvaughn/react-highlight-words/blob/HEAD/src/Highlighter.js
 */

/* eslint-disable jsdoc/valid-types */

/**
 * @typedef Options
 * @property {string}                                                     [activeClassName='']      Classname for active highlighted areas.
 * @property {number}                                                     [activeIndex=-1]          The index of the active highlighted area.
 * @property {import('react').AllHTMLAttributes<HTMLDivElement>['style']} [activeStyle]             Styles to apply to the active highlighted area.
 * @property {boolean}                                                    [autoEscape]              Whether to automatically escape text.
 * @property {boolean}                                                    [caseSensitive=false]     Whether to highlight in a case-sensitive manner.
 * @property {string}                                                     children                  Children to highlight.
 * @property {import('highlight-words-core').FindAllArgs['findChunks']}   [findChunks]              Custom `findChunks` function to pass to `highlight-words-core`.
 * @property {string | Record<string, unknown>}                           [highlightClassName='']   Classname to apply to highlighted text or a Record of classnames to apply to given text (which should be the key).
 * @property {import('react').AllHTMLAttributes<HTMLDivElement>['style']} [highlightStyle={}]       Styles to apply to highlighted text.
 * @property {keyof JSX.IntrinsicElements}                                [highlightTag='mark']     Tag to use for the highlighted text.
 * @property {import('highlight-words-core').FindAllArgs['sanitize']}     [sanitize]                Custom `santize` function to pass to `highlight-words-core`.
 * @property {string[]}                                                   [searchWords=[]]          Words to search for and highlight.
 * @property {string}                                                     [unhighlightClassName=''] Classname to apply to unhighlighted text.
 * @property {import('react').AllHTMLAttributes<HTMLDivElement>['style']} [unhighlightStyle]        Style to apply to unhighlighted text.
 */

/**
 * Maps props to lowercase names.
 *
 * @template {Record<string, unknown>} T
 * @param {T} object Props to map.
 * @return {{[K in keyof T as Lowercase<string & K>]: T[K]}} The mapped props.
 */

/* eslint-enable jsdoc/valid-types */

const lowercaseProps = object => {
  /** @type {any} */
  const mapped = {};

  for (const key in object) {
    mapped[key.toLowerCase()] = object[key];
  }

  return mapped;
};

const memoizedLowercaseProps = memize_default()(lowercaseProps);
/**
 *
 * @param {Options} options
 */

function createHighlighterText(_ref) {
  let {
    activeClassName = '',
    activeIndex = -1,
    activeStyle,
    autoEscape,
    caseSensitive = false,
    children,
    findChunks,
    highlightClassName = '',
    highlightStyle = {},
    highlightTag = 'mark',
    sanitize,
    searchWords = [],
    unhighlightClassName = '',
    unhighlightStyle
  } = _ref;
  if (!children) return null;
  if (typeof children !== 'string') return children;
  const textToHighlight = children;
  const chunks = (0,dist.findAll)({
    autoEscape,
    caseSensitive,
    findChunks,
    sanitize,
    searchWords,
    textToHighlight
  });
  const HighlightTag = highlightTag;
  let highlightIndex = -1;
  let highlightClassNames = '';
  let highlightStyles;
  const textContent = chunks.map((chunk, index) => {
    const text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);

    if (chunk.highlight) {
      highlightIndex++;
      let highlightClass;

      if (typeof highlightClassName === 'object') {
        if (!caseSensitive) {
          highlightClassName = memoizedLowercaseProps(highlightClassName);
          highlightClass = highlightClassName[text.toLowerCase()];
        } else {
          highlightClass = highlightClassName[text];
        }
      } else {
        highlightClass = highlightClassName;
      }

      const isActive = highlightIndex === +activeIndex;
      highlightClassNames = `${highlightClass} ${isActive ? activeClassName : ''}`;
      highlightStyles = isActive === true && activeStyle !== null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;
      /** @type {Record<string, any>} */

      const props = {
        children: text,
        className: highlightClassNames,
        key: index,
        style: highlightStyles
      }; // Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)
      // Only pass through the highlightIndex attribute for custom components.

      if (typeof HighlightTag !== 'string') {
        props.highlightIndex = highlightIndex;
      }

      return (0,react.createElement)(HighlightTag, props);
    }

    return (0,react.createElement)('span', {
      children: text,
      className: unhighlightClassName,
      key: index,
      style: unhighlightStyle
    });
  });
  return textContent;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/utils/font-size.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const BASE_FONT_SIZE = 13;
const PRESET_FONT_SIZES = {
  body: BASE_FONT_SIZE,
  caption: 10,
  footnote: 11,
  largeTitle: 28,
  subheadline: 12,
  title: 20
};
const HEADING_FONT_SIZES = [1, 2, 3, 4, 5, 6].flatMap(n => [n, n.toString()]);
function getFontSize() {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BASE_FONT_SIZE;

  if (size in PRESET_FONT_SIZES) {
    return getFontSize(PRESET_FONT_SIZES[size]);
  }

  if (typeof size !== 'number') {
    const parsed = parseFloat(size);
    if (Number.isNaN(parsed)) return size;
    size = parsed;
  }

  const ratio = `(${size} / ${BASE_FONT_SIZE})`;
  return `calc(${ratio} * ${config_values.fontSize})`;
}
function getHeadingFontSize() {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;

  if (!HEADING_FONT_SIZES.includes(size)) {
    return getFontSize(size);
  }

  const headingSize = `fontSizeH${size}`;
  return config_values[headingSize];
}
//# sourceMappingURL=font-size.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text/get-line-height.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


function getLineHeight(adjustLineHeightForInnerControls, lineHeight) {
  if (lineHeight) return lineHeight;
  if (!adjustLineHeightForInnerControls) return;
  let value = `calc(${config_values.controlHeight} + ${space(2)})`;

  switch (adjustLineHeightForInnerControls) {
    case 'large':
      value = `calc(${config_values.controlHeightLarge} + ${space(2)})`;
      break;

    case 'small':
      value = `calc(${config_values.controlHeightSmall} + ${space(2)})`;
      break;

    case 'xSmall':
      value = `calc(${config_values.controlHeightXSmall} + ${space(2)})`;
      break;

    default:
      break;
  }

  return value;
}
//# sourceMappingURL=get-line-height.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text/hook.js
function hook_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */










/**
 * @param {import('../ui/context').WordPressComponentProps<import('./types').Props, 'span'>} props
 */

var hook_ref =  true ? {
  name: "50zrmy",
  styles: "text-transform:uppercase"
} : 0;

function useText(props) {
  const {
    adjustLineHeightForInnerControls,
    align,
    children,
    className,
    color,
    ellipsizeMode,
    isDestructive = false,
    display,
    highlightEscape = false,
    highlightCaseSensitive = false,
    highlightWords,
    highlightSanitize,
    isBlock = false,
    letterSpacing,
    lineHeight: lineHeightProp,
    optimizeReadabilityFor,
    size,
    truncate = false,
    upperCase = false,
    variant,
    weight = config_values.fontWeight,
    ...otherProps
  } = useContextSystem(props, 'Text');
  /** @type {import('react').ReactNode} */

  let content = children;
  const isHighlighter = Array.isArray(highlightWords);
  const isCaption = size === 'caption';

  if (isHighlighter) {
    if (typeof children !== 'string') {
      throw new TypeError('`children` of `Text` must only be `string` types when `highlightWords` is defined');
    }

    content = createHighlighterText({
      autoEscape: highlightEscape,
      // Disable reason: We need to disable this otherwise it erases the cast
      // eslint-disable-next-line object-shorthand
      children:
      /** @type {string} */
      children,
      caseSensitive: highlightCaseSensitive,
      searchWords: highlightWords,
      sanitize: highlightSanitize
    });
  }

  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    const sx = {};
    const lineHeight = getLineHeight(adjustLineHeightForInnerControls, lineHeightProp);
    sx.Base = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      color,
      display,
      fontSize: getFontSize(size),

      /* eslint-disable jsdoc/valid-types */
      fontWeight:
      /** @type {import('react').CSSProperties['fontWeight']} */
      weight,

      /* eslint-enable jsdoc/valid-types */
      lineHeight,
      letterSpacing,
      textAlign: align
    },  true ? "" : 0,  true ? "" : 0);
    sx.upperCase = hook_ref;
    sx.optimalTextColor = null;

    if (optimizeReadabilityFor) {
      const isOptimalTextColorDark = getOptimalTextShade(optimizeReadabilityFor) === 'dark';
      sx.optimalTextColor = isOptimalTextColorDark ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
        color: COLORS.gray[900]
      },  true ? "" : 0,  true ? "" : 0) : /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
        color: COLORS.white
      },  true ? "" : 0,  true ? "" : 0);
    }

    return cx(Text, sx.Base, sx.optimalTextColor, isDestructive && destructive, !!isHighlighter && highlighterText, isBlock && styles_block, isCaption && muted, variant && text_styles_namespaceObject[variant], upperCase && sx.upperCase, className);
  }, [adjustLineHeightForInnerControls, align, className, color, cx, display, isBlock, isCaption, isDestructive, isHighlighter, letterSpacing, lineHeightProp, optimizeReadabilityFor, size, upperCase, variant, weight]);
  /** @type {undefined | 'auto' | 'none'} */

  let finalEllipsizeMode;

  if (truncate === true) {
    finalEllipsizeMode = 'auto';
  }

  if (truncate === false) {
    finalEllipsizeMode = 'none';
  }

  const finalComponentProps = { ...otherProps,
    className: classes,
    children,
    ellipsizeMode: ellipsizeMode || finalEllipsizeMode
  };
  const truncateProps = useTruncate(finalComponentProps);
  /**
   * Enhance child `<Link />` components to inherit font size.
   */

  if (!truncate && Array.isArray(children)) {
    content = react.Children.map(children, child => {
      if (typeof child !== 'object' || child === null || !('props' in child)) {
        return child;
      }

      const isLink = hasConnectNamespace(child, ['Link']);

      if (isLink) {
        return (0,react.cloneElement)(child, {
          size: child.props.size || 'inherit'
        });
      }

      return child;
    });
  }

  return { ...truncateProps,
    children: truncate ? truncateProps.children : content
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text/component.js



/**
 * Internal dependencies
 */



/**
 * @param {import('../ui/context').WordPressComponentProps<import('./types').Props, 'span'>} props
 * @param {import('react').ForwardedRef<any>}                                                forwardedRef
 */

function component_Text(props, forwardedRef) {
  const textProps = useText(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({
    as: "span"
  }, textProps, {
    ref: forwardedRef
  }));
}
/**
 * `Text` is a core component that renders text in the library, using the
 * library's typography system.
 *
 * `Text` can be used to render any text-content, like an HTML `p` or `span`.
 *
 * @example
 *
 * ```jsx
 * import { __experimentalText as Text } from `@wordpress/components`;
 *
 * function Example() {
 * 	return <Text>Code is Poetry</Text>;
 * }
 * ```
 */


const ConnectedText = contextConnect(component_Text, 'Text');
/* harmony default export */ const text_component = (ConnectedText);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js




function input_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */






var _ref6 =  true ? {
  name: "1739oy8",
  styles: "z-index:1"
} : 0;

const rootFocusedStyles = _ref7 => {
  let {
    isFocused
  } = _ref7;
  if (!isFocused) return '';
  return _ref6;
};

var _ref3 =  true ? {
  name: "2o6p8u",
  styles: "justify-content:space-between"
} : 0;

var _ref4 =  true ? {
  name: "14qk3ip",
  styles: "align-items:flex-start;flex-direction:column-reverse"
} : 0;

var _ref5 =  true ? {
  name: "hbng6e",
  styles: "align-items:flex-start;flex-direction:column"
} : 0;

const rootLabelPositionStyles = _ref8 => {
  let {
    labelPosition
  } = _ref8;

  switch (labelPosition) {
    case 'top':
      return _ref5;

    case 'bottom':
      return _ref4;

    case 'edge':
      return _ref3;

    default:
      return '';
  }
};

const Root = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "em5sgkm7"
} : 0)("position:relative;border-radius:2px;padding-top:0;", rootFocusedStyles, " ", rootLabelPositionStyles, ";" + ( true ? "" : 0));

const containerDisabledStyles = _ref9 => {
  let {
    disabled
  } = _ref9;
  const backgroundColor = disabled ? COLORS.ui.backgroundDisabled : COLORS.ui.background;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    backgroundColor
  },  true ? "" : 0,  true ? "" : 0);
}; // Normalizes the margins from the <Flex /> (components/ui/flex/) container.


var _ref2 =  true ? {
  name: "wyxldh",
  styles: "margin:0 !important"
} : 0;

const containerMarginStyles = _ref10 => {
  let {
    hideLabel
  } = _ref10;
  return hideLabel ? _ref2 : null;
};

var input_control_styles_ref =  true ? {
  name: "1d3w5wq",
  styles: "width:100%"
} : 0;

const containerWidthStyles = _ref11 => {
  let {
    __unstableInputWidth,
    labelPosition
  } = _ref11;
  if (!__unstableInputWidth) return input_control_styles_ref;
  if (labelPosition === 'side') return '';

  if (labelPosition === 'edge') {
    return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      flex: `0 0 ${__unstableInputWidth}`
    },  true ? "" : 0,  true ? "" : 0);
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    width: __unstableInputWidth
  },  true ? "" : 0,  true ? "" : 0);
};

const Container = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "em5sgkm6"
} : 0)("align-items:center;box-sizing:border-box;border-radius:inherit;display:flex;flex:1;position:relative;", containerDisabledStyles, " ", containerMarginStyles, " ", containerWidthStyles, ";" + ( true ? "" : 0));

const disabledStyles = _ref12 => {
  let {
    disabled
  } = _ref12;
  if (!disabled) return '';
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    color: COLORS.ui.textDisabled
  },  true ? "" : 0,  true ? "" : 0);
};

const fontSizeStyles = _ref13 => {
  let {
    inputSize: size
  } = _ref13;
  const sizes = {
    default: '13px',
    small: '11px',
    '__unstable-large': '13px'
  };
  const fontSize = sizes[size] || sizes.default;
  const fontSizeMobile = '16px';
  if (!fontSize) return '';
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("font-size:", fontSizeMobile, ";@media ( min-width: 600px ){font-size:", fontSize, ";}" + ( true ? "" : 0),  true ? "" : 0);
};

const getSizeConfig = _ref14 => {
  let {
    inputSize: size,
    __next36pxDefaultSize
  } = _ref14;
  // Paddings may be overridden by the custom paddings props.
  const sizes = {
    default: {
      height: 36,
      lineHeight: 1,
      minHeight: 36,
      paddingLeft: space(4),
      paddingRight: space(4)
    },
    small: {
      height: 24,
      lineHeight: 1,
      minHeight: 24,
      paddingLeft: space(2),
      paddingRight: space(2)
    },
    '__unstable-large': {
      height: 40,
      lineHeight: 1,
      minHeight: 40,
      paddingLeft: space(4),
      paddingRight: space(4)
    }
  };

  if (!__next36pxDefaultSize) {
    sizes.default = {
      height: 30,
      lineHeight: 1,
      minHeight: 30,
      paddingLeft: space(2),
      paddingRight: space(2)
    };
  }

  return sizes[size] || sizes.default;
};

const sizeStyles = props => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(getSizeConfig(props),  true ? "" : 0,  true ? "" : 0);
};

const customPaddings = _ref15 => {
  let {
    paddingInlineStart,
    paddingInlineEnd
  } = _ref15;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    paddingInlineStart,
    paddingInlineEnd
  },  true ? "" : 0,  true ? "" : 0);
};

const dragStyles = _ref16 => {
  let {
    isDragging,
    dragCursor
  } = _ref16;
  let defaultArrowStyles;
  let activeDragCursorStyles;

  if (isDragging) {
    defaultArrowStyles = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("cursor:", dragCursor, ";user-select:none;&::-webkit-outer-spin-button,&::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}" + ( true ? "" : 0),  true ? "" : 0);
  }

  if (isDragging && dragCursor) {
    activeDragCursorStyles = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("&:active{cursor:", dragCursor, ";}" + ( true ? "" : 0),  true ? "" : 0);
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(defaultArrowStyles, " ", activeDragCursorStyles, ";" + ( true ? "" : 0),  true ? "" : 0);
}; // TODO: Resolve need to use &&& to increase specificity
// https://github.com/WordPress/gutenberg/issues/18483


const Input = (0,emotion_styled_base_browser_esm/* default */.A)("input",  true ? {
  target: "em5sgkm5"
} : 0)("&&&{background-color:transparent;box-sizing:border-box;border:none;box-shadow:none!important;color:", COLORS.gray[900], ";display:block;font-family:inherit;margin:0;outline:none;width:100%;", dragStyles, " ", disabledStyles, " ", fontSizeStyles, " ", sizeStyles, " ", customPaddings, " &::-webkit-input-placeholder{line-height:normal;}}" + ( true ? "" : 0));

const labelMargin = _ref17 => {
  let {
    labelPosition
  } = _ref17;
  let marginBottom = 8;

  if (labelPosition === 'edge' || labelPosition === 'side') {
    marginBottom = 0;
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    marginTop: 0,
    marginRight: 0,
    marginBottom,
    marginLeft: 0
  },  true ? "" : 0,  true ? "" : 0);
};

const BaseLabel = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(text_component,  true ? {
  target: "em5sgkm4"
} : 0)("&&&{", baseLabelTypography, ";box-sizing:border-box;display:block;padding-top:0;padding-bottom:0;max-width:100%;z-index:1;", labelMargin, " overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}" + ( true ? "" : 0));

const Label = props => (0,react.createElement)(BaseLabel, (0,helpers_esm_extends/* default */.A)({}, props, {
  as: "label"
}));
const LabelWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_item_component,  true ? {
  target: "em5sgkm3"
} : 0)( true ? {
  name: "1b6uupn",
  styles: "max-width:calc( 100% - 10px )"
} : 0);

const backdropFocusedStyles = _ref18 => {
  let {
    disabled,
    isFocused
  } = _ref18;
  let borderColor = isFocused ? COLORS.ui.borderFocus : COLORS.ui.border;
  let boxShadow;

  if (isFocused) {
    boxShadow = `0 0 0 1px ${COLORS.ui.borderFocus} inset`;
  }

  if (disabled) {
    borderColor = COLORS.ui.borderDisabled;
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    boxShadow,
    borderColor,
    borderStyle: 'solid',
    borderWidth: 1
  },  true ? "" : 0,  true ? "" : 0);
};

const BackdropUI = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "em5sgkm2"
} : 0)("&&&{box-sizing:border-box;border-radius:inherit;bottom:0;left:0;margin:0;padding:0;pointer-events:none;position:absolute;right:0;top:0;", backdropFocusedStyles, " ", rtl({
  paddingLeft: 2
}), ";}" + ( true ? "" : 0));
const Prefix = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "em5sgkm1"
} : 0)( true ? {
  name: "pvvbxf",
  styles: "box-sizing:border-box;display:block"
} : 0);
const Suffix = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "em5sgkm0"
} : 0)( true ? {
  name: "jgf79h",
  styles: "align-items:center;align-self:stretch;box-sizing:border-box;display:flex"
} : 0);
//# sourceMappingURL=input-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/backdrop.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function Backdrop(_ref) {
  let {
    disabled = false,
    isFocused = false
  } = _ref;
  return (0,react.createElement)(BackdropUI, {
    "aria-hidden": "true",
    className: "components-input-control__backdrop",
    disabled: disabled,
    isFocused: isFocused
  });
}

const MemoizedBackdrop = (0,react.memo)(Backdrop);
/* harmony default export */ const backdrop = (MemoizedBackdrop);
//# sourceMappingURL=backdrop.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/label.js



/**
 * Internal dependencies
 */


function label_Label(_ref) {
  let {
    children,
    hideLabelFromVision,
    htmlFor,
    ...props
  } = _ref;
  if (!children) return null;

  if (hideLabelFromVision) {
    return (0,react.createElement)(visually_hidden_component, {
      as: "label",
      htmlFor: htmlFor
    }, children);
  }

  return (0,react.createElement)(Label, (0,helpers_esm_extends/* default */.A)({
    htmlFor: htmlFor
  }, props), children);
}
//# sourceMappingURL=label.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/input-base.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






function useUniqueId(idProp) {
  const instanceId = (0,use_instance_id/* default */.A)(InputBase);
  const id = `input-base-control-${instanceId}`;
  return idProp || id;
} // Adapter to map props for the new ui/flex compopnent.


function getUIFlexProps(labelPosition) {
  const props = {};

  switch (labelPosition) {
    case 'top':
      props.direction = 'column';
      props.gap = 0;
      break;

    case 'bottom':
      props.direction = 'column-reverse';
      props.gap = 0;
      break;

    case 'edge':
      props.justify = 'space-between';
      break;
  }

  return props;
}

function InputBase(_ref, ref) {
  let {
    __next36pxDefaultSize,
    __unstableInputWidth,
    children,
    className,
    disabled = false,
    hideLabelFromVision = false,
    labelPosition,
    id: idProp,
    isFocused = false,
    label,
    prefix,
    size = 'default',
    suffix,
    ...props
  } = _ref;
  const id = useUniqueId(idProp);
  const hideLabel = hideLabelFromVision || !label;
  const {
    paddingLeft,
    paddingRight
  } = getSizeConfig({
    inputSize: size,
    __next36pxDefaultSize
  });
  const prefixSuffixContextValue = (0,react.useMemo)(() => {
    return {
      InputControlPrefixWrapper: {
        paddingLeft
      },
      InputControlSuffixWrapper: {
        paddingRight
      }
    };
  }, [paddingLeft, paddingRight]);
  return (// @ts-expect-error The `direction` prop from Flex (FlexDirection) conflicts with legacy SVGAttributes `direction` (string) that come from React intrinsic prop definitions.
    (0,react.createElement)(Root, (0,helpers_esm_extends/* default */.A)({}, props, getUIFlexProps(labelPosition), {
      className: className,
      isFocused: isFocused,
      labelPosition: labelPosition,
      ref: ref
    }), (0,react.createElement)(LabelWrapper, null, (0,react.createElement)(label_Label, {
      className: "components-input-control__label",
      hideLabelFromVision: hideLabelFromVision,
      labelPosition: labelPosition,
      htmlFor: id
    }, label)), (0,react.createElement)(Container, {
      __unstableInputWidth: __unstableInputWidth,
      className: "components-input-control__container",
      disabled: disabled,
      hideLabel: hideLabel,
      labelPosition: labelPosition
    }, (0,react.createElement)(ContextSystemProvider, {
      value: prefixSuffixContextValue
    }, prefix && (0,react.createElement)(Prefix, {
      className: "components-input-control__prefix"
    }, prefix), children, suffix && (0,react.createElement)(Suffix, {
      className: "components-input-control__suffix"
    }, suffix)), (0,react.createElement)(backdrop, {
      disabled: disabled,
      isFocused: isFocused
    })))
  );
}
/* harmony default export */ const input_base = ((0,react.forwardRef)(InputBase));
//# sourceMappingURL=input-base.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Gets a CSS cursor value based on a drag direction.
 *
 * @param  dragDirection The drag direction.
 * @return  The CSS cursor value.
 */
function getDragCursor(dragDirection) {
  let dragCursor = 'ns-resize';

  switch (dragDirection) {
    case 'n':
    case 's':
      dragCursor = 'ns-resize';
      break;

    case 'e':
    case 'w':
      dragCursor = 'ew-resize';
      break;
  }

  return dragCursor;
}
/**
 * Custom hook that renders a drag cursor when dragging.
 *
 * @param {boolean} isDragging    The dragging state.
 * @param {string}  dragDirection The drag direction.
 *
 * @return {string} The CSS cursor value.
 */

function useDragCursor(isDragging, dragDirection) {
  const dragCursor = getDragCursor(dragDirection);
  (0,react.useEffect)(() => {
    if (isDragging) {
      document.documentElement.style.cursor = dragCursor;
    } else {
      // @ts-expect-error
      document.documentElement.style.cursor = null;
    }
  }, [isDragging, dragCursor]);
  return dragCursor;
}
function useDraft(props) {
  const refPreviousValue = (0,react.useRef)(props.value);
  const [draft, setDraft] = (0,react.useState)({});
  const value = draft.value !== undefined ? draft.value : props.value; // Determines when to discard the draft value to restore controlled status.
  // To do so, it tracks the previous value and marks the draft value as stale
  // after each render.

  (0,react.useLayoutEffect)(() => {
    const {
      current: previousValue
    } = refPreviousValue;
    refPreviousValue.current = props.value;
    if (draft.value !== undefined && !draft.isStale) setDraft({ ...draft,
      isStale: true
    });else if (draft.isStale && props.value !== previousValue) setDraft({});
  }, [props.value, draft]);

  const onChange = (nextValue, extra) => {
    // Mutates the draft value to avoid an extra effect run.
    setDraft(current => Object.assign(current, {
      value: nextValue,
      isStale: false
    }));
    props.onChange(nextValue, extra);
  };

  const onBlur = event => {
    var _props$onBlur;

    setDraft({});
    (_props$onBlur = props.onBlur) === null || _props$onBlur === void 0 ? void 0 : _props$onBlur.call(props, event);
  };

  return {
    value,
    onBlur,
    onChange
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/reducer/state.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */
const initialStateReducer = state => state;
const initialInputControlState = {
  error: null,
  initialValue: '',
  isDirty: false,
  isDragEnabled: false,
  isDragging: false,
  isPressEnterToChange: false,
  value: ''
};
//# sourceMappingURL=state.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/reducer/reducer.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Prepares initialState for the reducer.
 *
 * @param  initialState The initial state.
 * @return Prepared initialState for the reducer
 */
function mergeInitialState() {
  let initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialInputControlState;
  const {
    value
  } = initialState;
  return { ...initialInputControlState,
    ...initialState,
    initialValue: value
  };
}
/**
 * Creates the base reducer which may be coupled to a specializing reducer.
 * As its final step, for all actions other than CONTROL, the base reducer
 * passes the state and action on through the specializing reducer. The
 * exception for CONTROL actions is because they represent controlled updates
 * from props and no case has yet presented for their specialization.
 *
 * @param  composedStateReducers A reducer to specialize state changes.
 * @return The reducer.
 */


function inputControlStateReducer(composedStateReducers) {
  return (state, action) => {
    const nextState = { ...state
    };

    switch (action.type) {
      /*
       * Controlled updates
       */
      case CONTROL:
        nextState.value = action.payload.value;
        nextState.isDirty = false;
        nextState._event = undefined; // Returns immediately to avoid invoking additional reducers.

        return nextState;

      /**
       * Keyboard events
       */

      case PRESS_UP:
        nextState.isDirty = false;
        break;

      case PRESS_DOWN:
        nextState.isDirty = false;
        break;

      /**
       * Drag events
       */

      case DRAG_START:
        nextState.isDragging = true;
        break;

      case DRAG_END:
        nextState.isDragging = false;
        break;

      /**
       * Input events
       */

      case CHANGE:
        nextState.error = null;
        nextState.value = action.payload.value;

        if (state.isPressEnterToChange) {
          nextState.isDirty = true;
        }

        break;

      case COMMIT:
        nextState.value = action.payload.value;
        nextState.isDirty = false;
        break;

      case RESET:
        nextState.error = null;
        nextState.isDirty = false;
        nextState.value = action.payload.value || state.initialValue;
        break;

      /**
       * Validation
       */

      case INVALIDATE:
        nextState.error = action.payload.error;
        break;
    }

    nextState._event = action.payload.event;
    /**
     * Send the nextState + action to the composedReducers via
     * this "bridge" mechanism. This allows external stateReducers
     * to hook into actions, and modify state if needed.
     */

    return composedStateReducers(nextState, action);
  };
}
/**
 * A custom hook that connects and external stateReducer with an internal
 * reducer. This hook manages the internal state of InputControl.
 * However, by connecting an external stateReducer function, other
 * components can react to actions as well as modify state before it is
 * applied.
 *
 * This technique uses the "stateReducer" design pattern:
 * https://kentcdodds.com/blog/the-state-reducer-pattern/
 *
 * @param  stateReducer    An external state reducer.
 * @param  initialState    The initial state for the reducer.
 * @param  onChangeHandler A handler for the onChange event.
 * @return State, dispatch, and a collection of actions.
 */


function useInputControlStateReducer() {
  let stateReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialStateReducer;
  let initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : initialInputControlState;
  let onChangeHandler = arguments.length > 2 ? arguments[2] : undefined;
  const [state, dispatch] = (0,react.useReducer)(inputControlStateReducer(stateReducer), mergeInitialState(initialState));

  const createChangeEvent = type => (nextValue, event) => {
    dispatch({
      type,
      payload: {
        value: nextValue,
        event
      }
    });
  };

  const createKeyEvent = type => event => {
    dispatch({
      type,
      payload: {
        event
      }
    });
  };

  const createDragEvent = type => payload => {
    dispatch({
      type,
      payload
    });
  };
  /**
   * Actions for the reducer
   */


  const change = createChangeEvent(CHANGE);

  const invalidate = (error, event) => dispatch({
    type: INVALIDATE,
    payload: {
      error,
      event
    }
  });

  const reset = createChangeEvent(RESET);
  const commit = createChangeEvent(COMMIT);
  const dragStart = createDragEvent(DRAG_START);
  const drag = createDragEvent(DRAG);
  const dragEnd = createDragEvent(DRAG_END);
  const pressUp = createKeyEvent(PRESS_UP);
  const pressDown = createKeyEvent(PRESS_DOWN);
  const pressEnter = createKeyEvent(PRESS_ENTER);
  const currentState = (0,react.useRef)(state);
  const refProps = (0,react.useRef)({
    value: initialState.value,
    onChangeHandler
  }); // Freshens refs to props and state so that subsequent effects have access
  // to their latest values without their changes causing effect runs.

  (0,react.useLayoutEffect)(() => {
    currentState.current = state;
    refProps.current = {
      value: initialState.value,
      onChangeHandler
    };
  }); // Propagates the latest state through onChange.

  (0,react.useLayoutEffect)(() => {
    if (currentState.current._event !== undefined && state.value !== refProps.current.value && !state.isDirty) {
      var _state$value;

      refProps.current.onChangeHandler((_state$value = state.value) !== null && _state$value !== void 0 ? _state$value : '', {
        event: currentState.current._event
      });
    }
  }, [state.value, state.isDirty]); // Updates the state from props.

  (0,react.useLayoutEffect)(() => {
    if (initialState.value !== currentState.current.value && !currentState.current.isDirty) {
      var _initialState$value;

      dispatch({
        type: CONTROL,
        payload: {
          value: (_initialState$value = initialState.value) !== null && _initialState$value !== void 0 ? _initialState$value : ''
        }
      });
    }
  }, [initialState.value]);
  return {
    change,
    commit,
    dispatch,
    drag,
    dragEnd,
    dragStart,
    invalidate,
    pressDown,
    pressEnter,
    pressUp,
    reset,
    state
  };
}
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/input-field.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





const input_field_noop = () => {};

function InputField(_ref, ref) {
  let {
    disabled = false,
    dragDirection = 'n',
    dragThreshold = 10,
    id,
    isDragEnabled = false,
    isFocused,
    isPressEnterToChange = false,
    onBlur = input_field_noop,
    onChange = input_field_noop,
    onDrag = input_field_noop,
    onDragEnd = input_field_noop,
    onDragStart = input_field_noop,
    onFocus = input_field_noop,
    onKeyDown = input_field_noop,
    onValidate = input_field_noop,
    size = 'default',
    setIsFocused,
    stateReducer = state => state,
    value: valueProp,
    type,
    ...props
  } = _ref;
  const {
    // State.
    state,
    // Actions.
    change,
    commit,
    drag,
    dragEnd,
    dragStart,
    invalidate,
    pressDown,
    pressEnter,
    pressUp,
    reset
  } = useInputControlStateReducer(stateReducer, {
    isDragEnabled,
    value: valueProp,
    isPressEnterToChange
  }, onChange);
  const {
    value,
    isDragging,
    isDirty
  } = state;
  const wasDirtyOnBlur = (0,react.useRef)(false);
  const dragCursor = useDragCursor(isDragging, dragDirection);

  const handleOnBlur = event => {
    onBlur(event);
    setIsFocused === null || setIsFocused === void 0 ? void 0 : setIsFocused(false);
    /**
     * If isPressEnterToChange is set, this commits the value to
     * the onChange callback.
     */

    if (isDirty || !event.target.validity.valid) {
      wasDirtyOnBlur.current = true;
      handleOnCommit(event);
    }
  };

  const handleOnFocus = event => {
    onFocus(event);
    setIsFocused === null || setIsFocused === void 0 ? void 0 : setIsFocused(true);
  };

  const handleOnChange = event => {
    const nextValue = event.target.value;
    change(nextValue, event);
  };

  const handleOnCommit = event => {
    const nextValue = event.currentTarget.value;

    try {
      onValidate(nextValue);
      commit(nextValue, event);
    } catch (err) {
      invalidate(err, event);
    }
  };

  const handleOnKeyDown = event => {
    const {
      key
    } = event;
    onKeyDown(event);

    switch (key) {
      case 'ArrowUp':
        pressUp(event);
        break;

      case 'ArrowDown':
        pressDown(event);
        break;

      case 'Enter':
        pressEnter(event);

        if (isPressEnterToChange) {
          event.preventDefault();
          handleOnCommit(event);
        }

        break;

      case 'Escape':
        if (isPressEnterToChange && isDirty) {
          event.preventDefault();
          reset(valueProp, event);
        }

        break;
    }
  };

  const dragGestureProps = (0,use_gesture_react_esm.useDrag)(dragProps => {
    const {
      distance,
      dragging,
      event,
      target
    } = dragProps; // The `target` prop always references the `input` element while, by
    // default, the `dragProps.event.target` property would reference the real
    // event target (i.e. any DOM element that the pointer is hovering while
    // dragging). Ensuring that the `target` is always the `input` element
    // allows consumers of `InputControl` (or any higher-level control) to
    // check the input's validity by accessing `event.target.validity.valid`.

    dragProps.event = { ...dragProps.event,
      target
    };
    if (!distance) return;
    event.stopPropagation();
    /**
     * Quick return if no longer dragging.
     * This prevents unnecessary value calculations.
     */

    if (!dragging) {
      onDragEnd(dragProps);
      dragEnd(dragProps);
      return;
    }

    onDrag(dragProps);
    drag(dragProps);

    if (!isDragging) {
      onDragStart(dragProps);
      dragStart(dragProps);
    }
  }, {
    axis: dragDirection === 'e' || dragDirection === 'w' ? 'x' : 'y',
    threshold: dragThreshold,
    enabled: isDragEnabled,
    pointer: {
      capture: false
    }
  });
  const dragProps = isDragEnabled ? dragGestureProps() : {};
  /*
   * Works around the odd UA (e.g. Firefox) that does not focus inputs of
   * type=number when their spinner arrows are pressed.
   */

  let handleOnMouseDown;

  if (type === 'number') {
    handleOnMouseDown = event => {
      var _props$onMouseDown;

      (_props$onMouseDown = props.onMouseDown) === null || _props$onMouseDown === void 0 ? void 0 : _props$onMouseDown.call(props, event);

      if (event.currentTarget !== event.currentTarget.ownerDocument.activeElement) {
        event.currentTarget.focus();
      }
    };
  }

  return (0,react.createElement)(Input, (0,helpers_esm_extends/* default */.A)({}, props, dragProps, {
    className: "components-input-control__input",
    disabled: disabled,
    dragCursor: dragCursor,
    isDragging: isDragging,
    id: id,
    onBlur: handleOnBlur,
    onChange: handleOnChange,
    onFocus: handleOnFocus,
    onKeyDown: handleOnKeyDown,
    onMouseDown: handleOnMouseDown,
    ref: ref,
    inputSize: size,
    value: value,
    type: type
  }));
}

const ForwardedComponent = (0,react.forwardRef)(InputField);
/* harmony default export */ const input_field = (ForwardedComponent);
//# sourceMappingURL=input-field.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const input_control_noop = () => {};

function input_control_useUniqueId(idProp) {
  const instanceId = (0,use_instance_id/* default */.A)(InputControl);
  const id = `inspector-input-control-${instanceId}`;
  return idProp || id;
}

function UnforwardedInputControl(_ref, ref) {
  let {
    __next36pxDefaultSize,
    __unstableStateReducer: stateReducer = state => state,
    __unstableInputWidth,
    className,
    disabled = false,
    hideLabelFromVision = false,
    id: idProp,
    isPressEnterToChange = false,
    label,
    labelPosition = 'top',
    onChange = input_control_noop,
    onValidate = input_control_noop,
    onKeyDown = input_control_noop,
    prefix,
    size = 'default',
    suffix,
    value,
    ...props
  } = _ref;
  const [isFocused, setIsFocused] = (0,react.useState)(false);
  const id = input_control_useUniqueId(idProp);
  const classes = classnames_default()('components-input-control', className);
  const draftHookProps = useDraft({
    value,
    onBlur: props.onBlur,
    onChange
  });
  return (0,react.createElement)(input_base, {
    __next36pxDefaultSize: __next36pxDefaultSize,
    __unstableInputWidth: __unstableInputWidth,
    className: classes,
    disabled: disabled,
    gap: 3,
    hideLabelFromVision: hideLabelFromVision,
    id: id,
    isFocused: isFocused,
    justify: "left",
    label: label,
    labelPosition: labelPosition,
    prefix: prefix,
    size: size,
    suffix: suffix
  }, (0,react.createElement)(input_field, (0,helpers_esm_extends/* default */.A)({}, props, {
    __next36pxDefaultSize: __next36pxDefaultSize,
    className: "components-input-control__input",
    disabled: disabled,
    id: id,
    isFocused: isFocused,
    isPressEnterToChange: isPressEnterToChange,
    onKeyDown: onKeyDown,
    onValidate: onValidate,
    paddingInlineStart: prefix ? space(2) : undefined,
    paddingInlineEnd: suffix ? space(2) : undefined,
    ref: ref,
    setIsFocused: setIsFocused,
    size: size,
    stateReducer: stateReducer
  }, draftHookProps)));
}
/**
 * InputControl components let users enter and edit text. This is an experimental component
 * intended to (in time) merge with or replace `TextControl`.
 *
 * ```jsx
 * import { __experimentalInputControl as InputControl } from '@wordpress/components';
 * import { useState } from '@wordpress/compose';
 *
 * const Example = () => {
 *   const [ value, setValue ] = useState( '' );
 *
 *   return (
 *  	<InputControl
 *  		value={ value }
 *  		onChange={ ( nextValue ) => setValue( nextValue ?? '' ) }
 *  	/>
 *   );
 * };
 * ```
 */

const InputControl = (0,react.forwardRef)(UnforwardedInputControl);
/* harmony default export */ const input_control = (InputControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/number-control/styles/number-control-styles.js


function number_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

// @ts-nocheck

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */


var number_control_styles_ref =  true ? {
  name: "euqsgg",
  styles: "input[type='number']::-webkit-outer-spin-button,input[type='number']::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}input[type='number']{-moz-appearance:textfield;}"
} : 0;

const htmlArrowStyles = _ref2 => {
  let {
    hideHTMLArrows
  } = _ref2;
  if (!hideHTMLArrows) return ``;
  return number_control_styles_ref;
};

const number_control_styles_Input = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(input_control,  true ? {
  target: "ep48uk90"
} : 0)(htmlArrowStyles, ";" + ( true ? "" : 0));
//# sourceMappingURL=number-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/math.js
/**
 * Parses and retrieves a number value.
 *
 * @param {unknown} value The incoming value.
 *
 * @return {number} The parsed number value.
 */
function getNumber(value) {
  const number = Number(value);
  return isNaN(number) ? 0 : number;
}
/**
 * Safely adds 2 values.
 *
 * @param {Array<number|string>} args Values to add together.
 *
 * @return {number} The sum of values.
 */

function add() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.reduce(
  /** @type {(sum:number, arg: number|string) => number} */
  (sum, arg) => sum + getNumber(arg), 0);
}
/**
 * Safely subtracts 2 values.
 *
 * @param {Array<number|string>} args Values to subtract together.
 *
 * @return {number} The difference of the values.
 */

function subtract() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.reduce(
  /** @type {(diff:number, arg: number|string, index:number) => number} */
  (diff, arg, index) => {
    const value = getNumber(arg);
    return index === 0 ? value : diff - value;
  }, 0);
}
/**
 * Determines the decimal position of a number value.
 *
 * @param {number} value The number to evaluate.
 *
 * @return {number} The number of decimal places.
 */

function getPrecision(value) {
  const split = (value + '').split('.');
  return split[1] !== undefined ? split[1].length : 0;
}
/**
 * Clamps a value based on a min/max range.
 *
 * @param {number} value The value.
 * @param {number} min   The minimum range.
 * @param {number} max   The maximum range.
 *
 * @return {number} The clamped value.
 */


function clamp(value, min, max) {
  const baseValue = getNumber(value);
  return Math.max(min, Math.min(baseValue, max));
}
/**
 * Clamps a value based on a min/max range with rounding
 *
 * @param {number} value The value.
 * @param {number} min   The minimum range.
 * @param {number} max   The maximum range.
 * @param {number} step  A multiplier for the value.
 *
 * @return {number} The rounded and clamped value.
 */

function roundClamp() {
  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  let step = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  const baseValue = getNumber(value);
  const stepValue = getNumber(step);
  const precision = getPrecision(step);
  const rounded = Math.round(baseValue / stepValue) * stepValue;
  const clampedValue = clamp(rounded, min, max);
  return precision ? getNumber(clampedValue.toFixed(precision)) : clampedValue;
}
/**
 * Clamps a value based on a min/max range with rounding.
 * Returns a string.
 *
 * @param {Parameters<typeof roundClamp>} args Arguments for roundClamp().
 * @return {string} The rounded and clamped value.
 */

function roundClampString() {
  return roundClamp(...arguments).toString();
}
//# sourceMappingURL=math.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/number-control/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function NumberControl(_ref, ref) {
  let {
    __unstableStateReducer: stateReducerProp,
    className,
    dragDirection = 'n',
    hideHTMLArrows = false,
    isDragEnabled = true,
    isShiftStepEnabled = true,
    label,
    max = Infinity,
    min = -Infinity,
    required = false,
    shiftStep = 10,
    step = 1,
    type: typeProp = 'number',
    value: valueProp,
    ...props
  } = _ref;
  const isStepAny = step === 'any';
  const baseStep = isStepAny ? 1 : parseFloat(step);
  const baseValue = roundClamp(0, min, max, baseStep);

  const constrainValue = (value, stepOverride) => {
    // When step is "any" clamp the value, otherwise round and clamp it.
    return isStepAny ? Math.min(max, Math.max(min, value)) : roundClamp(value, min, max, stepOverride !== null && stepOverride !== void 0 ? stepOverride : baseStep);
  };

  const autoComplete = typeProp === 'number' ? 'off' : null;
  const classes = classnames_default()('components-number-control', className);
  /**
   * "Middleware" function that intercepts updates from InputControl.
   * This allows us to tap into actions to transform the (next) state for
   * InputControl.
   *
   * @param {Object} state  State from InputControl
   * @param {Object} action Action triggering state change
   * @return {Object} The updated state to apply to InputControl
   */

  const numberControlStateReducer = (state, action) => {
    const nextState = { ...state
    };
    const {
      type,
      payload
    } = action;
    const event = payload === null || payload === void 0 ? void 0 : payload.event;
    const currentValue = nextState.value;
    /**
     * Handles custom UP and DOWN Keyboard events
     */

    if (type === PRESS_UP || type === PRESS_DOWN) {
      const enableShift = event.shiftKey && isShiftStepEnabled;
      const incrementalValue = enableShift ? parseFloat(shiftStep) * baseStep : baseStep;
      let nextValue = isValueEmpty(currentValue) ? baseValue : currentValue;

      if (event !== null && event !== void 0 && event.preventDefault) {
        event.preventDefault();
      }

      if (type === PRESS_UP) {
        nextValue = add(nextValue, incrementalValue);
      }

      if (type === PRESS_DOWN) {
        nextValue = subtract(nextValue, incrementalValue);
      }

      nextState.value = constrainValue(nextValue, enableShift ? incrementalValue : null);
    }
    /**
     * Handles drag to update events
     */


    if (type === DRAG && isDragEnabled) {
      const [x, y] = payload.delta;
      const enableShift = payload.shiftKey && isShiftStepEnabled;
      const modifier = enableShift ? parseFloat(shiftStep) * baseStep : baseStep;
      let directionModifier;
      let delta;

      switch (dragDirection) {
        case 'n':
          delta = y;
          directionModifier = -1;
          break;

        case 'e':
          delta = x;
          directionModifier = (0,i18n_build_module/* isRTL */.V8)() ? -1 : 1;
          break;

        case 's':
          delta = y;
          directionModifier = 1;
          break;

        case 'w':
          delta = x;
          directionModifier = (0,i18n_build_module/* isRTL */.V8)() ? 1 : -1;
          break;
      }

      if (delta !== 0) {
        delta = Math.ceil(Math.abs(delta)) * Math.sign(delta);
        const distance = delta * modifier * directionModifier;
        nextState.value = constrainValue(add(currentValue, distance), enableShift ? modifier : null);
      }
    }
    /**
     * Handles commit (ENTER key press or blur)
     */


    if (type === PRESS_ENTER || type === COMMIT) {
      const applyEmptyValue = required === false && currentValue === '';
      nextState.value = applyEmptyValue ? currentValue : constrainValue(currentValue);
    }

    return nextState;
  };

  return (0,react.createElement)(number_control_styles_Input, (0,helpers_esm_extends/* default */.A)({
    autoComplete: autoComplete,
    inputMode: "numeric"
  }, props, {
    className: classes,
    dragDirection: dragDirection,
    hideHTMLArrows: hideHTMLArrows,
    isDragEnabled: isDragEnabled,
    label: label,
    max: max,
    min: min,
    ref: ref,
    required: required,
    step: step,
    type: typeProp,
    value: valueProp,
    __unstableStateReducer: (state, action) => {
      var _stateReducerProp;

      const baseState = numberControlStateReducer(state, action);
      return (_stateReducerProp = stateReducerProp === null || stateReducerProp === void 0 ? void 0 : stateReducerProp(baseState, action)) !== null && _stateReducerProp !== void 0 ? _stateReducerProp : baseState;
    }
  }));
}
/* harmony default export */ const number_control = ((0,react.forwardRef)(NumberControl));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/unit-control/styles/unit-control-styles.js


function unit_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



 // Using `selectSize` instead of `size` to avoid a type conflict with the
// `size` HTML attribute of the `select` element.

const unit_control_styles_Root = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1bagdl33"
} : 0)("box-sizing:border-box;position:relative;&&& ", BackdropUI, "{transition:box-shadow 0.1s linear;}" + ( true ? "" : 0));

var unit_control_styles_ref =  true ? {
  name: "1y65o8",
  styles: "&::-webkit-outer-spin-button,&::-webkit-inner-spin-button{-webkit-appearance:none;margin:0;}"
} : 0;

const arrowStyles = _ref2 => {
  let {
    disableUnits
  } = _ref2;
  if (disableUnits) return '';
  return unit_control_styles_ref;
}; // TODO: Resolve need to use &&& to increase specificity
// https://github.com/WordPress/gutenberg/issues/18483


const ValueInput = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(number_control,  true ? {
  target: "e1bagdl32"
} : 0)("&&&{input{appearance:none;-moz-appearance:textfield;display:block;width:100%;", arrowStyles, ";}}" + ( true ? "" : 0));

const baseUnitLabelStyles = _ref3 => {
  let {
    selectSize
  } = _ref3;
  const sizes = {
    default: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-sizing:border-box;padding:2px 1px;width:20px;color:", COLORS.darkGray[500], ";font-size:8px;line-height:1;letter-spacing:-0.5px;text-transform:uppercase;text-align-last:center;" + ( true ? "" : 0),  true ? "" : 0),
    large: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-sizing:border-box;min-width:24px;max-width:48px;height:24px;margin-inline-end:", space(2), ";padding:", space(1), ";color:", COLORS.ui.theme, ";font-size:13px;line-height:1;text-align-last:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;" + ( true ? "" : 0),  true ? "" : 0)
  };
  return selectSize === '__unstable-large' ? sizes.large : sizes.default;
};

const UnitLabel = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1bagdl31"
} : 0)("&&&{pointer-events:none;", baseUnitLabelStyles, ";color:", COLORS.gray[900], ";}" + ( true ? "" : 0));

const unitSelectSizes = _ref4 => {
  let {
    selectSize = 'default'
  } = _ref4;
  const sizes = {
    default: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("height:100%;border:1px solid transparent;transition:box-shadow 0.1s linear,border 0.1s linear;", rtl({
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    })(), " &:not(:disabled):hover{background-color:", COLORS.lightGray[300], ";}&:focus{border:1px solid ", COLORS.ui.borderFocus, ";box-shadow:inset 0 0 0 ", config_values.borderWidth + ' ' + COLORS.ui.borderFocus, ";outline-offset:0;outline:2px solid transparent;z-index:1;}" + ( true ? "" : 0),  true ? "" : 0),
    large: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("display:flex;justify-content:center;align-items:center;&:hover{color:", COLORS.ui.borderFocus, ";box-shadow:inset 0 0 0 ", config_values.borderWidth + ' ' + COLORS.ui.borderFocus, ";outline:", config_values.borderWidth, " solid transparent;}&:focus{box-shadow:0 0 0 ", config_values.borderWidthFocus + ' ' + COLORS.ui.borderFocus, ";outline:", config_values.borderWidthFocus, " solid transparent;}" + ( true ? "" : 0),  true ? "" : 0)
  };
  return selectSize === '__unstable-large' ? sizes.large : sizes.default;
};

const UnitSelect = (0,emotion_styled_base_browser_esm/* default */.A)("select",  true ? {
  target: "e1bagdl30"
} : 0)("&&{appearance:none;background:transparent;border-radius:2px;border:none;display:block;outline:none;margin:0;min-height:auto;font-family:inherit;", baseUnitLabelStyles, ";", unitSelectSizes, ";&:not( :disabled ){cursor:pointer;}}" + ( true ? "" : 0));
//# sourceMappingURL=unit-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/unit-control/unit-select-control.js



/**
 * External dependencies
 */



function UnitSelectControl(_ref) {
  let {
    className,
    isUnitSelectTabbable: isTabbable = true,
    onChange,
    size = 'default',
    unit = 'px',
    units = CSS_UNITS,
    ...props
  } = _ref;

  if (!hasUnits(units) || (units === null || units === void 0 ? void 0 : units.length) === 1) {
    return (0,react.createElement)(UnitLabel, {
      className: "components-unit-control__unit-label",
      selectSize: size
    }, unit);
  }

  const handleOnChange = event => {
    const {
      value: unitValue
    } = event.target;
    const data = units.find(option => option.value === unitValue);
    onChange === null || onChange === void 0 ? void 0 : onChange(unitValue, {
      event,
      data
    });
  };

  const classes = classnames_default()('components-unit-control__select', className);
  return (0,react.createElement)(UnitSelect, (0,helpers_esm_extends/* default */.A)({
    className: classes,
    onChange: handleOnChange,
    selectSize: size,
    tabIndex: isTabbable ? undefined : -1,
    value: unit
  }, props), units.map(option => (0,react.createElement)("option", {
    value: option.value,
    key: option.value
  }, option.label)));
}
//# sourceMappingURL=unit-select-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/hooks/use-controlled-state.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * @template T
 * @typedef Options
 * @property {T | undefined} initial  Initial value
 * @property {T | ""}        fallback Fallback value
 */

/** @type {Readonly<{ initial: undefined, fallback: '' }>} */

const defaultOptions = {
  initial: undefined,

  /**
   * Defaults to empty string, as that is preferred for usage with
   * <input />, <textarea />, and <select /> form elements.
   */
  fallback: ''
};
/**
 * Custom hooks for "controlled" components to track and consolidate internal
 * state and incoming values. This is useful for components that render
 * `input`, `textarea`, or `select` HTML elements.
 *
 * https://reactjs.org/docs/forms.html#controlled-components
 *
 * At first, a component using useControlledState receives an initial prop
 * value, which is used as initial internal state.
 *
 * This internal state can be maintained and updated without
 * relying on new incoming prop values.
 *
 * Unlike the basic useState hook, useControlledState's state can
 * be updated if a new incoming prop value is changed.
 *
 * @template T
 *
 * @param {T | undefined} currentState             The current value.
 * @param {Options<T>}    [options=defaultOptions] Additional options for the hook.
 *
 * @return {[T | "", (nextState: T) => void]} The controlled value and the value setter.
 */

function useControlledState(currentState) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  const {
    initial,
    fallback
  } = { ...defaultOptions,
    ...options
  };
  const [internalState, setInternalState] = (0,react.useState)(currentState);
  const hasCurrentState = isValueDefined(currentState);
  /*
   * Resets internal state if value every changes from uncontrolled <-> controlled.
   */

  (0,react.useEffect)(() => {
    if (hasCurrentState && internalState) {
      setInternalState(undefined);
    }
  }, [hasCurrentState, internalState]);
  const state = getDefinedValue([currentState, internalState, initial], fallback);
  /* eslint-disable jsdoc/no-undefined-types */

  /** @type {(nextState: T) => void} */

  const setState = nextState => {
    if (!hasCurrentState) {
      setInternalState(nextState);
    }
  };
  /* eslint-enable jsdoc/no-undefined-types */


  return [state, setState];
}

/* harmony default export */ const use_controlled_state = (useControlledState);
//# sourceMappingURL=use-controlled-state.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/unit-control/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







function UnforwardedUnitControl(unitControlProps, forwardedRef) {
  const {
    __unstableStateReducer: stateReducerProp,
    autoComplete = 'off',
    children,
    className,
    disabled = false,
    disableUnits = false,
    isPressEnterToChange = false,
    isResetValueOnUnitChange = false,
    isUnitSelectTabbable = true,
    label,
    onChange: onChangeProp,
    onUnitChange,
    size = 'default',
    style,
    unit: unitProp,
    units: unitsProp = CSS_UNITS,
    value: valueProp,
    onBlur: onBlurProp,
    ...props
  } = unitControlProps;

  if ('unit' in unitControlProps) {
    (0,deprecated_build_module/* default */.A)('UnitControl unit prop', {
      since: '5.6',
      hint: 'The unit should be provided within the `value` prop.',
      version: '6.2'
    });
  } // The `value` prop, in theory, should not be `null`, but the following line
  // ensures it fallback to `undefined` in case a consumer of `UnitControl`
  // still passes `null` as a `value`.


  const nonNullValueProp = valueProp !== null && valueProp !== void 0 ? valueProp : undefined;
  const units = (0,react.useMemo)(() => getUnitsWithCurrentUnit(nonNullValueProp, unitProp, unitsProp), [nonNullValueProp, unitProp, unitsProp]);
  const [parsedQuantity, parsedUnit] = getParsedQuantityAndUnit(nonNullValueProp, unitProp, units);
  const [unit, setUnit] = use_controlled_state(units.length === 1 ? units[0].value : unitProp, {
    initial: parsedUnit,
    fallback: ''
  });
  (0,react.useEffect)(() => {
    if (parsedUnit !== undefined) {
      setUnit(parsedUnit);
    }
  }, [parsedUnit]); // Stores parsed value for hand-off in state reducer.

  const refParsedQuantity = (0,react.useRef)(undefined);
  const classes = classnames_default()('components-unit-control', className);

  const handleOnQuantityChange = (nextQuantityValue, changeProps) => {
    if (nextQuantityValue === '' || typeof nextQuantityValue === 'undefined' || nextQuantityValue === null) {
      onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp('', changeProps);
      return;
    }
    /*
     * Customizing the onChange callback.
     * This allows as to broadcast a combined value+unit to onChange.
     */


    const onChangeValue = getValidParsedQuantityAndUnit(nextQuantityValue, units, parsedQuantity, unit).join('');
    onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(onChangeValue, changeProps);
  };

  const handleOnUnitChange = (nextUnitValue, changeProps) => {
    const {
      data
    } = changeProps;
    let nextValue = `${parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : ''}${nextUnitValue}`;

    if (isResetValueOnUnitChange && (data === null || data === void 0 ? void 0 : data.default) !== undefined) {
      nextValue = `${data.default}${nextUnitValue}`;
    }

    onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(nextValue, changeProps);
    onUnitChange === null || onUnitChange === void 0 ? void 0 : onUnitChange(nextUnitValue, changeProps);
    setUnit(nextUnitValue);
  };

  const mayUpdateUnit = event => {
    if (!isNaN(Number(event.currentTarget.value))) {
      refParsedQuantity.current = undefined;
      return;
    }

    const [validParsedQuantity, validParsedUnit] = getValidParsedQuantityAndUnit(event.currentTarget.value, units, parsedQuantity, unit);
    refParsedQuantity.current = validParsedQuantity;

    if (isPressEnterToChange && validParsedUnit !== unit) {
      const data = Array.isArray(units) ? units.find(option => option.value === validParsedUnit) : undefined;
      const changeProps = {
        event,
        data
      }; // The `onChange` callback already gets called, no need to call it explicitely.

      onUnitChange === null || onUnitChange === void 0 ? void 0 : onUnitChange(validParsedUnit, changeProps);
      setUnit(validParsedUnit);
    }
  };

  const handleOnBlur = event => {
    mayUpdateUnit(event);
    onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(event);
  };

  const handleOnKeyDown = event => {
    const {
      key
    } = event;

    if (key === 'Enter') {
      mayUpdateUnit(event);
    }
  };
  /**
   * "Middleware" function that intercepts updates from InputControl.
   * This allows us to tap into actions to transform the (next) state for
   * InputControl.
   *
   * @param  state  State from InputControl
   * @param  action Action triggering state change
   * @return The updated state to apply to InputControl
   */


  const unitControlStateReducer = (state, action) => {
    const nextState = { ...state
    };
    /*
     * On commits (when pressing ENTER and on blur if
     * isPressEnterToChange is true), if a parse has been performed
     * then use that result to update the state.
     */

    if (action.type === COMMIT) {
      if (refParsedQuantity.current !== undefined) {
        var _refParsedQuantity$cu;

        nextState.value = ((_refParsedQuantity$cu = refParsedQuantity.current) !== null && _refParsedQuantity$cu !== void 0 ? _refParsedQuantity$cu : '').toString();
        refParsedQuantity.current = undefined;
      }
    }

    return nextState;
  };

  let stateReducer = unitControlStateReducer;

  if (stateReducerProp) {
    stateReducer = (state, action) => {
      const baseState = unitControlStateReducer(state, action);
      return stateReducerProp(baseState, action);
    };
  }

  const inputSuffix = !disableUnits ? (0,react.createElement)(UnitSelectControl, {
    "aria-label": (0,i18n_build_module.__)('Select unit'),
    disabled: disabled,
    isUnitSelectTabbable: isUnitSelectTabbable,
    onChange: handleOnUnitChange,
    size: size,
    unit: unit,
    units: units,
    onBlur: onBlurProp
  }) : null;
  let step = props.step;
  /*
   * If no step prop has been passed, lookup the active unit and
   * try to get step from `units`, or default to a value of `1`
   */

  if (!step && units) {
    var _activeUnit$step;

    const activeUnit = units.find(option => option.value === unit);
    step = (_activeUnit$step = activeUnit === null || activeUnit === void 0 ? void 0 : activeUnit.step) !== null && _activeUnit$step !== void 0 ? _activeUnit$step : 1;
  }

  return (0,react.createElement)(unit_control_styles_Root, {
    className: "components-unit-control-wrapper",
    style: style
  }, (0,react.createElement)(ValueInput, (0,helpers_esm_extends/* default */.A)({
    "aria-label": label,
    type: isPressEnterToChange ? 'text' : 'number'
  }, props, {
    autoComplete: autoComplete,
    className: classes,
    disabled: disabled,
    disableUnits: disableUnits,
    isPressEnterToChange: isPressEnterToChange,
    label: label,
    onBlur: handleOnBlur,
    onKeyDown: handleOnKeyDown,
    onChange: handleOnQuantityChange,
    ref: forwardedRef,
    size: size,
    suffix: inputSuffix,
    value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : '',
    step: step,
    __unstableStateReducer: stateReducer
  })));
}
/**
 * `UnitControl` allows the user to set a numeric quantity as well as a unit (e.g. `px`).
 *
 *
 * @example
 * ```jsx
 * import { __experimentalUnitControl as UnitControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const Example = () => {
 *   const [ value, setValue ] = useState( '10px' );
 *
 *   return <UnitControl onChange={ setValue } value={ value } />;
 * };
 * ```
 */


const UnitControl = (0,react.forwardRef)(UnforwardedUnitControl);

/* harmony default export */ const unit_control = (UnitControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/styles/box-control-styles.js


function box_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



const box_control_styles_Root = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e7pk0lh6"
} : 0)( true ? {
  name: "14bvcyk",
  styles: "box-sizing:border-box;max-width:235px;padding-bottom:12px;width:100%"
} : 0);
const Header = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "e7pk0lh5"
} : 0)( true ? {
  name: "5bhc30",
  styles: "margin-bottom:8px"
} : 0);
const HeaderControlWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "e7pk0lh4"
} : 0)( true ? {
  name: "aujtid",
  styles: "min-height:30px;gap:0"
} : 0);
const UnitControlWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e7pk0lh3"
} : 0)( true ? {
  name: "112jwab",
  styles: "box-sizing:border-box;max-width:80px"
} : 0);
const LayoutContainer = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "e7pk0lh2"
} : 0)( true ? {
  name: "xy18ro",
  styles: "justify-content:center;padding-top:8px"
} : 0);
const Layout = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "e7pk0lh1"
} : 0)( true ? {
  name: "3tw5wk",
  styles: "position:relative;height:100%;width:100%;justify-content:flex-start"
} : 0);

var box_control_styles_ref =  true ? {
  name: "1ch9yvl",
  styles: "border-radius:0"
} : 0;

var box_control_styles_ref2 =  true ? {
  name: "tg3mx0",
  styles: "border-radius:2px"
} : 0;

const unitControlBorderRadiusStyles = _ref3 => {
  let {
    isFirst,
    isLast,
    isOnly
  } = _ref3;

  if (isFirst) {
    return rtl({
      borderTopRightRadius: 0,
      borderBottomRightRadius: 0
    })();
  }

  if (isLast) {
    return rtl({
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    })();
  }

  if (isOnly) {
    return box_control_styles_ref2;
  }

  return box_control_styles_ref;
};

const unitControlMarginStyles = _ref4 => {
  let {
    isFirst,
    isOnly
  } = _ref4;
  const marginLeft = isFirst || isOnly ? 0 : -1;
  return rtl({
    marginLeft
  })();
};

const box_control_styles_UnitControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(unit_control,  true ? {
  target: "e7pk0lh0"
} : 0)("max-width:60px;", unitControlBorderRadiusStyles, ";", unitControlMarginStyles, ";" + ( true ? "" : 0));
//# sourceMappingURL=box-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/unit-control.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




const unit_control_noop = () => {};

function BoxUnitControl(_ref) {
  let {
    isFirst,
    isLast,
    isOnly,
    onHoverOn = unit_control_noop,
    onHoverOff = unit_control_noop,
    label,
    value,
    ...props
  } = _ref;
  const bindHoverGesture = (0,use_gesture_react_esm.useHover)(_ref2 => {
    let {
      event,
      ...state
    } = _ref2;

    if (state.hovering) {
      onHoverOn(event, state);
    } else {
      onHoverOff(event, state);
    }
  });
  return (0,react.createElement)(UnitControlWrapper, bindHoverGesture(), (0,react.createElement)(unit_control_Tooltip, {
    text: label
  }, (0,react.createElement)(box_control_styles_UnitControl, (0,helpers_esm_extends/* default */.A)({
    "aria-label": label,
    className: "component-box-control__unit-control",
    hideHTMLArrows: true,
    isFirst: isFirst,
    isLast: isLast,
    isOnly: isOnly,
    isPressEnterToChange: true,
    isResetValueOnUnitChange: false,
    value: value
  }, props))));
}

function unit_control_Tooltip(_ref3) {
  let {
    children,
    text
  } = _ref3;
  if (!text) return children;
  /**
   * Wrapping the children in a `<div />` as Tooltip as it attempts
   * to render the <UnitControl />. Using a plain `<div />` appears to
   * resolve this issue.
   *
   * Originally discovered and referenced here:
   * https://github.com/WordPress/gutenberg/pull/24966#issuecomment-685875026
   */

  return (0,react.createElement)(tooltip, {
    text: text,
    position: "top"
  }, (0,react.createElement)("div", null, children));
}
//# sourceMappingURL=unit-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/utils.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const LABELS = {
  all: (0,i18n_build_module.__)('All'),
  top: (0,i18n_build_module.__)('Top'),
  bottom: (0,i18n_build_module.__)('Bottom'),
  left: (0,i18n_build_module.__)('Left'),
  right: (0,i18n_build_module.__)('Right'),
  mixed: (0,i18n_build_module.__)('Mixed'),
  vertical: (0,i18n_build_module.__)('Vertical'),
  horizontal: (0,i18n_build_module.__)('Horizontal')
};
const DEFAULT_VALUES = {
  top: undefined,
  right: undefined,
  bottom: undefined,
  left: undefined
};
const ALL_SIDES = ['top', 'right', 'bottom', 'left'];
/**
 * Gets an items with the most occurrence within an array
 * https://stackoverflow.com/a/20762713
 *
 * @param {Array<any>} arr Array of items to check.
 * @return {any} The item with the most occurrences.
 */

function mode(arr) {
  return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();
}
/**
 * Gets the 'all' input value and unit from values data.
 *
 * @param {Object} values         Box values.
 * @param {Object} selectedUnits  Box units.
 * @param {Array}  availableSides Available box sides to evaluate.
 *
 * @return {string} A value + unit for the 'all' input.
 */


function getAllValue() {
  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let selectedUnits = arguments.length > 1 ? arguments[1] : undefined;
  let availableSides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALL_SIDES;
  const sides = normalizeSides(availableSides);
  const parsedQuantitiesAndUnits = sides.map(side => parseQuantityAndUnitFromRawValue(values[side]));
  const allParsedQuantities = parsedQuantitiesAndUnits.map(value => {
    var _value$;

    return (_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : '';
  });
  const allParsedUnits = parsedQuantitiesAndUnits.map(value => value[1]);
  const commonQuantity = allParsedQuantities.every(v => v === allParsedQuantities[0]) ? allParsedQuantities[0] : '';
  /**
   * The typeof === 'number' check is important. On reset actions, the incoming value
   * may be null or an empty string.
   *
   * Also, the value may also be zero (0), which is considered a valid unit value.
   *
   * typeof === 'number' is more specific for these cases, rather than relying on a
   * simple truthy check.
   */

  let commonUnit;

  if (typeof commonQuantity === 'number') {
    commonUnit = mode(allParsedUnits);
  } else {
    var _getAllUnitFallback;

    // Set meaningful unit selection if no commonQuantity and user has previously
    // selected units without assigning values while controls were unlinked.
    commonUnit = (_getAllUnitFallback = getAllUnitFallback(selectedUnits)) !== null && _getAllUnitFallback !== void 0 ? _getAllUnitFallback : mode(allParsedUnits);
  }

  return [commonQuantity, commonUnit].join('');
}
/**
 * Determine the most common unit selection to use as a fallback option.
 *
 * @param {Object} selectedUnits Current unit selections for individual sides.
 * @return {string} Most common unit selection.
 */

function getAllUnitFallback(selectedUnits) {
  if (!selectedUnits || typeof selectedUnits !== 'object') {
    return undefined;
  }

  const filteredUnits = Object.values(selectedUnits).filter(Boolean);
  return mode(filteredUnits);
}
/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values        Box values.
 * @param {Object} selectedUnits Box units.
 * @param {Array}  sides         Available box sides to evaluate.
 *
 * @return {boolean} Whether values are mixed.
 */

function isValuesMixed() {
  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let selectedUnits = arguments.length > 1 ? arguments[1] : undefined;
  let sides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALL_SIDES;
  const allValue = getAllValue(values, selectedUnits, sides);
  const isMixed = isNaN(parseFloat(allValue));
  return isMixed;
}
/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Box values.
 *
 * @return {boolean} Whether values are mixed.
 */

function isValuesDefined(values) {
  return values !== undefined && Object.values(values).filter( // Switching units when input is empty causes values only
  // containing units. This gives false positive on mixed values
  // unless filtered.
  value => !!value && /\d/.test(value)).length > 0;
}
/**
 * Get initial selected side, factoring in whether the sides are linked,
 * and whether the vertical / horizontal directions are grouped via splitOnAxis.
 *
 * @param {boolean} isLinked    Whether the box control's fields are linked.
 * @param {boolean} splitOnAxis Whether splitting by horizontal or vertical axis.
 * @return {string} The initial side.
 */

function getInitialSide(isLinked, splitOnAxis) {
  let initialSide = 'all';

  if (!isLinked) {
    initialSide = splitOnAxis ? 'vertical' : 'top';
  }

  return initialSide;
}
/**
 * Normalizes provided sides configuration to an array containing only top,
 * right, bottom and left. This essentially just maps `horizontal` or `vertical`
 * to their appropriate sides to facilitate correctly determining value for
 * all input control.
 *
 * @param {Array} sides Available sides for box control.
 * @return {Array} Normalized sides configuration.
 */

function normalizeSides(sides) {
  const filteredSides = [];

  if (!(sides !== null && sides !== void 0 && sides.length)) {
    return ALL_SIDES;
  }

  if (sides.includes('vertical')) {
    filteredSides.push(...['top', 'bottom']);
  } else if (sides.includes('horizontal')) {
    filteredSides.push(...['left', 'right']);
  } else {
    const newSides = ALL_SIDES.filter(side => sides.includes(side));
    filteredSides.push(...newSides);
  }

  return filteredSides;
}
/**
 * Applies a value to an object representing top, right, bottom and left sides
 * while taking into account any custom side configuration.
 *
 * @param {Object}        currentValues The current values for each side.
 * @param {string|number} newValue      The value to apply to the sides object.
 * @param {string[]}      sides         Array defining valid sides.
 *
 * @return {Object} Object containing the updated values for each side.
 */

function applyValueToSides(currentValues, newValue, sides) {
  const newValues = { ...currentValues
  };

  if (sides !== null && sides !== void 0 && sides.length) {
    sides.forEach(side => {
      if (side === 'vertical') {
        newValues.top = newValue;
        newValues.bottom = newValue;
      } else if (side === 'horizontal') {
        newValues.left = newValue;
        newValues.right = newValue;
      } else {
        newValues[side] = newValue;
      }
    });
  } else {
    ALL_SIDES.forEach(side => newValues[side] = newValue);
  }

  return newValues;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/all-input-control.js



/**
 * Internal dependencies
 */



const all_input_control_noop = () => {};

function AllInputControl(_ref) {
  let {
    onChange = all_input_control_noop,
    onFocus = all_input_control_noop,
    onHoverOn = all_input_control_noop,
    onHoverOff = all_input_control_noop,
    values,
    sides,
    selectedUnits,
    setSelectedUnits,
    ...props
  } = _ref;
  const allValue = getAllValue(values, selectedUnits, sides);
  const hasValues = isValuesDefined(values);
  const isMixed = hasValues && isValuesMixed(values, selectedUnits, sides);
  const allPlaceholder = isMixed ? LABELS.mixed : null;

  const handleOnFocus = event => {
    onFocus(event, {
      side: 'all'
    });
  };

  const handleOnChange = next => {
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    const nextValues = applyValueToSides(values, nextValue, sides);
    onChange(nextValues);
  }; // Set selected unit so it can be used as fallback by unlinked controls
  // when individual sides do not have a value containing a unit.


  const handleOnUnitChange = unit => {
    const newUnits = applyValueToSides(selectedUnits, unit, sides);
    setSelectedUnits(newUnits);
  };

  const handleOnHoverOn = () => {
    onHoverOn({
      top: true,
      bottom: true,
      left: true,
      right: true
    });
  };

  const handleOnHoverOff = () => {
    onHoverOff({
      top: false,
      bottom: false,
      left: false,
      right: false
    });
  };

  return (0,react.createElement)(BoxUnitControl, (0,helpers_esm_extends/* default */.A)({}, props, {
    disableUnits: isMixed,
    isOnly: true,
    value: allValue,
    onChange: handleOnChange,
    onUnitChange: handleOnUnitChange,
    onFocus: handleOnFocus,
    onHoverOn: handleOnHoverOn,
    onHoverOff: handleOnHoverOff,
    placeholder: allPlaceholder
  }));
}
//# sourceMappingURL=all-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/input-controls.js



/**
 * Internal dependencies
 */





const input_controls_noop = () => {};

function BoxInputControls(_ref) {
  let {
    onChange = input_controls_noop,
    onFocus = input_controls_noop,
    onHoverOn = input_controls_noop,
    onHoverOff = input_controls_noop,
    values,
    selectedUnits,
    setSelectedUnits,
    sides,
    ...props
  } = _ref;

  const createHandleOnFocus = side => event => {
    onFocus(event, {
      side
    });
  };

  const createHandleOnHoverOn = side => () => {
    onHoverOn({
      [side]: true
    });
  };

  const createHandleOnHoverOff = side => () => {
    onHoverOff({
      [side]: false
    });
  };

  const handleOnChange = nextValues => {
    onChange(nextValues);
  };

  const createHandleOnChange = side => (next, _ref2) => {
    let {
      event
    } = _ref2;
    const {
      altKey
    } = event;
    const nextValues = { ...values
    };
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    nextValues[side] = nextValue;
    /**
     * Supports changing pair sides. For example, holding the ALT key
     * when changing the TOP will also update BOTTOM.
     */

    if (altKey) {
      switch (side) {
        case 'top':
          nextValues.bottom = nextValue;
          break;

        case 'bottom':
          nextValues.top = nextValue;
          break;

        case 'left':
          nextValues.right = nextValue;
          break;

        case 'right':
          nextValues.left = nextValue;
          break;
      }
    }

    handleOnChange(nextValues);
  };

  const createHandleOnUnitChange = side => next => {
    const newUnits = { ...selectedUnits
    };
    newUnits[side] = next;
    setSelectedUnits(newUnits);
  }; // Filter sides if custom configuration provided, maintaining default order.


  const filteredSides = sides !== null && sides !== void 0 && sides.length ? ALL_SIDES.filter(side => sides.includes(side)) : ALL_SIDES;
  const first = filteredSides[0];
  const last = filteredSides[filteredSides.length - 1];
  const only = first === last && first;
  return (0,react.createElement)(LayoutContainer, {
    className: "component-box-control__input-controls-wrapper"
  }, (0,react.createElement)(Layout, {
    gap: 0,
    align: "top",
    className: "component-box-control__input-controls"
  }, filteredSides.map(side => {
    const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(values[side]);
    const computedUnit = values[side] ? parsedUnit : selectedUnits[side];
    return (0,react.createElement)(BoxUnitControl, (0,helpers_esm_extends/* default */.A)({}, props, {
      isFirst: first === side,
      isLast: last === side,
      isOnly: only === side,
      value: [parsedQuantity, computedUnit].join(''),
      onChange: createHandleOnChange(side),
      onUnitChange: createHandleOnUnitChange(side),
      onFocus: createHandleOnFocus(side),
      onHoverOn: createHandleOnHoverOn(side),
      onHoverOff: createHandleOnHoverOff(side),
      label: LABELS[side],
      key: `box-control-${side}`
    }));
  })));
}
//# sourceMappingURL=input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/axial-input-controls.js



/**
 * Internal dependencies
 */




const groupedSides = ['vertical', 'horizontal'];
function AxialInputControls(_ref) {
  let {
    onChange,
    onFocus,
    onHoverOn,
    onHoverOff,
    values,
    selectedUnits,
    setSelectedUnits,
    sides,
    ...props
  } = _ref;

  const createHandleOnFocus = side => event => {
    if (!onFocus) {
      return;
    }

    onFocus(event, {
      side
    });
  };

  const createHandleOnHoverOn = side => () => {
    if (!onHoverOn) {
      return;
    }

    if (side === 'vertical') {
      onHoverOn({
        top: true,
        bottom: true
      });
    }

    if (side === 'horizontal') {
      onHoverOn({
        left: true,
        right: true
      });
    }
  };

  const createHandleOnHoverOff = side => () => {
    if (!onHoverOff) {
      return;
    }

    if (side === 'vertical') {
      onHoverOff({
        top: false,
        bottom: false
      });
    }

    if (side === 'horizontal') {
      onHoverOff({
        left: false,
        right: false
      });
    }
  };

  const createHandleOnChange = side => next => {
    if (!onChange) {
      return;
    }

    const nextValues = { ...values
    };
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;

    if (side === 'vertical') {
      nextValues.top = nextValue;
      nextValues.bottom = nextValue;
    }

    if (side === 'horizontal') {
      nextValues.left = nextValue;
      nextValues.right = nextValue;
    }

    onChange(nextValues);
  };

  const createHandleOnUnitChange = side => next => {
    const newUnits = { ...selectedUnits
    };

    if (side === 'vertical') {
      newUnits.top = next;
      newUnits.bottom = next;
    }

    if (side === 'horizontal') {
      newUnits.left = next;
      newUnits.right = next;
    }

    setSelectedUnits(newUnits);
  }; // Filter sides if custom configuration provided, maintaining default order.


  const filteredSides = sides !== null && sides !== void 0 && sides.length ? groupedSides.filter(side => sides.includes(side)) : groupedSides;
  const first = filteredSides[0];
  const last = filteredSides[filteredSides.length - 1];
  const only = first === last && first;
  return (0,react.createElement)(Layout, {
    gap: 0,
    align: "top",
    className: "component-box-control__vertical-horizontal-input-controls"
  }, filteredSides.map(side => {
    const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(side === 'vertical' ? values.top : values.left);
    const selectedUnit = side === 'vertical' ? selectedUnits.top : selectedUnits.left;
    return (0,react.createElement)(BoxUnitControl, (0,helpers_esm_extends/* default */.A)({}, props, {
      isFirst: first === side,
      isLast: last === side,
      isOnly: only === side,
      value: [parsedQuantity, selectedUnit !== null && selectedUnit !== void 0 ? selectedUnit : parsedUnit].join(''),
      onChange: createHandleOnChange(side),
      onUnitChange: createHandleOnUnitChange(side),
      onFocus: createHandleOnFocus(side),
      onHoverOn: createHandleOnHoverOn(side),
      onHoverOff: createHandleOnHoverOff(side),
      label: LABELS[side],
      key: side
    }));
  }));
}
//# sourceMappingURL=axial-input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/styles/box-control-icon-styles.js


function box_control_icon_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

const box_control_icon_styles_Root = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "eaw9yqk8"
} : 0)( true ? {
  name: "1w884gc",
  styles: "box-sizing:border-box;display:block;width:24px;height:24px;position:relative;padding:4px"
} : 0);
const Viewbox = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "eaw9yqk7"
} : 0)( true ? {
  name: "i6vjox",
  styles: "box-sizing:border-box;display:block;position:relative;width:100%;height:100%"
} : 0);

const strokeFocus = _ref => {
  let {
    isFocused
  } = _ref;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    backgroundColor: 'currentColor',
    opacity: isFocused ? 1 : 0.3
  },  true ? "" : 0,  true ? "" : 0);
};

const Stroke = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "eaw9yqk6"
} : 0)("box-sizing:border-box;display:block;pointer-events:none;position:absolute;", strokeFocus, ";" + ( true ? "" : 0));

const VerticalStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(Stroke,  true ? {
  target: "eaw9yqk5"
} : 0)( true ? {
  name: "1k2w39q",
  styles: "bottom:3px;top:3px;width:2px"
} : 0);

const HorizontalStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(Stroke,  true ? {
  target: "eaw9yqk4"
} : 0)( true ? {
  name: "1q9b07k",
  styles: "height:2px;left:3px;right:3px"
} : 0);

const TopStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(HorizontalStroke,  true ? {
  target: "eaw9yqk3"
} : 0)( true ? {
  name: "abcix4",
  styles: "top:0"
} : 0);
const RightStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(VerticalStroke,  true ? {
  target: "eaw9yqk2"
} : 0)( true ? {
  name: "1wf8jf",
  styles: "right:0"
} : 0);
const BottomStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(HorizontalStroke,  true ? {
  target: "eaw9yqk1"
} : 0)( true ? {
  name: "8tapst",
  styles: "bottom:0"
} : 0);
const LeftStroke = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(VerticalStroke,  true ? {
  target: "eaw9yqk0"
} : 0)( true ? {
  name: "1ode3cm",
  styles: "left:0"
} : 0);
//# sourceMappingURL=box-control-icon-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/icon.js



/**
 * Internal dependencies
 */

const BASE_ICON_SIZE = 24;
function BoxControlIcon(_ref) {
  let {
    size = 24,
    side = 'all',
    sides,
    ...props
  } = _ref;

  const isSideDisabled = value => (sides === null || sides === void 0 ? void 0 : sides.length) && !sides.includes(value);

  const hasSide = value => {
    if (isSideDisabled(value)) {
      return false;
    }

    return side === 'all' || side === value;
  };

  const top = hasSide('top') || hasSide('vertical');
  const right = hasSide('right') || hasSide('horizontal');
  const bottom = hasSide('bottom') || hasSide('vertical');
  const left = hasSide('left') || hasSide('horizontal'); // Simulates SVG Icon scaling.

  const scale = size / BASE_ICON_SIZE;
  return (0,react.createElement)(box_control_icon_styles_Root, (0,helpers_esm_extends/* default */.A)({
    style: {
      transform: `scale(${scale})`
    }
  }, props), (0,react.createElement)(Viewbox, null, (0,react.createElement)(TopStroke, {
    isFocused: top
  }), (0,react.createElement)(RightStroke, {
    isFocused: right
  }), (0,react.createElement)(BottomStroke, {
    isFocused: bottom
  }), (0,react.createElement)(LeftStroke, {
    isFocused: left
  })));
}
//# sourceMappingURL=icon.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/link.js

/**
 * WordPress dependencies
 */

const link_link = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M10 17.389H8.444A5.194 5.194 0 1 1 8.444 7H10v1.5H8.444a3.694 3.694 0 0 0 0 7.389H10v1.5ZM14 7h1.556a5.194 5.194 0 0 1 0 10.39H14v-1.5h1.556a3.694 3.694 0 0 0 0-7.39H14V7Zm-4.5 6h5v-1.5h-5V13Z"
}));
/* harmony default export */ const library_link = (link_link);
//# sourceMappingURL=link.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/link-off.js

/**
 * WordPress dependencies
 */

const linkOff = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M17.031 4.703 15.576 4l-1.56 3H14v.03l-2.324 4.47H9.5V13h1.396l-1.502 2.889h-.95a3.694 3.694 0 0 1 0-7.389H10V7H8.444a5.194 5.194 0 1 0 0 10.389h.17L7.5 19.53l1.416.719L15.049 8.5h.507a3.694 3.694 0 0 1 0 7.39H14v1.5h1.556a5.194 5.194 0 0 0 .273-10.383l1.202-2.304Z"
}));
/* harmony default export */ const link_off = (linkOff);
//# sourceMappingURL=link-off.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/linked-button.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function LinkedButton(_ref) {
  let {
    isLinked,
    ...props
  } = _ref;
  const label = isLinked ? (0,i18n_build_module.__)('Unlink Sides') : (0,i18n_build_module.__)('Link Sides');
  return (0,react.createElement)(tooltip, {
    text: label
  }, (0,react.createElement)("span", null, (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({}, props, {
    className: "component-box-control__linked-button",
    variant: isLinked ? 'primary' : 'secondary',
    isSmall: true,
    icon: isLinked ? library_link : link_off,
    iconSize: 16,
    "aria-label": label
  }))));
}
//# sourceMappingURL=linked-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/box-control/index.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */













const defaultInputProps = {
  min: 0
};

const box_control_noop = () => {};

function box_control_useUniqueId(idProp) {
  const instanceId = (0,use_instance_id/* default */.A)(BoxControl, 'inspector-box-control');
  return idProp || instanceId;
}

function BoxControl(_ref) {
  let {
    id: idProp,
    inputProps = defaultInputProps,
    onChange = box_control_noop,
    label = (0,i18n_build_module.__)('Box Control'),
    values: valuesProp,
    units,
    sides,
    splitOnAxis = false,
    allowReset = true,
    resetValues = DEFAULT_VALUES
  } = _ref;
  const [values, setValues] = use_controlled_state(valuesProp, {
    fallback: DEFAULT_VALUES
  });
  const inputValues = values || DEFAULT_VALUES;
  const hasInitialValue = isValuesDefined(valuesProp);
  const hasOneSide = (sides === null || sides === void 0 ? void 0 : sides.length) === 1;
  const [isDirty, setIsDirty] = (0,react.useState)(hasInitialValue);
  const [isLinked, setIsLinked] = (0,react.useState)(!hasInitialValue || !isValuesMixed(inputValues) || hasOneSide);
  const [side, setSide] = (0,react.useState)(getInitialSide(isLinked, splitOnAxis)); // Tracking selected units via internal state allows filtering of CSS unit
  // only values from being saved while maintaining preexisting unit selection
  // behaviour. Filtering CSS only values prevents invalid style values.

  const [selectedUnits, setSelectedUnits] = (0,react.useState)({
    top: parseQuantityAndUnitFromRawValue(valuesProp === null || valuesProp === void 0 ? void 0 : valuesProp.top)[1],
    right: parseQuantityAndUnitFromRawValue(valuesProp === null || valuesProp === void 0 ? void 0 : valuesProp.right)[1],
    bottom: parseQuantityAndUnitFromRawValue(valuesProp === null || valuesProp === void 0 ? void 0 : valuesProp.bottom)[1],
    left: parseQuantityAndUnitFromRawValue(valuesProp === null || valuesProp === void 0 ? void 0 : valuesProp.left)[1]
  });
  const id = box_control_useUniqueId(idProp);
  const headingId = `${id}-heading`;

  const toggleLinked = () => {
    setIsLinked(!isLinked);
    setSide(getInitialSide(!isLinked, splitOnAxis));
  };

  const handleOnFocus = (event, _ref2) => {
    let {
      side: nextSide
    } = _ref2;
    setSide(nextSide);
  };

  const handleOnChange = nextValues => {
    onChange(nextValues);
    setValues(nextValues);
    setIsDirty(true);
  };

  const handleOnReset = () => {
    onChange(resetValues);
    setValues(resetValues);
    setSelectedUnits(resetValues);
    setIsDirty(false);
  };

  const inputControlProps = { ...inputProps,
    onChange: handleOnChange,
    onFocus: handleOnFocus,
    isLinked,
    units,
    selectedUnits,
    setSelectedUnits,
    sides,
    values: inputValues
  };
  return (0,react.createElement)(box_control_styles_Root, {
    id: id,
    role: "group",
    "aria-labelledby": headingId
  }, (0,react.createElement)(Header, {
    className: "component-box-control__header"
  }, (0,react.createElement)(flex_item_component, null, (0,react.createElement)(BaseControl.VisualLabel, {
    id: headingId
  }, label)), allowReset && (0,react.createElement)(flex_item_component, null, (0,react.createElement)(build_module_button, {
    className: "component-box-control__reset-button",
    isSecondary: true,
    isSmall: true,
    onClick: handleOnReset,
    disabled: !isDirty
  }, (0,i18n_build_module.__)('Reset')))), (0,react.createElement)(HeaderControlWrapper, {
    className: "component-box-control__header-control-wrapper"
  }, (0,react.createElement)(flex_item_component, null, (0,react.createElement)(BoxControlIcon, {
    side: side,
    sides: sides
  })), isLinked && (0,react.createElement)(flex_block_component, null, (0,react.createElement)(AllInputControl, (0,helpers_esm_extends/* default */.A)({
    "aria-label": label
  }, inputControlProps))), !isLinked && splitOnAxis && (0,react.createElement)(flex_block_component, null, (0,react.createElement)(AxialInputControls, inputControlProps)), !hasOneSide && (0,react.createElement)(flex_item_component, null, (0,react.createElement)(LinkedButton, {
    onClick: toggleLinked,
    isLinked: isLinked
  }))), !isLinked && !splitOnAxis && (0,react.createElement)(BoxInputControls, inputControlProps));
}

//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js
var use_ref_effect = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/provider/block-refs-provider.js


/**
 * WordPress dependencies
 */

const BlockRefs = (0,react.createContext)({
  refs: new Map(),
  callbacks: new Map()
});
function BlockRefsProvider(_ref) {
  let {
    children
  } = _ref;
  const value = (0,react.useMemo)(() => ({
    refs: new Map(),
    callbacks: new Map()
  }), []);
  return (0,react.createElement)(BlockRefs.Provider, {
    value: value
  }, children);
}
//# sourceMappingURL=block-refs-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').RefCallback} RefCallback */

/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Provides a ref to the BlockRefs context.
 *
 * @param {string} clientId The client ID of the element ref.
 *
 * @return {RefCallback} Ref callback.
 */

function useBlockRefProvider(clientId) {
  const {
    refs,
    callbacks
  } = (0,react.useContext)(BlockRefs);
  const ref = (0,react.useRef)();
  (0,react.useLayoutEffect)(() => {
    refs.set(ref, clientId);
    return () => {
      refs.delete(ref);
    };
  }, [clientId]);
  return (0,use_ref_effect/* default */.A)(element => {
    // Update the ref in the provider.
    ref.current = element; // Call any update functions.

    callbacks.forEach((id, setElement) => {
      if (clientId === id) {
        setElement(element);
      }
    });
  }, [clientId]);
}
/**
 * Gets a ref pointing to the current block element. Continues to return a
 * stable ref even if the block client ID changes.
 *
 * @param {string} clientId The client ID to get a ref for.
 *
 * @return {RefObject} A ref containing the element.
 */

function useBlockRef(clientId) {
  const {
    refs
  } = (0,react.useContext)(BlockRefs);
  const freshClientId = (0,react.useRef)();
  freshClientId.current = clientId; // Always return an object, even if no ref exists for a given client ID, so
  // that `current` works at a later point.

  return (0,react.useMemo)(() => ({
    get current() {
      let element = null; // Multiple refs may be created for a single block. Find the
      // first that has an element set.

      for (const [ref, id] of refs.entries()) {
        if (id === freshClientId.current && ref.current) {
          element = ref.current;
        }
      }

      return element;
    }

  }), []);
}
/**
 * Return the element for a given client ID. Updates whenever the element
 * changes, becomes available, or disappears.
 *
 * @param {string} clientId The client ID to an element for.
 *
 * @return {Element|null} The block's wrapper element.
 */


function useBlockElement(clientId) {
  const {
    callbacks
  } = (0,react.useContext)(BlockRefs);
  const ref = useBlockRef(clientId);
  const [element, setElement] = (0,react.useState)(null);
  (0,react.useLayoutEffect)(() => {
    if (!clientId) {
      return;
    }

    callbacks.set(setElement, clientId);
    return () => {
      callbacks.delete(setElement);
    };
  }, [clientId]);
  return ref.current || element;
}



//# sourceMappingURL=use-block-refs.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Checks is given value is a spacing preset.
 *
 * @param {string} value Value to check
 *
 * @return {boolean} Return true if value is string in format var:preset|spacing|.
 */

function isValueSpacingPreset(value) {
  if (!(value !== null && value !== void 0 && value.includes)) {
    return false;
  }

  return value === '0' || value.includes('var:preset|spacing|');
}
/**
 * Converts a spacing preset into a custom value.
 *
 * @param {string} value        Value to convert
 * @param {Array}  spacingSizes Array of the current spacing preset objects
 *
 * @return {string} Mapping of the spacing preset to its equivalent custom value.
 */

function getCustomValueFromPreset(value, spacingSizes) {
  if (!isValueSpacingPreset(value)) {
    return value;
  }

  const slug = getSpacingPresetSlug(value);
  const spacingSize = spacingSizes.find(size => String(size.slug) === slug);
  return spacingSize === null || spacingSize === void 0 ? void 0 : spacingSize.size;
}
/**
 * Converts a spacing preset into a custom value.
 *
 * @param {string} value Value to convert.
 *
 * @return {string} CSS var string for given spacing preset value.
 */

function getSpacingPresetCssVar(value) {
  if (!value) {
    return;
  }

  const slug = value.match(/var:preset\|spacing\|(.+)/);

  if (!slug) {
    return value;
  }

  return `var(--wp--preset--spacing--${slug[1]})`;
}
/**
 * Returns the slug section of the given spacing preset string.
 *
 * @param {string} value Value to extract slug from.
 *
 * @return {number} The int value of the slug from given spacing preset.
 */

function getSpacingPresetSlug(value) {
  if (!value) {
    return;
  }

  if (value === '0' || value === 'default') {
    return value;
  }

  const slug = value.match(/var:preset\|spacing\|(.+)/);
  return slug ? slug[1] : undefined;
}
/**
 * Converts spacing preset value into a Range component value .
 *
 * @param {string} presetValue  Value to convert to Range value.
 * @param {Array}  spacingSizes Array of current spacing preset value objects.
 *
 * @return {number} The int value for use in Range control.
 */

function getSliderValueFromPreset(presetValue, spacingSizes) {
  if (presetValue === undefined) {
    return 0;
  }

  const slug = parseFloat(presetValue, 10) === 0 ? '0' : getSpacingPresetSlug(presetValue);
  const sliderValue = spacingSizes.findIndex(spacingSize => {
    return String(spacingSize.slug) === slug;
  }); // Returning NaN rather than undefined as undefined makes range control thumb sit in center

  return sliderValue !== -1 ? sliderValue : NaN;
}
const utils_LABELS = {
  all: (0,_wordpress_i18n_build_module.__)('All sides'),
  top: (0,_wordpress_i18n_build_module.__)('Top'),
  bottom: (0,_wordpress_i18n_build_module.__)('Bottom'),
  left: (0,_wordpress_i18n_build_module.__)('Left'),
  right: (0,_wordpress_i18n_build_module.__)('Right'),
  mixed: (0,_wordpress_i18n_build_module.__)('Mixed'),
  vertical: (0,_wordpress_i18n_build_module.__)('Vertical'),
  horizontal: (0,_wordpress_i18n_build_module.__)('Horizontal')
};
const utils_DEFAULT_VALUES = {
  top: undefined,
  right: undefined,
  bottom: undefined,
  left: undefined
};
const utils_ALL_SIDES = ['top', 'right', 'bottom', 'left'];
/**
 * Gets an items with the most occurrence within an array
 * https://stackoverflow.com/a/20762713
 *
 * @param {Array<any>} arr Array of items to check.
 * @return {any} The item with the most occurrences.
 */

function utils_mode(arr) {
  return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();
}
/**
 * Gets the 'all' input value from values data.
 *
 * @param {Object} values Box spacing values
 *
 * @return {string} The most common value from all sides of box.
 */


function getAllRawValue() {
  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return utils_mode(Object.values(values));
}
/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values Box values.
 * @param {Array}  sides  Sides that values relate to.
 *
 * @return {boolean} Whether values are mixed.
 */

function utils_isValuesMixed() {
  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let sides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils_ALL_SIDES;
  return Object.values(values).length >= 1 && Object.values(values).length < sides.length || new Set(Object.values(values)).size > 1;
}
/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Box values.
 *
 * @return {boolean} Whether values are defined.
 */

function utils_isValuesDefined(values) {
  return values !== undefined && !(0,lodash.isEmpty)(Object.values(values).filter( // Switching units when input is empty causes values only
  // containing units. This gives false positive on mixed values
  // unless filtered.
  value => !!value && /\d/.test(value)));
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/use-setting/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const blockedPaths = ['color', 'border', 'typography', 'spacing'];
const deprecatedFlags = {
  'color.palette': settings => settings.colors === undefined ? undefined : settings.colors,
  'color.gradients': settings => settings.gradients === undefined ? undefined : settings.gradients,
  'color.custom': settings => settings.disableCustomColors === undefined ? undefined : !settings.disableCustomColors,
  'color.customGradient': settings => settings.disableCustomGradients === undefined ? undefined : !settings.disableCustomGradients,
  'typography.fontSizes': settings => settings.fontSizes === undefined ? undefined : settings.fontSizes,
  'typography.customFontSize': settings => settings.disableCustomFontSizes === undefined ? undefined : !settings.disableCustomFontSizes,
  'typography.lineHeight': settings => settings.enableCustomLineHeight,
  'spacing.units': settings => {
    if (settings.enableCustomUnits === undefined) {
      return;
    }

    if (settings.enableCustomUnits === true) {
      return ['px', 'em', 'rem', 'vh', 'vw', '%'];
    }

    return settings.enableCustomUnits;
  },
  'spacing.padding': settings => settings.enableCustomSpacing
};
const prefixedFlags = {
  /*
   * These were only available in the plugin
   * and can be removed when the minimum WordPress version
   * for the plugin is 5.9.
   */
  'border.customColor': 'border.color',
  'border.customStyle': 'border.style',
  'border.customWidth': 'border.width',
  'typography.customFontStyle': 'typography.fontStyle',
  'typography.customFontWeight': 'typography.fontWeight',
  'typography.customLetterSpacing': 'typography.letterSpacing',
  'typography.customTextDecorations': 'typography.textDecoration',
  'typography.customTextTransforms': 'typography.textTransform',

  /*
   * These were part of WordPress 5.8 and we need to keep them.
   */
  'border.customRadius': 'border.radius',
  'spacing.customMargin': 'spacing.margin',
  'spacing.customPadding': 'spacing.padding',
  'typography.customLineHeight': 'typography.lineHeight'
};
/**
 * Remove `custom` prefixes for flags that did not land in 5.8.
 *
 * This provides continued support for `custom` prefixed properties. It will
 * be removed once third party devs have had sufficient time to update themes,
 * plugins, etc.
 *
 * @see https://github.com/WordPress/gutenberg/pull/34485
 *
 * @param {string} path Path to desired value in settings.
 * @return {string}     The value for defined setting.
 */

const removeCustomPrefixes = path => {
  return prefixedFlags[path] || path;
};
/**
 * Hook that retrieves the given setting for the block instance in use.
 *
 * It looks up the settings first in the block instance hierarchy.
 * If none is found, it'll look it up in the block editor store.
 *
 * @param {string} path The path to the setting.
 * @return {any} Returns the value defined for the setting.
 * @example
 * ```js
 * const isEnabled = useSetting( 'typography.dropCap' );
 * ```
 */


function use_setting_useSetting(path) {
  const {
    name: blockName,
    clientId
  } = context_useBlockEditContext();
  const setting = use_select_useSelect(select => {
    if (blockedPaths.includes(path)) {
      // eslint-disable-next-line no-console
      console.warn('Top level useSetting paths are disabled. Please use a subpath to query the information needed.');
      return undefined;
    }

    let result;
    const normalizedPath = removeCustomPrefixes(path); // 1. Take settings from the block instance or its ancestors.

    const candidates = [...select(store_store).getBlockParents(clientId), clientId // The current block is added last, so it overwrites any ancestor.
    ];
    candidates.forEach(candidateClientId => {
      const candidateBlockName = select(store_store).getBlockName(candidateClientId);

      if ((0,build_module/* hasBlockSupport */.pN)(candidateBlockName, '__experimentalSettings', false)) {
        var _get;

        const candidateAtts = select(store_store).getBlockAttributes(candidateClientId);
        const candidateResult = (_get = (0,lodash.get)(candidateAtts, `settings.blocks.${blockName}.${normalizedPath}`)) !== null && _get !== void 0 ? _get : (0,lodash.get)(candidateAtts, `settings.${normalizedPath}`);

        if (candidateResult !== undefined) {
          result = candidateResult;
        }
      }
    }); // 2. Fall back to the settings from the block editor store (__experimentalFeatures).

    const settings = select(store_store).getSettings();

    if (result === undefined) {
      var _get2;

      const defaultsPath = `__experimentalFeatures.${normalizedPath}`;
      const blockPath = `__experimentalFeatures.blocks.${blockName}.${normalizedPath}`;
      result = (_get2 = (0,lodash.get)(settings, blockPath)) !== null && _get2 !== void 0 ? _get2 : (0,lodash.get)(settings, defaultsPath);
    } // Return if the setting was found in either the block instance or the store.


    if (result !== undefined) {
      if (build_module/* __EXPERIMENTAL_PATHS_WITH_MERGE */.UT[normalizedPath]) {
        var _ref, _result$custom;

        return (_ref = (_result$custom = result.custom) !== null && _result$custom !== void 0 ? _result$custom : result.theme) !== null && _ref !== void 0 ? _ref : result.default;
      }

      return result;
    } // 3. Otherwise, use deprecated settings.


    const deprecatedSettingsValue = deprecatedFlags[normalizedPath] ? deprecatedFlags[normalizedPath](settings) : undefined;

    if (deprecatedSettingsValue !== undefined) {
      return deprecatedSettingsValue;
    } // 4. Fallback for typography.dropCap:
    // This is only necessary to support typography.dropCap.
    // when __experimentalFeatures are not present (core without plugin).
    // To remove when __experimentalFeatures are ported to core.


    return normalizedPath === 'typography.dropCap' ? true : undefined;
  }, [blockName, clientId, path]);
  return setting;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-previous/index.js
/**
 * WordPress dependencies
 */

/**
 * Use something's value from the previous render.
 * Based on https://usehooks.com/usePrevious/.
 *
 * @param  value The value to track.
 *
 * @return The value from the previous render.
 */

function usePrevious(value) {
  const ref = (0,react.useRef)(); // Store current value in ref.

  (0,react.useEffect)(() => {
    ref.current = value;
  }, [value]); // Re-run when value changes.
  // Return previous value (happens before update in useEffect above).

  return ref.current;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/styles.js
function tools_panel_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





const toolsPanelGrid = {
  columns: columns => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("grid-template-columns:", `repeat( ${columns}, minmax(0, 1fr) )`, ";" + ( true ? "" : 0),  true ? "" : 0),
  spacing: /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("column-gap:", space(2), ";row-gap:", space(4), ";" + ( true ? "" : 0),  true ? "" : 0),
  item: {
    fullWidth:  true ? {
      name: "18iuzk9",
      styles: "grid-column:1/-1"
    } : 0
  }
};
const ToolsPanel = columns => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(toolsPanelGrid.columns(columns), " ", toolsPanelGrid.spacing, " border-top:", config_values.borderWidth, " solid ", COLORS.gray[300], ";margin-top:-1px;padding:", space(4), ";" + ( true ? "" : 0),  true ? "" : 0);
/**
 * Items injected into a ToolsPanel via a virtual bubbling slot will require
 * an inner dom element to be injected. The following rule allows for the
 * CSS grid display to be re-established.
 */

const ToolsPanelWithInnerWrapper = columns => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(">div:not( :first-of-type ){display:grid;", toolsPanelGrid.columns(columns), " ", toolsPanelGrid.spacing, " ", toolsPanelGrid.item.fullWidth, ";}" + ( true ? "" : 0),  true ? "" : 0);
};
const ToolsPanelHiddenInnerWrapper =  true ? {
  name: "huufmu",
  styles: ">div:not( :first-of-type ){display:none;}"
} : 0;
const ToolsPanelHeader = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(toolsPanelGrid.item.fullWidth, " gap:", space(2), ";.components-dropdown-menu{margin:", space(-1), " 0;line-height:0;}&&&& .components-dropdown-menu__toggle{padding:0;min-width:", space(6), ";}" + ( true ? "" : 0),  true ? "" : 0);
const ToolsPanelHeading =  true ? {
  name: "1pmxm02",
  styles: "font-size:inherit;font-weight:500;line-height:normal;&&{margin:0;}"
} : 0;
const ToolsPanelItem = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(toolsPanelGrid.item.fullWidth, "&>div,&>fieldset{padding-bottom:0;margin-bottom:0;max-width:100%;}&& ", Wrapper, "{margin-bottom:0;", StyledField, ":last-child{margin-bottom:0;}}", StyledHelp, "{margin-bottom:0;}&& ", LabelWrapper, "{label{line-height:1.4em;}}" + ( true ? "" : 0),  true ? "" : 0);
const ToolsPanelItemPlaceholder =  true ? {
  name: "eivff4",
  styles: "display:none"
} : 0;
const styles_DropdownMenu =  true ? {
  name: "16gsvie",
  styles: "min-width:200px"
} : 0;
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/context.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const context_noop = () => undefined;

const ToolsPanelContext = (0,react.createContext)({
  menuItems: {
    default: {},
    optional: {}
  },
  hasMenuItems: false,
  isResetting: false,
  shouldRenderPlaceholderItems: false,
  registerPanelItem: context_noop,
  deregisterPanelItem: context_noop,
  flagItemCustomization: context_noop,
  areAllOptionalControlsHidden: true
});
const useToolsPanelContext = () => (0,react.useContext)(ToolsPanelContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-item/hook.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function useToolsPanelItem(props) {
  var _menuItems$menuGroup, _menuItems$menuGroup2;

  const {
    className,
    hasValue,
    isShownByDefault,
    label,
    panelId,
    resetAllFilter,
    onDeselect,
    onSelect,
    ...otherProps
  } = useContextSystem(props, 'ToolsPanelItem');
  const {
    panelId: currentPanelId,
    menuItems,
    registerPanelItem,
    deregisterPanelItem,
    flagItemCustomization,
    isResetting,
    shouldRenderPlaceholderItems: shouldRenderPlaceholder,
    firstDisplayedItem,
    lastDisplayedItem,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass
  } = useToolsPanelContext();
  const hasValueCallback = (0,react.useCallback)(hasValue, [panelId]);
  const resetAllFilterCallback = (0,react.useCallback)(resetAllFilter, [panelId]);
  const previousPanelId = usePrevious(currentPanelId);
  const hasMatchingPanel = currentPanelId === panelId || currentPanelId === null; // Registering the panel item allows the panel to include it in its
  // automatically generated menu and determine its initial checked status.

  (0,react.useEffect)(() => {
    if (hasMatchingPanel && previousPanelId !== null) {
      registerPanelItem({
        hasValue: hasValueCallback,
        isShownByDefault,
        label,
        resetAllFilter: resetAllFilterCallback,
        panelId
      });
    }

    return () => {
      if (previousPanelId === null && !!currentPanelId || currentPanelId === panelId) {
        deregisterPanelItem(label);
      }
    };
  }, [currentPanelId, hasMatchingPanel, isShownByDefault, label, hasValueCallback, panelId, previousPanelId, resetAllFilterCallback]);
  const isValueSet = hasValue();
  const wasValueSet = usePrevious(isValueSet); // If this item represents a default control it will need to notify the
  // panel when a custom value has been set.

  (0,react.useEffect)(() => {
    if (isShownByDefault && isValueSet && !wasValueSet) {
      flagItemCustomization(label);
    }
  }, [isValueSet, wasValueSet, isShownByDefault, label]); // Note: `label` is used as a key when building menu item state in
  // `ToolsPanel`.

  const menuGroup = isShownByDefault ? 'default' : 'optional';
  const isMenuItemChecked = menuItems === null || menuItems === void 0 ? void 0 : (_menuItems$menuGroup = menuItems[menuGroup]) === null || _menuItems$menuGroup === void 0 ? void 0 : _menuItems$menuGroup[label];
  const wasMenuItemChecked = usePrevious(isMenuItemChecked); // Determine if the panel item's corresponding menu is being toggled and
  // trigger appropriate callback if it is.

  (0,react.useEffect)(() => {
    if (isResetting || !hasMatchingPanel) {
      return;
    }

    if (isMenuItemChecked && !isValueSet && !wasMenuItemChecked) {
      onSelect === null || onSelect === void 0 ? void 0 : onSelect();
    }

    if (!isMenuItemChecked && wasMenuItemChecked) {
      onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect();
    }
  }, [hasMatchingPanel, isMenuItemChecked, isResetting, isValueSet, wasMenuItemChecked]); // The item is shown if it is a default control regardless of whether it
  // has a value. Optional items are shown when they are checked or have
  // a value.

  const isShown = isShownByDefault ? (menuItems === null || menuItems === void 0 ? void 0 : (_menuItems$menuGroup2 = menuItems[menuGroup]) === null || _menuItems$menuGroup2 === void 0 ? void 0 : _menuItems$menuGroup2[label]) !== undefined : isMenuItemChecked;
  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    const placeholderStyle = shouldRenderPlaceholder && !isShown && ToolsPanelItemPlaceholder;
    const firstItemStyle = firstDisplayedItem === label && __experimentalFirstVisibleItemClass;
    const lastItemStyle = lastDisplayedItem === label && __experimentalLastVisibleItemClass;
    return cx(ToolsPanelItem, placeholderStyle, className, firstItemStyle, lastItemStyle);
  }, [isShown, shouldRenderPlaceholder, className, cx, firstDisplayedItem, lastDisplayedItem, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass]);
  return { ...otherProps,
    isShown,
    shouldRenderPlaceholder,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-item/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




// This wraps controls to be conditionally displayed within a tools panel. It
// prevents props being applied to HTML elements that would make them invalid.
const component_ToolsPanelItem = (props, forwardedRef) => {
  const {
    children,
    isShown,
    shouldRenderPlaceholder,
    ...toolsPanelItemProps
  } = useToolsPanelItem(props);

  if (!isShown) {
    return shouldRenderPlaceholder ? (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, toolsPanelItemProps, {
      ref: forwardedRef
    })) : null;
  }

  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, toolsPanelItemProps, {
    ref: forwardedRef
  }), children);
};

const ConnectedToolsPanelItem = contextConnect(component_ToolsPanelItem, 'ToolsPanelItem');
/* harmony default export */ const tools_panel_item_component = (ConnectedToolsPanelItem);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/groups.js
/**
 * WordPress dependencies
 */

const InspectorControlsDefault = createSlotFill('InspectorControls');
const InspectorControlsAdvanced = createSlotFill('InspectorAdvancedControls');
const InspectorControlsBorder = createSlotFill('InspectorControlsBorder');
const InspectorControlsColor = createSlotFill('InspectorControlsColor');
const InspectorControlsDimensions = createSlotFill('InspectorControlsDimensions');
const InspectorControlsTypography = createSlotFill('InspectorControlsTypography');
const groups_groups = {
  default: InspectorControlsDefault,
  advanced: InspectorControlsAdvanced,
  border: InspectorControlsBorder,
  color: InspectorControlsColor,
  dimensions: InspectorControlsDimensions,
  typography: InspectorControlsTypography
};
/* harmony default export */ const inspector_controls_groups = (groups_groups);
//# sourceMappingURL=groups.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/fill.js
/* provided dependency */ var fill_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function InspectorControlsFill(_ref) {
  var _groups$group;

  let {
    __experimentalGroup: group = 'default',
    children
  } = _ref;
  const isDisplayed = useDisplayBlockControls();
  const Fill = (_groups$group = inspector_controls_groups[group]) === null || _groups$group === void 0 ? void 0 : _groups$group.Fill;

  if (!Fill) {
    typeof fill_process !== "undefined" && fill_process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  if (!isDisplayed) {
    return null;
  }

  return (0,react.createElement)(style_provider, {
    document: document
  }, (0,react.createElement)(Fill, null, fillProps => {
    // Children passed to InspectorControlsFill will not have
    // access to any React Context whose Provider is part of
    // the InspectorControlsSlot tree. So we re-create the
    // Provider in this subtree.
    const value = !(0,lodash.isEmpty)(fillProps) ? fillProps : null;
    return (0,react.createElement)(ToolsPanelContext.Provider, {
      value: value
    }, children);
  }));
}
//# sourceMappingURL=fill.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/reset.js

/**
 * WordPress dependencies
 */

const reset_reset = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M7 11.5h10V13H7z"
}));
/* harmony default export */ const library_reset = (reset_reset);
//# sourceMappingURL=reset.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/check.js

/**
 * WordPress dependencies
 */

const check = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M16.7 7.1l-6.3 8.5-3.3-2.5-.9 1.2 4.5 3.4L17.9 8z"
}));
/* harmony default export */ const library_check = (check);
//# sourceMappingURL=check.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/plus.js

/**
 * WordPress dependencies
 */

const plus = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M18 11.2h-5.2V6h-1.6v5.2H6v1.6h5.2V18h1.6v-5.2H18z"
}));
/* harmony default export */ const library_plus = (plus);
//# sourceMappingURL=plus.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/more-vertical.js

/**
 * WordPress dependencies
 */

const moreVertical = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z"
}));
/* harmony default export */ const more_vertical = (moreVertical);
//# sourceMappingURL=more-vertical.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/h-stack/utils.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const H_ALIGNMENTS = {
  bottom: {
    align: 'flex-end',
    justify: 'center'
  },
  bottomLeft: {
    align: 'flex-start',
    justify: 'flex-end'
  },
  bottomRight: {
    align: 'flex-end',
    justify: 'flex-end'
  },
  center: {
    align: 'center',
    justify: 'center'
  },
  edge: {
    align: 'center',
    justify: 'space-between'
  },
  left: {
    align: 'center',
    justify: 'flex-start'
  },
  right: {
    align: 'center',
    justify: 'flex-end'
  },
  stretch: {
    align: 'stretch'
  },
  top: {
    align: 'flex-start',
    justify: 'center'
  },
  topLeft: {
    align: 'flex-start',
    justify: 'flex-start'
  },
  topRight: {
    align: 'flex-start',
    justify: 'flex-end'
  }
};
const V_ALIGNMENTS = {
  bottom: {
    justify: 'flex-end',
    align: 'center'
  },
  bottomLeft: {
    justify: 'flex-start',
    align: 'flex-end'
  },
  bottomRight: {
    justify: 'flex-end',
    align: 'flex-end'
  },
  center: {
    justify: 'center',
    align: 'center'
  },
  edge: {
    justify: 'space-between',
    align: 'center'
  },
  left: {
    justify: 'center',
    align: 'flex-start'
  },
  right: {
    justify: 'center',
    align: 'flex-end'
  },
  stretch: {
    justify: 'stretch'
  },
  top: {
    justify: 'flex-start',
    align: 'center'
  },
  topLeft: {
    justify: 'flex-start',
    align: 'flex-start'
  },
  topRight: {
    justify: 'flex-start',
    align: 'flex-end'
  }
};
function getAlignmentProps(alignment) {
  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'row';

  if (!isValueDefined(alignment)) {
    return {};
  }

  const isVertical = direction === 'column';
  const props = isVertical ? V_ALIGNMENTS : H_ALIGNMENTS;
  const alignmentProps = alignment in props ? props[alignment] : {
    align: alignment
  };
  return alignmentProps;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/utils/get-valid-children.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Gets a collection of available children elements from a React component's children prop.
 *
 * @param  children
 *
 * @return An array of available children.
 */

function getValidChildren(children) {
  if (typeof children === 'string') return [children];
  return react.Children.toArray(children).filter(child => (0,react.isValidElement)(child));
}
//# sourceMappingURL=get-valid-children.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/h-stack/hook.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function useHStack(props) {
  const {
    alignment = 'edge',
    children,
    direction,
    spacing = 2,
    ...otherProps
  } = useContextSystem(props, 'HStack');
  const align = getAlignmentProps(alignment, direction);
  const validChildren = getValidChildren(children);
  const clonedChildren = validChildren.map((child, index) => {
    const _isSpacer = hasConnectNamespace(child, ['Spacer']);

    if (_isSpacer) {
      const childElement = child;

      const _key = childElement.key || `hstack-${index}`;

      return (0,react.createElement)(flex_item_component, (0,helpers_esm_extends/* default */.A)({
        isBlock: true,
        key: _key
      }, childElement.props));
    }

    return child;
  });
  const propsForFlex = {
    children: clonedChildren,
    direction,
    justify: 'center',
    ...align,
    ...otherProps,
    gap: spacing
  };
  const flexProps = useFlex(propsForFlex);
  return flexProps;
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/h-stack/component.js



/**
 * Internal dependencies
 */




function UnconnectedHStack(props, forwardedRef) {
  const hStackProps = useHStack(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, hStackProps, {
    ref: forwardedRef
  }));
}
/**
 * `HStack` (Horizontal Stack) arranges child elements in a horizontal line.
 *
 * `HStack` can render anything inside.
 *
 * @example
 * ```jsx
 * import {
 * 	__experimentalHStack as HStack,
 * 	__experimentalText as Text,
 * } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<HStack>
 * 			<Text>Code</Text>
 * 			<Text>is</Text>
 * 			<Text>Poetry</Text>
 * 		</HStack>
 * 	);
 * }
 * ```
 */


const HStack = contextConnect(UnconnectedHStack, 'HStack');
/* harmony default export */ const h_stack_component = (HStack);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/heading/hook.js
/**
 * Internal dependencies
 */




function useHeading(props) {
  const {
    as: asProp,
    level = 2,
    ...otherProps
  } = useContextSystem(props, 'Heading');
  const as = asProp || `h${level}`;
  const a11yProps = {};

  if (typeof as === 'string' && as[0] !== 'h') {
    // If not a semantic `h` element, add a11y props:
    a11yProps.role = 'heading';
    a11yProps['aria-level'] = typeof level === 'string' ? parseInt(level) : level;
  }

  const textProps = useText({
    color: COLORS.gray[900],
    size: getHeadingFontSize(level),
    isBlock: true,
    weight: config_values.fontWeightHeading,
    ...otherProps
  });
  return { ...textProps,
    ...a11yProps,
    as
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/heading/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedHeading(props, forwardedRef) {
  const headerProps = useHeading(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, headerProps, {
    ref: forwardedRef
  }));
}
/**
 * `Heading` renders headings and titles using the library's typography system.
 *
 * ```jsx
 * import { __experimentalHeading as Heading } from "@wordpress/components";
 *
 * function Example() {
 *   return <Heading>Code is Poetry</Heading>;
 * }
 * ```
 */


const Heading = contextConnect(UnconnectedHeading, 'Heading');
/* harmony default export */ const heading_component = (Heading);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-header/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





function useToolsPanelHeader(props) {
  const {
    className,
    ...otherProps
  } = useContextSystem(props, 'ToolsPanelHeader');
  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    return cx(ToolsPanelHeader, className);
  }, [className, cx]);
  const dropdownMenuClassName = (0,react.useMemo)(() => {
    return cx(styles_DropdownMenu);
  }, [cx]);
  const headingClassName = (0,react.useMemo)(() => {
    return cx(ToolsPanelHeading);
  }, [cx]);
  const {
    menuItems,
    hasMenuItems,
    areAllOptionalControlsHidden
  } = useToolsPanelContext();
  return { ...otherProps,
    areAllOptionalControlsHidden,
    dropdownMenuClassName,
    hasMenuItems,
    headingClassName,
    menuItems,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/tools-panel-header/component.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */









const DefaultControlsGroup = _ref => {
  let {
    items,
    toggleItem
  } = _ref;

  if (!items.length) {
    return null;
  }

  return (0,react.createElement)(menu_group, null, items.map(_ref2 => {
    let [label, hasValue] = _ref2;

    if (hasValue) {
      return (0,react.createElement)(menu_item, {
        key: label,
        role: "menuitem",
        icon: library_reset,
        label: (0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the control being reset e.g. "Padding".
        (0,i18n_build_module.__)('Reset %s'), label),
        onClick: () => {
          toggleItem(label);
          speak((0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the control being reset e.g. "Padding".
          (0,i18n_build_module.__)('%s reset to default'), label), 'assertive');
        }
      }, label);
    }

    return (0,react.createElement)(menu_item, {
      key: label,
      role: "menuitemcheckbox",
      icon: library_check,
      isSelected: true,
      "aria-disabled": true
    }, label);
  }));
};

const OptionalControlsGroup = _ref3 => {
  let {
    items,
    toggleItem
  } = _ref3;

  if (!items.length) {
    return null;
  }

  return (0,react.createElement)(menu_group, null, items.map(_ref4 => {
    let [label, isSelected] = _ref4;
    const itemLabel = isSelected ? (0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the control being hidden and reset e.g. "Padding".
    (0,i18n_build_module.__)('Hide and reset %s'), label) : (0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the control to display e.g. "Padding".
    (0,i18n_build_module.__)('Show %s'), label);
    return (0,react.createElement)(menu_item, {
      key: label,
      icon: isSelected && library_check,
      isSelected: isSelected,
      label: itemLabel,
      onClick: () => {
        if (isSelected) {
          speak((0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the control being reset e.g. "Padding".
          (0,i18n_build_module.__)('%s hidden and reset to default'), label), 'assertive');
        } else {
          speak((0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the control being reset e.g. "Padding".
          (0,i18n_build_module.__)('%s is now visible'), label), 'assertive');
        }

        toggleItem(label);
      },
      role: "menuitemcheckbox"
    }, label);
  }));
};

const component_ToolsPanelHeader = (props, forwardedRef) => {
  const {
    areAllOptionalControlsHidden,
    dropdownMenuClassName,
    hasMenuItems,
    headingClassName,
    label: labelText,
    menuItems,
    resetAll,
    toggleItem,
    ...headerProps
  } = useToolsPanelHeader(props);

  if (!labelText) {
    return null;
  }

  const defaultItems = Object.entries((menuItems === null || menuItems === void 0 ? void 0 : menuItems.default) || {});
  const optionalItems = Object.entries((menuItems === null || menuItems === void 0 ? void 0 : menuItems.optional) || {});
  const dropDownMenuIcon = areAllOptionalControlsHidden ? library_plus : more_vertical;
  const dropDownMenuLabelText = (0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the tool e.g. "Color" or "Typography".
  (0,i18n_build_module._x)('%s options', 'Button label to reveal tool panel options'), labelText);
  const dropdownMenuDescriptionText = areAllOptionalControlsHidden ? (0,i18n_build_module.__)('All options are currently hidden') : undefined;
  const canResetAll = [...defaultItems, ...optionalItems].some(_ref5 => {
    let [, isSelected] = _ref5;
    return isSelected;
  });
  return (0,react.createElement)(h_stack_component, (0,helpers_esm_extends/* default */.A)({}, headerProps, {
    ref: forwardedRef
  }), (0,react.createElement)(heading_component, {
    level: 2,
    className: headingClassName
  }, labelText), hasMenuItems && (0,react.createElement)(dropdown_menu, {
    icon: dropDownMenuIcon,
    label: dropDownMenuLabelText,
    menuProps: {
      className: dropdownMenuClassName
    },
    toggleProps: {
      isSmall: true,
      describedBy: dropdownMenuDescriptionText
    }
  }, () => (0,react.createElement)(react.Fragment, null, (0,react.createElement)(DefaultControlsGroup, {
    items: defaultItems,
    toggleItem: toggleItem
  }), (0,react.createElement)(OptionalControlsGroup, {
    items: optionalItems,
    toggleItem: toggleItem
  }), (0,react.createElement)(menu_group, null, (0,react.createElement)(menu_item, {
    "aria-disabled": !canResetAll,
    variant: 'tertiary',
    onClick: () => {
      if (canResetAll) {
        resetAll();
        speak((0,i18n_build_module.__)('All options reset'), 'assertive');
      }
    }
  }, (0,i18n_build_module.__)('Reset all'))))));
};

const ConnectedToolsPanelHeader = contextConnect(component_ToolsPanelHeader, 'ToolsPanelHeader');
/* harmony default export */ const tools_panel_header_component = (ConnectedToolsPanelHeader);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/tools-panel/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const DEFAULT_COLUMNS = 2;

const generateMenuItems = _ref => {
  let {
    panelItems,
    shouldReset,
    currentMenuItems
  } = _ref;
  const menuItems = {
    default: {},
    optional: {}
  };
  panelItems.forEach(_ref2 => {
    var _currentMenuItems$gro;

    let {
      hasValue,
      isShownByDefault,
      label
    } = _ref2;
    const group = isShownByDefault ? 'default' : 'optional'; // If a menu item for this label already exists, do not overwrite its value.
    // This can cause default controls that have been flagged as customized to
    // lose their value.

    const existingItemValue = currentMenuItems === null || currentMenuItems === void 0 ? void 0 : (_currentMenuItems$gro = currentMenuItems[group]) === null || _currentMenuItems$gro === void 0 ? void 0 : _currentMenuItems$gro[label];
    const value = existingItemValue !== undefined ? existingItemValue : hasValue();
    menuItems[group][label] = shouldReset ? false : value;
  });
  return menuItems;
};

const isMenuItemTypeEmpty = obj => obj && Object.keys(obj).length === 0;

function useToolsPanel(props) {
  const {
    className,
    resetAll,
    panelId,
    hasInnerWrapper,
    shouldRenderPlaceholderItems,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass,
    ...otherProps
  } = useContextSystem(props, 'ToolsPanel');
  const isResetting = (0,react.useRef)(false);
  const wasResetting = isResetting.current; // `isResetting` is cleared via this hook to effectively batch together
  // the resetAll task. Without this, the flag is cleared after the first
  // control updates and forces a rerender with subsequent controls then
  // believing they need to reset, unfortunately using stale data.

  (0,react.useEffect)(() => {
    if (wasResetting) {
      isResetting.current = false;
    }
  }, [wasResetting]); // Allow panel items to register themselves.

  const [panelItems, setPanelItems] = (0,react.useState)([]);
  const registerPanelItem = (0,react.useCallback)(item => {
    setPanelItems(items => {
      const newItems = [...items]; // If an item with this label has already been registered, remove it
      // first. This can happen when an item is moved between the default
      // and optional groups.

      const existingIndex = newItems.findIndex(oldItem => oldItem.label === item.label);

      if (existingIndex !== -1) {
        newItems.splice(existingIndex, 1);
      }

      return [...newItems, item];
    });
  }, [setPanelItems]); // Panels need to deregister on unmount to avoid orphans in menu state.
  // This is an issue when panel items are being injected via SlotFills.

  const deregisterPanelItem = (0,react.useCallback)(label => {
    // When switching selections between components injecting matching
    // controls, e.g. both panels have a "padding" control, the
    // deregistration of the first panel doesn't occur until after the
    // registration of the next.
    setPanelItems(items => {
      const newItems = [...items];
      const index = newItems.findIndex(item => item.label === label);

      if (index !== -1) {
        newItems.splice(index, 1);
      }

      return newItems;
    });
  }, [setPanelItems]); // Manage and share display state of menu items representing child controls.

  const [menuItems, setMenuItems] = (0,react.useState)({
    default: {},
    optional: {}
  }); // Setup menuItems state as panel items register themselves.

  (0,react.useEffect)(() => {
    setMenuItems(prevState => {
      const items = generateMenuItems({
        panelItems,
        shouldReset: false,
        currentMenuItems: prevState
      });
      return items;
    });
  }, [generateMenuItems, panelItems, setMenuItems]); // Force a menu item to be checked.
  // This is intended for use with default panel items. They are displayed
  // separately to optional items and have different display states,
  // we need to update that when their value is customized.

  const flagItemCustomization = (0,react.useCallback)(function (label) {
    let group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
    setMenuItems(items => {
      const newState = { ...items,
        [group]: { ...items[group],
          [label]: true
        }
      };
      return newState;
    });
  }, [setMenuItems]); // Whether all optional menu items are hidden or not must be tracked
  // in order to later determine if the panel display is empty and handle
  // conditional display of a plus icon to indicate the presence of further
  // menu items.

  const [areAllOptionalControlsHidden, setAreAllOptionalControlsHidden] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    if (isMenuItemTypeEmpty(menuItems === null || menuItems === void 0 ? void 0 : menuItems.default) && !isMenuItemTypeEmpty(menuItems === null || menuItems === void 0 ? void 0 : menuItems.optional)) {
      const allControlsHidden = !Object.entries(menuItems.optional).some(_ref3 => {
        let [, isSelected] = _ref3;
        return isSelected;
      });
      setAreAllOptionalControlsHidden(allControlsHidden);
    }
  }, [menuItems, setAreAllOptionalControlsHidden]);
  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    const wrapperStyle = hasInnerWrapper && ToolsPanelWithInnerWrapper(DEFAULT_COLUMNS);
    const emptyStyle = isMenuItemTypeEmpty(menuItems === null || menuItems === void 0 ? void 0 : menuItems.default) && areAllOptionalControlsHidden && ToolsPanelHiddenInnerWrapper;
    return cx(ToolsPanel(DEFAULT_COLUMNS), wrapperStyle, emptyStyle, className);
  }, [areAllOptionalControlsHidden, className, cx, hasInnerWrapper, menuItems]); // Toggle the checked state of a menu item which is then used to determine
  // display of the item within the panel.

  const toggleItem = (0,react.useCallback)(label => {
    const currentItem = panelItems.find(item => item.label === label);

    if (!currentItem) {
      return;
    }

    const menuGroup = currentItem.isShownByDefault ? 'default' : 'optional';
    const newMenuItems = { ...menuItems,
      [menuGroup]: { ...menuItems[menuGroup],
        [label]: !menuItems[menuGroup][label]
      }
    };
    setMenuItems(newMenuItems);
  }, [menuItems, panelItems, setMenuItems]); // Resets display of children and executes resetAll callback if available.

  const resetAllItems = (0,react.useCallback)(() => {
    if (typeof resetAll === 'function') {
      isResetting.current = true; // Collect available reset filters from panel items.

      const filters = [];
      panelItems.forEach(item => {
        if (item.resetAllFilter) {
          filters.push(item.resetAllFilter);
        }
      });
      resetAll(filters);
    } // Turn off display of all non-default items.


    const resetMenuItems = generateMenuItems({
      panelItems,
      shouldReset: true
    });
    setMenuItems(resetMenuItems);
  }, [generateMenuItems, isResetting.current, panelItems, resetAll, setMenuItems]); // Assist ItemGroup styling when there are potentially hidden placeholder
  // items by identifying first & last items that are toggled on for display.

  const getFirstVisibleItemLabel = items => {
    const optionalItems = menuItems.optional || {};
    const firstItem = items.find(item => item.isShownByDefault || !!optionalItems[item.label]);
    return firstItem === null || firstItem === void 0 ? void 0 : firstItem.label;
  };

  const firstDisplayedItem = getFirstVisibleItemLabel(panelItems);
  const lastDisplayedItem = getFirstVisibleItemLabel([...panelItems].reverse());
  const panelContext = (0,react.useMemo)(() => ({
    areAllOptionalControlsHidden,
    deregisterPanelItem,
    firstDisplayedItem,
    flagItemCustomization,
    hasMenuItems: !!panelItems.length,
    isResetting: isResetting.current,
    lastDisplayedItem,
    menuItems,
    panelId,
    registerPanelItem,
    shouldRenderPlaceholderItems,
    __experimentalFirstVisibleItemClass,
    __experimentalLastVisibleItemClass
  }), [areAllOptionalControlsHidden, deregisterPanelItem, firstDisplayedItem, flagItemCustomization, isResetting.current, lastDisplayedItem, menuItems, panelId, panelItems, registerPanelItem, shouldRenderPlaceholderItems, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass]);
  return { ...otherProps,
    panelContext,
    resetAllItems,
    toggleItem,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/grid/utils.js
/**
 * External dependencies
 */
const ALIGNMENTS = {
  bottom: {
    alignItems: 'flex-end',
    justifyContent: 'center'
  },
  bottomLeft: {
    alignItems: 'flex-start',
    justifyContent: 'flex-end'
  },
  bottomRight: {
    alignItems: 'flex-end',
    justifyContent: 'flex-end'
  },
  center: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  spaced: {
    alignItems: 'center',
    justifyContent: 'space-between'
  },
  left: {
    alignItems: 'center',
    justifyContent: 'flex-start'
  },
  right: {
    alignItems: 'center',
    justifyContent: 'flex-end'
  },
  stretch: {
    alignItems: 'stretch'
  },
  top: {
    alignItems: 'flex-start',
    justifyContent: 'center'
  },
  topLeft: {
    alignItems: 'flex-start',
    justifyContent: 'flex-start'
  },
  topRight: {
    alignItems: 'flex-start',
    justifyContent: 'flex-end'
  }
};
function utils_getAlignmentProps(alignment) {
  const alignmentProps = alignment ? ALIGNMENTS[alignment] : {};
  return alignmentProps;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/grid/hook.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






function useGrid(props) {
  const {
    align,
    alignment,
    className,
    columnGap,
    columns = 2,
    gap = 3,
    isInline = false,
    justify,
    rowGap,
    rows,
    templateColumns,
    templateRows,
    ...otherProps
  } = useContextSystem(props, 'Grid');
  const columnsAsArray = Array.isArray(columns) ? columns : [columns];
  const column = useResponsiveValue(columnsAsArray);
  const rowsAsArray = Array.isArray(rows) ? rows : [rows];
  const row = useResponsiveValue(rowsAsArray);
  const gridTemplateColumns = templateColumns || !!columns && `repeat( ${column}, 1fr )`;
  const gridTemplateRows = templateRows || !!rows && `repeat( ${row}, 1fr )`;
  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    const alignmentProps = utils_getAlignmentProps(alignment);
    const gridClasses = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      alignItems: align,
      display: isInline ? 'inline-grid' : 'grid',
      gap: `calc( ${config_values.gridBase} * ${gap} )`,
      gridTemplateColumns: gridTemplateColumns || undefined,
      gridTemplateRows: gridTemplateRows || undefined,
      gridRowGap: rowGap,
      gridColumnGap: columnGap,
      justifyContent: justify,
      verticalAlign: isInline ? 'middle' : undefined,
      ...alignmentProps
    },  true ? "" : 0,  true ? "" : 0);
    return cx(gridClasses, className);
  }, [align, alignment, className, columnGap, cx, gap, gridTemplateColumns, gridTemplateRows, isInline, justify, rowGap]);
  return { ...otherProps,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/grid/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedGrid(props, forwardedRef) {
  const gridProps = useGrid(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, gridProps, {
    ref: forwardedRef
  }));
}
/**
 * `Grid` is a primitive layout component that can arrange content in a grid configuration.
 *
 * ```jsx
 * import {
 * 	__experimentalGrid as Grid,
 * 	__experimentalText as Text
 * } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<Grid columns={ 3 }>
 * 			<Text>Code</Text>
 * 			<Text>is</Text>
 * 			<Text>Poetry</Text>
 * 		</Grid>
 * 	);
 * }
 * ```
 */


const Grid = contextConnect(UnconnectedGrid, 'Grid');
/* harmony default export */ const grid_component = (Grid);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tools-panel/tools-panel/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */






const component_ToolsPanel = (props, forwardedRef) => {
  const {
    children,
    label,
    panelContext,
    resetAllItems,
    toggleItem,
    ...toolsPanelProps
  } = useToolsPanel(props);
  return (0,react.createElement)(grid_component, (0,helpers_esm_extends/* default */.A)({}, toolsPanelProps, {
    columns: 2,
    ref: forwardedRef
  }), (0,react.createElement)(ToolsPanelContext.Provider, {
    value: panelContext
  }, (0,react.createElement)(tools_panel_header_component, {
    label: label,
    resetAll: resetAllItems,
    toggleItem: toggleItem
  }), children));
};

const ConnectedToolsPanel = contextConnect(component_ToolsPanel, 'ToolsPanel');
/* harmony default export */ const tools_panel_component = (ConnectedToolsPanel);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch.js
/**
 * Internal dependencies
 */

/**
 * @typedef {import('../../types').StoreDescriptor<StoreConfig>} StoreDescriptor
 * @template StoreConfig
 */

/**
 * @typedef {import('../../types').UseDispatchReturn<StoreNameOrDescriptor>} UseDispatchReturn
 * @template StoreNameOrDescriptor
 */

/**
 * A custom react hook returning the current registry dispatch actions creators.
 *
 * Note: The component using this hook must be within the context of a
 * RegistryProvider.
 *
 * @template {undefined | string | StoreDescriptor<any>} [StoreNameOrDescriptor=undefined]
 * @param {StoreNameOrDescriptor} [storeNameOrDescriptor] Optionally provide the name of the
 *                                                        store or its descriptor from which to
 *                                                        retrieve action creators. If not
 *                                                        provided, the registry.dispatch
 *                                                        function is returned instead.
 *
 * @example
 * This illustrates a pattern where you may need to retrieve dynamic data from
 * the server via the `useSelect` hook to use in combination with the dispatch
 * action.
 *
 * ```jsx
 * import { useDispatch, useSelect } from '@wordpress/data';
 * import { useCallback } from '@wordpress/element';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function Button( { onClick, children } ) {
 *   return <button type="button" onClick={ onClick }>{ children }</button>
 * }
 *
 * const SaleButton = ( { children } ) => {
 *   const { stockNumber } = useSelect(
 *     ( select ) => select( myCustomStore ).getStockNumber(),
 *     []
 *   );
 *   const { startSale } = useDispatch( myCustomStore );
 *   const onClick = useCallback( () => {
 *     const discountPercent = stockNumber > 50 ? 10: 20;
 *     startSale( discountPercent );
 *   }, [ stockNumber ] );
 *   return <Button onClick={ onClick }>{ children }</Button>
 * }
 *
 * // Rendered somewhere in the application:
 * //
 * // <SaleButton>Start Sale!</SaleButton>
 * ```
 * @return {UseDispatchReturn<StoreNameOrDescriptor>} A custom react hook.
 */

const use_dispatch_useDispatch = storeNameOrDescriptor => {
  const {
    dispatch
  } = use_registry_useRegistry();
  return storeNameOrDescriptor === void 0 ? dispatch : dispatch(storeNameOrDescriptor);
};

/* harmony default export */ const use_dispatch = (use_dispatch_useDispatch);
//# sourceMappingURL=use-dispatch.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



const utils_identity = x => x;
/**
 * Removed falsy values from nested object.
 *
 * @param {*} object
 * @return {*} Object cleaned from falsy values
 */


const cleanEmptyObject = object => {
  if (object === null || typeof object !== 'object' || Array.isArray(object)) {
    return object;
  }

  const cleanedNestedObjects = (0,lodash.pickBy)((0,lodash.mapValues)(object, cleanEmptyObject), utils_identity);
  return (0,lodash.isEmpty)(cleanedNestedObjects) ? undefined : cleanedNestedObjects;
};
function immutableSet(object, path, value) {
  return (0,lodash.setWith)(object ? (0,lodash.clone)(object) : {}, path, value, lodash.clone);
}
function transformStyles(activeSupports, migrationPaths, result, source, index, results) {
  var _source$;

  // If there are no active supports return early.
  if ((0,lodash.every)(activeSupports, isActive => !isActive)) {
    return result;
  } // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the styles should not be transformed.


  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  } // For cases where we have a transform from one block to multiple blocks
  // or multiple blocks to one block we apply the styles of the first source block
  // to the result(s).


  let referenceBlockAttributes = (_source$ = source[0]) === null || _source$ === void 0 ? void 0 : _source$.attributes; // If we are in presence of transform between more than one block in the source
  // that has more than one block in the result
  // we apply the styles on source N to the result N,
  // if source N does not exists we do nothing.

  if (results.length > 1 && source.length > 1) {
    if (source[index]) {
      var _source$index;

      referenceBlockAttributes = (_source$index = source[index]) === null || _source$index === void 0 ? void 0 : _source$index.attributes;
    } else {
      return result;
    }
  }

  let returnBlock = result;
  (0,lodash.forEach)(activeSupports, (isActive, support) => {
    if (isActive) {
      migrationPaths[support].forEach(path => {
        const styleValue = (0,lodash.get)(referenceBlockAttributes, path);

        if (styleValue) {
          returnBlock = { ...returnBlock,
            attributes: immutableSet(returnBlock.attributes, path, styleValue)
          };
        }
      });
    }
  });
  return returnBlock;
}
/**
 * Check whether serialization of specific block support feature or set should
 * be skipped.
 *
 * @param {string|Object} blockType  Block name or block type object.
 * @param {string}        featureSet Name of block support feature set.
 * @param {string}        feature    Name of the individual feature to check.
 *
 * @return {boolean} Whether serialization should occur.
 */

function shouldSkipSerialization(blockType, featureSet, feature) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, featureSet);
  const skipSerialization = support === null || support === void 0 ? void 0 : support.__experimentalSkipSerialization;

  if (Array.isArray(skipSerialization)) {
    return skipSerialization.includes(feature);
  }

  return skipSerialization;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-tools-panel.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockSupportToolsPanel(_ref) {
  let {
    children,
    group,
    label
  } = _ref;
  const {
    updateBlockAttributes
  } = use_dispatch(store_store);
  const {
    getBlockAttributes,
    getMultiSelectedBlockClientIds,
    getSelectedBlockClientId,
    hasMultiSelection
  } = use_select_useSelect(store_store);
  const panelId = getSelectedBlockClientId();
  const resetAll = (0,react.useCallback)(function () {
    let resetFilters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const newAttributes = {};
    const clientIds = hasMultiSelection() ? getMultiSelectedBlockClientIds() : [panelId];
    clientIds.forEach(clientId => {
      const {
        style
      } = getBlockAttributes(clientId);
      let newBlockAttributes = {
        style
      };
      resetFilters.forEach(resetFilter => {
        newBlockAttributes = { ...newBlockAttributes,
          ...resetFilter(newBlockAttributes)
        };
      }); // Enforce a cleaned style object.

      newBlockAttributes = { ...newBlockAttributes,
        style: cleanEmptyObject(newBlockAttributes.style)
      };
      newAttributes[clientId] = newBlockAttributes;
    });
    updateBlockAttributes(clientIds, newAttributes, true);
  }, [cleanEmptyObject, getBlockAttributes, getMultiSelectedBlockClientIds, hasMultiSelection, panelId, updateBlockAttributes]);
  return (0,react.createElement)(tools_panel_component, {
    className: `${group}-block-support-panel`,
    label: label,
    resetAll: resetAll,
    key: panelId,
    panelId: panelId,
    hasInnerWrapper: true,
    shouldRenderPlaceholderItems: true // Required to maintain fills ordering.
    ,
    __experimentalFirstVisibleItemClass: "first",
    __experimentalLastVisibleItemClass: "last"
  }, children);
}
//# sourceMappingURL=block-support-tools-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/block-support-slot-container.js



/**
 * WordPress dependencies
 */


function BlockSupportSlotContainer(_ref) {
  let {
    Slot,
    ...props
  } = _ref;
  const toolsPanelContext = (0,react.useContext)(ToolsPanelContext);
  return (0,react.createElement)(Slot, (0,esm_extends/* default */.A)({}, props, {
    fillProps: toolsPanelContext,
    bubblesVirtually: true
  }));
}
//# sourceMappingURL=block-support-slot-container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/slot.js
/* provided dependency */ var slot_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function InspectorControlsSlot(_ref) {
  var _groups$group;

  let {
    __experimentalGroup: group = 'default',
    label,
    ...props
  } = _ref;
  const Slot = (_groups$group = inspector_controls_groups[group]) === null || _groups$group === void 0 ? void 0 : _groups$group.Slot;
  const slot = useSlot(Slot === null || Slot === void 0 ? void 0 : Slot.__unstableName);

  if (!Slot || !slot) {
    typeof slot_process !== "undefined" && slot_process.env && "production" !== "production" ? 0 : void 0;
    return null;
  }

  const hasFills = Boolean(slot.fills && slot.fills.length);

  if (!hasFills) {
    return null;
  }

  if (label) {
    return (0,react.createElement)(BlockSupportToolsPanel, {
      group: group,
      label: label
    }, (0,react.createElement)(BlockSupportSlotContainer, (0,esm_extends/* default */.A)({}, props, {
      Slot: Slot
    })));
  }

  return (0,react.createElement)(Slot, (0,esm_extends/* default */.A)({}, props, {
    bubblesVirtually: true
  }));
}
//# sourceMappingURL=slot.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inspector-controls/index.js



/**
 * Internal dependencies
 */


const InspectorControls = InspectorControlsFill;
InspectorControls.Slot = InspectorControlsSlot; // This is just here for backward compatibility.

const InspectorAdvancedControls = props => {
  return (0,react.createElement)(InspectorControlsFill, (0,esm_extends/* default */.A)({}, props, {
    __experimentalGroup: "advanced"
  }));
};

InspectorAdvancedControls.Slot = props => {
  return (0,react.createElement)(InspectorControlsSlot, (0,esm_extends/* default */.A)({}, props, {
    __experimentalGroup: "advanced"
  }));
};

InspectorAdvancedControls.slotName = 'InspectorAdvancedControls';
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inspector-controls/README.md
 */

/* harmony default export */ const inspector_controls = (InspectorControls);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-popover/use-popover-scroll.js
/**
 * WordPress dependencies
 */

/**
 * Allow scrolling "through" popovers over the canvas. This is only called for
 * as long as the pointer is over a popover. Do not use React events because it
 * will bubble through portals.
 *
 * @param {Object} scrollableRef
 */

function usePopoverScroll(scrollableRef) {
  return (0,use_ref_effect/* default */.A)(node => {
    if (!scrollableRef) {
      return;
    }

    function onWheel(event) {
      const {
        deltaX,
        deltaY
      } = event;
      scrollableRef.current.scrollBy(deltaX, deltaY);
    } // Tell the browser that we do not call event.preventDefault
    // See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scrolling_performance_with_passive_listeners


    const options = {
      passive: true
    };
    node.addEventListener('wheel', onWheel, options);
    return () => {
      node.removeEventListener('wheel', onWheel, options);
    };
  }, [scrollableRef]);
}

/* harmony default export */ const use_popover_scroll = (usePopoverScroll);
//# sourceMappingURL=use-popover-scroll.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-popover/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function BlockPopover(_ref, ref) {
  let {
    clientId,
    bottomClientId,
    children,
    __unstableRefreshSize,
    __unstableCoverTarget = false,
    __unstablePopoverSlot,
    __unstableContentRef,
    ...props
  } = _ref;
  const selectedElement = useBlockElement(clientId);
  const lastSelectedElement = useBlockElement(bottomClientId !== null && bottomClientId !== void 0 ? bottomClientId : clientId);
  const mergedRefs = (0,use_merge_refs/* default */.A)([ref, use_popover_scroll(__unstableContentRef)]);
  const style = (0,react.useMemo)(() => {
    if (!selectedElement || lastSelectedElement !== selectedElement) {
      return {};
    }

    return {
      position: 'absolute',
      width: selectedElement.offsetWidth,
      height: selectedElement.offsetHeight
    };
  }, [selectedElement, lastSelectedElement, __unstableRefreshSize]);

  if (!selectedElement || bottomClientId && !lastSelectedElement) {
    return null;
  }

  const anchorRef = {
    top: selectedElement,
    bottom: lastSelectedElement
  };
  return (0,react.createElement)(popover, (0,esm_extends/* default */.A)({
    ref: mergedRefs,
    animate: false,
    position: "top right left",
    focusOnMount: false,
    anchorRef: anchorRef // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null // Observe movement for block animations (especially horizontal).
    ,
    __unstableObserveElement: selectedElement,
    __unstableForcePosition: true,
    __unstableShift: true
  }, props, {
    className: classnames_default()('block-editor-block-popover', props.className)
  }), __unstableCoverTarget && (0,react.createElement)("div", {
    style: style
  }, children), !__unstableCoverTarget && children);
}

/* harmony default export */ const block_popover = ((0,react.forwardRef)(BlockPopover));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const utils_noop = () => {};
/**
 * A float supported clamp function for a specific value.
 *
 * @param  value The value to clamp.
 * @param  min   The minimum value.
 * @param  max   The maximum value.
 *
 * @return A (float) number
 */


function floatClamp(value, min, max) {
  if (typeof value !== 'number') {
    return null;
  }

  return parseFloat(`${clamp(value, min, max)}`);
}
/**
 * Hook to store a clamped value, derived from props.
 *
 * @param  settings
 * @return The controlled value and the value setter.
 */

function useControlledRangeValue(settings) {
  const {
    min,
    max,
    value: valueProp,
    initial
  } = settings;
  const [state, setInternalState] = use_controlled_state(floatClamp(valueProp, min, max), {
    initial: floatClamp(initial !== null && initial !== void 0 ? initial : null, min, max),
    fallback: null
  });
  const setState = (0,react.useCallback)(nextValue => {
    if (nextValue === null) {
      setInternalState(null);
    } else {
      setInternalState(floatClamp(nextValue, min, max));
    }
  }, [min, max]); // `state` can't be an empty string because we specified a fallback value of
  // `null` in `useControlledState`

  return [state, setState];
}
/**
 * Hook to encapsulate the debouncing "hover" to better handle the showing
 * and hiding of the Tooltip.
 *
 * @param  settings
 * @return Bound properties for use on a React.Node.
 */

function useDebouncedHoverInteraction(settings) {
  const {
    onHide = utils_noop,
    onMouseLeave = utils_noop,
    onMouseMove = utils_noop,
    onShow = utils_noop,
    timeout = 300
  } = settings;
  const [show, setShow] = (0,react.useState)(false);
  const timeoutRef = (0,react.useRef)();
  const setDebouncedTimeout = (0,react.useCallback)(callback => {
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(callback, timeout);
  }, [timeout]);
  const handleOnMouseMove = (0,react.useCallback)(event => {
    onMouseMove(event);
    setDebouncedTimeout(() => {
      if (!show) {
        setShow(true);
        onShow();
      }
    });
  }, []);
  const handleOnMouseLeave = (0,react.useCallback)(event => {
    onMouseLeave(event);
    setDebouncedTimeout(() => {
      setShow(false);
      onHide();
    });
  }, []);
  (0,react.useEffect)(() => {
    return () => {
      window.clearTimeout(timeoutRef.current);
    };
  });
  return {
    onMouseMove: handleOnMouseMove,
    onMouseLeave: handleOnMouseLeave
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/reduce-motion.js
/**
 * Allows users to opt-out of animations via OS-level preferences.
 *
 * @param {'transition' | 'animation' | string} [prop='transition'] CSS Property name
 * @return {string} Generated CSS code for the reduced style
 */
function reduceMotion() {
  let prop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transition';
  let style;

  switch (prop) {
    case 'transition':
      style = 'transition-duration: 0ms;';
      break;

    case 'animation':
      style = 'animation-duration: 1ms;';
      break;

    default:
      style = `
				animation-duration: 1ms;
				transition-duration: 0ms;
			`;
  }

  return `
		@media ( prefers-reduced-motion: reduce ) {
			${style};
		}
	`;
}
//# sourceMappingURL=reduce-motion.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/styles/range-control-styles.js


function range_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



const rangeHeightValue = 30;
const railHeight = 4;

const rangeHeight = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
  height: rangeHeightValue,
  minHeight: rangeHeightValue
},  true ? "" : 0,  true ? "" : 0);

const thumbSize = 12;
const range_control_styles_Root = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1epgpqk14"
} : 0)( true ? {
  name: "1se47kl",
  styles: "-webkit-tap-highlight-color:transparent;align-items:flex-start;display:flex;justify-content:flex-start;padding:0;position:relative;touch-action:none;width:100%"
} : 0);

const wrapperColor = _ref4 => {
  let {
    color = COLORS.ui.borderFocus
  } = _ref4;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    color
  },  true ? "" : 0,  true ? "" : 0);
};

const wrapperMargin = _ref5 => {
  let {
    marks,
    __nextHasNoMarginBottom
  } = _ref5;

  if (!__nextHasNoMarginBottom) {
    return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
      marginBottom: marks ? 16 : undefined
    },  true ? "" : 0,  true ? "" : 0);
  }

  return '';
};

const range_control_styles_Wrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1epgpqk13"
} : 0)("display:block;flex:1;position:relative;width:100%;", wrapperColor, ";", rangeHeight, ";", wrapperMargin, ";" + ( true ? "" : 0));
const BeforeIconWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk12"
} : 0)("display:flex;margin-top:", railHeight, "px;", rtl({
  marginRight: 6
}), ";" + ( true ? "" : 0));
const AfterIconWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk11"
} : 0)("display:flex;margin-top:", railHeight, "px;", rtl({
  marginLeft: 6
}), ";" + ( true ? "" : 0));

const railBackgroundColor = _ref6 => {
  let {
    disabled,
    railColor
  } = _ref6;
  let background = railColor || '';

  if (disabled) {
    background = COLORS.lightGray[400];
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    background
  },  true ? "" : 0,  true ? "" : 0);
};

const Rail = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk10"
} : 0)("background-color:", COLORS.lightGray[600], ";left:0;pointer-events:none;right:0;display:block;height:", railHeight, "px;position:absolute;margin-top:", (rangeHeightValue - railHeight) / 2, "px;top:0;border-radius:", railHeight, "px;", railBackgroundColor, ";" + ( true ? "" : 0));

const trackBackgroundColor = _ref7 => {
  let {
    disabled,
    trackColor
  } = _ref7;
  let background = trackColor || 'currentColor';

  if (disabled) {
    background = COLORS.lightGray[800];
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    background
  },  true ? "" : 0,  true ? "" : 0);
};

const Track = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk9"
} : 0)("background-color:currentColor;border-radius:", railHeight, "px;height:", railHeight, "px;pointer-events:none;display:block;position:absolute;margin-top:", (rangeHeightValue - railHeight) / 2, "px;top:0;", trackBackgroundColor, ";" + ( true ? "" : 0));
const MarksWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk8"
} : 0)( true ? {
  name: "l7tjj5",
  styles: "display:block;pointer-events:none;position:relative;width:100%;user-select:none"
} : 0);

const markFill = _ref8 => {
  let {
    disabled,
    isFilled
  } = _ref8;
  let backgroundColor = isFilled ? 'currentColor' : COLORS.lightGray[600];

  if (disabled) {
    backgroundColor = COLORS.lightGray[800];
  }

  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    backgroundColor
  },  true ? "" : 0,  true ? "" : 0);
};

const Mark = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk7"
} : 0)("height:", thumbSize, "px;left:0;position:absolute;top:-4px;width:1px;", markFill, ";" + ( true ? "" : 0));

const markLabelFill = _ref9 => {
  let {
    isFilled
  } = _ref9;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    color: isFilled ? COLORS.darkGray[300] : COLORS.lightGray[600]
  },  true ? "" : 0,  true ? "" : 0);
};

const MarkLabel = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk6"
} : 0)("color:", COLORS.lightGray[600], ";left:0;font-size:11px;position:absolute;top:12px;transform:translateX( -50% );white-space:nowrap;", markLabelFill, ";" + ( true ? "" : 0));

var range_control_styles_ref3 =  true ? {
  name: "1sb75b3",
  styles: "background-color:var( --wp-admin-theme-color )"
} : 0;

const thumbColor = _ref10 => {
  let {
    disabled
  } = _ref10;
  return disabled ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background-color:", COLORS.lightGray[800], ";" + ( true ? "" : 0),  true ? "" : 0) : range_control_styles_ref3;
};

const ThumbWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk5"
} : 0)("align-items:center;display:flex;height:", thumbSize, "px;justify-content:center;margin-top:", (rangeHeightValue - thumbSize) / 2, "px;outline:0;pointer-events:none;position:absolute;top:0;user-select:none;width:", thumbSize, "px;border-radius:50%;", thumbColor, ";", rtl({
  marginLeft: -10
}), ";", rtl({
  transform: 'translateX( 4.5px )'
}, {
  transform: 'translateX( -4.5px )'
}), ";" + ( true ? "" : 0));

const thumbFocus = _ref11 => {
  let {
    isFocused
  } = _ref11;
  return isFocused ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("&::before{content:' ';position:absolute;background-color:var( --wp-admin-theme-color );opacity:0.4;border-radius:50%;height:", thumbSize + 8, "px;width:", thumbSize + 8, "px;top:-4px;left:-4px;}" + ( true ? "" : 0),  true ? "" : 0) : '';
};

const Thumb = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk4"
} : 0)("align-items:center;border-radius:50%;height:100%;outline:0;position:absolute;user-select:none;width:100%;", thumbColor, ";", thumbFocus, ";" + ( true ? "" : 0));
const InputRange = (0,emotion_styled_base_browser_esm/* default */.A)("input",  true ? {
  target: "e1epgpqk3"
} : 0)("box-sizing:border-box;cursor:pointer;display:block;height:100%;left:0;margin:0 -", thumbSize / 2, "px;opacity:0;outline:none;position:absolute;right:0;top:0;width:calc( 100% + ", thumbSize, "px );" + ( true ? "" : 0));

const tooltipShow = _ref12 => {
  let {
    show
  } = _ref12;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    opacity: show ? 1 : 0
  },  true ? "" : 0,  true ? "" : 0);
};

var range_control_styles_ref =  true ? {
  name: "1cypxip",
  styles: "top:-80%"
} : 0;

var range_control_styles_ref2 =  true ? {
  name: "1lr98c4",
  styles: "bottom:-80%"
} : 0;

const tooltipPosition = _ref13 => {
  let {
    position
  } = _ref13;
  const isBottom = position === 'bottom';

  if (isBottom) {
    return range_control_styles_ref2;
  }

  return range_control_styles_ref;
};

const range_control_styles_Tooltip = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk2"
} : 0)("background:rgba( 0, 0, 0, 0.8 );border-radius:2px;color:white;display:inline-block;font-size:12px;min-width:32px;opacity:0;padding:4px 8px;pointer-events:none;position:absolute;text-align:center;transition:opacity 120ms ease;user-select:none;line-height:1.4;", tooltipShow, ";", tooltipPosition, ";", reduceMotion('transition'), ";", rtl({
  transform: 'translateX(-50%)'
}, {
  transform: 'translateX(50%)'
}), ";" + ( true ? "" : 0)); // @todo: Refactor RangeControl with latest HStack configuration
// @wordpress/components/ui/hstack.

const InputNumber = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(number_control,  true ? {
  target: "e1epgpqk1"
} : 0)("display:inline-block;font-size:13px;margin-top:0;width:", space(16), "!important;input[type='number']&{", rangeHeight, ";}", rtl({
  marginLeft: `${space(4)} !important`
}), ";" + ( true ? "" : 0));
const ActionRightWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("span",  true ? {
  target: "e1epgpqk0"
} : 0)("display:block;margin-top:0;button,button.is-small{margin-left:0;", rangeHeight, ";}", rtl({
  marginLeft: 8
}), ";" + ( true ? "" : 0));
//# sourceMappingURL=range-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/input-range.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const input_range_noop = () => {};

function input_range_InputRange(props, ref) {
  const {
    describedBy,
    label,
    onHideTooltip = input_range_noop,
    onMouseLeave = input_range_noop,
    onMouseMove = input_range_noop,
    onShowTooltip = input_range_noop,
    value,
    ...otherProps
  } = props;
  const hoverInteractions = useDebouncedHoverInteraction({
    onHide: onHideTooltip,
    onMouseLeave,
    onMouseMove,
    onShow: onShowTooltip
  });
  return (0,react.createElement)(InputRange, (0,helpers_esm_extends/* default */.A)({}, otherProps, hoverInteractions, {
    "aria-describedby": describedBy,
    "aria-label": label,
    "aria-hidden": false,
    ref: ref,
    tabIndex: 0,
    type: "range",
    value: value
  }));
}

const input_range_ForwardedComponent = (0,react.forwardRef)(input_range_InputRange);
/* harmony default export */ const input_range = (input_range_ForwardedComponent);
//# sourceMappingURL=input-range.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/mark.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


function RangeMark(props) {
  const {
    className,
    isFilled = false,
    label,
    style = {},
    ...otherProps
  } = props;
  const classes = classnames_default()('components-range-control__mark', isFilled && 'is-filled', className);
  const labelClasses = classnames_default()('components-range-control__mark-label', isFilled && 'is-filled');
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(Mark, (0,helpers_esm_extends/* default */.A)({}, otherProps, {
    "aria-hidden": "true",
    className: classes,
    isFilled: isFilled,
    style: style
  })), label && (0,react.createElement)(MarkLabel, {
    "aria-hidden": "true",
    className: labelClasses,
    isFilled: isFilled,
    style: style
  }, label));
}
//# sourceMappingURL=mark.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/rail.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function RangeRail(props) {
  const {
    disabled = false,
    marks = false,
    min = 0,
    max = 100,
    step = 1,
    value = 0,
    ...restProps
  } = props;
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(Rail, (0,helpers_esm_extends/* default */.A)({
    disabled: disabled
  }, restProps)), marks && (0,react.createElement)(Marks, {
    disabled: disabled,
    marks: marks,
    min: min,
    max: max,
    step: step,
    value: value
  }));
}

function Marks(props) {
  const {
    disabled = false,
    marks = false,
    min = 0,
    max = 100,
    step: stepProp = 1,
    value = 0
  } = props;
  const step = stepProp === 'any' ? 1 : stepProp;
  const marksData = useMarks({
    marks,
    min,
    max,
    step,
    value
  });
  return (0,react.createElement)(MarksWrapper, {
    "aria-hidden": "true",
    className: "components-range-control__marks"
  }, marksData.map(mark => (0,react.createElement)(RangeMark, (0,helpers_esm_extends/* default */.A)({}, mark, {
    key: mark.key,
    "aria-hidden": "true",
    disabled: disabled
  }))));
}

function useMarks(_ref) {
  let {
    marks,
    min = 0,
    max = 100,
    step = 1,
    value = 0
  } = _ref;

  if (!marks) {
    return [];
  }

  const range = max - min;

  if (!Array.isArray(marks)) {
    marks = [];
    const count = 1 + Math.round(range / step);

    while (count > marks.push({
      value: step * marks.length + min
    }));
  }

  const placedMarks = [];
  marks.forEach((mark, index) => {
    if (mark.value < min || mark.value > max) {
      return;
    }

    const key = `mark-${index}`;
    const isFilled = mark.value <= value;
    const offset = `${(mark.value - min) / range * 100}%`;
    const offsetStyle = {
      [(0,i18n_build_module/* isRTL */.V8)() ? 'right' : 'left']: offset
    };
    placedMarks.push({ ...mark,
      isFilled,
      key,
      style: offsetStyle
    });
  });
  return placedMarks;
}
//# sourceMappingURL=rail.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/tooltip.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function SimpleTooltip(props) {
  const {
    className,
    inputRef,
    tooltipPosition,
    show = false,
    style = {},
    value = 0,
    renderTooltipContent = v => v,
    zIndex = 100,
    ...restProps
  } = props;
  const position = useTooltipPosition({
    inputRef,
    tooltipPosition
  });
  const classes = classnames_default()('components-simple-tooltip', className);
  const styles = { ...style,
    zIndex
  };
  return (0,react.createElement)(range_control_styles_Tooltip, (0,helpers_esm_extends/* default */.A)({}, restProps, {
    "aria-hidden": show,
    className: classes,
    position: position,
    show: show,
    role: "tooltip",
    style: styles
  }), renderTooltipContent(value));
}

function useTooltipPosition(_ref) {
  let {
    inputRef,
    tooltipPosition
  } = _ref;
  const [position, setPosition] = (0,react.useState)();
  const setTooltipPosition = (0,react.useCallback)(() => {
    if (inputRef && inputRef.current) {
      setPosition(tooltipPosition);
    }
  }, [tooltipPosition]);
  (0,react.useEffect)(() => {
    setTooltipPosition();
  }, [setTooltipPosition]);
  (0,react.useEffect)(() => {
    window.addEventListener('resize', setTooltipPosition);
    return () => {
      window.removeEventListener('resize', setTooltipPosition);
    };
  });
  return position;
}
//# sourceMappingURL=tooltip.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/range-control/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */












const range_control_noop = () => {};

function UnforwardedRangeControl(props, forwardedRef) {
  var _inputRef$current;

  const {
    __nextHasNoMarginBottom = false,
    afterIcon,
    allowReset = false,
    beforeIcon,
    className,
    color: colorProp = COLORS.ui.theme,
    currentInput,
    disabled = false,
    help,
    hideLabelFromVision = false,
    initialPosition,
    isShiftStepEnabled = true,
    label,
    marks = false,
    max = 100,
    min = 0,
    onBlur = range_control_noop,
    onChange = range_control_noop,
    onFocus = range_control_noop,
    onMouseLeave = range_control_noop,
    onMouseMove = range_control_noop,
    railColor,
    renderTooltipContent = v => v,
    resetFallbackValue,
    shiftStep = 10,
    showTooltip: showTooltipProp,
    step = 1,
    trackColor,
    value: valueProp,
    withInputField = true,
    ...otherProps
  } = props;
  const [value, setValue] = useControlledRangeValue({
    min,
    max,
    value: valueProp !== null && valueProp !== void 0 ? valueProp : null,
    initial: initialPosition
  });
  const isResetPendent = (0,react.useRef)(false);
  let hasTooltip = showTooltipProp;
  let hasInputField = withInputField;

  if (step === 'any') {
    // The tooltip and number input field are hidden when the step is "any"
    // because the decimals get too lengthy to fit well.
    hasTooltip = false;
    hasInputField = false;
  }

  const [showTooltip, setShowTooltip] = (0,react.useState)(hasTooltip);
  const [isFocused, setIsFocused] = (0,react.useState)(false);
  const inputRef = (0,react.useRef)();
  const isCurrentlyFocused = (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.matches(':focus');
  const isThumbFocused = !disabled && isFocused;
  const isValueReset = value === null;
  const currentValue = value !== undefined ? value : currentInput;
  const inputSliderValue = isValueReset ? '' : currentValue;
  const rangeFillValue = isValueReset ? (max - min) / 2 + min : value;
  const fillValue = isValueReset ? 50 : (value - min) / (max - min) * 100;
  const fillValueOffset = `${clamp(fillValue, 0, 100)}%`;
  const classes = classnames_default()('components-range-control', className);
  const wrapperClasses = classnames_default()('components-range-control__wrapper', !!marks && 'is-marked');
  const id = (0,use_instance_id/* default */.A)(UnforwardedRangeControl, 'inspector-range-control');
  const describedBy = !!help ? `${id}__help` : undefined;
  const enableTooltip = hasTooltip !== false && Number.isFinite(value);

  const handleOnRangeChange = event => {
    const nextValue = parseFloat(event.target.value);
    setValue(nextValue);
    onChange(nextValue);
  };

  const handleOnChange = next => {
    let nextValue = parseFloat(next);
    setValue(nextValue);
    /*
     * Calls onChange only when nextValue is numeric
     * otherwise may queue a reset for the blur event.
     */

    if (!isNaN(nextValue)) {
      if (nextValue < min || nextValue > max) {
        nextValue = floatClamp(nextValue, min, max);
      }

      onChange(nextValue);
      isResetPendent.current = false;
    } else if (allowReset) {
      isResetPendent.current = true;
    }
  };

  const handleOnInputNumberBlur = () => {
    if (isResetPendent.current) {
      handleOnReset();
      isResetPendent.current = false;
    }
  };

  const handleOnReset = () => {
    let resetValue = parseFloat(`${resetFallbackValue}`);
    let onChangeResetValue = resetValue;

    if (isNaN(resetValue)) {
      resetValue = null;
      onChangeResetValue = undefined;
    }

    setValue(resetValue);
    /**
     * Previously, this callback would always receive undefined as
     * an argument. This behavior is unexpected, specifically
     * when resetFallbackValue is defined.
     *
     * The value of undefined is not ideal. Passing it through
     * to internal <input /> elements would change it from a
     * controlled component to an uncontrolled component.
     *
     * For now, to minimize unexpected regressions, we're going to
     * preserve the undefined callback argument, except when a
     * resetFallbackValue is defined.
     */

    onChange(onChangeResetValue);
  };

  const handleShowTooltip = () => setShowTooltip(true);

  const handleHideTooltip = () => setShowTooltip(false);

  const handleOnBlur = event => {
    onBlur(event);
    setIsFocused(false);
    handleHideTooltip();
  };

  const handleOnFocus = event => {
    onFocus(event);
    setIsFocused(true);
    handleShowTooltip();
  };

  const offsetStyle = {
    [(0,i18n_build_module/* isRTL */.V8)() ? 'right' : 'left']: fillValueOffset
  };
  return (0,react.createElement)(base_control, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    className: classes,
    label: label,
    hideLabelFromVision: hideLabelFromVision,
    id: `${id}`,
    help: help
  }, (0,react.createElement)(range_control_styles_Root, {
    className: "components-range-control__root"
  }, beforeIcon && (0,react.createElement)(BeforeIconWrapper, null, (0,react.createElement)(build_module_icon, {
    icon: beforeIcon
  })), (0,react.createElement)(range_control_styles_Wrapper, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    className: wrapperClasses,
    color: colorProp,
    marks: !!marks
  }, (0,react.createElement)(input_range, (0,helpers_esm_extends/* default */.A)({}, otherProps, {
    className: "components-range-control__slider",
    describedBy: describedBy,
    disabled: disabled,
    id: `${id}`,
    label: label,
    max: max,
    min: min,
    onBlur: handleOnBlur,
    onChange: handleOnRangeChange,
    onFocus: handleOnFocus,
    onMouseMove: onMouseMove,
    onMouseLeave: onMouseLeave,
    ref: (0,use_merge_refs/* default */.A)([inputRef, forwardedRef]),
    step: step,
    value: inputSliderValue !== null && inputSliderValue !== void 0 ? inputSliderValue : undefined
  })), (0,react.createElement)(RangeRail, {
    "aria-hidden": true,
    disabled: disabled,
    marks: marks,
    max: max,
    min: min,
    railColor: railColor,
    step: step,
    value: rangeFillValue
  }), (0,react.createElement)(Track, {
    "aria-hidden": true,
    className: "components-range-control__track",
    disabled: disabled,
    style: {
      width: fillValueOffset
    },
    trackColor: trackColor
  }), (0,react.createElement)(ThumbWrapper, {
    style: offsetStyle,
    disabled: disabled
  }, (0,react.createElement)(Thumb, {
    "aria-hidden": true,
    isFocused: isThumbFocused,
    disabled: disabled
  })), enableTooltip && (0,react.createElement)(SimpleTooltip, {
    className: "components-range-control__tooltip",
    inputRef: inputRef,
    tooltipPosition: "bottom",
    renderTooltipContent: renderTooltipContent,
    show: isCurrentlyFocused || showTooltip,
    style: offsetStyle,
    value: value
  })), afterIcon && (0,react.createElement)(AfterIconWrapper, null, (0,react.createElement)(build_module_icon, {
    icon: afterIcon
  })), hasInputField && (0,react.createElement)(InputNumber, {
    "aria-label": label,
    className: "components-range-control__number",
    disabled: disabled,
    inputMode: "decimal",
    isShiftStepEnabled: isShiftStepEnabled,
    max: max,
    min: min,
    onBlur: handleOnInputNumberBlur,
    onChange: handleOnChange,
    shiftStep: shiftStep,
    step: step,
    value: inputSliderValue
  }), allowReset && (0,react.createElement)(ActionRightWrapper, null, (0,react.createElement)(build_module_button, {
    className: "components-range-control__reset",
    disabled: disabled || value === undefined,
    variant: "secondary",
    isSmall: true,
    onClick: handleOnReset
  }, (0,i18n_build_module.__)('Reset')))));
}
/**
 * RangeControls are used to make selections from a range of incremental values.
 *
 * ```jsx
 * import { RangeControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyRangeControl = () => {
 *   const [ isChecked, setChecked ] = useState( true );
 *   return (
 *     <RangeControl
 *       help="Please select how transparent you would like this."
 *       initialPosition={50}
 *       label="Opacity"
 *       max={100}
 *       min={0}
 *       onChange={() => {}}
 *     />
 *   );
 * };
 * ```
 */


const RangeControl = (0,react.forwardRef)(UnforwardedRangeControl);
/* harmony default export */ const range_control = (RangeControl);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/downshift@6.1.12_react@17.0.2/node_modules/downshift/dist/downshift.esm.js + 1 modules
var downshift_esm = __webpack_require__("../../node_modules/.pnpm/downshift@6.1.12_react@17.0.2/node_modules/downshift/dist/downshift.esm.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/icon/index.js
/**
 * WordPress dependencies
 */


/** @typedef {{icon: JSX.Element, size?: number} & import('@wordpress/primitives').SVGProps} IconProps */

/**
 * Return an SVG icon.
 *
 * @param {IconProps}                                 props icon is the SVG component to render
 *                                                          size is a number specifiying the icon size in pixels
 *                                                          Other props will be passed to wrapped SVG component
 * @param {import('react').ForwardedRef<HTMLElement>} ref   The forwarded ref to the SVG element.
 *
 * @return {JSX.Element}  Icon component
 */
function icon_Icon({
  icon,
  size = 24,
  ...props
}, ref) {
  return (0,react.cloneElement)(icon, {
    width: size,
    height: size,
    ...props,
    ref
  });
}
/* harmony default export */ const icon = ((0,react.forwardRef)(icon_Icon));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/spacer/hook.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





const isDefined = o => typeof o !== 'undefined' && o !== null;

function useSpacer(props) {
  const {
    className,
    margin,
    marginBottom = 2,
    marginLeft,
    marginRight,
    marginTop,
    marginX,
    marginY,
    padding,
    paddingBottom,
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingX,
    paddingY,
    ...otherProps
  } = useContextSystem(props, 'Spacer');
  const cx = useCx();
  const classes = cx(isDefined(margin) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin:", space(margin), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(marginY) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin-bottom:", space(marginY), ";margin-top:", space(marginY), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(marginX) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin-left:", space(marginX), ";margin-right:", space(marginX), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(marginTop) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin-top:", space(marginTop), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(marginBottom) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin-bottom:", space(marginBottom), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(marginLeft) && rtl({
    marginLeft: space(marginLeft)
  })(), isDefined(marginRight) && rtl({
    marginRight: space(marginRight)
  })(), isDefined(padding) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding:", space(padding), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(paddingY) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding-bottom:", space(paddingY), ";padding-top:", space(paddingY), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(paddingX) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding-left:", space(paddingX), ";padding-right:", space(paddingX), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(paddingTop) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding-top:", space(paddingTop), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(paddingBottom) && /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding-bottom:", space(paddingBottom), ";" + ( true ? "" : 0),  true ? "" : 0), isDefined(paddingLeft) && rtl({
    paddingLeft: space(paddingLeft)
  })(), isDefined(paddingRight) && rtl({
    paddingRight: space(paddingRight)
  })(), className);
  return { ...otherProps,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/spacer/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedSpacer(props, forwardedRef) {
  const spacerProps = useSpacer(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, spacerProps, {
    ref: forwardedRef
  }));
}
/**
 * `Spacer` is a primitive layout component that providers inner (`padding`) or outer (`margin`) space in-between components. It can also be used to adaptively provide space within an `HStack` or `VStack`.
 *
 * `Spacer` comes with a bunch of shorthand props to adjust `margin` and `padding`. The values of these props
 * can either be a number (which will act as a multiplier to the library's grid system base of 4px),
 * or a literal CSS value string.
 *
 * ```jsx
 * import { Spacer } from `@wordpress/components`
 *
 * function Example() {
 *   return (
 *     <View>
 *       <Spacer>
 *         <Heading>WordPress.org</Heading>
 *       </Spacer>
 *       <Text>
 *         Code is Poetry
 *       </Text>
 *     </View>
 *   );
 * }
 * ```
 */


const Spacer = contextConnect(UnconnectedSpacer, 'Spacer');
/* harmony default export */ const spacer_component = (Spacer);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/input-control/input-suffix-wrapper.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function UnconnectedInputControlSuffixWrapper(props, forwardedRef) {
  const derivedProps = useContextSystem(props, 'InputControlSuffixWrapper');
  return (0,react.createElement)(spacer_component, (0,helpers_esm_extends/* default */.A)({
    marginBottom: 0
  }, derivedProps, {
    ref: forwardedRef
  }));
}
/**
 * A convenience wrapper for the `suffix` when you want to apply
 * standard padding in accordance with the size variant.
 *
 * ```jsx
 * import {
 *   __experimentalInputControl as InputControl,
 *   __experimentalInputControlSuffixWrapper as InputControlSuffixWrapper,
 * } from '@wordpress/components';
 *
 * <InputControl
 *   suffix={<InputControlSuffixWrapper>%</InputControlSuffixWrapper>}
 * />
 * ```
 */


const InputControlSuffixWrapper = contextConnect(UnconnectedInputControlSuffixWrapper, 'InputControlSuffixWrapper');
/* harmony default export */ const input_suffix_wrapper = (InputControlSuffixWrapper);
//# sourceMappingURL=input-suffix-wrapper.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/select-control/styles/select-control-styles.js


/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




const select_control_styles_disabledStyles = _ref => {
  let {
    disabled
  } = _ref;
  if (!disabled) return '';
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)({
    color: COLORS.ui.textDisabled
  },  true ? "" : 0,  true ? "" : 0);
};

const select_control_styles_fontSizeStyles = _ref2 => {
  let {
    selectSize = 'default'
  } = _ref2;
  const sizes = {
    default: '13px',
    small: '11px',
    '__unstable-large': '13px'
  };
  const fontSize = sizes[selectSize];
  const fontSizeMobile = '16px';
  if (!fontSize) return '';
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("font-size:", fontSizeMobile, ";@media ( min-width: 600px ){font-size:", fontSize, ";}" + ( true ? "" : 0),  true ? "" : 0);
};

const select_control_styles_sizeStyles = _ref3 => {
  let {
    __next36pxDefaultSize,
    selectSize = 'default'
  } = _ref3;
  const sizes = {
    default: {
      height: 36,
      minHeight: 36,
      paddingTop: 0,
      paddingBottom: 0
    },
    small: {
      height: 24,
      minHeight: 24,
      paddingTop: 0,
      paddingBottom: 0
    },
    '__unstable-large': {
      height: 40,
      minHeight: 40,
      paddingTop: 0,
      paddingBottom: 0
    }
  };

  if (!__next36pxDefaultSize) {
    sizes.default = {
      height: 30,
      minHeight: 30,
      paddingTop: 0,
      paddingBottom: 0
    };
  }

  const style = sizes[selectSize] || sizes.default;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(style,  true ? "" : 0,  true ? "" : 0);
};

const chevronIconSize = 18;

const sizePaddings = _ref4 => {
  let {
    __next36pxDefaultSize,
    selectSize = 'default'
  } = _ref4;
  const iconWidth = chevronIconSize;
  const sizes = {
    default: {
      paddingLeft: 16,
      paddingRight: 16 + iconWidth
    },
    small: {
      paddingLeft: 8,
      paddingRight: 8 + iconWidth
    },
    '__unstable-large': {
      paddingLeft: 16,
      paddingRight: 16 + iconWidth
    }
  };

  if (!__next36pxDefaultSize) {
    sizes.default = {
      paddingLeft: 8,
      paddingRight: 8 + iconWidth
    };
  }

  return rtl(sizes[selectSize] || sizes.default);
}; // TODO: Resolve need to use &&& to increase specificity
// https://github.com/WordPress/gutenberg/issues/18483


const Select = (0,emotion_styled_base_browser_esm/* default */.A)("select",  true ? {
  target: "e1mv6sxx2"
} : 0)("&&&{appearance:none;background:transparent;box-sizing:border-box;border:none;box-shadow:none!important;color:", COLORS.gray[900], ";display:block;font-family:inherit;margin:0;width:100%;max-width:none;cursor:pointer;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;", select_control_styles_disabledStyles, ";", select_control_styles_fontSizeStyles, ";", select_control_styles_sizeStyles, ";", sizePaddings, ";}" + ( true ? "" : 0));
const DownArrowWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e1mv6sxx1"
} : 0)("margin-inline-end:", space(-1), ";line-height:0;" + ( true ? "" : 0));
const InputControlSuffixWrapperWithClickThrough = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(input_suffix_wrapper,  true ? {
  target: "e1mv6sxx0"
} : 0)("position:absolute;pointer-events:none;", rtl({
  right: 0
}), ";" + ( true ? "" : 0));
//# sourceMappingURL=select-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/chevron-down.js

/**
 * WordPress dependencies
 */

const chevronDown = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z"
}));
/* harmony default export */ const chevron_down = (chevronDown);
//# sourceMappingURL=chevron-down.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/select-control/chevron-down.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const SelectControlChevronDown = () => {
  return (0,react.createElement)(InputControlSuffixWrapperWithClickThrough, null, (0,react.createElement)(DownArrowWrapper, null, (0,react.createElement)(icon, {
    icon: chevron_down,
    size: chevronIconSize
  })));
};

/* harmony default export */ const select_control_chevron_down = (SelectControlChevronDown);
//# sourceMappingURL=chevron-down.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-select-control/styles.js


/**
 * External dependencies
 */


/**
 * Internal dependencies
 */



const backCompatMinWidth = props => !props.__nextUnconstrainedWidth ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(Container, "{min-width:130px;}" + ( true ? "" : 0),  true ? "" : 0) : '';

const InputBaseWithBackCompatMinWidth = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(input_base,  true ? {
  target: "eswuck60"
} : 0)(backCompatMinWidth, ";" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-select-control/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const itemToString = item => item === null || item === void 0 ? void 0 : item.name; // This is needed so that in Windows, where
// the menu does not necessarily open on
// key up/down, you can still switch between
// options with the menu closed.


const stateReducer = (_ref, _ref2) => {
  let {
    selectedItem
  } = _ref;
  let {
    type,
    changes,
    props: {
      items
    }
  } = _ref2;

  switch (type) {
    case downshift_esm/* useSelect */.WM.stateChangeTypes.ToggleButtonKeyDownArrowDown:
      // If we already have a selected item, try to select the next one,
      // without circular navigation. Otherwise, select the first item.
      return {
        selectedItem: items[selectedItem ? Math.min(items.indexOf(selectedItem) + 1, items.length - 1) : 0]
      };

    case downshift_esm/* useSelect */.WM.stateChangeTypes.ToggleButtonKeyDownArrowUp:
      // If we already have a selected item, try to select the previous one,
      // without circular navigation. Otherwise, select the last item.
      return {
        selectedItem: items[selectedItem ? Math.max(items.indexOf(selectedItem) - 1, 0) : items.length - 1]
      };

    default:
      return changes;
  }
};

function CustomSelectControl(_ref3) {
  var _menuProps$ariaActiv;

  let {
    /** Start opting into the larger default height that will become the default size in a future version. */
    __next36pxDefaultSize = false,

    /** Start opting into the unconstrained width that will become the default in a future version. */
    __nextUnconstrainedWidth = false,
    className,
    hideLabelFromVision,
    label,
    describedBy,
    options: items,
    onChange: onSelectedItemChange,

    /** @type {import('../select-control/types').SelectControlProps.size} */
    size = 'default',
    value: _selectedItem
  } = _ref3;
  const {
    getLabelProps,
    getToggleButtonProps,
    getMenuProps,
    getItemProps,
    isOpen,
    highlightedIndex,
    selectedItem
  } = (0,downshift_esm/* useSelect */.WM)({
    initialSelectedItem: items[0],
    items,
    itemToString,
    onSelectedItemChange,
    ...(typeof _selectedItem !== 'undefined' && _selectedItem !== null ? {
      selectedItem: _selectedItem
    } : undefined),
    stateReducer
  });
  const [isFocused, setIsFocused] = (0,react.useState)(false);

  if (!__nextUnconstrainedWidth) {
    (0,deprecated_build_module/* default */.A)('Constrained width styles for wp.components.CustomSelectControl', {
      since: '6.1',
      version: '6.4',
      hint: 'Set the `__nextUnconstrainedWidth` prop to true to start opting into the new styles, which will become the default in a future version'
    });
  }

  function getDescribedBy() {
    if (describedBy) {
      return describedBy;
    }

    if (!selectedItem) {
      return (0,i18n_build_module.__)('No selection');
    } // translators: %s: The selected option.


    return (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Currently selected: %s'), selectedItem.name);
  }

  const menuProps = getMenuProps({
    className: 'components-custom-select-control__menu',
    'aria-hidden': !isOpen
  });
  const onKeyDownHandler = (0,react.useCallback)(e => {
    var _menuProps$onKeyDown;

    e.stopPropagation();
    menuProps === null || menuProps === void 0 ? void 0 : (_menuProps$onKeyDown = menuProps.onKeyDown) === null || _menuProps$onKeyDown === void 0 ? void 0 : _menuProps$onKeyDown.call(menuProps, e);
  }, [menuProps]); // We need this here, because the null active descendant is not fully ARIA compliant.

  if ((_menuProps$ariaActiv = menuProps['aria-activedescendant']) !== null && _menuProps$ariaActiv !== void 0 && _menuProps$ariaActiv.startsWith('downshift-null')) {
    delete menuProps['aria-activedescendant'];
  }

  return (0,react.createElement)("div", {
    className: classnames_default()('components-custom-select-control', className)
  }, hideLabelFromVision ? (0,react.createElement)(visually_hidden_component, (0,helpers_esm_extends/* default */.A)({
    as: "label"
  }, getLabelProps()), label) :
  /* eslint-disable-next-line jsx-a11y/label-has-associated-control, jsx-a11y/label-has-for */
  (0,react.createElement)(StyledLabel, getLabelProps({
    className: 'components-custom-select-control__label'
  }), label), (0,react.createElement)(InputBaseWithBackCompatMinWidth, {
    __next36pxDefaultSize: __next36pxDefaultSize,
    __nextUnconstrainedWidth: __nextUnconstrainedWidth,
    isFocused: isOpen || isFocused,
    __unstableInputWidth: __nextUnconstrainedWidth ? undefined : 'auto',
    labelPosition: __nextUnconstrainedWidth ? undefined : 'top',
    size: size,
    suffix: (0,react.createElement)(select_control_chevron_down, null)
  }, (0,react.createElement)(Select, (0,helpers_esm_extends/* default */.A)({
    as: "button",
    onFocus: () => setIsFocused(true),
    onBlur: () => setIsFocused(false),
    selectSize: size,
    __next36pxDefaultSize: __next36pxDefaultSize
  }, getToggleButtonProps({
    // This is needed because some speech recognition software don't support `aria-labelledby`.
    'aria-label': label,
    'aria-labelledby': undefined,
    className: 'components-custom-select-control__button',
    describedBy: getDescribedBy()
  })), itemToString(selectedItem))), (0,react.createElement)("ul", (0,helpers_esm_extends/* default */.A)({}, menuProps, {
    onKeyDown: onKeyDownHandler
  }), isOpen && items.map((item, index) => // eslint-disable-next-line react/jsx-key
  (0,react.createElement)("li", getItemProps({
    item,
    index,
    key: item.key,
    className: classnames_default()(item.className, 'components-custom-select-control__item', {
      'is-highlighted': index === highlightedIndex,
      'has-hint': !!item.__experimentalHint,
      'is-next-36px-default-size': __next36pxDefaultSize
    }),
    style: item.style
  }), item.name, item.__experimentalHint && (0,react.createElement)("span", {
    className: "components-custom-select-control__item-hint"
  }, item.__experimentalHint), item === selectedItem && (0,react.createElement)(icon, {
    icon: library_check,
    className: "components-custom-select-control__item-icon"
  })))));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/settings.js

/**
 * WordPress dependencies
 */

const settings_settings = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "m19 7.5h-7.628c-.3089-.87389-1.1423-1.5-2.122-1.5-.97966 0-1.81309.62611-2.12197 1.5h-2.12803v1.5h2.12803c.30888.87389 1.14231 1.5 2.12197 1.5.9797 0 1.8131-.62611 2.122-1.5h7.628z"
}), (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "m19 15h-2.128c-.3089-.8739-1.1423-1.5-2.122-1.5s-1.8131.6261-2.122 1.5h-7.628v1.5h7.628c.3089.8739 1.1423 1.5 2.122 1.5s1.8131-.6261 2.122-1.5h2.128z"
}));
/* harmony default export */ const library_settings = (settings_settings);
//# sourceMappingURL=settings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/spacing-input-control.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function SpacingInputControl(_ref) {
  var _spacingSizes$current;

  let {
    spacingSizes,
    value,
    side,
    onChange,
    isMixed = false,
    type,
    minimumCustomValue
  } = _ref;
  let selectListSizes = spacingSizes;
  const showRangeControl = spacingSizes.length <= 8;
  const disableCustomSpacingSizes = use_select_useSelect(select => {
    const editorSettings = select(store_store).getSettings();
    return editorSettings === null || editorSettings === void 0 ? void 0 : editorSettings.disableCustomSpacingSizes;
  });
  const [showCustomValueControl, setShowCustomValueControl] = (0,react.useState)(!disableCustomSpacingSizes && value !== undefined && !isValueSpacingPreset(value));
  const units = useCustomUnits({
    availableUnits: use_setting_useSetting('spacing.units') || ['px', 'em', 'rem']
  });
  let currentValue = null;
  const showCustomValueInSelectList = !showRangeControl && !showCustomValueControl && value !== undefined && (!isValueSpacingPreset(value) || isValueSpacingPreset(value) && isMixed);

  if (showCustomValueInSelectList) {
    selectListSizes = [...spacingSizes, {
      name: !isMixed ? // translators: A custom measurement, eg. a number followed by a unit like 12px.
      (0,_wordpress_i18n_build_module/* sprintf */.nv)((0,_wordpress_i18n_build_module.__)('Custom (%s)'), value) : (0,_wordpress_i18n_build_module.__)('Mixed'),
      slug: 'custom',
      size: value
    }];
    currentValue = selectListSizes.length - 1;
  } else if (!isMixed) {
    currentValue = !showCustomValueControl ? getSliderValueFromPreset(value, spacingSizes) : getCustomValueFromPreset(value, spacingSizes);
  }

  const selectedUnit = (0,react.useMemo)(() => parseQuantityAndUnitFromRawValue(currentValue), [currentValue])[1] || units[0].value;

  const setInitialValue = () => {
    if (value === undefined) {
      onChange('0');
    }
  };

  const customTooltipContent = newValue => {
    var _spacingSizes$newValu;

    return value === undefined ? undefined : (_spacingSizes$newValu = spacingSizes[newValue]) === null || _spacingSizes$newValu === void 0 ? void 0 : _spacingSizes$newValu.name;
  };

  const customRangeValue = parseInt(currentValue, 10);

  const getNewCustomValue = newSize => {
    const isNumeric = !isNaN(parseFloat(newSize));
    const nextValue = isNumeric ? newSize : undefined;
    return nextValue;
  };

  const getNewPresetValue = (newSize, controlType) => {
    var _spacingSizes$newSize;

    const size = parseInt(newSize, 10);

    if (controlType === 'selectList') {
      if (size === 0) {
        return undefined;
      }

      if (size === 1) {
        return '0';
      }
    } else if (size === 0) {
      return '0';
    }

    return `var:preset|spacing|${(_spacingSizes$newSize = spacingSizes[newSize]) === null || _spacingSizes$newSize === void 0 ? void 0 : _spacingSizes$newSize.slug}`;
  };

  const handleCustomValueSliderChange = next => {
    onChange([next, selectedUnit].join(''));
  };

  const allPlaceholder = isMixed ? (0,_wordpress_i18n_build_module.__)('Mixed') : null;
  const currentValueHint = !isMixed ? customTooltipContent(currentValue) : (0,_wordpress_i18n_build_module.__)('Mixed');
  const options = selectListSizes.map((size, index) => ({
    key: index,
    name: size.name
  }));
  const marks = spacingSizes.map((newValue, index) => ({
    value: index,
    label: undefined
  }));
  const ariaLabel = (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: The side of the block being modified (top, bottom, left, etc.). 2. Type of spacing being modified (Padding, margin, etc)
  (0,_wordpress_i18n_build_module.__)('%1$s %2$s'), utils_LABELS[side], type === null || type === void 0 ? void 0 : type.toLowerCase());
  const showHint = showRangeControl && !showCustomValueControl && currentValueHint !== undefined;
  return (0,react.createElement)(react.Fragment, null, side !== 'all' && (0,react.createElement)(h_stack_component, {
    className: "components-spacing-sizes-control__side-labels"
  }, (0,react.createElement)(text_component, {
    className: "components-spacing-sizes-control__side-label"
  }, utils_LABELS[side]), showHint && (0,react.createElement)(text_component, {
    className: "components-spacing-sizes-control__hint-single"
  }, currentValueHint)), side === 'all' && showHint && (0,react.createElement)(text_component, {
    className: "components-spacing-sizes-control__hint-all"
  }, currentValueHint), !disableCustomSpacingSizes && (0,react.createElement)(build_module_button, {
    label: showCustomValueControl ? (0,_wordpress_i18n_build_module.__)('Use size preset') : (0,_wordpress_i18n_build_module.__)('Set custom size'),
    icon: library_settings,
    onClick: () => {
      setShowCustomValueControl(!showCustomValueControl);
    },
    isPressed: showCustomValueControl,
    isSmall: true,
    className: classnames_default()({
      'components-spacing-sizes-control__custom-toggle-all': side === 'all',
      'components-spacing-sizes-control__custom-toggle-single': side !== 'all'
    }),
    iconSize: 24
  }), showCustomValueControl && (0,react.createElement)(react.Fragment, null, (0,react.createElement)(unit_control, {
    onChange: newSize => onChange(getNewCustomValue(newSize)),
    value: currentValue,
    units: units,
    min: minimumCustomValue,
    placeholder: allPlaceholder,
    disableUnits: isMixed,
    label: ariaLabel,
    hideLabelFromVision: true,
    className: "components-spacing-sizes-control__custom-value-input"
  }), (0,react.createElement)(range_control, {
    value: customRangeValue,
    min: 0,
    max: 100,
    withInputField: false,
    onChange: handleCustomValueSliderChange,
    className: "components-spacing-sizes-control__custom-value-range"
  })), showRangeControl && !showCustomValueControl && (0,react.createElement)(range_control, {
    className: "components-spacing-sizes-control__range-control",
    value: currentValue,
    onChange: newSize => onChange(getNewPresetValue(newSize)),
    onMouseDown: event => {
      var _event$nativeEvent;

      // If mouse down is near start of range set initial value to 0, which
      // prevents the user have to drag right then left to get 0 setting.
      if ((event === null || event === void 0 ? void 0 : (_event$nativeEvent = event.nativeEvent) === null || _event$nativeEvent === void 0 ? void 0 : _event$nativeEvent.offsetX) < 35) {
        setInitialValue();
      }
    },
    withInputField: false,
    "aria-valuenow": currentValue,
    "aria-valuetext": (_spacingSizes$current = spacingSizes[currentValue]) === null || _spacingSizes$current === void 0 ? void 0 : _spacingSizes$current.name,
    renderTooltipContent: customTooltipContent,
    min: 0,
    max: spacingSizes.length - 1,
    marks: marks,
    label: ariaLabel,
    hideLabelFromVision: true
  }), !showRangeControl && !showCustomValueControl && (0,react.createElement)(CustomSelectControl, {
    className: "components-spacing-sizes-control__custom-select-control",
    value: options.find(option => option.key === currentValue) || '' // passing undefined here causes a downshift controlled/uncontrolled warning
    ,
    onChange: selection => {
      onChange(getNewPresetValue(selection.selectedItem.key, 'selectList'));
    },
    options: options,
    label: ariaLabel,
    hideLabelFromVision: true,
    __nextUnconstrainedWidth: true
  }));
}
//# sourceMappingURL=spacing-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/all-input-control.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function all_input_control_AllInputControl(_ref) {
  let {
    onChange,
    values,
    sides,
    spacingSizes,
    type,
    minimumCustomValue
  } = _ref;
  const allValue = getAllRawValue(values);
  const hasValues = utils_isValuesDefined(values);
  const isMixed = hasValues && utils_isValuesMixed(values, sides);

  const handleOnChange = next => {
    const nextValues = applyValueToSides(values, next, sides);
    onChange(nextValues);
  };

  return (0,react.createElement)(SpacingInputControl, {
    value: allValue,
    onChange: handleOnChange,
    side: 'all',
    spacingSizes: spacingSizes,
    isMixed: isMixed,
    type: type,
    minimumCustomValue: minimumCustomValue
  });
}
//# sourceMappingURL=all-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/input-controls.js


/**
 * Internal dependencies
 */


function input_controls_BoxInputControls(_ref) {
  let {
    values,
    sides,
    onChange,
    spacingSizes,
    type,
    minimumCustomValue
  } = _ref;
  // Filter sides if custom configuration provided, maintaining default order.
  const filteredSides = sides !== null && sides !== void 0 && sides.length ? utils_ALL_SIDES.filter(side => sides.includes(side)) : utils_ALL_SIDES;

  const createHandleOnChange = side => next => {
    const nextValues = { ...values
    };
    nextValues[side] = next;
    onChange(nextValues);
  };

  return (0,react.createElement)(react.Fragment, null, filteredSides.map(side => {
    return (0,react.createElement)(SpacingInputControl, {
      value: values[side],
      label: utils_LABELS[side],
      key: `spacing-sizes-control-${side}`,
      withInputField: false,
      side: side,
      onChange: createHandleOnChange(side),
      spacingSizes: spacingSizes,
      type: type,
      minimumCustomValue: minimumCustomValue
    });
  }));
}
//# sourceMappingURL=input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/axial-input-controls.js


/**
 * Internal dependencies
 */


const axial_input_controls_groupedSides = ['vertical', 'horizontal'];
function axial_input_controls_AxialInputControls(_ref) {
  let {
    onChange,
    values,
    sides,
    spacingSizes,
    type,
    minimumCustomValue
  } = _ref;

  const createHandleOnChange = side => next => {
    if (!onChange) {
      return;
    }

    const nextValues = { ...values
    };

    if (side === 'vertical') {
      nextValues.top = next;
      nextValues.bottom = next;
    }

    if (side === 'horizontal') {
      nextValues.left = next;
      nextValues.right = next;
    }

    onChange(nextValues);
  }; // Filter sides if custom configuration provided, maintaining default order.


  const filteredSides = sides !== null && sides !== void 0 && sides.length ? axial_input_controls_groupedSides.filter(side => sides.includes(side)) : axial_input_controls_groupedSides;
  return (0,react.createElement)(react.Fragment, null, filteredSides.map(side => {
    const axisValue = side === 'vertical' ? values.top : values.left;
    return (0,react.createElement)(SpacingInputControl, {
      value: axisValue,
      onChange: createHandleOnChange(side),
      label: utils_LABELS[side],
      key: `spacing-sizes-control-${side}`,
      withInputField: false,
      side: side,
      spacingSizes: spacingSizes,
      type: type,
      minimumCustomValue: minimumCustomValue
    });
  }));
}
//# sourceMappingURL=axial-input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/linked-button.js


/**
 * WordPress dependencies
 */



function linked_button_LinkedButton(_ref) {
  let {
    isLinked,
    onClick
  } = _ref;
  const label = isLinked ? (0,_wordpress_i18n_build_module.__)('Unlink Sides') : (0,_wordpress_i18n_build_module.__)('Link Sides');
  return (0,react.createElement)(tooltip, {
    text: label
  }, (0,react.createElement)("span", {
    className: "component-spacing-sizes-control__linked-button"
  }, (0,react.createElement)(build_module_button, {
    variant: isLinked ? 'primary' : 'secondary',
    isSmall: true,
    icon: isLinked ? library_link : link_off,
    iconSize: 16,
    "aria-label": label,
    onClick: onClick
  })));
}
//# sourceMappingURL=linked-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/index.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







function SpacingSizesControl(_ref) {
  let {
    inputProps,
    onChange,
    label = (0,_wordpress_i18n_build_module.__)('Spacing Control'),
    values,
    sides,
    splitOnAxis = false,
    useSelect,
    minimumCustomValue = 0
  } = _ref;
  const spacingSizes = [{
    name: 0,
    slug: '0',
    size: 0
  }, ...(use_setting_useSetting('spacing.spacingSizes') || [])];

  if (spacingSizes.length > 8) {
    spacingSizes.unshift({
      name: (0,_wordpress_i18n_build_module.__)('Default'),
      slug: 'default',
      size: undefined
    });
  }

  const inputValues = values || utils_DEFAULT_VALUES;
  const hasInitialValue = utils_isValuesDefined(values);
  const hasOneSide = (sides === null || sides === void 0 ? void 0 : sides.length) === 1;
  const [isLinked, setIsLinked] = (0,react.useState)(!hasInitialValue || !utils_isValuesMixed(inputValues, sides) || hasOneSide);

  const toggleLinked = () => {
    setIsLinked(!isLinked);
  };

  const handleOnChange = nextValue => {
    const newValues = { ...values,
      ...nextValue
    };
    onChange(newValues);
  };

  const inputControlProps = { ...inputProps,
    onChange: handleOnChange,
    isLinked,
    sides,
    values: inputValues,
    spacingSizes,
    useSelect,
    type: label,
    minimumCustomValue
  };
  return (0,react.createElement)("fieldset", {
    role: "region",
    className: "component-spacing-sizes-control"
  }, (0,react.createElement)(text_component, {
    as: "legend"
  }, label), !hasOneSide && (0,react.createElement)(linked_button_LinkedButton, {
    onClick: toggleLinked,
    isLinked: isLinked
  }), isLinked && (0,react.createElement)(all_input_control_AllInputControl, (0,esm_extends/* default */.A)({
    "aria-label": label
  }, inputControlProps)), !isLinked && splitOnAxis && (0,react.createElement)(axial_input_controls_AxialInputControls, inputControlProps), !isLinked && !splitOnAxis && (0,react.createElement)(input_controls_BoxInputControls, inputControlProps));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/margin.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







/**
 * Determines if there is margin support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */

function hasMarginSupport(blockType) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, SPACING_SUPPORT_KEY);
  return !!(true === support || support !== null && support !== void 0 && support.margin);
}
/**
 * Checks if there is a current value in the margin block support attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean}      Whether or not the block has a margin value set.
 */

function hasMarginValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return ((_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : (_props$attributes$sty2 = _props$attributes$sty.spacing) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.margin) !== undefined;
}
/**
 * Resets the margin block support attributes. This can be used when disabling
 * the margin support controls for a block via a `ToolsPanel`.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetMargin(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        margin: undefined
      }
    })
  });
}
/**
 * Custom hook that checks if margin settings have been disabled.
 *
 * @param {string} name The name of the block.
 *
 * @return {boolean} Whether margin setting is disabled.
 */

function useIsMarginDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const isDisabled = !use_setting_useSetting('spacing.margin');
  const isInvalid = !useIsDimensionsSupportValid(blockName, 'margin');
  return !hasMarginSupport(blockName) || isDisabled || isInvalid;
}
/**
 * Inspector control panel containing the margin related configuration
 *
 * @param {Object} props Block props.
 *
 * @return {WPElement} Margin edit element.
 */

function MarginEdit(props) {
  var _style$spacing, _style$spacing2;

  const {
    name: blockName,
    attributes: {
      style
    },
    setAttributes
  } = props;
  const spacingSizes = use_setting_useSetting('spacing.spacingSizes');
  const units = useCustomUnits({
    availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
  });
  const sides = useCustomSides(blockName, 'margin');
  const splitOnAxis = sides && sides.some(side => AXIAL_SIDES.includes(side));

  if (useIsMarginDisabled(props)) {
    return null;
  }

  const onChange = next => {
    const newStyle = { ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        margin: next
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return platform.select({
    web: (0,react.createElement)(react.Fragment, null, (!spacingSizes || (spacingSizes === null || spacingSizes === void 0 ? void 0 : spacingSizes.length) === 0) && (0,react.createElement)(BoxControl, {
      values: style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.margin,
      onChange: onChange,
      label: (0,_wordpress_i18n_build_module.__)('Margin'),
      sides: sides,
      units: units,
      allowReset: false,
      splitOnAxis: splitOnAxis
    }), (spacingSizes === null || spacingSizes === void 0 ? void 0 : spacingSizes.length) > 0 && (0,react.createElement)(SpacingSizesControl, {
      values: style === null || style === void 0 ? void 0 : (_style$spacing2 = style.spacing) === null || _style$spacing2 === void 0 ? void 0 : _style$spacing2.margin,
      onChange: onChange,
      label: (0,_wordpress_i18n_build_module.__)('Margin'),
      sides: sides,
      units: units,
      allowReset: false,
      splitOnAxis: false
    })),
    native: null
  });
}
function MarginVisualizer(_ref2) {
  var _attributes$style, _attributes$style$spa;

  let {
    clientId,
    attributes
  } = _ref2;
  const margin = attributes === null || attributes === void 0 ? void 0 : (_attributes$style = attributes.style) === null || _attributes$style === void 0 ? void 0 : (_attributes$style$spa = _attributes$style.spacing) === null || _attributes$style$spa === void 0 ? void 0 : _attributes$style$spa.margin;
  const spacingSizes = use_setting_useSetting('spacing.spacingSizes');
  const style = (0,react.useMemo)(() => {
    const marginTop = margin !== null && margin !== void 0 && margin.top ? getCustomValueFromPreset(margin === null || margin === void 0 ? void 0 : margin.top, spacingSizes) : 0;
    const marginRight = margin !== null && margin !== void 0 && margin.right ? getCustomValueFromPreset(margin === null || margin === void 0 ? void 0 : margin.right, spacingSizes) : 0;
    const marginBottom = margin !== null && margin !== void 0 && margin.bottom ? getCustomValueFromPreset(margin === null || margin === void 0 ? void 0 : margin.bottom, spacingSizes) : 0;
    const marginLeft = margin !== null && margin !== void 0 && margin.left ? getCustomValueFromPreset(margin === null || margin === void 0 ? void 0 : margin.left, spacingSizes) : 0;
    return {
      borderTopWidth: marginTop,
      borderRightWidth: marginRight,
      borderBottomWidth: marginBottom,
      borderLeftWidth: marginLeft,
      top: marginTop !== 0 ? `-${marginTop}` : 0,
      right: marginRight !== 0 ? `-${marginRight}` : 0,
      bottom: marginBottom !== 0 ? `-${marginBottom}` : 0,
      left: marginLeft !== 0 ? `-${marginLeft}` : 0
    };
  }, [margin]);
  const [isActive, setIsActive] = (0,react.useState)(false);
  const valueRef = (0,react.useRef)(margin);
  const timeoutRef = (0,react.useRef)();

  const clearTimer = () => {
    if (timeoutRef.current) {
      window.clearTimeout(timeoutRef.current);
    }
  };

  (0,react.useEffect)(() => {
    if (!(0,is_shallow_equal_build_module/* default */.Ay)(margin, valueRef.current)) {
      setIsActive(true);
      valueRef.current = margin;
      clearTimer();
      timeoutRef.current = setTimeout(() => {
        setIsActive(false);
      }, 400);
    }

    return () => clearTimer();
  }, [margin]);

  if (!isActive) {
    return null;
  }

  return (0,react.createElement)(block_popover, {
    clientId: clientId,
    __unstableCoverTarget: true,
    __unstableRefreshSize: margin
  }, (0,react.createElement)("div", {
    className: "block-editor__padding-visualizer",
    style: style
  }));
}
//# sourceMappingURL=margin.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/padding.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







/**
 * Determines if there is padding support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 *
 * @return {boolean} Whether there is support.
 */

function hasPaddingSupport(blockType) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, SPACING_SUPPORT_KEY);
  return !!(true === support || support !== null && support !== void 0 && support.padding);
}
/**
 * Checks if there is a current value in the padding block support attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean}      Whether or not the block has a padding value set.
 */

function hasPaddingValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return ((_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : (_props$attributes$sty2 = _props$attributes$sty.spacing) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.padding) !== undefined;
}
/**
 * Resets the padding block support attributes. This can be used when disabling
 * the padding support controls for a block via a `ToolsPanel`.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetPadding(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        padding: undefined
      }
    })
  });
}
/**
 * Custom hook that checks if padding settings have been disabled.
 *
 * @param {string} name The name of the block.
 *
 * @return {boolean} Whether padding setting is disabled.
 */

function useIsPaddingDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const isDisabled = !use_setting_useSetting('spacing.padding');
  const isInvalid = !useIsDimensionsSupportValid(blockName, 'padding');
  return !hasPaddingSupport(blockName) || isDisabled || isInvalid;
}
/**
 * Inspector control panel containing the padding related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Padding edit element.
 */

function PaddingEdit(props) {
  var _style$spacing, _style$spacing2;

  const {
    name: blockName,
    attributes: {
      style
    },
    setAttributes
  } = props;
  const spacingSizes = use_setting_useSetting('spacing.spacingSizes');
  const units = useCustomUnits({
    availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
  });
  const sides = useCustomSides(blockName, 'padding');
  const splitOnAxis = sides && sides.some(side => AXIAL_SIDES.includes(side));

  if (useIsPaddingDisabled(props)) {
    return null;
  }

  const onChange = next => {
    const newStyle = { ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        padding: next
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return platform.select({
    web: (0,react.createElement)(react.Fragment, null, (!spacingSizes || (spacingSizes === null || spacingSizes === void 0 ? void 0 : spacingSizes.length) === 0) && (0,react.createElement)(BoxControl, {
      values: style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.padding,
      onChange: onChange,
      label: (0,_wordpress_i18n_build_module.__)('Padding'),
      sides: sides,
      units: units,
      allowReset: false,
      splitOnAxis: splitOnAxis
    }), (spacingSizes === null || spacingSizes === void 0 ? void 0 : spacingSizes.length) > 0 && (0,react.createElement)(SpacingSizesControl, {
      values: style === null || style === void 0 ? void 0 : (_style$spacing2 = style.spacing) === null || _style$spacing2 === void 0 ? void 0 : _style$spacing2.padding,
      onChange: onChange,
      label: (0,_wordpress_i18n_build_module.__)('Padding'),
      sides: sides,
      units: units,
      allowReset: false,
      splitOnAxis: splitOnAxis
    })),
    native: null
  });
}
function PaddingVisualizer(_ref2) {
  var _attributes$style, _attributes$style$spa;

  let {
    clientId,
    attributes
  } = _ref2;
  const padding = attributes === null || attributes === void 0 ? void 0 : (_attributes$style = attributes.style) === null || _attributes$style === void 0 ? void 0 : (_attributes$style$spa = _attributes$style.spacing) === null || _attributes$style$spa === void 0 ? void 0 : _attributes$style$spa.padding;
  const style = (0,react.useMemo)(() => {
    return {
      borderTopWidth: isValueSpacingPreset(padding === null || padding === void 0 ? void 0 : padding.top) ? getSpacingPresetCssVar(padding === null || padding === void 0 ? void 0 : padding.top) : padding === null || padding === void 0 ? void 0 : padding.top,
      borderRightWidth: isValueSpacingPreset(padding === null || padding === void 0 ? void 0 : padding.right) ? getSpacingPresetCssVar(padding === null || padding === void 0 ? void 0 : padding.right) : padding === null || padding === void 0 ? void 0 : padding.right,
      borderBottomWidth: isValueSpacingPreset(padding === null || padding === void 0 ? void 0 : padding.bottom) ? getSpacingPresetCssVar(padding === null || padding === void 0 ? void 0 : padding.bottom) : padding === null || padding === void 0 ? void 0 : padding.bottom,
      borderLeftWidth: isValueSpacingPreset(padding === null || padding === void 0 ? void 0 : padding.left) ? getSpacingPresetCssVar(padding === null || padding === void 0 ? void 0 : padding.left) : padding === null || padding === void 0 ? void 0 : padding.left
    };
  }, [padding]);
  const [isActive, setIsActive] = (0,react.useState)(false);
  const valueRef = (0,react.useRef)(padding);
  const timeoutRef = (0,react.useRef)();

  const clearTimer = () => {
    if (timeoutRef.current) {
      window.clearTimeout(timeoutRef.current);
    }
  };

  (0,react.useEffect)(() => {
    if (!(0,is_shallow_equal_build_module/* default */.Ay)(padding, valueRef.current)) {
      setIsActive(true);
      valueRef.current = padding;
      clearTimer();
      timeoutRef.current = setTimeout(() => {
        setIsActive(false);
      }, 400);
    }

    return () => clearTimer();
  }, [padding]);

  if (!isActive) {
    return null;
  }

  return (0,react.createElement)(block_popover, {
    clientId: clientId,
    __unstableCoverTarget: true,
    __unstableRefreshSize: padding
  }, (0,react.createElement)("div", {
    className: "block-editor__padding-visualizer",
    style: style
  }));
}
//# sourceMappingURL=padding.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/dimensions.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const SPACING_SUPPORT_KEY = 'spacing';
const dimensions_ALL_SIDES = ['top', 'right', 'bottom', 'left'];
const AXIAL_SIDES = ['vertical', 'horizontal'];
/**
 * Inspector controls for dimensions support.
 *
 * @param {Object} props Block props.
 *
 * @return {WPElement} Inspector controls for spacing support features.
 */

function DimensionsPanel(props) {
  const isGapDisabled = useIsGapDisabled(props);
  const isPaddingDisabled = useIsPaddingDisabled(props);
  const isMarginDisabled = useIsMarginDisabled(props);
  const isDisabled = useIsDimensionsDisabled(props);
  const isSupported = hasDimensionsSupport(props.name);
  const spacingSizes = use_setting_useSetting('spacing.spacingSizes');

  if (isDisabled || !isSupported) {
    return null;
  }

  const defaultSpacingControls = (0,build_module/* getBlockSupport */.bI)(props.name, [SPACING_SUPPORT_KEY, '__experimentalDefaultControls']);

  const createResetAllFilter = attribute => newAttributes => {
    var _newAttributes$style;

    return { ...newAttributes,
      style: { ...newAttributes.style,
        spacing: { ...((_newAttributes$style = newAttributes.style) === null || _newAttributes$style === void 0 ? void 0 : _newAttributes$style.spacing),
          [attribute]: undefined
        }
      }
    };
  };

  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(inspector_controls, {
    __experimentalGroup: "dimensions"
  }, !isPaddingDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: classnames_default()({
      'tools-panel-item-spacing': spacingSizes && spacingSizes.length > 0
    }),
    hasValue: () => hasPaddingValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Padding'),
    onDeselect: () => resetPadding(props),
    resetAllFilter: createResetAllFilter('padding'),
    isShownByDefault: defaultSpacingControls === null || defaultSpacingControls === void 0 ? void 0 : defaultSpacingControls.padding,
    panelId: props.clientId
  }, (0,react.createElement)(PaddingEdit, props)), !isMarginDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: classnames_default()({
      'tools-panel-item-spacing': spacingSizes && spacingSizes.length > 0
    }),
    hasValue: () => hasMarginValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Margin'),
    onDeselect: () => resetMargin(props),
    resetAllFilter: createResetAllFilter('margin'),
    isShownByDefault: defaultSpacingControls === null || defaultSpacingControls === void 0 ? void 0 : defaultSpacingControls.margin,
    panelId: props.clientId
  }, (0,react.createElement)(MarginEdit, props)), !isGapDisabled && (0,react.createElement)(tools_panel_item_component, {
    hasValue: () => hasGapValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Block spacing'),
    onDeselect: () => resetGap(props),
    resetAllFilter: createResetAllFilter('blockGap'),
    isShownByDefault: defaultSpacingControls === null || defaultSpacingControls === void 0 ? void 0 : defaultSpacingControls.blockGap,
    panelId: props.clientId
  }, (0,react.createElement)(GapEdit, props))), !isPaddingDisabled && (0,react.createElement)(PaddingVisualizer, props), !isMarginDisabled && (0,react.createElement)(MarginVisualizer, props));
}
/**
 * Determine whether there is dimensions related block support.
 *
 * @param {string} blockName Block name.
 *
 * @return {boolean} Whether there is support.
 */

function hasDimensionsSupport(blockName) {
  if (platform.OS !== 'web') {
    return false;
  }

  return hasGapSupport(blockName) || hasPaddingSupport(blockName) || hasMarginSupport(blockName);
}
/**
 * Determines whether dimensions support has been disabled.
 *
 * @param {Object} props Block properties.
 *
 * @return {boolean} If spacing support is completely disabled.
 */

const useIsDimensionsDisabled = function () {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const gapDisabled = useIsGapDisabled(props);
  const paddingDisabled = useIsPaddingDisabled(props);
  const marginDisabled = useIsMarginDisabled(props);
  return gapDisabled && paddingDisabled && marginDisabled;
};
/**
 * Custom hook to retrieve which padding/margin/blockGap is supported
 * e.g. top, right, bottom or left.
 *
 * Sides are opted into by default. It is only if a specific side is set to
 * false that it is omitted.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   The feature custom sides relate to e.g. padding or margins.
 *
 * @return {?string[]} Strings representing the custom sides available.
 */


function useCustomSides(blockName, feature) {
  var _support$feature;

  const support = (0,build_module/* getBlockSupport */.bI)(blockName, SPACING_SUPPORT_KEY); // Skip when setting is boolean as theme isn't setting arbitrary sides.

  if (!support || typeof support[feature] === 'boolean') {
    return;
  } // Return if the setting is an array of sides (e.g. `[ 'top', 'bottom' ]`).


  if (Array.isArray(support[feature])) {
    return support[feature];
  } // Finally, attempt to return `.sides` if the setting is an object.


  if ((_support$feature = support[feature]) !== null && _support$feature !== void 0 && _support$feature.sides) {
    return support[feature].sides;
  }
}
/**
 * Custom hook to determine whether the sides configured in the
 * block support are valid. A dimension property cannot declare
 * support for a mix of axial and individual sides.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   The feature custom sides relate to e.g. padding or margins.
 *
 * @return {boolean} If the feature has a valid configuration of sides.
 */

function useIsDimensionsSupportValid(blockName, feature) {
  const sides = useCustomSides(blockName, feature);

  if (sides && sides.some(side => dimensions_ALL_SIDES.includes(side)) && sides.some(side => AXIAL_SIDES.includes(side))) {
    // eslint-disable-next-line no-console
    console.warn(`The ${feature} support for the "${blockName}" block can not be configured to support both axial and arbitrary sides.`);
    return false;
  }

  return true;
}
//# sourceMappingURL=dimensions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/gap.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






/**
 * Determines if there is gap support.
 *
 * @param {string|Object} blockType Block name or Block Type object.
 * @return {boolean}                Whether there is support.
 */

function hasGapSupport(blockType) {
  const support = (0,build_module/* getBlockSupport */.bI)(blockType, SPACING_SUPPORT_KEY);
  return !!(true === support || support !== null && support !== void 0 && support.blockGap);
}
/**
 * Checks if there is a current value in the gap block support attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean}      Whether or not the block has a gap value set.
 */

function hasGapValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return ((_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : (_props$attributes$sty2 = _props$attributes$sty.spacing) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.blockGap) !== undefined;
}
/**
 * Returns a BoxControl object value from a given blockGap style value.
 * The string check is for backwards compatibility before Gutenberg supported
 * split gap values (row and column) and the value was a string n + unit.
 *
 * @param {string? | Object?} blockGapValue A block gap string or axial object value, e.g., '10px' or { top: '10px', left: '10px'}.
 * @return {Object|null}                    A value to pass to the BoxControl component.
 */

function getGapBoxControlValueFromStyle(blockGapValue) {
  if (!blockGapValue) {
    return null;
  }

  const isValueString = typeof blockGapValue === 'string';
  return {
    top: isValueString ? getSpacingPresetCssVar(blockGapValue) : getSpacingPresetCssVar(blockGapValue === null || blockGapValue === void 0 ? void 0 : blockGapValue.top),
    left: isValueString ? getSpacingPresetCssVar(blockGapValue) : getSpacingPresetCssVar(blockGapValue === null || blockGapValue === void 0 ? void 0 : blockGapValue.left)
  };
}
/**
 * Returns a CSS value for the `gap` property from a given blockGap style.
 *
 * @param {string? | Object?} blockGapValue A block gap string or axial object value, e.g., '10px' or { top: '10px', left: '10px'}.
 * @param {string?}           defaultValue  A default gap value.
 * @return {string|null}                    The concatenated gap value (row and column).
 */

function getGapCSSValue(blockGapValue) {
  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';
  const blockGapBoxControlValue = getGapBoxControlValueFromStyle(blockGapValue);

  if (!blockGapBoxControlValue) {
    return null;
  }

  const row = (blockGapBoxControlValue === null || blockGapBoxControlValue === void 0 ? void 0 : blockGapBoxControlValue.top) || defaultValue;
  const column = (blockGapBoxControlValue === null || blockGapBoxControlValue === void 0 ? void 0 : blockGapBoxControlValue.left) || defaultValue;
  return row === column ? row : `${row} ${column}`;
}
/**
 * Resets the gap block support attribute. This can be used when disabling
 * the gap support controls for a block via a progressive discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetGap(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: { ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        blockGap: undefined
      }
    }
  });
}
/**
 * Custom hook that checks if gap settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean}     Whether the gap setting is disabled.
 */

function useIsGapDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const isDisabled = !use_setting_useSetting('spacing.blockGap');
  return !hasGapSupport(blockName) || isDisabled;
}
/**
 * Inspector control panel containing the gap related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Gap edit element.
 */

function GapEdit(props) {
  var _style$spacing;

  const {
    clientId,
    attributes: {
      style
    },
    name: blockName,
    setAttributes
  } = props;
  const units = useCustomUnits({
    availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
  });
  const sides = useCustomSides(blockName, 'blockGap');
  const ref = useBlockRef(clientId);

  if (useIsGapDisabled(props)) {
    return null;
  }

  const splitOnAxis = sides && sides.some(side => AXIAL_SIDES.includes(side));

  const onChange = next => {
    var _window;

    let blockGap = next; // If splitOnAxis activated we need to return a BoxControl object to the BoxControl component.

    if (!!next && splitOnAxis) {
      blockGap = { ...getGapBoxControlValueFromStyle(next)
      };
    }

    const newStyle = { ...style,
      spacing: { ...(style === null || style === void 0 ? void 0 : style.spacing),
        blockGap
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    }); // In Safari, changing the `gap` CSS value on its own will not trigger the layout
    // to be recalculated / re-rendered. To force the updated gap to re-render, here
    // we replace the block's node with itself.

    const isSafari = ((_window = window) === null || _window === void 0 ? void 0 : _window.navigator.userAgent) && window.navigator.userAgent.includes('Safari') && !window.navigator.userAgent.includes('Chrome ') && !window.navigator.userAgent.includes('Chromium ');

    if (ref.current && isSafari) {
      var _ref$current$parentNo;

      (_ref$current$parentNo = ref.current.parentNode) === null || _ref$current$parentNo === void 0 ? void 0 : _ref$current$parentNo.replaceChild(ref.current, ref.current);
    }
  };

  const gapValue = getGapBoxControlValueFromStyle(style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.blockGap); // The BoxControl component expects a full complement of side values.
  // Gap row and column values translate to top/bottom and left/right respectively.

  const boxControlGapValue = splitOnAxis ? { ...gapValue,
    right: gapValue === null || gapValue === void 0 ? void 0 : gapValue.left,
    bottom: gapValue === null || gapValue === void 0 ? void 0 : gapValue.top
  } : gapValue === null || gapValue === void 0 ? void 0 : gapValue.top;
  return platform.select({
    web: (0,react.createElement)(react.Fragment, null, splitOnAxis ? (0,react.createElement)(BoxControl, {
      label: (0,_wordpress_i18n_build_module.__)('Block spacing'),
      min: 0,
      onChange: onChange,
      units: units,
      sides: sides,
      values: boxControlGapValue,
      allowReset: false,
      splitOnAxis: splitOnAxis
    }) : (0,react.createElement)(unit_control, {
      label: (0,_wordpress_i18n_build_module.__)('Block spacing'),
      __unstableInputWidth: "80px",
      min: 0,
      onChange: onChange,
      units: units // Default to `row` for combined values.
      ,
      value: boxControlGapValue
    })),
    native: null
  });
}
//# sourceMappingURL=gap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/icons.js


/**
 * WordPress dependencies
 */

const alignBottom = (0,react.createElement)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(svg/* Path */.wA, {
  d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z"
}));
const alignCenter = (0,react.createElement)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(svg/* Path */.wA, {
  d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z"
}));
const alignTop = (0,react.createElement)(svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(svg/* Path */.wA, {
  d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z"
}));
//# sourceMappingURL=icons.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/ui.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const BLOCK_ALIGNMENTS_CONTROLS = {
  top: {
    icon: alignTop,
    title: (0,_wordpress_i18n_build_module._x)('Align top', 'Block vertical alignment setting')
  },
  center: {
    icon: alignCenter,
    title: (0,_wordpress_i18n_build_module._x)('Align middle', 'Block vertical alignment setting')
  },
  bottom: {
    icon: alignBottom,
    title: (0,_wordpress_i18n_build_module._x)('Align bottom', 'Block vertical alignment setting')
  }
};
const DEFAULT_CONTROLS = ['top', 'center', 'bottom'];
const DEFAULT_CONTROL = 'top';
const POPOVER_PROPS = {
  isAlternate: true
};

function ui_BlockVerticalAlignmentUI(_ref) {
  let {
    value,
    onChange,
    controls = DEFAULT_CONTROLS,
    isCollapsed = true,
    isToolbar
  } = _ref;

  function applyOrUnset(align) {
    return () => onChange(value === align ? undefined : align);
  }

  const activeAlignment = BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
  const UIComponent = isToolbar ? toolbar_group : toolbar_dropdown_menu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return (0,react.createElement)(UIComponent, (0,esm_extends/* default */.A)({
    popoverProps: POPOVER_PROPS,
    icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
    label: (0,_wordpress_i18n_build_module._x)('Change vertical alignment', 'Block vertical alignment setting label'),
    controls: controls.map(control => {
      return { ...BLOCK_ALIGNMENTS_CONTROLS[control],
        isActive: value === control,
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: applyOrUnset(control)
      };
    })
  }, extraProps));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-toolbar/README.md
 */


/* harmony default export */ const ui = (ui_BlockVerticalAlignmentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/index.js



/**
 * Internal dependencies
 */


const BlockVerticalAlignmentControl = props => {
  return (0,react.createElement)(ui, (0,esm_extends/* default */.A)({}, props, {
    isToolbar: false
  }));
};

const BlockVerticalAlignmentToolbar = props => {
  return createElement(BlockVerticalAlignmentUI, _extends({}, props, {
    isToolbar: true
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-vertical-alignment-control/README.md
 */



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/justify-content-control/ui.js



/**
 * WordPress dependencies
 */



const icons = {
  left: justify_left,
  center: justify_center,
  right: justify_right,
  'space-between': justify_space_between
};

function ui_JustifyContentUI(_ref) {
  let {
    allowedControls = ['left', 'center', 'right', 'space-between'],
    isCollapsed = true,
    onChange,
    value,
    popoverProps,
    isToolbar
  } = _ref;

  // If the control is already selected we want a click
  // again on the control to deselect the item, so we
  // call onChange( undefined )
  const handleClick = next => {
    if (next === value) {
      onChange(undefined);
    } else {
      onChange(next);
    }
  };

  const icon = value ? icons[value] : icons.left;
  const allControls = [{
    name: 'left',
    icon: justify_left,
    title: (0,_wordpress_i18n_build_module.__)('Justify items left'),
    isActive: 'left' === value,
    onClick: () => handleClick('left')
  }, {
    name: 'center',
    icon: justify_center,
    title: (0,_wordpress_i18n_build_module.__)('Justify items center'),
    isActive: 'center' === value,
    onClick: () => handleClick('center')
  }, {
    name: 'right',
    icon: justify_right,
    title: (0,_wordpress_i18n_build_module.__)('Justify items right'),
    isActive: 'right' === value,
    onClick: () => handleClick('right')
  }, {
    name: 'space-between',
    icon: justify_space_between,
    title: (0,_wordpress_i18n_build_module.__)('Space between items'),
    isActive: 'space-between' === value,
    onClick: () => handleClick('space-between')
  }];
  const UIComponent = isToolbar ? toolbar_group : toolbar_dropdown_menu;
  const extraProps = isToolbar ? {
    isCollapsed
  } : {};
  return (0,react.createElement)(UIComponent, (0,esm_extends/* default */.A)({
    icon: icon,
    popoverProps: popoverProps,
    label: (0,_wordpress_i18n_build_module.__)('Change items justification'),
    controls: allControls.filter(elem => allowedControls.includes(elem.name))
  }, extraProps));
}

/* harmony default export */ const justify_content_control_ui = (ui_JustifyContentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/justify-content-control/index.js



/**
 * Internal dependencies
 */


const JustifyContentControl = props => {
  return (0,react.createElement)(justify_content_control_ui, (0,esm_extends/* default */.A)({}, props, {
    isToolbar: false
  }));
};

const JustifyToolbar = props => {
  return createElement(JustifyContentUI, _extends({}, props, {
    isToolbar: true
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/justify-content-control/README.md
 */



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/layouts/flex.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




 // Used with the default, horizontal flex orientation.

const justifyContentMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center',
  'space-between': 'space-between'
}; // Used with the vertical (column) flex orientation.

const alignItemsMap = {
  left: 'flex-start',
  right: 'flex-end',
  center: 'center'
};
const verticalAlignmentMap = {
  top: 'flex-start',
  center: 'center',
  bottom: 'flex-end'
};
const flexWrapOptions = ['wrap', 'nowrap'];
/* harmony default export */ const flex = ({
  name: 'flex',
  label: (0,_wordpress_i18n_build_module.__)('Flex'),
  inspectorControls: function FlexLayoutInspectorControls(_ref) {
    let {
      layout = {},
      onChange,
      layoutBlockSupport = {}
    } = _ref;
    const {
      allowOrientation = true
    } = layoutBlockSupport;
    return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(flex_component, null, (0,react.createElement)(flex_item_component, null, (0,react.createElement)(FlexLayoutJustifyContentControl, {
      layout: layout,
      onChange: onChange
    })), (0,react.createElement)(flex_item_component, null, allowOrientation && (0,react.createElement)(OrientationControl, {
      layout: layout,
      onChange: onChange
    }))), (0,react.createElement)(FlexWrapControl, {
      layout: layout,
      onChange: onChange
    }));
  },
  toolBarControls: function FlexLayoutToolbarControls(_ref2) {
    let {
      layout = {},
      onChange,
      layoutBlockSupport
    } = _ref2;

    if (layoutBlockSupport !== null && layoutBlockSupport !== void 0 && layoutBlockSupport.allowSwitching) {
      return null;
    }

    const {
      allowVerticalAlignment = true
    } = layoutBlockSupport;
    return (0,react.createElement)(block_controls, {
      group: "block",
      __experimentalShareWithChildBlocks: true
    }, (0,react.createElement)(FlexLayoutJustifyContentControl, {
      layout: layout,
      onChange: onChange,
      isToolbar: true
    }), allowVerticalAlignment && (layout === null || layout === void 0 ? void 0 : layout.orientation) !== 'vertical' && (0,react.createElement)(FlexLayoutVerticalAlignmentControl, {
      layout: layout,
      onChange: onChange,
      isToolbar: true
    }));
  },
  getLayoutStyle: function getLayoutStyle(_ref3) {
    var _style$spacing, _style$spacing2;

    let {
      selector,
      layout,
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions
    } = _ref3;
    const {
      orientation = 'horizontal'
    } = layout; // If a block's block.json skips serialization for spacing or spacing.blockGap,
    // don't apply the user-defined value to the styles.

    const blockGapValue = style !== null && style !== void 0 && (_style$spacing = style.spacing) !== null && _style$spacing !== void 0 && _style$spacing.blockGap && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? getGapCSSValue(style === null || style === void 0 ? void 0 : (_style$spacing2 = style.spacing) === null || _style$spacing2 === void 0 ? void 0 : _style$spacing2.blockGap, '0.5em') : undefined;
    const justifyContent = justifyContentMap[layout.justifyContent];
    const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : 'wrap';
    const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment];
    const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
    let output = '';
    const rules = [];

    if (flexWrap && flexWrap !== 'wrap') {
      rules.push(`flex-wrap: ${flexWrap}`);
    }

    if (orientation === 'horizontal') {
      if (verticalAlignment) {
        rules.push(`align-items: ${verticalAlignment}`);
      }

      if (justifyContent) {
        rules.push(`justify-content: ${justifyContent}`);
      }
    } else {
      rules.push('flex-direction: column');
      rules.push(`align-items: ${alignItems}`);
    }

    if (rules.length) {
      output = `${appendSelectors(selector)} {
				${rules.join('; ')};
			}`;
    } // Output blockGap styles based on rules contained in layout definitions in theme.json.


    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'flex', blockGapValue);
    }

    return output;
  },

  getOrientation(layout) {
    const {
      orientation = 'horizontal'
    } = layout;
    return orientation;
  },

  getAlignments() {
    return [];
  }

});

function FlexLayoutVerticalAlignmentControl(_ref4) {
  let {
    layout,
    onChange,
    isToolbar = false
  } = _ref4;
  const {
    verticalAlignment = verticalAlignmentMap.center
  } = layout;

  const onVerticalAlignmentChange = value => {
    onChange({ ...layout,
      verticalAlignment: value
    });
  };

  if (isToolbar) {
    return (0,react.createElement)(BlockVerticalAlignmentControl, {
      onChange: onVerticalAlignmentChange,
      value: verticalAlignment
    });
  }

  const verticalAlignmentOptions = [{
    value: 'flex-start',
    label: (0,_wordpress_i18n_build_module.__)('Align items top')
  }, {
    value: 'center',
    label: (0,_wordpress_i18n_build_module.__)('Align items center')
  }, {
    value: 'flex-end',
    label: (0,_wordpress_i18n_build_module.__)('Align items bottom')
  }];
  return (0,react.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-vertical-alignment-control"
  }, (0,react.createElement)("legend", null, (0,_wordpress_i18n_build_module.__)('Vertical alignment')), (0,react.createElement)("div", null, verticalAlignmentOptions.map((value, icon, label) => {
    return (0,react.createElement)(build_module_button, {
      key: value,
      label: label,
      icon: icon,
      isPressed: verticalAlignment === value,
      onClick: () => onVerticalAlignmentChange(value)
    });
  })));
}

function FlexLayoutJustifyContentControl(_ref5) {
  let {
    layout,
    onChange,
    isToolbar = false
  } = _ref5;
  const {
    justifyContent = 'left',
    orientation = 'horizontal'
  } = layout;

  const onJustificationChange = value => {
    onChange({ ...layout,
      justifyContent: value
    });
  };

  const allowedControls = ['left', 'center', 'right'];

  if (orientation === 'horizontal') {
    allowedControls.push('space-between');
  }

  if (isToolbar) {
    return (0,react.createElement)(JustifyContentControl, {
      allowedControls: allowedControls,
      value: justifyContent,
      onChange: onJustificationChange,
      popoverProps: {
        position: 'bottom right',
        isAlternate: true
      }
    });
  }

  const justificationOptions = [{
    value: 'left',
    icon: justify_left,
    label: (0,_wordpress_i18n_build_module.__)('Justify items left')
  }, {
    value: 'center',
    icon: justify_center,
    label: (0,_wordpress_i18n_build_module.__)('Justify items center')
  }, {
    value: 'right',
    icon: justify_right,
    label: (0,_wordpress_i18n_build_module.__)('Justify items right')
  }];

  if (orientation === 'horizontal') {
    justificationOptions.push({
      value: 'space-between',
      icon: justify_space_between,
      label: (0,_wordpress_i18n_build_module.__)('Space between items')
    });
  }

  return (0,react.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-justification-controls"
  }, (0,react.createElement)("legend", null, (0,_wordpress_i18n_build_module.__)('Justification')), (0,react.createElement)("div", null, justificationOptions.map(_ref6 => {
    let {
      value,
      icon,
      label
    } = _ref6;
    return (0,react.createElement)(build_module_button, {
      key: value,
      label: label,
      icon: icon,
      isPressed: justifyContent === value,
      onClick: () => onJustificationChange(value)
    });
  })));
}

function FlexWrapControl(_ref7) {
  let {
    layout,
    onChange
  } = _ref7;
  const {
    flexWrap = 'wrap'
  } = layout;
  return (0,react.createElement)(ToggleControl, {
    label: (0,_wordpress_i18n_build_module.__)('Allow to wrap to multiple lines'),
    onChange: value => {
      onChange({ ...layout,
        flexWrap: value ? 'wrap' : 'nowrap'
      });
    },
    checked: flexWrap === 'wrap'
  });
}

function OrientationControl(_ref8) {
  let {
    layout,
    onChange
  } = _ref8;
  const {
    orientation = 'horizontal'
  } = layout;
  return (0,react.createElement)("fieldset", {
    className: "block-editor-hooks__flex-layout-orientation-controls"
  }, (0,react.createElement)("legend", null, (0,_wordpress_i18n_build_module.__)('Orientation')), (0,react.createElement)(build_module_button, {
    label: (0,_wordpress_i18n_build_module.__)('Horizontal'),
    icon: arrow_right,
    isPressed: orientation === 'horizontal',
    onClick: () => onChange({ ...layout,
      orientation: 'horizontal'
    })
  }), (0,react.createElement)(build_module_button, {
    label: (0,_wordpress_i18n_build_module.__)('Vertical'),
    icon: arrow_down,
    isPressed: orientation === 'vertical',
    onClick: () => onChange({ ...layout,
      orientation: 'vertical'
    })
  }));
}
//# sourceMappingURL=flex.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/layouts/flow.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/* harmony default export */ const flow = ({
  name: 'default',
  label: (0,_wordpress_i18n_build_module.__)('Flow'),
  inspectorControls: function DefaultLayoutInspectorControls() {
    return null;
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle(_ref) {
    var _style$spacing;

    let {
      selector,
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions
    } = _ref;
    const blockGapStyleValue = getGapBoxControlValueFromStyle(style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.blockGap); // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.

    const blockGapValue = blockGapStyleValue !== null && blockGapStyleValue !== void 0 && blockGapStyleValue.top && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? blockGapStyleValue === null || blockGapStyleValue === void 0 ? void 0 : blockGapStyleValue.top : '';
    let output = ''; // Output blockGap styles based on rules contained in layout definitions in theme.json.

    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'default', blockGapValue);
    }

    return output;
  },

  getOrientation() {
    return 'vertical';
  },

  getAlignments(layout) {
    const alignmentInfo = getAlignmentsInfo(layout);

    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }

      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }

    const {
      contentSize,
      wideSize
    } = layout;
    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }];

    if (contentSize) {
      alignments.unshift({
        name: 'full'
      });
    }

    if (wideSize) {
      alignments.unshift({
        name: 'wide',
        info: alignmentInfo.wide
      });
    }

    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }

});
//# sourceMappingURL=flow.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/position-center.js

/**
 * WordPress dependencies
 */

const positionCenter = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM7 9h10v6H7V9Z"
}));
/* harmony default export */ const position_center = (positionCenter);
//# sourceMappingURL=position-center.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/stretch-wide.js

/**
 * WordPress dependencies
 */

const stretchWide = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M16 5.5H8V4h8v1.5ZM16 20H8v-1.5h8V20ZM5 9h14v6H5V9Z"
}));
/* harmony default export */ const stretch_wide = (stretchWide);
//# sourceMappingURL=stretch-wide.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/constants.js
const VARIABLE_REFERENCE_PREFIX = 'var:';
const VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE = '|';
const VARIABLE_PATH_SEPARATOR_TOKEN_STYLE = '--';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/utils.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Returns a JSON representation of the generated CSS rules.
 *
 * @param  style   Style object.
 * @param  options Options object with settings to adjust how the styles are generated.
 * @param  path    An array of strings representing the path to the style value in the style object.
 * @param  ruleKey A CSS property key.
 *
 * @return GeneratedCSSRule[] CSS rules.
 */

function generateRule(style, options, path, ruleKey) {
  const styleValue = (0,lodash.get)(style, path);
  return styleValue ? [{
    selector: options === null || options === void 0 ? void 0 : options.selector,
    key: ruleKey,
    value: getCSSVarFromStyleValue(styleValue)
  }] : [];
}
/**
 * Returns a JSON representation of the generated CSS rules taking into account box model properties, top, right, bottom, left.
 *
 * @param  style                Style object.
 * @param  options              Options object with settings to adjust how the styles are generated.
 * @param  path                 An array of strings representing the path to the style value in the style object.
 * @param  ruleKeys             An array of CSS property keys and patterns.
 * @param  individualProperties The "sides" or individual properties for which to generate rules.
 *
 * @return GeneratedCSSRule[]  CSS rules.
 */

function generateBoxRules(style, options, path, ruleKeys) {
  let individualProperties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['top', 'right', 'bottom', 'left'];
  const boxStyle = (0,lodash.get)(style, path);

  if (!boxStyle) {
    return [];
  }

  const rules = [];

  if (typeof boxStyle === 'string') {
    rules.push({
      selector: options === null || options === void 0 ? void 0 : options.selector,
      key: ruleKeys.default,
      value: boxStyle
    });
  } else {
    const sideRules = individualProperties.reduce((acc, side) => {
      const value = getCSSVarFromStyleValue((0,lodash.get)(boxStyle, [side]));

      if (value) {
        acc.push({
          selector: options === null || options === void 0 ? void 0 : options.selector,
          key: ruleKeys === null || ruleKeys === void 0 ? void 0 : ruleKeys.individual.replace('%s', upperFirst(side)),
          value
        });
      }

      return acc;
    }, []);
    rules.push(...sideRules);
  }

  return rules;
}
/**
 * Returns a CSS var value from incoming style value following the pattern `var:description|context|slug`.
 *
 * @param  styleValue A raw style value.
 *
 * @return string A CSS var value.
 */

function getCSSVarFromStyleValue(styleValue) {
  if (typeof styleValue === 'string' && styleValue.startsWith(VARIABLE_REFERENCE_PREFIX)) {
    const variable = styleValue.slice(VARIABLE_REFERENCE_PREFIX.length).split(VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE).join(VARIABLE_PATH_SEPARATOR_TOKEN_STYLE);
    return `var(--wp--${variable})`;
  }

  return styleValue;
}
/**
 * Capitalizes the first letter in a string.
 *
 * @param {string} str The string whose first letter the function will capitalize.
 *
 * @return string A CSS var value.
 */

function upperFirst(_ref) {
  let [firstLetter, ...rest] = _ref;
  return firstLetter.toUpperCase() + rest.join('');
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/border/index.js
/**
 * Internal dependencies
 */

const color = {
  name: 'color',
  generate: function (style, options) {
    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['border', 'color'];
    let ruleKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'borderColor';
    return generateRule(style, options, path, ruleKey);
  }
};
const radius = {
  name: 'radius',
  generate: (style, options) => {
    return generateBoxRules(style, options, ['border', 'radius'], {
      default: 'borderRadius',
      individual: 'border%sRadius'
    }, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
  }
};
const borderStyle = {
  name: 'style',
  generate: function (style, options) {
    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['border', 'style'];
    let ruleKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'borderStyle';
    return generateRule(style, options, path, ruleKey);
  }
};
const width = {
  name: 'width',
  generate: function (style, options) {
    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['border', 'width'];
    let ruleKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'borderWidth';
    return generateRule(style, options, path, ruleKey);
  }
};
const borderDefinitionsWithIndividualStyles = [color, borderStyle, width];
/**
 * Returns a curried generator function with the individual border property ('top' | 'right' | 'bottom' | 'left') baked in.
 *
 * @param  individualProperty Individual border property ('top' | 'right' | 'bottom' | 'left').
 *
 * @return StyleDefinition[ 'generate' ]
 */

const createBorderGenerateFunction = individualProperty => (style, options) => {
  var _style$border;

  const styleValue = style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border[individualProperty];

  if (!styleValue) {
    return [];
  }

  return borderDefinitionsWithIndividualStyles.reduce((acc, borderDefinition) => {
    const key = borderDefinition.name;

    if (styleValue.hasOwnProperty(key) && typeof borderDefinition.generate === 'function') {
      const ruleKey = `border${upperFirst(individualProperty)}${upperFirst(key)}`;
      acc.push(...borderDefinition.generate(style, options, ['border', individualProperty, key], ruleKey));
    }

    return acc;
  }, []);
};

const borderTop = {
  name: 'borderTop',
  generate: createBorderGenerateFunction('top')
};
const borderRight = {
  name: 'borderRight',
  generate: createBorderGenerateFunction('right')
};
const borderBottom = {
  name: 'borderBottom',
  generate: createBorderGenerateFunction('bottom')
};
const borderLeft = {
  name: 'borderLeft',
  generate: createBorderGenerateFunction('left')
};
/* harmony default export */ const border = ([...borderDefinitionsWithIndividualStyles, radius, borderTop, borderRight, borderBottom, borderLeft]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/color/background.js
/**
 * Internal dependencies
 */

const background = {
  name: 'background',
  generate: (style, options) => {
    return generateRule(style, options, ['color', 'background'], 'backgroundColor');
  }
};
/* harmony default export */ const color_background = (background);
//# sourceMappingURL=background.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/color/gradient.js
/**
 * Internal dependencies
 */

const gradient = {
  name: 'gradient',
  generate: (style, options) => {
    return generateRule(style, options, ['color', 'gradient'], 'background');
  }
};
/* harmony default export */ const color_gradient = (gradient);
//# sourceMappingURL=gradient.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/color/text.js
/**
 * Internal dependencies
 */

const text_text = {
  name: 'text',
  generate: (style, options) => {
    return generateRule(style, options, ['color', 'text'], 'color');
  }
};
/* harmony default export */ const color_text = (text_text);
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/color/index.js
/**
 * Internal dependencies
 */



/* harmony default export */ const styles_color = ([color_text, color_gradient, color_background]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/spacing/padding.js
/**
 * Internal dependencies
 */

const padding = {
  name: 'padding',
  generate: (style, options) => {
    return generateBoxRules(style, options, ['spacing', 'padding'], {
      default: 'padding',
      individual: 'padding%s'
    });
  }
};
/* harmony default export */ const spacing_padding = (padding);
//# sourceMappingURL=padding.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/spacing/margin.js
/**
 * Internal dependencies
 */

const margin = {
  name: 'margin',
  generate: (style, options) => {
    return generateBoxRules(style, options, ['spacing', 'margin'], {
      default: 'margin',
      individual: 'margin%s'
    });
  }
};
/* harmony default export */ const spacing_margin = (margin);
//# sourceMappingURL=margin.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/spacing/index.js
/**
 * Internal dependencies
 */


/* harmony default export */ const spacing = ([spacing_margin, spacing_padding]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/typography/index.js
/**
 * Internal dependencies
 */

const fontSize = {
  name: 'fontSize',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontSize'], 'fontSize');
  }
};
const fontStyle = {
  name: 'fontStyle',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontStyle'], 'fontStyle');
  }
};
const fontWeight = {
  name: 'fontWeight',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontWeight'], 'fontWeight');
  }
};
const fontFamily = {
  name: 'fontFamily',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'fontFamily'], 'fontFamily');
  }
};
const letterSpacing = {
  name: 'letterSpacing',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'letterSpacing'], 'letterSpacing');
  }
};
const lineHeight = {
  name: 'letterSpacing',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'lineHeight'], 'lineHeight');
  }
};
const textDecoration = {
  name: 'textDecoration',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'textDecoration'], 'textDecoration');
  }
};
const textTransform = {
  name: 'textTransform',
  generate: (style, options) => {
    return generateRule(style, options, ['typography', 'textTransform'], 'textTransform');
  }
};
/* harmony default export */ const typography = ([fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textDecoration, textTransform]);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/styles/index.js
/**
 * Internal dependencies
 */




const styleDefinitions = [...border, ...styles_color, ...spacing, ...typography];
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+style-engine@0.15.0/node_modules/@wordpress/style-engine/build-module/index.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Generates a stylesheet for a given style object and selector.
 *
 * @param  style   Style object, for example, the value of a block's attributes.style object or the top level styles in theme.json
 * @param  options Options object with settings to adjust how the styles are generated.
 *
 * @return generated stylesheet.
 */

function compileCSS(style) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const rules = getCSSRules(style, options); // If no selector is provided, treat generated rules as inline styles to be returned as a single string.

  if (!(options !== null && options !== void 0 && options.selector)) {
    const inlineRules = [];
    rules.forEach(rule => {
      inlineRules.push(`${(0,lodash.kebabCase)(rule.key)}: ${rule.value};`);
    });
    return inlineRules.join(' ');
  }

  const groupedRules = (0,lodash.groupBy)(rules, 'selector');
  const selectorRules = Object.keys(groupedRules).reduce((acc, subSelector) => {
    acc.push(`${subSelector} { ${groupedRules[subSelector].map(rule => `${(0,lodash.kebabCase)(rule.key)}: ${rule.value};`).join(' ')} }`);
    return acc;
  }, []);
  return selectorRules.join('\n');
}
/**
 * Returns a JSON representation of the generated CSS rules.
 *
 * @param  style   Style object, for example, the value of a block's attributes.style object or the top level styles in theme.json
 * @param  options Options object with settings to adjust how the styles are generated.
 *
 * @return generated styles.
 */

function getCSSRules(style) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const rules = [];
  styleDefinitions.forEach(definition => {
    if (typeof definition.generate === 'function') {
      rules.push(...definition.generate(style, options));
    }
  });
  return rules;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/layouts/constrained.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





/* harmony default export */ const constrained = ({
  name: 'constrained',
  label: (0,_wordpress_i18n_build_module.__)('Constrained'),
  inspectorControls: function DefaultLayoutInspectorControls(_ref) {
    let {
      layout,
      onChange
    } = _ref;
    const {
      wideSize,
      contentSize
    } = layout;
    const units = useCustomUnits({
      availableUnits: use_setting_useSetting('spacing.units') || ['%', 'px', 'em', 'rem', 'vw']
    });
    return (0,react.createElement)(react.Fragment, null, (0,react.createElement)("div", {
      className: "block-editor-hooks__layout-controls"
    }, (0,react.createElement)("div", {
      className: "block-editor-hooks__layout-controls-unit"
    }, (0,react.createElement)(unit_control, {
      label: (0,_wordpress_i18n_build_module.__)('Content'),
      labelPosition: "top",
      __unstableInputWidth: "80px",
      value: contentSize || wideSize || '',
      onChange: nextWidth => {
        nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
        onChange({ ...layout,
          contentSize: nextWidth
        });
      },
      units: units
    }), (0,react.createElement)(icon, {
      icon: position_center
    })), (0,react.createElement)("div", {
      className: "block-editor-hooks__layout-controls-unit"
    }, (0,react.createElement)(unit_control, {
      label: (0,_wordpress_i18n_build_module.__)('Wide'),
      labelPosition: "top",
      __unstableInputWidth: "80px",
      value: wideSize || contentSize || '',
      onChange: nextWidth => {
        nextWidth = 0 > parseFloat(nextWidth) ? '0' : nextWidth;
        onChange({ ...layout,
          wideSize: nextWidth
        });
      },
      units: units
    }), (0,react.createElement)(icon, {
      icon: stretch_wide
    }))), (0,react.createElement)("div", {
      className: "block-editor-hooks__layout-controls-reset"
    }, (0,react.createElement)(build_module_button, {
      variant: "secondary",
      isSmall: true,
      disabled: !contentSize && !wideSize,
      onClick: () => onChange({
        contentSize: undefined,
        wideSize: undefined,
        inherit: false
      })
    }, (0,_wordpress_i18n_build_module.__)('Reset'))), (0,react.createElement)("p", {
      className: "block-editor-hooks__layout-controls-helptext"
    }, (0,_wordpress_i18n_build_module.__)('Customize the width for all elements that are assigned to the center or wide columns.')));
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle(_ref2) {
    var _style$spacing, _style$spacing2;

    let {
      selector,
      layout = {},
      style,
      blockName,
      hasBlockGapSupport,
      layoutDefinitions
    } = _ref2;
    const {
      contentSize,
      wideSize
    } = layout;
    const blockGapStyleValue = getGapBoxControlValueFromStyle(style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.blockGap); // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.

    const blockGapValue = blockGapStyleValue !== null && blockGapStyleValue !== void 0 && blockGapStyleValue.top && !shouldSkipSerialization(blockName, 'spacing', 'blockGap') ? blockGapStyleValue === null || blockGapStyleValue === void 0 ? void 0 : blockGapStyleValue.top : '';
    let output = !!contentSize || !!wideSize ? `
					${appendSelectors(selector, '> :where(:not(.alignleft):not(.alignright):not(.alignfull))')} {
						max-width: ${contentSize !== null && contentSize !== void 0 ? contentSize : wideSize};
						margin-left: auto !important;
						margin-right: auto !important;
					}
					${appendSelectors(selector, '> .alignwide')}  {
						max-width: ${wideSize !== null && wideSize !== void 0 ? wideSize : contentSize};
					}
					${appendSelectors(selector, '> .alignfull')} {
						max-width: none;
					}
				` : ''; // If there is custom padding, add negative margins for alignfull blocks.

    if (style !== null && style !== void 0 && (_style$spacing2 = style.spacing) !== null && _style$spacing2 !== void 0 && _style$spacing2.padding) {
      // The style object might be storing a preset so we need to make sure we get a usable value.
      const paddingValues = getCSSRules(style);
      paddingValues.forEach(rule => {
        if (rule.key === 'paddingRight') {
          output += `
					${appendSelectors(selector, '> .alignfull')} {
						margin-right: calc(${rule.value} * -1);
					}
					`;
        } else if (rule.key === 'paddingLeft') {
          output += `
					${appendSelectors(selector, '> .alignfull')} {
						margin-left: calc(${rule.value} * -1);
					}
					`;
        }
      });
    } // Output blockGap styles based on rules contained in layout definitions in theme.json.


    if (hasBlockGapSupport && blockGapValue) {
      output += getBlockGapCSS(selector, layoutDefinitions, 'constrained', blockGapValue);
    }

    return output;
  },

  getOrientation() {
    return 'vertical';
  },

  getAlignments(layout) {
    const alignmentInfo = getAlignmentsInfo(layout);

    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }

      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }

    const {
      contentSize,
      wideSize
    } = layout;
    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }];

    if (contentSize) {
      alignments.unshift({
        name: 'full'
      });
    }

    if (wideSize) {
      alignments.unshift({
        name: 'wide',
        info: alignmentInfo.wide
      });
    }

    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }

});
//# sourceMappingURL=constrained.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/layouts/index.js
/**
 * Internal dependencies
 */



const layoutTypes = [flow, flex, constrained];
/**
 * Retrieves a layout type by name.
 *
 * @param {string} name - The name of the layout type.
 * @return {Object} Layout type.
 */

function getLayoutType() {
  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
  return layoutTypes.find(layoutType => layoutType.name === name);
}
/**
 * Retrieves the available layout types.
 *
 * @return {Array} Layout types.
 */

function getLayoutTypes() {
  return layoutTypes;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/layout.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const defaultLayout = {
  type: 'default'
};
const layout_Layout = (0,react.createContext)(defaultLayout);
/**
 * Allows to define the layout.
 */

const LayoutProvider = layout_Layout.Provider;
/**
 * React hook used to retrieve the layout config.
 */

function useLayout() {
  return (0,react.useContext)(layout_Layout);
}
function LayoutStyle(_ref) {
  let {
    layout = {},
    css,
    ...props
  } = _ref;
  const layoutType = getLayoutType(layout.type);
  const blockGapSupport = use_setting_useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;

  if (layoutType) {
    var _layoutType$getLayout;

    if (css) {
      return (0,react.createElement)("style", null, css);
    }

    const layoutStyle = (_layoutType$getLayout = layoutType.getLayoutStyle) === null || _layoutType$getLayout === void 0 ? void 0 : _layoutType$getLayout.call(layoutType, {
      hasBlockGapSupport,
      layout,
      ...props
    });

    if (layoutStyle) {
      return (0,react.createElement)("style", null, layoutStyle);
    }
  }

  return null;
}
//# sourceMappingURL=layout.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/use-available-alignments.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const use_available_alignments_DEFAULT_CONTROLS = ['none', 'left', 'center', 'right', 'wide', 'full'];
const WIDE_CONTROLS = ['wide', 'full'];
function useAvailableAlignments() {
  let controls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : use_available_alignments_DEFAULT_CONTROLS;

  // Always add the `none` option if not exists.
  if (!controls.includes('none')) {
    controls = ['none', ...controls];
  }

  const {
    wideControlsEnabled = false,
    themeSupportsLayout
  } = use_select_useSelect(select => {
    const {
      getSettings
    } = select(store_store);
    const settings = getSettings();
    return {
      wideControlsEnabled: settings.alignWide,
      themeSupportsLayout: settings.supportsLayout
    };
  }, []);
  const layout = useLayout();
  const layoutType = getLayoutType(layout === null || layout === void 0 ? void 0 : layout.type);
  const layoutAlignments = layoutType.getAlignments(layout);

  if (themeSupportsLayout) {
    const alignments = layoutAlignments.filter(_ref => {
      let {
        name: alignmentName
      } = _ref;
      return controls.includes(alignmentName);
    }); // While we treat `none` as an alignment, we shouldn't return it if no
    // other alignments exist.

    if (alignments.length === 1 && alignments[0].name === 'none') {
      return [];
    }

    return alignments;
  } // Starting here, it's the fallback for themes not supporting the layout config.


  if (layoutType.name !== 'default' && layoutType.name !== 'constrained') {
    return [];
  }

  const {
    alignments: availableAlignments = use_available_alignments_DEFAULT_CONTROLS
  } = layout;
  const enabledControls = controls.filter(control => (layout.alignments || // Ignore the global wideAlignment check if the layout explicitely defines alignments.
  wideControlsEnabled || !WIDE_CONTROLS.includes(control)) && availableAlignments.includes(control)).map(enabledControl => ({
    name: enabledControl
  })); // While we treat `none` as an alignment, we shouldn't return it if no
  // other alignments exist.

  if (enabledControls.length === 1 && enabledControls[0].name === 'none') {
    return [];
  }

  return enabledControls;
}
//# sourceMappingURL=use-available-alignments.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/align-none.js

/**
 * WordPress dependencies
 */

const alignNone = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M19 5.5H5V4h14v1.5ZM19 20H5v-1.5h14V20ZM5 9h14v6H5V9Z"
}));
/* harmony default export */ const align_none = (alignNone);
//# sourceMappingURL=align-none.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/position-left.js

/**
 * WordPress dependencies
 */

const positionLeft = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M5 5.5h8V4H5v1.5ZM5 20h8v-1.5H5V20ZM19 9H5v6h14V9Z"
}));
/* harmony default export */ const position_left = (positionLeft);
//# sourceMappingURL=position-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/position-right.js

/**
 * WordPress dependencies
 */

const positionRight = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M19 5.5h-8V4h8v1.5ZM19 20h-8v-1.5h8V20ZM5 9h14v6H5V9Z"
}));
/* harmony default export */ const position_right = (positionRight);
//# sourceMappingURL=position-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/stretch-full-width.js

/**
 * WordPress dependencies
 */

const stretchFullWidth = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M5 4h14v11H5V4Zm11 16H8v-1.5h8V20Z"
}));
/* harmony default export */ const stretch_full_width = (stretchFullWidth);
//# sourceMappingURL=stretch-full-width.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/constants.js
/**
 * WordPress dependencies
 */


const constants_BLOCK_ALIGNMENTS_CONTROLS = {
  none: {
    icon: align_none,
    title: (0,_wordpress_i18n_build_module._x)('None', 'Alignment option')
  },
  left: {
    icon: position_left,
    title: (0,_wordpress_i18n_build_module.__)('Align left')
  },
  center: {
    icon: position_center,
    title: (0,_wordpress_i18n_build_module.__)('Align center')
  },
  right: {
    icon: position_right,
    title: (0,_wordpress_i18n_build_module.__)('Align right')
  },
  wide: {
    icon: stretch_wide,
    title: (0,_wordpress_i18n_build_module.__)('Wide width')
  },
  full: {
    icon: stretch_full_width,
    title: (0,_wordpress_i18n_build_module.__)('Full width')
  }
};
const constants_DEFAULT_CONTROL = 'none';
const constants_POPOVER_PROPS = {
  isAlternate: true
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/ui.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function ui_BlockAlignmentUI(_ref) {
  let {
    value,
    onChange,
    controls,
    isToolbar,
    isCollapsed = true
  } = _ref;
  const enabledControls = useAvailableAlignments(controls);
  const hasEnabledControls = !!enabledControls.length;

  if (!hasEnabledControls) {
    return null;
  }

  function onChangeAlignment(align) {
    onChange([value, 'none'].includes(align) ? undefined : align);
  }

  const activeAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[value];
  const defaultAlignmentControl = constants_BLOCK_ALIGNMENTS_CONTROLS[constants_DEFAULT_CONTROL];
  const UIComponent = isToolbar ? toolbar_group : toolbar_dropdown_menu;
  const commonProps = {
    popoverProps: constants_POPOVER_PROPS,
    icon: activeAlignmentControl ? activeAlignmentControl.icon : defaultAlignmentControl.icon,
    label: (0,_wordpress_i18n_build_module.__)('Align'),
    toggleProps: {
      describedBy: (0,_wordpress_i18n_build_module.__)('Change alignment')
    }
  };
  const extraProps = isToolbar ? {
    isCollapsed,
    controls: enabledControls.map(_ref2 => {
      let {
        name: controlName
      } = _ref2;
      return { ...constants_BLOCK_ALIGNMENTS_CONTROLS[controlName],
        isActive: value === controlName || !value && controlName === 'none',
        role: isCollapsed ? 'menuitemradio' : undefined,
        onClick: () => onChangeAlignment(controlName)
      };
    })
  } : {
    children: _ref3 => {
      let {
        onClose
      } = _ref3;
      return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(menu_group, {
        className: "block-editor-block-alignment-control__menu-group"
      }, enabledControls.map(_ref4 => {
        let {
          name: controlName,
          info
        } = _ref4;
        const {
          icon,
          title
        } = constants_BLOCK_ALIGNMENTS_CONTROLS[controlName]; // If no value is provided, mark as selected the `none` option.

        const isSelected = controlName === value || !value && controlName === 'none';
        return (0,react.createElement)(menu_item, {
          key: controlName,
          icon: icon,
          iconPosition: "left",
          className: classnames_default()('components-dropdown-menu__menu-item', {
            'is-active': isSelected
          }),
          isSelected: isSelected,
          onClick: () => {
            onChangeAlignment(controlName);
            onClose();
          },
          role: "menuitemradio",
          info: info
        }, title);
      })));
    }
  };
  return (0,react.createElement)(UIComponent, (0,esm_extends/* default */.A)({}, commonProps, extraProps));
}

/* harmony default export */ const block_alignment_control_ui = (ui_BlockAlignmentUI);
//# sourceMappingURL=ui.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-alignment-control/index.js



/**
 * Internal dependencies
 */


const BlockAlignmentControl = props => {
  return (0,react.createElement)(block_alignment_control_ui, (0,esm_extends/* default */.A)({}, props, {
    isToolbar: false
  }));
};

const BlockAlignmentToolbar = props => {
  return createElement(BlockAlignmentUI, _extends({}, props, {
    isToolbar: true
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-alignment-control/README.md
 */



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/align.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * An array which includes all possible valid alignments,
 * used to validate if an alignment is valid or not.
 *
 * @constant
 * @type {string[]}
 */

const ALL_ALIGNMENTS = ['left', 'center', 'right', 'wide', 'full'];
/**
 * An array which includes all wide alignments.
 * In order for this alignments to be valid they need to be supported by the block,
 * and by the theme.
 *
 * @constant
 * @type {string[]}
 */

const WIDE_ALIGNMENTS = ['wide', 'full'];
/**
 * Returns the valid alignments.
 * Takes into consideration the aligns supported by a block, if the block supports wide controls or not and if theme supports wide controls or not.
 * Exported just for testing purposes, not exported outside the module.
 *
 * @param {?boolean|string[]} blockAlign          Aligns supported by the block.
 * @param {?boolean}          hasWideBlockSupport True if block supports wide alignments. And False otherwise.
 * @param {?boolean}          hasWideEnabled      True if theme supports wide alignments. And False otherwise.
 *
 * @return {string[]} Valid alignments.
 */

function getValidAlignments(blockAlign) {
  let hasWideBlockSupport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let hasWideEnabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let validAlignments;

  if (Array.isArray(blockAlign)) {
    validAlignments = ALL_ALIGNMENTS.filter(value => blockAlign.includes(value));
  } else if (blockAlign === true) {
    // `true` includes all alignments...
    validAlignments = [...ALL_ALIGNMENTS];
  } else {
    validAlignments = [];
  }

  if (!hasWideEnabled || blockAlign === true && !hasWideBlockSupport) {
    return (0,lodash.without)(validAlignments, ...WIDE_ALIGNMENTS);
  }

  return validAlignments;
}
/**
 * Filters registered block settings, extending attributes to include `align`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function addAttribute(settings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if ((0,lodash.has)(settings.attributes, ['align', 'type'])) {
    return settings;
  }

  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'align')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      align: {
        type: 'string',
        // Allow for '' since it is used by updateAlignment function
        // in withToolbarControls for special cases with defined default values.
        enum: [...ALL_ALIGNMENTS, '']
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include new toolbar controls for block
 * alignment, if block defines support.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const withToolbarControls = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => props => {
  const {
    name: blockName
  } = props; // Compute the block valid alignments by taking into account,
  // if the theme supports wide alignments or not and the layout's
  // availble alignments. We do that for conditionally rendering
  // Slot.

  const blockAllowedAlignments = getValidAlignments((0,build_module/* getBlockSupport */.bI)(blockName, 'align'), (0,build_module/* hasBlockSupport */.pN)(blockName, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments).map(_ref => {
    let {
      name
    } = _ref;
    return name;
  });

  const updateAlignment = nextAlign => {
    if (!nextAlign) {
      var _blockType$attributes, _blockType$attributes2;

      const blockType = (0,build_module/* getBlockType */.E7)(props.name);
      const blockDefaultAlign = blockType === null || blockType === void 0 ? void 0 : (_blockType$attributes = blockType.attributes) === null || _blockType$attributes === void 0 ? void 0 : (_blockType$attributes2 = _blockType$attributes.align) === null || _blockType$attributes2 === void 0 ? void 0 : _blockType$attributes2.default;

      if (blockDefaultAlign) {
        nextAlign = '';
      }
    }

    props.setAttributes({
      align: nextAlign
    });
  };

  return (0,react.createElement)(react.Fragment, null, !!validAlignments.length && (0,react.createElement)(block_controls, {
    group: "block",
    __experimentalShareWithChildBlocks: true
  }, (0,react.createElement)(BlockAlignmentControl, {
    value: props.attributes.align,
    onChange: updateAlignment,
    controls: validAlignments
  })), (0,react.createElement)(BlockEdit, props));
}, 'withToolbarControls');
/**
 * Override the default block element to add alignment wrapper props.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withDataAlign = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const {
    align
  } = attributes;
  const blockAllowedAlignments = getValidAlignments((0,build_module/* getBlockSupport */.bI)(name, 'align'), (0,build_module/* hasBlockSupport */.pN)(name, 'alignWide', true));
  const validAlignments = useAvailableAlignments(blockAllowedAlignments); // If an alignment is not assigned, there's no need to go through the
  // effort to validate or assign its value.

  if (align === undefined) {
    return (0,react.createElement)(BlockListBlock, props);
  }

  let wrapperProps = props.wrapperProps;

  if (validAlignments.some(alignment => alignment.name === align)) {
    wrapperProps = { ...wrapperProps,
      'data-align': align
    };
  }

  return (0,react.createElement)(BlockListBlock, (0,esm_extends/* default */.A)({}, props, {
    wrapperProps: wrapperProps
  }));
});
/**
 * Override props assigned to save component to inject alignment class name if
 * block supports it.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addAssignedAlign(props, blockType, attributes) {
  const {
    align
  } = attributes;
  const blockAlign = (0,build_module/* getBlockSupport */.bI)(blockType, 'align');
  const hasWideBlockSupport = (0,build_module/* hasBlockSupport */.pN)(blockType, 'alignWide', true); // Compute valid alignments without taking into account if
  // the theme supports wide alignments or not.
  // This way changing themes does not impact the block save.

  const isAlignValid = getValidAlignments(blockAlign, hasWideBlockSupport).includes(align);

  if (isAlignValid) {
    props.className = classnames_default()(`align${align}`, props.className);
  }

  return props;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/align/addAttribute', addAttribute);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/editor/align/with-data-align', withDataAlign);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/editor/align/with-toolbar-controls', withToolbarControls);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/align/addAssignedAlign', addAssignedAlign);
//# sourceMappingURL=align.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/lock.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Filters registered block settings, extending attributes to include `lock`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function lock_addAttribute(settings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if ((0,lodash.has)(settings.attributes, ['lock', 'type'])) {
    return settings;
  } // Gracefully handle if settings.attributes is undefined.


  settings.attributes = { ...settings.attributes,
    lock: {
      type: 'object'
    }
  };
  return settings;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/lock/addAttribute', lock_addAttribute);
//# sourceMappingURL=lock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/text-control/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function UnforwardedTextControl(props, ref) {
  const {
    label,
    hideLabelFromVision,
    value,
    help,
    className,
    onChange,
    type = 'text',
    ...additionalProps
  } = props;
  const instanceId = (0,use_instance_id/* default */.A)(TextControl);
  const id = `inspector-text-control-${instanceId}`;

  const onChangeValue = event => onChange(event.target.value);

  return (0,react.createElement)(base_control, {
    label: label,
    hideLabelFromVision: hideLabelFromVision,
    id: id,
    help: help,
    className: className
  }, (0,react.createElement)("input", (0,helpers_esm_extends/* default */.A)({
    className: "components-text-control__input",
    type: type,
    id: id,
    value: value,
    onChange: onChangeValue,
    "aria-describedby": !!help ? id + '__help' : undefined,
    ref: ref
  }, additionalProps)));
}
/**
 * TextControl components let users enter and edit text.
 *
 *
 * @example
 * ```jsx
 * import { TextControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyTextControl = () => {
 *   const [ className, setClassName ] = useState( '' );
 *
 *   return (
 *     <TextControl
 *       label="Additional CSS Class"
 *       value={ className }
 *       onChange={ ( value ) => setClassName( value ) }
 *     />
 *   );
 * };
 * ```
 */


const TextControl = (0,react.forwardRef)(UnforwardedTextControl);
/* harmony default export */ const text_control = (TextControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/external.js

/**
 * WordPress dependencies
 */

const external = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M19.5 4.5h-7V6h4.44l-5.97 5.97 1.06 1.06L18 7.06v4.44h1.5v-7Zm-13 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-3H17v3a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h3V5.5h-3Z"
}));
/* harmony default export */ const library_external = (external);
//# sourceMappingURL=external.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/external-link/styles/external-link-styles.js


function external_link_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

const StyledIcon = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(icon,  true ? {
  target: "esh4a730"
} : 0)( true ? {
  name: "rvs7bx",
  styles: "width:1em;height:1em;margin:0;vertical-align:middle;fill:currentColor"
} : 0);
//# sourceMappingURL=external-link-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/external-link/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function UnforwardedExternalLink(props, ref) {
  const {
    href,
    children,
    className,
    rel = '',
    ...additionalProps
  } = props;
  const optimizedRel = [...new Set([...rel.split(' '), 'external', 'noreferrer', 'noopener'].filter(Boolean))].join(' ');
  const classes = classnames_default()('components-external-link', className);
  /* Anchor links are percieved as external links.
  This constant helps check for on page anchor links,
  to prevent them from being opened in the editor. */

  const isInternalAnchor = !!(href !== null && href !== void 0 && href.startsWith('#'));
  return (
    /* eslint-disable react/jsx-no-target-blank */
    (0,react.createElement)("a", (0,helpers_esm_extends/* default */.A)({}, additionalProps, {
      className: classes,
      href: href,
      onClick: isInternalAnchor ? event => event.preventDefault() : undefined,
      target: "_blank",
      rel: optimizedRel,
      ref: ref
    }), children, (0,react.createElement)(visually_hidden_component, {
      as: "span"
    },
    /* translators: accessibility text */
    (0,i18n_build_module.__)('(opens in a new tab)')), (0,react.createElement)(StyledIcon, {
      icon: library_external,
      className: "components-external-link__icon"
    }))
    /* eslint-enable react/jsx-no-target-blank */

  );
}
/**
 * Link to an external resource.
 *
 * ```jsx
 * import { ExternalLink } from '@wordpress/components';
 *
 * const MyExternalLink = () => (
 *   <ExternalLink href="https://wordpress.org">WordPress.org</ExternalLink>
 * );
 * ```
 */


const ExternalLink = (0,react.forwardRef)(UnforwardedExternalLink);
/* harmony default export */ const external_link = (ExternalLink);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-media-query/index.js
var use_media_query = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-media-query/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-reduced-motion/index.js
/**
 * Internal dependencies
 */

/**
 * Hook returning whether the user has a preference for reduced motion.
 *
 * @return {boolean} Reduced motion preference value.
 */

const useReducedMotion = () => (0,use_media_query/* default */.A)('(prefers-reduced-motion: reduce)');

/* harmony default export */ const hooks_use_reduced_motion = (useReducedMotion);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/chevron-up.js

/**
 * WordPress dependencies
 */

const chevronUp = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
}));
/* harmony default export */ const chevron_up = (chevronUp);
//# sourceMappingURL=chevron-up.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/hooks/use-update-effect.js
/**
 * WordPress dependencies
 */

/**
 * A `React.useEffect` that will not run on the first render.
 * Source:
 * https://github.com/reakit/reakit/blob/HEAD/packages/reakit-utils/src/useUpdateEffect.ts
 *
 * @param {import('react').EffectCallback} effect
 * @param {import('react').DependencyList} deps
 */

function use_update_effect_useUpdateEffect(effect, deps) {
  const mounted = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    if (mounted.current) {
      return effect();
    }

    mounted.current = true;
    return undefined;
  }, deps);
}

/* harmony default export */ const use_update_effect = (use_update_effect_useUpdateEffect);
//# sourceMappingURL=use-update-effect.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/panel/body.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const body_noop = () => {};

function PanelBody(_ref, ref) {
  let {
    buttonProps = {},
    children,
    className,
    icon,
    initialOpen,
    onToggle = body_noop,
    opened,
    title,
    scrollAfterOpen = true
  } = _ref;
  const [isOpened, setIsOpened] = use_controlled_state(opened, {
    initial: initialOpen === undefined ? true : initialOpen
  });
  const nodeRef = (0,react.useRef)(); // Defaults to 'smooth' scrolling
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView

  const scrollBehavior = hooks_use_reduced_motion() ? 'auto' : 'smooth';

  const handleOnToggle = event => {
    event.preventDefault();
    const next = !isOpened;
    setIsOpened(next);
    onToggle(next);
  }; // Ref is used so that the effect does not re-run upon scrollAfterOpen changing value.


  const scrollAfterOpenRef = (0,react.useRef)();
  scrollAfterOpenRef.current = scrollAfterOpen; // Runs after initial render.

  use_update_effect(() => {
    var _nodeRef$current;

    if (isOpened && scrollAfterOpenRef.current && (_nodeRef$current = nodeRef.current) !== null && _nodeRef$current !== void 0 && _nodeRef$current.scrollIntoView) {
      /*
       * Scrolls the content into view when visible.
       * This improves the UX when there are multiple stacking <PanelBody />
       * components in a scrollable container.
       */
      nodeRef.current.scrollIntoView({
        inline: 'nearest',
        block: 'nearest',
        behavior: scrollBehavior
      });
    }
  }, [isOpened, scrollBehavior]);
  const classes = classnames_default()('components-panel__body', className, {
    'is-opened': isOpened
  });
  return (0,react.createElement)("div", {
    className: classes,
    ref: (0,use_merge_refs/* default */.A)([nodeRef, ref])
  }, (0,react.createElement)(PanelBodyTitle, (0,helpers_esm_extends/* default */.A)({
    icon: icon,
    isOpened: isOpened,
    onClick: handleOnToggle,
    title: title
  }, buttonProps)), typeof children === 'function' ? children({
    opened: isOpened
  }) : isOpened && children);
}
const PanelBodyTitle = (0,react.forwardRef)((_ref2, ref) => {
  let {
    isOpened,
    icon,
    title,
    ...props
  } = _ref2;
  if (!title) return null;
  return (0,react.createElement)("h2", {
    className: "components-panel__body-title"
  }, (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    className: "components-panel__body-toggle",
    "aria-expanded": isOpened,
    ref: ref
  }, props), (0,react.createElement)("span", {
    "aria-hidden": "true"
  }, (0,react.createElement)(build_module_icon, {
    className: "components-panel__arrow",
    icon: isOpened ? chevron_up : chevron_down
  })), title, icon && (0,react.createElement)(build_module_icon, {
    icon: icon,
    className: "components-panel__icon",
    size: 20
  })));
});
const body_ForwardedComponent = (0,react.forwardRef)(PanelBody);
body_ForwardedComponent.displayName = 'PanelBody';
/* harmony default export */ const body = (body_ForwardedComponent);
//# sourceMappingURL=body.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/anchor.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */


/**
 * Regular expression matching invalid anchor characters for replacement.
 *
 * @type {RegExp}
 */

const ANCHOR_REGEX = /[\s#]/g;
const ANCHOR_SCHEMA = {
  type: 'string',
  source: 'attribute',
  attribute: 'id',
  selector: '*'
};
/**
 * Filters registered block settings, extending attributes with anchor using ID
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function anchor_addAttribute(settings) {
  // Allow blocks to specify their own attribute definition with default values if needed.
  if ((0,lodash.has)(settings.attributes, ['anchor', 'type'])) {
    return settings;
  }

  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'anchor')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      anchor: ANCHOR_SCHEMA
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning the anchor ID, if block supports anchor.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */

const withInspectorControl = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => {
  return props => {
    const hasAnchor = (0,build_module/* hasBlockSupport */.pN)(props.name, 'anchor');

    if (hasAnchor && props.isSelected) {
      const isWeb = platform.OS === 'web';
      const textControl = (0,react.createElement)(text_control, {
        className: "html-anchor-control",
        label: (0,_wordpress_i18n_build_module.__)('HTML anchor'),
        help: (0,react.createElement)(react.Fragment, null, (0,_wordpress_i18n_build_module.__)('Enter a word or two — without spaces — to make a unique web address just for this block, called an “anchor.” Then, you’ll be able to link directly to this section of your page.'), isWeb && (0,react.createElement)(external_link, {
          href: (0,_wordpress_i18n_build_module.__)('https://wordpress.org/support/article/page-jumps/')
        }, (0,_wordpress_i18n_build_module.__)('Learn more about anchors'))),
        value: props.attributes.anchor || '',
        placeholder: !isWeb ? (0,_wordpress_i18n_build_module.__)('Add an anchor') : null,
        onChange: nextValue => {
          nextValue = nextValue.replace(ANCHOR_REGEX, '-');
          props.setAttributes({
            anchor: nextValue
          });
        },
        autoCapitalize: "none",
        autoComplete: "off"
      });
      return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(BlockEdit, props), isWeb && (0,react.createElement)(inspector_controls, {
        __experimentalGroup: "advanced"
      }, textControl), !isWeb && props.name === 'core/heading' && (0,react.createElement)(inspector_controls, null, (0,react.createElement)(body, {
        title: (0,_wordpress_i18n_build_module.__)('Heading settings')
      }, textControl)));
    }

    return (0,react.createElement)(BlockEdit, props);
  };
}, 'withInspectorControl');
/**
 * Override props assigned to save component to inject anchor ID, if block
 * supports anchor. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addSaveProps(extraProps, blockType, attributes) {
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'anchor')) {
    extraProps.id = attributes.anchor === '' ? null : attributes.anchor;
  }

  return extraProps;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/anchor/attribute', anchor_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/editor/anchor/with-inspector-control', withInspectorControl);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/anchor/save-props', addSaveProps);
//# sourceMappingURL=anchor.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/aria-label.js
/**
 * WordPress dependencies
 */


const ARIA_LABEL_SCHEMA = {
  type: 'string',
  source: 'attribute',
  attribute: 'aria-label',
  selector: '*'
};
/**
 * Filters registered block settings, extending attributes with ariaLabel using aria-label
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function aria_label_addAttribute(settings) {
  var _settings$attributes, _settings$attributes$;

  // Allow blocks to specify their own attribute definition with default values if needed.
  if (settings !== null && settings !== void 0 && (_settings$attributes = settings.attributes) !== null && _settings$attributes !== void 0 && (_settings$attributes$ = _settings$attributes.ariaLabel) !== null && _settings$attributes$ !== void 0 && _settings$attributes$.type) {
    return settings;
  }

  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'ariaLabel')) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      ariaLabel: ARIA_LABEL_SCHEMA
    };
  }

  return settings;
}
/**
 * Override props assigned to save component to inject aria-label, if block
 * supports ariaLabel. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function aria_label_addSaveProps(extraProps, blockType, attributes) {
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'ariaLabel')) {
    extraProps['aria-label'] = attributes.ariaLabel === '' ? null : attributes.ariaLabel;
  }

  return extraProps;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/ariaLabel/attribute', aria_label_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/ariaLabel/save-props', aria_label_addSaveProps);
//# sourceMappingURL=aria-label.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/custom-class-name.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/**
 * Filters registered block settings, extending attributes with anchor using ID
 * of the first node.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function custom_class_name_addAttribute(settings) {
  if ((0,build_module/* hasBlockSupport */.pN)(settings, 'customClassName', true)) {
    // Gracefully handle if settings.attributes is undefined.
    settings.attributes = { ...settings.attributes,
      className: {
        type: 'string'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning the custom class name, if block supports custom class name.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */

const custom_class_name_withInspectorControl = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => {
  return props => {
    const hasCustomClassName = (0,build_module/* hasBlockSupport */.pN)(props.name, 'customClassName', true);

    if (hasCustomClassName && props.isSelected) {
      return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(BlockEdit, props), (0,react.createElement)(inspector_controls, {
        __experimentalGroup: "advanced"
      }, (0,react.createElement)(text_control, {
        autoComplete: "off",
        label: (0,_wordpress_i18n_build_module.__)('Additional CSS class(es)'),
        value: props.attributes.className || '',
        onChange: nextValue => {
          props.setAttributes({
            className: nextValue !== '' ? nextValue : undefined
          });
        },
        help: (0,_wordpress_i18n_build_module.__)('Separate multiple classes with spaces.')
      })));
    }

    return (0,react.createElement)(BlockEdit, props);
  };
}, 'withInspectorControl');
/**
 * Override props assigned to save component to inject anchor ID, if block
 * supports anchor. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Current block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */

function custom_class_name_addSaveProps(extraProps, blockType, attributes) {
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'customClassName', true) && attributes.className) {
    extraProps.className = classnames_default()(extraProps.className, attributes.className);
  }

  return extraProps;
}
function addTransforms(result, source, index, results) {
  if (!(0,build_module/* hasBlockSupport */.pN)(result.name, 'customClassName', true)) {
    return result;
  } // If the condition verifies we are probably in the presence of a wrapping transform
  // e.g: nesting paragraphs in a group or columns and in that case the class should not be kept.


  if (results.length === 1 && result.innerBlocks.length === source.length) {
    return result;
  } // If we are transforming one block to multiple blocks or multiple blocks to one block,
  // we ignore the class during the transform.


  if (results.length === 1 && source.length > 1 || results.length > 1 && source.length === 1) {
    return result;
  } // If we are in presence of transform between one or more block in the source
  // that have one or more blocks in the result
  // we apply the class on source N to the result N,
  // if source N does not exists we do nothing.


  if (source[index]) {
    var _source$index;

    const originClassName = (_source$index = source[index]) === null || _source$index === void 0 ? void 0 : _source$index.attributes.className;

    if (originClassName) {
      return { ...result,
        attributes: { ...result.attributes,
          className: originClassName
        }
      };
    }
  }

  return result;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/custom-class-name/attribute', custom_class_name_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/editor/custom-class-name/with-inspector-control', custom_class_name_withInspectorControl);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/custom-class-name/save-props', custom_class_name_addSaveProps);
(0,hooks_build_module/* addFilter */.U2)('blocks.switchToBlockType.transformedBlock', 'core/color/addTransforms', addTransforms);
//# sourceMappingURL=custom-class-name.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/generated-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Override props assigned to save component to inject generated className if
 * block supports it. This is only applied if the block's save result is an
 * element and not a markup string.
 *
 * @param {Object} extraProps Additional props applied to save element.
 * @param {Object} blockType  Block type.
 *
 * @return {Object} Filtered props applied to save element.
 */

function addGeneratedClassName(extraProps, blockType) {
  // Adding the generated className.
  if ((0,build_module/* hasBlockSupport */.pN)(blockType, 'className', true)) {
    if (typeof extraProps.className === 'string') {
      // We have some extra classes and want to add the default classname
      // We use uniq to prevent duplicate classnames.
      extraProps.className = [...new Set([(0,build_module/* getBlockDefaultClassName */.KW)(blockType.name), ...extraProps.className.split(' ')])].join(' ').trim();
    } else {
      // There is no string in the className variable,
      // so we just dump the default name in there.
      extraProps.className = (0,build_module/* getBlockDefaultClassName */.KW)(blockType.name);
    }
  }

  return extraProps;
}
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/generated-class-name/save-props', addGeneratedClassName);
//# sourceMappingURL=generated-class-name.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/raw-html.js
var raw_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/raw-html.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/higher-order/with-filters/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




const ANIMATION_FRAME_PERIOD = 16;
/**
 * Creates a higher-order component which adds filtering capability to the
 * wrapped component. Filters get applied when the original component is about
 * to be mounted. When a filter is added or removed that matches the hook name,
 * the wrapped component re-renders.
 *
 * @param {string} hookName Hook name exposed to be used by filters.
 *
 * @return {Function} Higher-order component factory.
 */

function withFilters(hookName) {
  return (0,create_higher_order_component/* createHigherOrderComponent */.f)(OriginalComponent => {
    const namespace = 'core/with-filters/' + hookName;
    /**
     * The component definition with current filters applied. Each instance
     * reuse this shared reference as an optimization to avoid excessive
     * calls to `applyFilters` when many instances exist.
     *
     * @type {?Component}
     */

    let FilteredComponent;
    /**
     * Initializes the FilteredComponent variable once, if not already
     * assigned. Subsequent calls are effectively a noop.
     */

    function ensureFilteredComponent() {
      if (FilteredComponent === undefined) {
        FilteredComponent = (0,hooks_build_module/* applyFilters */.W5)(hookName, OriginalComponent);
      }
    }

    class FilteredComponentRenderer extends react.Component {
      constructor() {
        super(...arguments);
        ensureFilteredComponent();
      }

      componentDidMount() {
        FilteredComponentRenderer.instances.push(this); // If there were previously no mounted instances for components
        // filtered on this hook, add the hook handler.

        if (FilteredComponentRenderer.instances.length === 1) {
          (0,hooks_build_module/* addAction */.ip)('hookRemoved', namespace, onHooksUpdated);
          (0,hooks_build_module/* addAction */.ip)('hookAdded', namespace, onHooksUpdated);
        }
      }

      componentWillUnmount() {
        FilteredComponentRenderer.instances = (0,lodash.without)(FilteredComponentRenderer.instances, this); // If this was the last of the mounted components filtered on
        // this hook, remove the hook handler.

        if (FilteredComponentRenderer.instances.length === 0) {
          (0,hooks_build_module/* removeAction */.V5)('hookRemoved', namespace);
          (0,hooks_build_module/* removeAction */.V5)('hookAdded', namespace);
        }
      }

      render() {
        return (0,react.createElement)(FilteredComponent, this.props);
      }

    }

    FilteredComponentRenderer.instances = [];
    /**
     * Updates the FilteredComponent definition, forcing a render for each
     * mounted instance. This occurs a maximum of once per animation frame.
     */

    const throttledForceUpdate = (0,lodash.debounce)(() => {
      // Recreate the filtered component, only after delay so that it's
      // computed once, even if many filters added.
      FilteredComponent = (0,hooks_build_module/* applyFilters */.W5)(hookName, OriginalComponent); // Force each instance to render.

      FilteredComponentRenderer.instances.forEach(instance => {
        instance.forceUpdate();
      });
    }, ANIMATION_FRAME_PERIOD);
    /**
     * When a filter is added or removed for the matching hook name, each
     * mounted instance should re-render with the new filters having been
     * applied to the original component.
     *
     * @param {string} updatedHookName Name of the hook that was updated.
     */

    function onHooksUpdated(updatedHookName) {
      if (updatedHookName === hookName) {
        throttledForceUpdate();
      }
    }

    return FilteredComponentRenderer;
  }, 'withFilters');
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/pure/index.js
var pure = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/pure/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/with-select/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Higher-order component used to inject state-derived props using registered
 * selectors.
 *
 * @param {Function} mapSelectToProps Function called on every state change,
 *                                    expected to return object of props to
 *                                    merge with the component's own props.
 *
 * @example
 * ```js
 * import { withSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function PriceDisplay( { price, currency } ) {
 * 	return new Intl.NumberFormat( 'en-US', {
 * 		style: 'currency',
 * 		currency,
 * 	} ).format( price );
 * }
 *
 * const HammerPriceDisplay = withSelect( ( select, ownProps ) => {
 * 	const { getPrice } = select( myCustomStore );
 * 	const { currency } = ownProps;
 *
 * 	return {
 * 		price: getPrice( 'hammer', currency ),
 * 	};
 * } )( PriceDisplay );
 *
 * // Rendered in the application:
 * //
 * //  <HammerPriceDisplay currency="USD" />
 * ```
 * In the above example, when `HammerPriceDisplay` is rendered into an
 * application, it will pass the price into the underlying `PriceDisplay`
 * component and update automatically if the price of a hammer ever changes in
 * the store.
 *
 * @return {WPComponent} Enhanced component with merged state data props.
 */

const withSelect = mapSelectToProps => (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => (0,pure/* default */.A)(ownProps => {
  const mapSelect = (select, registry) => mapSelectToProps(select, ownProps, registry);

  const mergeProps = use_select_useSelect(mapSelect);
  return (0,react.createElement)(WrappedComponent, (0,helpers_esm_extends/* default */.A)({}, ownProps, mergeProps));
}), 'withSelect');

/* harmony default export */ const with_select = (withSelect);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch-with-map.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Custom react hook for returning aggregate dispatch actions using the provided
 * dispatchMap.
 *
 * Currently this is an internal api only and is implemented by `withDispatch`
 *
 * @param {Function} dispatchMap Receives the `registry.dispatch` function as
 *                               the first argument and the `registry` object
 *                               as the second argument.  Should return an
 *                               object mapping props to functions.
 * @param {Array}    deps        An array of dependencies for the hook.
 * @return {Object}  An object mapping props to functions created by the passed
 *                   in dispatchMap.
 */

const useDispatchWithMap = (dispatchMap, deps) => {
  const registry = use_registry_useRegistry();
  const currentDispatchMap = (0,react.useRef)(dispatchMap);
  (0,use_isomorphic_layout_effect/* default */.A)(() => {
    currentDispatchMap.current = dispatchMap;
  });
  return (0,react.useMemo)(() => {
    const currentDispatchProps = currentDispatchMap.current(registry.dispatch, registry);
    return (0,lodash.mapValues)(currentDispatchProps, (dispatcher, propName) => {
      if (typeof dispatcher !== 'function') {
        // eslint-disable-next-line no-console
        console.warn(`Property ${propName} returned from dispatchMap in useDispatchWithMap must be a function.`);
      }

      return function () {
        return currentDispatchMap.current(registry.dispatch, registry)[propName](...arguments);
      };
    });
  }, [registry, ...deps]);
};

/* harmony default export */ const use_dispatch_with_map = (useDispatchWithMap);
//# sourceMappingURL=use-dispatch-with-map.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/with-dispatch/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Higher-order component used to add dispatch props using registered action
 * creators.
 *
 * @param {Function} mapDispatchToProps A function of returning an object of
 *                                      prop names where value is a
 *                                      dispatch-bound action creator, or a
 *                                      function to be called with the
 *                                      component's props and returning an
 *                                      action creator.
 *
 * @example
 * ```jsx
 * function Button( { onClick, children } ) {
 *     return <button type="button" onClick={ onClick }>{ children }</button>;
 * }
 *
 * import { withDispatch } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * const SaleButton = withDispatch( ( dispatch, ownProps ) => {
 *     const { startSale } = dispatch( myCustomStore );
 *     const { discountPercent } = ownProps;
 *
 *     return {
 *         onClick() {
 *             startSale( discountPercent );
 *         },
 *     };
 * } )( Button );
 *
 * // Rendered in the application:
 * //
 * // <SaleButton discountPercent="20">Start Sale!</SaleButton>
 * ```
 *
 * @example
 * In the majority of cases, it will be sufficient to use only two first params
 * passed to `mapDispatchToProps` as illustrated in the previous example.
 * However, there might be some very advanced use cases where using the
 * `registry` object might be used as a tool to optimize the performance of
 * your component. Using `select` function from the registry might be useful
 * when you need to fetch some dynamic data from the store at the time when the
 * event is fired, but at the same time, you never use it to render your
 * component. In such scenario, you can avoid using the `withSelect` higher
 * order component to compute such prop, which might lead to unnecessary
 * re-renders of your component caused by its frequent value change.
 * Keep in mind, that `mapDispatchToProps` must return an object with functions
 * only.
 *
 * ```jsx
 * function Button( { onClick, children } ) {
 *     return <button type="button" onClick={ onClick }>{ children }</button>;
 * }
 *
 * import { withDispatch } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * const SaleButton = withDispatch( ( dispatch, ownProps, { select } ) => {
 *    // Stock number changes frequently.
 *    const { getStockNumber } = select( myCustomStore );
 *    const { startSale } = dispatch( myCustomStore );
 *    return {
 *        onClick() {
 *            const discountPercent = getStockNumber() > 50 ? 10 : 20;
 *            startSale( discountPercent );
 *        },
 *    };
 * } )( Button );
 *
 * // Rendered in the application:
 * //
 * //  <SaleButton>Start Sale!</SaleButton>
 * ```
 *
 * _Note:_ It is important that the `mapDispatchToProps` function always
 * returns an object with the same keys. For example, it should not contain
 * conditions under which a different value would be returned.
 *
 * @return {WPComponent} Enhanced component with merged dispatcher props.
 */

const withDispatch = mapDispatchToProps => (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => ownProps => {
  const mapDispatch = (dispatch, registry) => mapDispatchToProps(dispatch, ownProps, registry);

  const dispatchProps = use_dispatch_with_map(mapDispatch, []);
  return (0,react.createElement)(WrappedComponent, (0,helpers_esm_extends/* default */.A)({}, ownProps, dispatchProps));
}, 'withDispatch');

/* harmony default export */ const with_dispatch = (withDispatch);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/compose.js
var compose = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/compose.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/if-condition/index.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Higher-order component creator, creating a new component which renders if
 * the given condition is satisfied or with the given optional prop name.
 *
 * @example
 * ```ts
 * type Props = { foo: string };
 * const Component = ( props: Props ) => <div>{ props.foo }</div>;
 * const ConditionalComponent = ifCondition( ( props: Props ) => props.foo.length !== 0 )( Component );
 * <ConditionalComponent foo="" />; // => null
 * <ConditionalComponent foo="bar" />; // => <div>bar</div>;
 * ```
 *
 * @param  predicate Function to test condition.
 *
 * @return Higher-order component.
 */

function ifCondition(predicate) {
  return (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => props => {
    if (!predicate(props)) {
      return null;
    }

    return (0,react.createElement)(WrappedComponent, props);
  }, 'ifCondition');
}

/* harmony default export */ const if_condition = (ifCondition);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/safe-html.js
var safe_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/safe-html.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-context/index.js


/**
 * WordPress dependencies
 */

/** @typedef {import('react').ReactNode} ReactNode */

/**
 * @typedef BlockContextProviderProps
 *
 * @property {Record<string,*>} value    Context value to merge with current
 *                                       value.
 * @property {ReactNode}        children Component children.
 */

/** @type {import('react').Context<Record<string,*>>} */

const block_context_Context = (0,react.createContext)({});
/**
 * Component which merges passed value with current consumed block context.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-context/README.md
 *
 * @param {BlockContextProviderProps} props
 */

function BlockContextProvider(_ref) {
  let {
    value,
    children
  } = _ref;
  const context = (0,react.useContext)(block_context_Context);
  const nextValue = (0,react.useMemo)(() => ({ ...context,
    ...value
  }), [context, value]);
  return (0,react.createElement)(block_context_Context.Provider, {
    value: nextValue,
    children: children
  });
}
/* harmony default export */ const block_context = (block_context_Context);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Default value used for blocks which do not define their own context needs,
 * used to guarantee that a block's `context` prop will always be an object. It
 * is assigned as a constant since it is always expected to be an empty object,
 * and in order to avoid unnecessary React reconciliations of a changing object.
 *
 * @type {{}}
 */

const DEFAULT_BLOCK_CONTEXT = {};
const Edit = props => {
  const {
    attributes = {},
    name
  } = props;
  const blockType = (0,build_module/* getBlockType */.E7)(name);
  const blockContext = (0,react.useContext)(block_context); // Assign context values using the block type's declared context needs.

  const context = (0,react.useMemo)(() => {
    return blockType && blockType.usesContext ? (0,lodash.pick)(blockContext, blockType.usesContext) : DEFAULT_BLOCK_CONTEXT;
  }, [blockType, blockContext]);

  if (!blockType) {
    return null;
  } // `edit` and `save` are functions or components describing the markup
  // with which a block is displayed. If `blockType` is valid, assign
  // them preferentially as the render value for the block.


  const Component = blockType.edit || blockType.save;

  if (blockType.apiVersion > 1) {
    return (0,react.createElement)(Component, (0,esm_extends/* default */.A)({}, props, {
      context: context
    }));
  } // Generate a class name for the block's editable form.


  const generatedClassName = (0,build_module/* hasBlockSupport */.pN)(blockType, 'className', true) ? (0,build_module/* getBlockDefaultClassName */.KW)(name) : null;
  const className = classnames_default()(generatedClassName, attributes.className);
  return (0,react.createElement)(Component, (0,esm_extends/* default */.A)({}, props, {
    context: context,
    className: className
  }));
};
/* harmony default export */ const edit = (withFilters('editor.BlockEdit')(Edit));
//# sourceMappingURL=edit.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-edit/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



/**
 * The `useBlockEditContext` hook provides information about the block this hook is being used in.
 * It returns an object with the `name`, `isSelected` state, and the `clientId` of the block.
 * It is useful if you want to create custom hooks that need access to the current blocks clientId
 * but don't want to rely on the data getting passed in as a parameter.
 *
 * @return {Object} Block edit context
 */


function BlockEdit(props) {
  const {
    name,
    isSelected,
    clientId
  } = props;
  const context = {
    name,
    isSelected,
    clientId
  };
  return (0,react.createElement)(block_edit_context_Provider // It is important to return the same object if props haven't
  // changed to avoid  unnecessary rerenders.
  // See https://reactjs.org/docs/context.html#caveats.
  , {
    value: (0,react.useMemo)(() => context, Object.values(context))
  }, (0,react.createElement)(edit, props));
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-on-mount/index.js
var use_focus_on_mount = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-on-mount/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-constrained-tabbing/index.js
var use_constrained_tabbing = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-constrained-tabbing/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-return/index.js
var use_focus_return = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-return/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-outside/index.js
var use_focus_outside = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-outside/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/modal/aria-helper.js
// @ts-nocheck

/**
 * External dependencies
 */

const LIVE_REGION_ARIA_ROLES = new Set(['alert', 'status', 'log', 'marquee', 'timer']);
let hiddenElements = [],
    isHidden = false;
/**
 * Hides all elements in the body element from screen-readers except
 * the provided element and elements that should not be hidden from
 * screen-readers.
 *
 * The reason we do this is because `aria-modal="true"` currently is bugged
 * in Safari, and support is spotty in other browsers overall. In the future
 * we should consider removing these helper functions in favor of
 * `aria-modal="true"`.
 *
 * @param {Element} unhiddenElement The element that should not be hidden.
 */

function hideApp(unhiddenElement) {
  if (isHidden) {
    return;
  }

  const elements = document.body.children;
  (0,lodash.forEach)(elements, element => {
    if (element === unhiddenElement) {
      return;
    }

    if (elementShouldBeHidden(element)) {
      element.setAttribute('aria-hidden', 'true');
      hiddenElements.push(element);
    }
  });
  isHidden = true;
}
/**
 * Determines if the passed element should not be hidden from screen readers.
 *
 * @param {HTMLElement} element The element that should be checked.
 *
 * @return {boolean} Whether the element should not be hidden from screen-readers.
 */

function elementShouldBeHidden(element) {
  const role = element.getAttribute('role');
  return !(element.tagName === 'SCRIPT' || element.hasAttribute('aria-hidden') || element.hasAttribute('aria-live') || LIVE_REGION_ARIA_ROLES.has(role));
}
/**
 * Makes all elements in the body that have been hidden by `hideApp`
 * visible again to screen-readers.
 */

function showApp() {
  if (!isHidden) {
    return;
  }

  (0,lodash.forEach)(hiddenElements, element => {
    element.removeAttribute('aria-hidden');
  });
  hiddenElements = [];
  isHidden = false;
}
//# sourceMappingURL=aria-helper.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/modal/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



 // Used to count the number of open modals.

let openModalCount = 0;

function Modal(props, forwardedRef) {
  const {
    bodyOpenClassName = 'modal-open',
    role = 'dialog',
    title = null,
    focusOnMount = true,
    shouldCloseOnEsc = true,
    shouldCloseOnClickOutside = true,
    isDismissible = true,

    /* Accessibility. */
    aria = {
      labelledby: null,
      describedby: null
    },
    onRequestClose,
    icon,
    closeButtonLabel,
    children,
    style,
    overlayClassName,
    className,
    contentLabel,
    onKeyDown,
    isFullScreen = false,
    __experimentalHideHeader = false
  } = props;
  const ref = (0,react.useRef)();
  const instanceId = (0,use_instance_id/* default */.A)(Modal);
  const headingId = title ? `components-modal-header-${instanceId}` : aria.labelledby;
  const focusOnMountRef = (0,use_focus_on_mount/* default */.A)(focusOnMount);
  const constrainedTabbingRef = (0,use_constrained_tabbing/* default */.A)();
  const focusReturnRef = (0,use_focus_return/* default */.A)();
  const focusOutsideProps = (0,use_focus_outside/* default */.A)(onRequestClose);
  const [hasScrolledContent, setHasScrolledContent] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    openModalCount++;

    if (openModalCount === 1) {
      hideApp(ref.current);
      document.body.classList.add(bodyOpenClassName);
    }

    return () => {
      openModalCount--;

      if (openModalCount === 0) {
        document.body.classList.remove(bodyOpenClassName);
        showApp();
      }
    };
  }, [bodyOpenClassName]);

  function handleEscapeKeyDown(event) {
    if (shouldCloseOnEsc && event.code === 'Escape' && !event.defaultPrevented) {
      event.preventDefault();

      if (onRequestClose) {
        onRequestClose(event);
      }
    }
  }

  const onContentContainerScroll = (0,react.useCallback)(e => {
    var _e$target$scrollTop, _e$target;

    const scrollY = (_e$target$scrollTop = e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.scrollTop) !== null && _e$target$scrollTop !== void 0 ? _e$target$scrollTop : -1;

    if (!hasScrolledContent && scrollY > 0) {
      setHasScrolledContent(true);
    } else if (hasScrolledContent && scrollY <= 0) {
      setHasScrolledContent(false);
    }
  }, [hasScrolledContent]);
  return (0,react_dom.createPortal)( // eslint-disable-next-line jsx-a11y/no-static-element-interactions
  (0,react.createElement)("div", {
    ref: (0,use_merge_refs/* default */.A)([ref, forwardedRef]),
    className: classnames_default()('components-modal__screen-overlay', overlayClassName),
    onKeyDown: handleEscapeKeyDown
  }, (0,react.createElement)(style_provider, {
    document: document
  }, (0,react.createElement)("div", (0,helpers_esm_extends/* default */.A)({
    className: classnames_default()('components-modal__frame', className, {
      'is-full-screen': isFullScreen
    }),
    style: style,
    ref: (0,use_merge_refs/* default */.A)([constrainedTabbingRef, focusReturnRef, focusOnMountRef]),
    role: role,
    "aria-label": contentLabel,
    "aria-labelledby": contentLabel ? null : headingId,
    "aria-describedby": aria.describedby,
    tabIndex: "-1"
  }, shouldCloseOnClickOutside ? focusOutsideProps : {}, {
    onKeyDown: onKeyDown
  }), (0,react.createElement)("div", {
    className: classnames_default()('components-modal__content', {
      'hide-header': __experimentalHideHeader,
      'has-scrolled-content': hasScrolledContent
    }),
    role: "document",
    onScroll: onContentContainerScroll
  }, !__experimentalHideHeader && (0,react.createElement)("div", {
    className: "components-modal__header"
  }, (0,react.createElement)("div", {
    className: "components-modal__header-heading-container"
  }, icon && (0,react.createElement)("span", {
    className: "components-modal__icon-container",
    "aria-hidden": true
  }, icon), title && (0,react.createElement)("h1", {
    id: headingId,
    className: "components-modal__header-heading"
  }, title)), isDismissible && (0,react.createElement)(build_module_button, {
    onClick: onRequestClose,
    icon: library_close/* default */.A,
    label: closeButtonLabel || (0,i18n_build_module.__)('Close dialog')
  })), children)))), document.body);
}

/* harmony default export */ const modal = ((0,react.forwardRef)(Modal));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/more-horizontal.js

/**
 * WordPress dependencies
 */

const moreHorizontal = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M11 13h2v-2h-2v2zm-6 0h2v-2H5v2zm12-2v2h2v-2h-2z"
}));
/* harmony default export */ const more_horizontal = (moreHorizontal);
//# sourceMappingURL=more-horizontal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/warning/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






function Warning(_ref) {
  let {
    className,
    actions,
    children,
    secondaryActions
  } = _ref;
  return (0,react.createElement)("div", {
    style: {
      display: 'contents',
      all: 'initial'
    }
  }, (0,react.createElement)("div", {
    className: classnames_default()(className, 'block-editor-warning')
  }, (0,react.createElement)("div", {
    className: "block-editor-warning__contents"
  }, (0,react.createElement)("p", {
    className: "block-editor-warning__message"
  }, children), (react.Children.count(actions) > 0 || secondaryActions) && (0,react.createElement)("div", {
    className: "block-editor-warning__actions"
  }, react.Children.count(actions) > 0 && react.Children.map(actions, (action, i) => (0,react.createElement)("span", {
    key: i,
    className: "block-editor-warning__action"
  }, action)), secondaryActions && (0,react.createElement)(dropdown_menu, {
    className: "block-editor-warning__secondary",
    icon: more_horizontal,
    label: (0,_wordpress_i18n_build_module.__)('More options'),
    popoverProps: {
      position: 'bottom left',
      className: 'block-editor-warning__dropdown'
    },
    noIcons: true
  }, () => (0,react.createElement)(menu_group, null, secondaryActions.map((item, pos) => (0,react.createElement)(menu_item, {
    onClick: item.onClick,
    key: pos
  }, item.title))))))));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/warning/README.md
 */


/* harmony default export */ const warning = (Warning);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/character.js
var character = __webpack_require__("../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/character.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-compare/block-view.js


/**
 * WordPress dependencies
 */



function BlockView(_ref) {
  let {
    title,
    rawContent,
    renderedContent,
    action,
    actionText,
    className
  } = _ref;
  return (0,react.createElement)("div", {
    className: className
  }, (0,react.createElement)("div", {
    className: "block-editor-block-compare__content"
  }, (0,react.createElement)("h2", {
    className: "block-editor-block-compare__heading"
  }, title), (0,react.createElement)("div", {
    className: "block-editor-block-compare__html"
  }, rawContent), (0,react.createElement)("div", {
    className: "block-editor-block-compare__preview edit-post-visual-editor"
  }, (0,react.createElement)(raw_html/* default */.A, null, (0,safe_html/* default */.A)(renderedContent)))), (0,react.createElement)("div", {
    className: "block-editor-block-compare__action"
  }, (0,react.createElement)(build_module_button, {
    variant: "secondary",
    tabIndex: "0",
    onClick: action
  }, actionText)));
}
//# sourceMappingURL=block-view.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js


/**
 * External dependencies
 */

 // diff doesn't tree-shake correctly, so we import from the individual
// module here, to avoid including too much of the library


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockCompare(_ref) {
  let {
    block,
    onKeep,
    onConvert,
    convertor,
    convertButtonText
  } = _ref;

  function getDifference(originalContent, newContent) {
    const difference = (0,character/* diffChars */.JJ)(originalContent, newContent);
    return difference.map((item, pos) => {
      const classes = classnames_default()({
        'block-editor-block-compare__added': item.added,
        'block-editor-block-compare__removed': item.removed
      });
      return (0,react.createElement)("span", {
        key: pos,
        className: classes
      }, item.value);
    });
  }

  function getConvertedContent(convertedBlock) {
    // The convertor may return an array of items or a single item.
    const newBlocks = (0,lodash.castArray)(convertedBlock); // Get converted block details.

    const newContent = newBlocks.map(item => (0,build_module/* getSaveContent */.Z9)(item.name, item.attributes, item.innerBlocks));
    return newContent.join('');
  }

  const converted = getConvertedContent(convertor(block));
  const difference = getDifference(block.originalContent, converted);
  return (0,react.createElement)("div", {
    className: "block-editor-block-compare__wrapper"
  }, (0,react.createElement)(BlockView, {
    title: (0,_wordpress_i18n_build_module.__)('Current'),
    className: "block-editor-block-compare__current",
    action: onKeep,
    actionText: (0,_wordpress_i18n_build_module.__)('Convert to HTML'),
    rawContent: block.originalContent,
    renderedContent: block.originalContent
  }), (0,react.createElement)(BlockView, {
    title: (0,_wordpress_i18n_build_module.__)('After Conversion'),
    className: "block-editor-block-compare__converted",
    action: onConvert,
    actionText: convertButtonText,
    rawContent: difference,
    renderedContent: converted
  }));
}

/* harmony default export */ const block_compare = (BlockCompare);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/block-invalid-warning.js


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */




function BlockInvalidWarning(_ref) {
  let {
    convertToHTML,
    convertToBlocks,
    convertToClassic,
    attemptBlockRecovery,
    block
  } = _ref;
  const hasHTMLBlock = !!(0,build_module/* getBlockType */.E7)('core/html');
  const [compare, setCompare] = (0,react.useState)(false);
  const onCompare = (0,react.useCallback)(() => setCompare(true), []);
  const onCompareClose = (0,react.useCallback)(() => setCompare(false), []); // We memo the array here to prevent the children components from being updated unexpectedly.

  const hiddenActions = (0,react.useMemo)(() => [{
    // translators: Button to fix block content
    title: (0,_wordpress_i18n_build_module._x)('Resolve', 'imperative verb'),
    onClick: onCompare
  }, hasHTMLBlock && {
    title: (0,_wordpress_i18n_build_module.__)('Convert to HTML'),
    onClick: convertToHTML
  }, {
    title: (0,_wordpress_i18n_build_module.__)('Convert to Classic Block'),
    onClick: convertToClassic
  }].filter(Boolean), [onCompare, convertToHTML, convertToClassic]);
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(warning, {
    actions: [(0,react.createElement)(build_module_button, {
      key: "recover",
      onClick: attemptBlockRecovery,
      variant: "primary"
    }, (0,_wordpress_i18n_build_module.__)('Attempt Block Recovery'))],
    secondaryActions: hiddenActions
  }, (0,_wordpress_i18n_build_module.__)('This block contains unexpected or invalid content.')), compare && (0,react.createElement)(modal, {
    title: // translators: Dialog title to fix block content
    (0,_wordpress_i18n_build_module.__)('Resolve Block'),
    onRequestClose: onCompareClose,
    className: "block-editor-block-compare"
  }, (0,react.createElement)(block_compare, {
    block: block,
    onKeep: convertToHTML,
    onConvert: convertToBlocks,
    convertor: blockToBlocks,
    convertButtonText: (0,_wordpress_i18n_build_module.__)('Convert to Blocks')
  })));
}

const blockToClassic = block => (0,build_module/* createBlock */.Wv)('core/freeform', {
  content: block.originalContent
});

const blockToHTML = block => (0,build_module/* createBlock */.Wv)('core/html', {
  content: block.originalContent
});

const blockToBlocks = block => (0,build_module/* rawHandler */.lh)({
  HTML: block.originalContent
});

const recoverBlock = _ref2 => {
  let {
    name,
    attributes,
    innerBlocks
  } = _ref2;
  return (0,build_module/* createBlock */.Wv)(name, attributes, innerBlocks);
};

/* harmony default export */ const block_invalid_warning = ((0,compose/* default */.A)([with_select((select, _ref3) => {
  let {
    clientId
  } = _ref3;
  return {
    block: select(store_store).getBlock(clientId)
  };
}), with_dispatch((dispatch, _ref4) => {
  let {
    block
  } = _ref4;
  const {
    replaceBlock
  } = dispatch(store_store);
  return {
    convertToClassic() {
      replaceBlock(block.clientId, blockToClassic(block));
    },

    convertToHTML() {
      replaceBlock(block.clientId, blockToHTML(block));
    },

    convertToBlocks() {
      replaceBlock(block.clientId, blockToBlocks(block));
    },

    attemptBlockRecovery() {
      replaceBlock(block.clientId, recoverBlock(block));
    }

  };
})])(BlockInvalidWarning));
//# sourceMappingURL=block-invalid-warning.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-warning.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const block_crash_warning_warning = (0,react.createElement)(warning, {
  className: "block-editor-block-list__block-crash-warning"
}, (0,_wordpress_i18n_build_module.__)('This block has encountered an error and cannot be previewed.'));
/* harmony default export */ const block_crash_warning = (() => block_crash_warning_warning);
//# sourceMappingURL=block-crash-warning.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-boundary.js
/**
 * WordPress dependencies
 */


class BlockCrashBoundary extends react.Component {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false
    };
  }

  componentDidCatch() {
    this.setState({
      hasError: true
    });
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }

}

/* harmony default export */ const block_crash_boundary = (BlockCrashBoundary);
//# sourceMappingURL=block-crash-boundary.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-autosize-textarea/lib/index.js
var lib = __webpack_require__("../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-autosize-textarea/lib/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/block-html.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockHTML(_ref) {
  let {
    clientId
  } = _ref;
  const [html, setHtml] = (0,react.useState)('');
  const block = use_select_useSelect(select => select(store_store).getBlock(clientId), [clientId]);
  const {
    updateBlock
  } = use_dispatch(store_store);

  const onChange = () => {
    const blockType = (0,build_module/* getBlockType */.E7)(block.name);

    if (!blockType) {
      return;
    }

    const attributes = (0,build_module/* getBlockAttributes */.Ph)(blockType, html, block.attributes); // If html is empty  we reset the block to the default HTML and mark it as valid to avoid triggering an error

    const content = html ? html : (0,build_module/* getSaveContent */.Z9)(blockType, attributes);
    const [isValid] = html ? (0,build_module/* validateBlock */.YV)({ ...block,
      attributes,
      originalContent: content
    }) : [true];
    updateBlock(clientId, {
      attributes,
      originalContent: content,
      isValid
    }); // Ensure the state is updated if we reset so it displays the default content.

    if (!html) {
      setHtml({
        content
      });
    }
  };

  (0,react.useEffect)(() => {
    setHtml((0,build_module/* getBlockContent */.F8)(block));
  }, [block]);
  return (0,react.createElement)(lib/* default */.A, {
    className: "block-editor-block-list__block-html-textarea",
    value: html,
    onBlur: onChange,
    onChange: event => setHtml(event.target.value)
  });
}

/* harmony default export */ const block_html = (BlockHTML);
//# sourceMappingURL=block-html.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/utils/debounce/index.js
var debounce = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/utils/debounce/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-disabled/index.js
/**
 * Internal dependencies
 */


/**
 * In some circumstances, such as block previews, all focusable DOM elements
 * (input fields, links, buttons, etc.) need to be disabled. This hook adds the
 * behavior to disable nested DOM elements to the returned ref.
 *
 * If you can, prefer the use of the inert HTML attribute.
 *
 * @param {Object}   config            Configuration object.
 * @param {boolean=} config.isDisabled Whether the element should be disabled.
 * @return {import('react').RefCallback<HTMLElement>} Element Ref.
 *
 * @example
 * ```js
 * import { useDisabled } from '@wordpress/compose';
 *
 * const DisabledExample = () => {
 * 	const disabledRef = useDisabled();
 *	return (
 *		<div ref={ disabledRef }>
 *			<a href="#">This link will have tabindex set to -1</a>
 *			<input placeholder="This input will have the disabled attribute added to it." type="text" />
 *		</div>
 *	);
 * };
 * ```
 */

function use_disabled_useDisabled() {
  let {
    isDisabled: isDisabledProp = false
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (0,use_ref_effect/* default */.A)(node => {
    if (isDisabledProp) {
      return;
    }
    /** A variable keeping track of the previous updates in order to restore them. */


    const updates = [];

    const disable = () => {
      node.childNodes.forEach(child => {
        if (!(child instanceof HTMLElement)) {
          return;
        }

        if (!child.getAttribute('inert')) {
          child.setAttribute('inert', 'true');
          updates.push(() => {
            child.removeAttribute('inert');
          });
        }
      });
    }; // Debounce re-disable since disabling process itself will incur
    // additional mutations which should be ignored.


    const debouncedDisable = (0,debounce/* debounce */.s)(disable, 0, {
      leading: true
    });
    disable();
    /** @type {MutationObserver | undefined} */

    const observer = new window.MutationObserver(debouncedDisable);
    observer.observe(node, {
      childList: true
    });
    return () => {
      if (observer) {
        observer.disconnect();
      }

      debouncedDisable.cancel();
      updates.forEach(update => update());
    };
  }, [isDisabledProp]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+shared@9.7.3_react@17.0.2/node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/globals.ts
var globals_exports = {};
__export(globals_exports, {
  assign: () => react_spring_shared_modern_assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});

// ../rafz/dist/react-spring_rafz.modern.mjs
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time = raf.now() + ms;
  const cancel = () => {
    const i = timeouts.findIndex((t) => t.cancel == cancel);
    if (~i)
      timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t) => t.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e) {
      raf.catch(e);
    }
  });
}

// src/helpers.ts
function react_spring_shared_modern_noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a) => !!a && a.constructor.name === "Object",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0
};
function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  return a === b;
}
var react_spring_shared_modern_each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx) {
  if (is.arr(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn.call(ctx, obj[i], `${i}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx, obj[key], key);
    }
  }
}
var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    react_spring_shared_modern_each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);

// src/globals.ts
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = react_spring_shared_modern_noop;
var react_spring_shared_modern_assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};

// src/FrameLoop.ts
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i = 0; i < currentFrame.length; i++) {
    const animation = currentFrame[i];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}

// src/clamp.ts
var react_spring_shared_modern_clamp = (min, max, v) => Math.min(Math.max(v, min), max);

// src/colors.ts
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};

// src/colorMatchers.ts
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var react_spring_shared_modern_rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;

// src/normalizeColor.ts
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color] !== void 0) {
    return colors[color];
  }
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = react_spring_shared_modern_rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}

// src/colorToRgba.ts
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r = (int32Color & 4278190080) >>> 24;
  const g = (int32Color & 16711680) >>> 16;
  const b = (int32Color & 65280) >>> 8;
  const a = (int32Color & 255) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

// src/createInterpolator.ts
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config = range;
  const outputRange = config.output;
  const inputRange = config.range || [0, 1];
  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || "extend";
  const extrapolateRight = config.extrapolateRight || config.extrapolate || "extend";
  const easing = config.easing || ((t) => t);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}

// src/easings.ts
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return react_spring_shared_modern_clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
  steps
};

// src/fluids.ts
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
$get, $observers;
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});

// src/regexs.ts
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

// src/variableToRgba.ts
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};

// src/stringInterpolation.ts
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map(
    (_, i) => keyframes.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config, output: output2 })
  );
  return (input) => {
    const missingUnit = !unitRegex.test(output[0]) && output.find((value) => unitRegex.test(value))?.replace(numberRegex, "");
    let i = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};

// src/deprecations.ts
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}

// src/isAnimatedString.ts
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}

// src/dom-events/resize/resizeElement.ts
var observer;
var resizeHandlers = /* @__PURE__ */ new WeakMap();
var handleObservation = (entries) => entries.forEach(({ target, contentRect }) => {
  return resizeHandlers.get(target)?.forEach((handler) => handler(contentRect));
});
function resizeElement(handler, target) {
  if (!observer) {
    if (typeof ResizeObserver !== "undefined") {
      observer = new ResizeObserver(handleObservation);
    }
  }
  let elementHandlers = resizeHandlers.get(target);
  if (!elementHandlers) {
    elementHandlers = /* @__PURE__ */ new Set();
    resizeHandlers.set(target, elementHandlers);
  }
  elementHandlers.add(handler);
  if (observer) {
    observer.observe(target);
  }
  return () => {
    const elementHandlers2 = resizeHandlers.get(target);
    if (!elementHandlers2)
      return;
    elementHandlers2.delete(handler);
    if (!elementHandlers2.size && observer) {
      observer.unobserve(target);
    }
  };
}

// src/dom-events/resize/resizeWindow.ts
var listeners = /* @__PURE__ */ new Set();
var cleanupWindowResizeHandler;
var createResizeHandler = () => {
  const handleResize = () => {
    listeners.forEach(
      (callback) => callback({
        width: window.innerWidth,
        height: window.innerHeight
      })
    );
  };
  window.addEventListener("resize", handleResize);
  return () => {
    window.removeEventListener("resize", handleResize);
  };
};
var resizeWindow = (callback) => {
  listeners.add(callback);
  if (!cleanupWindowResizeHandler) {
    cleanupWindowResizeHandler = createResizeHandler();
  }
  return () => {
    listeners.delete(callback);
    if (!listeners.size && cleanupWindowResizeHandler) {
      cleanupWindowResizeHandler();
      cleanupWindowResizeHandler = void 0;
    }
  };
};

// src/dom-events/resize/index.ts
var react_spring_shared_modern_onResize = (callback, { container = document.documentElement } = {}) => {
  if (container === document.documentElement) {
    return resizeWindow(callback);
  } else {
    return resizeElement(callback, container);
  }
};

// src/progress.ts
var progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);

// src/dom-events/scroll/ScrollHandler.ts
var SCROLL_KEYS = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
var ScrollHandler = class {
  constructor(callback, container) {
    this.createAxis = () => ({
      current: 0,
      progress: 0,
      scrollLength: 0
    });
    this.updateAxis = (axisName) => {
      const axis = this.info[axisName];
      const { length, position } = SCROLL_KEYS[axisName];
      axis.current = this.container[`scroll${position}`];
      axis.scrollLength = this.container["scroll" + length] - this.container["client" + length];
      axis.progress = progress(0, axis.scrollLength, axis.current);
    };
    this.update = () => {
      this.updateAxis("x");
      this.updateAxis("y");
    };
    this.sendEvent = () => {
      this.callback(this.info);
    };
    this.advance = () => {
      this.update();
      this.sendEvent();
    };
    this.callback = callback;
    this.container = container;
    this.info = {
      time: 0,
      x: this.createAxis(),
      y: this.createAxis()
    };
  }
};

// src/dom-events/scroll/index.ts
var scrollListeners = /* @__PURE__ */ new WeakMap();
var resizeListeners = /* @__PURE__ */ new WeakMap();
var onScrollHandlers = /* @__PURE__ */ new WeakMap();
var getTarget = (container) => container === document.documentElement ? window : container;
var react_spring_shared_modern_onScroll = (callback, { container = document.documentElement } = {}) => {
  let containerHandlers = onScrollHandlers.get(container);
  if (!containerHandlers) {
    containerHandlers = /* @__PURE__ */ new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  const containerHandler = new ScrollHandler(callback, container);
  containerHandlers.add(containerHandler);
  if (!scrollListeners.has(container)) {
    const listener = () => {
      containerHandlers?.forEach((handler) => handler.advance());
      return true;
    };
    scrollListeners.set(container, listener);
    const target = getTarget(container);
    window.addEventListener("resize", listener, { passive: true });
    if (container !== document.documentElement) {
      resizeListeners.set(container, react_spring_shared_modern_onResize(listener, { container }));
    }
    target.addEventListener("scroll", listener, { passive: true });
  }
  const animateScroll = scrollListeners.get(container);
  raf(animateScroll);
  return () => {
    raf.cancel(animateScroll);
    const containerHandlers2 = onScrollHandlers.get(container);
    if (!containerHandlers2)
      return;
    containerHandlers2.delete(containerHandler);
    if (containerHandlers2.size)
      return;
    const listener = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (listener) {
      getTarget(container).removeEventListener("scroll", listener);
      window.removeEventListener("resize", listener);
      resizeListeners.get(container)?.();
    }
  };
};

// src/hooks/useConstant.ts

function react_spring_shared_modern_useConstant(init) {
  const ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// src/hooks/useForceUpdate.ts


// src/hooks/useIsMounted.ts


// src/hooks/useIsomorphicLayoutEffect.ts

var react_spring_shared_modern_useIsomorphicLayoutEffect = isSSR() ? react.useEffect : react.useLayoutEffect;

// src/hooks/useIsMounted.ts
var useIsMounted = () => {
  const isMounted = (0,react.useRef)(false);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};

// src/hooks/useForceUpdate.ts
function react_spring_shared_modern_useForceUpdate() {
  const update2 = (0,react.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update2(Math.random());
    }
  };
}

// src/hooks/useMemoOne.ts

function react_spring_shared_modern_useMemoOne(getResult, inputs) {
  const [initial] = (0,react.useState)(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = (0,react.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0,react.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i = 0; i < next.length; i++) {
    if (next[i] !== prev[i]) {
      return false;
    }
  }
  return true;
}

// src/hooks/useOnce.ts

var useOnce = (effect) => (0,react.useEffect)(effect, emptyDeps);
var emptyDeps = [];

// src/hooks/usePrev.ts

function usePrev(value) {
  const prevRef = (0,react.useRef)();
  (0,react.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// src/hooks/useReducedMotion.ts

var react_spring_shared_modern_useReducedMotion = () => {
  const [reducedMotion, setReducedMotion] = useState3(null);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    const mql = window.matchMedia("(prefers-reduced-motion)");
    const handleMediaChange = (e) => {
      setReducedMotion(e.matches);
      react_spring_shared_modern_assign({
        skipAnimation: e.matches
      });
    };
    handleMediaChange(mql);
    mql.addEventListener("change", handleMediaChange);
    return () => {
      mql.removeEventListener("change", handleMediaChange);
    };
  }, []);
  return reducedMotion;
};

//# sourceMappingURL=react-spring_shared.modern.mjs.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+animated@9.7.3_react@17.0.2/node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
// src/Animated.ts

var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};

// src/AnimatedValue.ts

var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};

// src/AnimatedString.ts

var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};

// src/AnimatedArray.ts


// src/AnimatedObject.ts


// src/context.ts
var TreeContext = { dependencies: null };

// src/AnimatedObject.ts
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      react_spring_shared_modern_each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      react_spring_shared_modern_each(payload, (node) => this.add(node));
    }
  }
};

// src/AnimatedArray.ts
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}

// src/getAnimatedType.ts

function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}

// src/createHost.ts


// src/withAnimated.tsx



var withAnimated = (Component, host) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return (0,react.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0,react.useRef)(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0,react.useCallback)(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host);
    const forceUpdate = react_spring_shared_modern_useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0,react.useRef)();
    react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      react_spring_shared_modern_each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          react_spring_shared_modern_each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0,react.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      react_spring_shared_modern_each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host.getComponentProps(props.getValue());
    return /* @__PURE__ */ react.createElement(Component, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update, deps) {
    this.update = update;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}

// src/createHost.ts
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues,
    createAnimatedStyle,
    getComponentProps
  };
  const animated = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated[key] = animated(Component);
  });
  return {
    animated
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

//# sourceMappingURL=react-spring_animated.modern.mjs.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+core@9.7.3_react@17.0.2/node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
// src/hooks/useChain.ts


// src/helpers.ts

function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = { to: to2 };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  ctrl.ref?.delete(ctrl);
  ref?.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    ctrl.ref?.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}

// src/hooks/useChain.ts
function useChain(refs, timeSteps, timeFrame = 1e3) {
  useIsomorphicLayoutEffect(() => {
    if (timeSteps) {
      let prevDelay = 0;
      each(refs, (ref, i) => {
        const controllers = ref.current;
        if (controllers.length) {
          let delay = timeFrame * timeSteps[i];
          if (isNaN(delay))
            delay = prevDelay;
          else
            prevDelay = delay;
          each(controllers, (ctrl) => {
            each(ctrl.queue, (props) => {
              const memoizedDelayProp = props.delay;
              props.delay = (key) => delay + callProp(memoizedDelayProp || 0, key);
            });
          });
          ref.start();
        }
      });
    } else {
      let p = Promise.resolve();
      each(refs, (ref) => {
        const controllers = ref.current;
        if (controllers.length) {
          const queues = controllers.map((ctrl) => {
            const q = ctrl.queue;
            ctrl.queue = [];
            return q;
          });
          p = p.then(() => {
            each(
              controllers,
              (ctrl, i) => each(queues[i] || [], (update2) => ctrl.queue.push(update2))
            );
            return Promise.all(ref.start());
          });
        }
      });
    }
  });
}

// src/hooks/useSpring.ts


// src/hooks/useSprings.ts



// src/SpringValue.ts



// src/AnimationConfig.ts


// src/constants.ts
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};

// src/AnimationConfig.ts
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    /**
     * The initial velocity of one or more values.
     *
     * @default 0
     */
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}

// src/Animation.ts
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};

// src/scheduleProps.ts

function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? defaultProps?.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps?.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}

// src/runAsync.ts


// src/AnimationResult.ts
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});

// src/runAsync.ts
function runAsync(to2, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t) => t.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};

// src/FrameValue.ts


var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority) {
    if (this._priority != priority) {
      this._priority = priority;
      this._onPriorityChange(priority);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority
    });
  }
};

// src/SpringPhase.ts
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;

// src/SpringValue.ts
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    /** The animation state */
    this.animation = new Animation();
    /** Some props have customizable default values */
    this.defaultProps = {};
    /** The state for `runAsync` calls */
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    /** The promise resolvers of pending `start` calls */
    this._pendingCalls = /* @__PURE__ */ new Set();
    /** The counter for tracking `scheduleProps` calls */
    this._lastCallId = 0;
    /** The last `scheduleProps` call that changed the `to` prop */
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i) => {
      if (node2.done)
        return;
      const to2 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
      );
      let finished = anim.immediate;
      let position = to2;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position = from + config2.easing(p) * (to2 - from);
          velocity = (position - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n = 0; n < numSteps; ++n) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to2 || position > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to2, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : { ...arg2, to: to2 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to2 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to2, from } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = { to: to2, from };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to2 = prevTo, from = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value = reset ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        react_spring_shared_modern_each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest?.(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart?.(result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority = 0;
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority = to2.priority + 1;
      }
    }
    this.priority = priority;
  }
  _detach() {
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      react_spring_shared_modern_each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop = props.loop, to2 = props.to) {
  const loopRet = callProp(loop);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to2, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update2 = createUpdate(props);
  if (is.und(update2.default)) {
    update2.default = getDefaultProps(update2);
  }
  return update2;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  target.animation[type]?.(...args);
  target.defaultProps[type]?.(...args);
}

// src/Controller.ts

var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    /** The animated values */
    this.springs = {};
    /** The queue of props passed to the `update` method. */
    this.queue = [];
    /** The counter for tracking `scheduleProps` calls */
    this._lastAsyncId = 0;
    /** The values currently being animated */
    this._active = /* @__PURE__ */ new Set();
    /** The values that changed recently */
    this._changed = /* @__PURE__ */ new Set();
    /** Equals false when `onStart` listeners can be called */
    this._started = false;
    /** State used by the `runAsync` function */
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    /** The event queues that are flushed once per frame maximum */
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      react_spring_shared_modern_each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to2, from, loop, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    react_spring_shared_modern_each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: react_spring_shared_modern_noop,
          resume: react_spring_shared_modern_noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    react_spring_shared_modern_each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    react_spring_shared_modern_each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  react_spring_shared_modern_each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}

// src/SpringContext.tsx



var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = (0,react.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = react_spring_shared_modern_useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider } = ctx;
  return /* @__PURE__ */ react.createElement(Provider, { value: props }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, react.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}

// src/SpringRef.ts

var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    react_spring_shared_modern_each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = _getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i = current.indexOf(ctrl);
    if (~i)
      current.splice(i, 1);
  };
  SpringRef2.pause = function() {
    react_spring_shared_modern_each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    react_spring_shared_modern_each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    react_spring_shared_modern_each(current, (ctrl, i) => {
      const update2 = is.fun(values) ? values(i, ctrl) : values;
      if (update2) {
        ctrl.set(update2);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    react_spring_shared_modern_each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = this._getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    react_spring_shared_modern_each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    react_spring_shared_modern_each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
    return this;
  };
  const _getProps = function(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};

// src/hooks/useSprings.ts
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0,react.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = (0,react.useRef)(0);
  const forceUpdate = react_spring_shared_modern_useForceUpdate();
  const state = (0,react.useMemo)(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = (0,react.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0,react.useMemo)(() => {
    react_spring_shared_modern_each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0,react.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i = startIndex; i < endIndex; i++) {
      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
      const update2 = propsFn ? propsFn(i, ctrl) : props[i];
      if (update2) {
        updates[i] = declareUpdate(update2);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
  const context = (0,react.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  react_spring_shared_modern_useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      react_spring_shared_modern_each(queue, (cb) => cb());
    }
    react_spring_shared_modern_each(ctrls.current, (ctrl, i) => {
      ref?.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update2 = updates[i];
      if (update2) {
        replaceRef(ctrl, update2.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update2);
        } else {
          ctrl.start(update2);
        }
      }
    });
  });
  useOnce(() => () => {
    react_spring_shared_modern_each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x) => ({ ...x }));
  return ref ? [values, ref] : values;
}

// src/hooks/useSpring.ts
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref] : values;
}

// src/hooks/useSpringRef.ts

var initSpringRef = () => SpringRef();
var useSpringRef = () => useState(initSpringRef)[0];

// src/hooks/useSpringValue.ts

var useSpringValue = (initial, props) => {
  const springValue = useConstant(() => new SpringValue(initial, props));
  useOnce2(() => () => {
    springValue.stop();
  });
  return springValue;
};

// src/hooks/useTrail.ts

function useTrail(length, propsArg, deps) {
  const propsFn = is10.fun(propsArg) && propsArg;
  if (propsFn && !deps)
    deps = [];
  let reverse = true;
  let passedRef = void 0;
  const result = useSprings(
    length,
    (i, ctrl) => {
      const props = propsFn ? propsFn(i, ctrl) : propsArg;
      passedRef = props.ref;
      reverse = reverse && props.reverse;
      return props;
    },
    // Ensure the props function is called when no deps exist.
    // This works around the 3 argument rule.
    deps || [{}]
  );
  useIsomorphicLayoutEffect3(() => {
    each6(result[1].current, (ctrl, i) => {
      const parent = result[1].current[i + (reverse ? 1 : -1)];
      replaceRef(ctrl, passedRef);
      if (ctrl.ref) {
        if (parent) {
          ctrl.update({ to: parent.springs });
        }
        return;
      }
      if (parent) {
        ctrl.start({ to: parent.springs });
      } else {
        ctrl.start();
      }
    });
  }, deps);
  if (propsFn || arguments.length == 3) {
    const ref = passedRef ?? result[1];
    ref["_getProps"] = (propsArg2, ctrl, i) => {
      const props = is10.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;
      if (props) {
        const parent = ref.current[i + (props.reverse ? 1 : -1)];
        if (parent)
          props.to = parent.springs;
        return props;
      }
    };
    return result;
  }
  return result[0];
}

// src/hooks/useTransition.tsx



function useTransition(data, props, deps) {
  const propsFn = is11.fun(props) && props;
  const {
    reset,
    sort,
    trail = 0,
    expires = true,
    exitBeforeEnter = false,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = useMemo2(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const items = toArray4(data);
  const transitions = [];
  const usedTransitions = useRef2(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useIsomorphicLayoutEffect4(() => {
    usedTransitions.current = transitions;
  });
  useOnce3(() => {
    each7(transitions, (t) => {
      ref?.add(t.ctrl);
      t.ctrl.ref = ref;
    });
    return () => {
      each7(usedTransitions.current, (t) => {
        if (t.expired) {
          clearTimeout(t.expirationId);
        }
        detachRefs(t.ctrl, ref);
        t.ctrl.stop(true);
      });
    };
  });
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useIsomorphicLayoutEffect4(
    () => each7(expired, ({ ctrl, item, key }) => {
      detachRefs(ctrl, ref);
      callProp(onDestroyed, item, key);
    })
  );
  const reused = [];
  if (prevTransitions)
    each7(prevTransitions, (t, i) => {
      if (t.expired) {
        clearTimeout(t.expirationId);
        expired.push(t);
      } else {
        i = reused[i] = keys.indexOf(t.key);
        if (~i)
          transitions[i] = t;
      }
    });
  each7(items, (item, i) => {
    if (!transitions[i]) {
      transitions[i] = {
        key: keys[i],
        item,
        phase: "mount" /* MOUNT */,
        ctrl: new Controller()
      };
      transitions[i].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i = -1;
    const { leave } = propsFn ? propsFn() : props;
    each7(reused, (keyIndex, prevIndex) => {
      const t = prevTransitions[prevIndex];
      if (~keyIndex) {
        i = transitions.indexOf(t);
        transitions[i] = { ...t, item: items[keyIndex] };
      } else if (leave) {
        transitions.splice(++i, 0, t);
      }
    });
  }
  if (is11.fun(sort)) {
    transitions.sort((a, b) => sort(a.item, b.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate2();
  const defaultProps = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  const exitingTransitions = useRef2(/* @__PURE__ */ new Map());
  const forceChange = useRef2(false);
  each7(transitions, (t, i) => {
    const key = t.key;
    const prevPhase = t.phase;
    const p = propsFn ? propsFn() : props;
    let to2;
    let phase;
    const propsDelay = callProp(p.delay || 0, key);
    if (prevPhase == "mount" /* MOUNT */) {
      to2 = p.enter;
      phase = "enter" /* ENTER */;
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != "leave" /* LEAVE */) {
        if (isLeave) {
          to2 = p.leave;
          phase = "leave" /* LEAVE */;
        } else if (to2 = p.update) {
          phase = "update" /* UPDATE */;
        } else
          return;
      } else if (!isLeave) {
        to2 = p.enter;
        phase = "enter" /* ENTER */;
      } else
        return;
    }
    to2 = callProp(to2, t.item, i);
    to2 = is11.obj(to2) ? inferTo(to2) : { to: to2 };
    if (!to2.config) {
      const config2 = propsConfig || defaultProps.config;
      to2.config = callProp(config2, t.item, i, phase);
    }
    delay += trail;
    const payload = {
      ...defaultProps,
      // we need to add our props.delay value you here.
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p.immediate,
      // This prevents implied resets.
      reset: false,
      // Merge any phase-specific props.
      ...to2
    };
    if (phase == "enter" /* ENTER */ && is11.und(payload.from)) {
      const p2 = propsFn ? propsFn() : props;
      const from = is11.und(p2.initial) || prevTransitions ? p2.from : p2.initial;
      payload.from = callProp(from, t.item, i);
    }
    const { onResolve } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t2 = transitions2.find((t3) => t3.key === key);
      if (!t2)
        return;
      if (result.cancelled && t2.phase != "update" /* UPDATE */) {
        return;
      }
      if (t2.ctrl.idle) {
        const idle = transitions2.every((t3) => t3.ctrl.idle);
        if (t2.phase == "leave" /* LEAVE */) {
          const expiry = callProp(expires, t2.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t2.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647)
                t2.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t3) => t3.expired)) {
          exitingTransitions.current.delete(t2);
          if (exitBeforeEnter) {
            forceChange.current = true;
          }
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t.ctrl, payload);
    if (phase === "leave" /* LEAVE */ && exitBeforeEnter) {
      exitingTransitions.current.set(t, { phase, springs, payload });
    } else {
      changes.set(t, { phase, springs, payload });
    }
  });
  const context = useContext3(SpringContext);
  const prevContext = usePrev2(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect4(() => {
    if (hasContext) {
      each7(transitions, (t) => {
        t.ctrl.start({ default: context });
      });
    }
  }, [context]);
  each7(changes, (_, t) => {
    if (exitingTransitions.current.size) {
      const ind = transitions.findIndex((state) => state.key === t.key);
      transitions.splice(ind, 1);
    }
  });
  useIsomorphicLayoutEffect4(
    () => {
      each7(
        exitingTransitions.current.size ? exitingTransitions.current : changes,
        ({ phase, payload }, t) => {
          const { ctrl } = t;
          t.phase = phase;
          ref?.add(ctrl);
          if (hasContext && phase == "enter" /* ENTER */) {
            ctrl.start({ default: context });
          }
          if (payload) {
            replaceRef(ctrl, payload.ref);
            if ((ctrl.ref || ref) && !forceChange.current) {
              ctrl.update(payload);
            } else {
              ctrl.start(payload);
              if (forceChange.current) {
                forceChange.current = false;
              }
            }
          }
        }
      );
    },
    reset ? void 0 : deps
  );
  const renderTransitions = (render) => /* @__PURE__ */ React2.createElement(React2.Fragment, null, transitions.map((t, i) => {
    const { springs } = changes.get(t) || t.ctrl;
    const elem = render({ ...springs }, t.item, t, i);
    return elem && elem.type ? /* @__PURE__ */ React2.createElement(
      elem.type,
      {
        ...elem.props,
        key: is11.str(t.key) || is11.num(t.key) ? t.key : t.ctrl.id,
        ref: elem.ref
      }
    ) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, { key, keys = key }, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t = prevTransitions && prevTransitions.find(
        (t2) => t2.item === item && t2.phase !== "leave" /* LEAVE */ && !reused.has(t2)
      );
      if (t) {
        reused.add(t);
        return t.key;
      }
      return nextKey++;
    });
  }
  return is11.und(keys) ? items : is11.fun(keys) ? items.map(keys) : toArray4(keys);
}

// src/hooks/useScroll.ts

var useScroll = ({
  container,
  ...springOptions
} = {}) => {
  const [scrollValues, api] = useSpring(
    () => ({
      scrollX: 0,
      scrollY: 0,
      scrollXProgress: 0,
      scrollYProgress: 0,
      ...springOptions
    }),
    []
  );
  useIsomorphicLayoutEffect5(() => {
    const cleanupScroll = onScroll(
      ({ x, y }) => {
        api.start({
          scrollX: x.current,
          scrollXProgress: x.progress,
          scrollY: y.current,
          scrollYProgress: y.progress
        });
      },
      { container: container?.current || void 0 }
    );
    return () => {
      each8(Object.values(scrollValues), (value) => value.stop());
      cleanupScroll();
    };
  }, []);
  return scrollValues;
};

// src/hooks/useResize.ts

var useResize = ({
  container,
  ...springOptions
}) => {
  const [sizeValues, api] = useSpring(
    () => ({
      width: 0,
      height: 0,
      ...springOptions
    }),
    []
  );
  useIsomorphicLayoutEffect6(() => {
    const cleanupScroll = onResize(
      ({ width, height }) => {
        api.start({
          width,
          height,
          immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0
        });
      },
      { container: container?.current || void 0 }
    );
    return () => {
      each9(Object.values(sizeValues), (value) => value.stop());
      cleanupScroll();
    };
  }, []);
  return sizeValues;
};

// src/hooks/useInView.ts


var defaultThresholdOptions = {
  any: 0,
  all: 1
};
function useInView(props, args) {
  const [isInView, setIsInView] = useState2(false);
  const ref = useRef3();
  const propsFn = is12.fun(props) && props;
  const springsProps = propsFn ? propsFn() : {};
  const { to: to2 = {}, from = {}, ...restSpringProps } = springsProps;
  const intersectionArguments = propsFn ? args : props;
  const [springs, api] = useSpring(() => ({ from, ...restSpringProps }), []);
  useIsomorphicLayoutEffect7(() => {
    const element = ref.current;
    const {
      root,
      once,
      amount = "any",
      ...restArgs
    } = intersectionArguments ?? {};
    if (!element || once && isInView || typeof IntersectionObserver === "undefined")
      return;
    const activeIntersections = /* @__PURE__ */ new WeakMap();
    const onEnter = () => {
      if (to2) {
        api.start(to2);
      }
      setIsInView(true);
      const cleanup = () => {
        if (from) {
          api.start(from);
        }
        setIsInView(false);
      };
      return once ? void 0 : cleanup;
    };
    const handleIntersection = (entries) => {
      entries.forEach((entry) => {
        const onLeave = activeIntersections.get(entry.target);
        if (entry.isIntersecting === Boolean(onLeave)) {
          return;
        }
        if (entry.isIntersecting) {
          const newOnLeave = onEnter();
          if (is12.fun(newOnLeave)) {
            activeIntersections.set(entry.target, newOnLeave);
          } else {
            observer.unobserve(entry.target);
          }
        } else if (onLeave) {
          onLeave();
          activeIntersections.delete(entry.target);
        }
      });
    };
    const observer = new IntersectionObserver(handleIntersection, {
      root: root && root.current || void 0,
      threshold: typeof amount === "number" || Array.isArray(amount) ? amount : defaultThresholdOptions[amount],
      ...restArgs
    });
    observer.observe(element);
    return () => observer.unobserve(element);
  }, [intersectionArguments]);
  if (propsFn) {
    return [ref, springs];
  }
  return [ref, isInView];
}

// src/components/Spring.tsx
function Spring({ children, ...props }) {
  return children(useSpring(props));
}

// src/components/Trail.tsx

function Trail({
  items,
  children,
  ...props
}) {
  const trails = useTrail(items.length, props);
  return items.map((item, index) => {
    const result = children(item, index);
    return is13.fun(result) ? result(trails[index]) : result;
  });
}

// src/components/Transition.tsx
function Transition({
  items,
  children,
  ...props
}) {
  return useTransition(items, props)(children);
}

// src/interpolate.ts


// src/Interpolation.ts


var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    /** Equals false when in the frameloop */
    this.idle = true;
    /** The inputs which are currently animating */
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      react_spring_shared_modern_each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority = 1;
    react_spring_shared_modern_each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority = Math.max(priority, source.priority + 1);
      }
    });
    this.priority = priority;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    react_spring_shared_modern_each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self) {
  if (!self.idle) {
    self.idle = true;
    react_spring_shared_modern_each(getPayload(self), (node) => {
      node.done = true;
    });
    callFluidObservers(self, {
      type: "idle",
      parent: self
    });
  }
}

// src/interpolate.ts
var react_spring_core_modern_to = (source, ...args) => new Interpolation(source, args);
var react_spring_core_modern_interpolate = (source, ...args) => (deprecateInterpolate2(), new Interpolation(source, args));

// src/globals.ts

globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var react_spring_core_modern_update = frameLoop.advance;

// src/index.ts



//# sourceMappingURL=react-spring_core.modern.mjs.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@react-spring+web@9.7.3_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
// src/index.ts





// src/applyAnimatedValues.ts
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const { style, children, scrollTop, scrollLeft, viewBox, ...attributes } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n) => "-" + n.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i) => {
    instance.setAttribute(name, values[i]);
  });
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);

// src/AnimatedStyle.ts


var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x, y, z, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x2, y2, z2, deg]) => [
            `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    react_spring_shared_modern_each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t, id] = this.transforms[i](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      react_spring_shared_modern_each(
        this.inputs,
        (input) => react_spring_shared_modern_each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      react_spring_shared_modern_each(
        this.inputs,
        (input) => react_spring_shared_modern_each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};

// src/primitives.ts
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];

// src/index.ts

globals_exports.assign({
  batchedUpdates: react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

//# sourceMappingURL=react-spring_web.modern.mjs.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js
var assert_is_defined = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/get-computed-style.js
/**
 * Internal dependencies
 */

/* eslint-disable jsdoc/valid-types */

/**
 * @param {Element} element
 * @return {ReturnType<Window['getComputedStyle']>} The computed style for the element.
 */

function getComputedStyle(element) {
  /* eslint-enable jsdoc/valid-types */
  (0,assert_is_defined/* assertIsDefined */.e)(element.ownerDocument.defaultView, 'element.ownerDocument.defaultView');
  return element.ownerDocument.defaultView.getComputedStyle(element);
}
//# sourceMappingURL=get-computed-style.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/get-scroll-container.js
/**
 * Internal dependencies
 */

/**
 * Given a DOM node, finds the closest scrollable container node or the node
 * itself, if scrollable.
 *
 * @param {Element | null} node Node from which to start.
 *
 * @return {Element | undefined} Scrollable container node, if found.
 */

function getScrollContainer(node) {
  if (!node) {
    return undefined;
  } // Scrollable if scrollable height exceeds displayed...


  if (node.scrollHeight > node.clientHeight) {
    // ...except when overflow is defined to be hidden or visible
    const {
      overflowY
    } = getComputedStyle(node);

    if (/(auto|scroll)/.test(overflowY)) {
      return node;
    }
  }

  if (node.ownerDocument === node.parentNode) {
    return node;
  } // Continue traversing.


  return getScrollContainer(
  /** @type {Element} */
  node.parentNode);
}
//# sourceMappingURL=get-scroll-container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/use-moving-animation/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Simple reducer used to increment a counter.
 *
 * @param {number} state Previous counter value.
 * @return {number} New state value.
 */

const counterReducer = state => state + 1;

const getAbsolutePosition = element => {
  return {
    top: element.offsetTop,
    left: element.offsetLeft
  };
};
/**
 * Hook used to compute the styles required to move a div into a new position.
 *
 * The way this animation works is the following:
 *  - It first renders the element as if there was no animation.
 *  - It takes a snapshot of the position of the block to use it
 *    as a destination point for the animation.
 *  - It restores the element to the previous position using a CSS transform
 *  - It uses the "resetAnimation" flag to reset the animation
 *    from the beginning in order to animate to the new destination point.
 *
 * @param {Object}  $1                          Options
 * @param {boolean} $1.isSelected               Whether it's the current block or not.
 * @param {boolean} $1.adjustScrolling          Adjust the scroll position to the current block.
 * @param {boolean} $1.enableAnimation          Enable/Disable animation.
 * @param {*}       $1.triggerAnimationOnChange Variable used to trigger the animation if it changes.
 */


function useMovingAnimation(_ref) {
  let {
    isSelected,
    adjustScrolling,
    enableAnimation,
    triggerAnimationOnChange
  } = _ref;
  const ref = (0,react.useRef)();
  const prefersReducedMotion = hooks_use_reduced_motion() || !enableAnimation;
  const [triggeredAnimation, triggerAnimation] = (0,react.useReducer)(counterReducer, 0);
  const [finishedAnimation, endAnimation] = (0,react.useReducer)(counterReducer, 0);
  const [transform, setTransform] = (0,react.useState)({
    x: 0,
    y: 0
  });
  const previous = (0,react.useMemo)(() => ref.current ? getAbsolutePosition(ref.current) : null, [triggerAnimationOnChange]); // Calculate the previous position of the block relative to the viewport and
  // return a function to maintain that position by scrolling.

  const preserveScrollPosition = (0,react.useMemo)(() => {
    if (!adjustScrolling || !ref.current) {
      return () => {};
    }

    const scrollContainer = getScrollContainer(ref.current);

    if (!scrollContainer) {
      return () => {};
    }

    const prevRect = ref.current.getBoundingClientRect();
    return () => {
      const blockRect = ref.current.getBoundingClientRect();
      const diff = blockRect.top - prevRect.top;

      if (diff) {
        scrollContainer.scrollTop += diff;
      }
    };
  }, [triggerAnimationOnChange, adjustScrolling]);
  (0,react.useLayoutEffect)(() => {
    if (triggeredAnimation) {
      endAnimation();
    }
  }, [triggeredAnimation]);
  (0,react.useLayoutEffect)(() => {
    if (!previous) {
      return;
    }

    if (prefersReducedMotion) {
      // If the animation is disabled and the scroll needs to be adjusted,
      // just move directly to the final scroll position.
      preserveScrollPosition();
      return;
    }

    ref.current.style.transform = '';
    const destination = getAbsolutePosition(ref.current);
    triggerAnimation();
    setTransform({
      x: Math.round(previous.left - destination.left),
      y: Math.round(previous.top - destination.top)
    });
  }, [triggerAnimationOnChange]); // Only called when either the x or y value changes.

  function onFrameChange(_ref2) {
    let {
      x,
      y
    } = _ref2;

    if (!ref.current) {
      return;
    }

    const isMoving = x === 0 && y === 0;
    ref.current.style.transformOrigin = isMoving ? '' : 'center';
    ref.current.style.transform = isMoving ? '' : `translate3d(${x}px,${y}px,0)`;
    ref.current.style.zIndex = !isSelected || isMoving ? '' : '1';
    preserveScrollPosition();
  } // Called for every frame computed by useSpring.


  function onChange(_ref3) {
    let {
      value
    } = _ref3;
    let {
      x,
      y
    } = value;
    x = Math.round(x);
    y = Math.round(y);

    if (x !== onChange.x || y !== onChange.y) {
      onFrameChange({
        x,
        y
      });
      onChange.x = x;
      onChange.y = y;
    }
  }

  onChange.x = 0;
  onChange.y = 0;
  useSpring({
    from: {
      x: transform.x,
      y: transform.y
    },
    to: {
      x: 0,
      y: 0
    },
    reset: triggeredAnimation !== finishedAnimation,
    config: {
      mass: 5,
      tension: 2000,
      friction: 200
    },
    immediate: prefersReducedMotion,
    onChange
  });
  return ref;
}

/* harmony default export */ const use_moving_animation = (useMovingAnimation);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-html-input-element.js
/* eslint-disable jsdoc/valid-types */

/**
 * @param {Node} node
 * @return {node is HTMLInputElement} Whether the node is an HTMLInputElement.
 */
function isHTMLInputElement(node) {
  /* eslint-enable jsdoc/valid-types */
  return (node === null || node === void 0 ? void 0 : node.nodeName) === 'INPUT';
}
//# sourceMappingURL=is-html-input-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-text-field.js
/**
 * Internal dependencies
 */

/* eslint-disable jsdoc/valid-types */

/**
 * Check whether the given element is a text field, where text field is defined
 * by the ability to select within the input, or that it is contenteditable.
 *
 * See: https://html.spec.whatwg.org/#textFieldSelection
 *
 * @param {Node} node The HTML element.
 * @return {node is HTMLElement} True if the element is an text field, false if not.
 */

function isTextField(node) {
  /* eslint-enable jsdoc/valid-types */
  const nonTextInputs = ['button', 'checkbox', 'hidden', 'file', 'radio', 'image', 'range', 'reset', 'submit', 'number', 'email', 'time'];
  return isHTMLInputElement(node) && node.type && !nonTextInputs.includes(node.type) || node.nodeName === 'TEXTAREA' ||
  /** @type {HTMLElement} */
  node.contentEditable === 'true';
}
//# sourceMappingURL=is-text-field.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-input-or-text-area.js
/* eslint-disable jsdoc/valid-types */

/**
 * @param {Element} element
 * @return {element is HTMLInputElement | HTMLTextAreaElement} Whether the element is an input or textarea
 */
function isInputOrTextArea(element) {
  /* eslint-enable jsdoc/valid-types */
  return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';
}
//# sourceMappingURL=is-input-or-text-area.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-form-element.js
/**
 * Internal dependencies
 */

/**
 *
 * Detects if element is a form element.
 *
 * @param {Element} element The element to check.
 *
 * @return {boolean} True if form element and false otherwise.
 */

function isFormElement(element) {
  if (!element) {
    return false;
  }

  const {
    tagName
  } = element;
  const checkForInputTextarea = isInputOrTextArea(element);
  return checkForInputTextarea || tagName === 'BUTTON' || tagName === 'SELECT';
}
//# sourceMappingURL=is-form-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/caret-range-from-point.js
/**
 * Polyfill.
 * Get a collapsed range for a given point.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint
 *
 * @param {DocumentMaybeWithCaretPositionFromPoint} doc The document of the range.
 * @param {number}                                  x   Horizontal position within the current viewport.
 * @param {number}                                  y   Vertical position within the current viewport.
 *
 * @return {Range | null} The best range for the given point.
 */
function caretRangeFromPoint(doc, x, y) {
  if (doc.caretRangeFromPoint) {
    return doc.caretRangeFromPoint(x, y);
  }

  if (!doc.caretPositionFromPoint) {
    return null;
  }

  const point = doc.caretPositionFromPoint(x, y); // If x or y are negative, outside viewport, or there is no text entry node.
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint

  if (!point) {
    return null;
  }

  const range = doc.createRange();
  range.setStart(point.offsetNode, point.offset);
  range.collapse(true);
  return range;
}
/**
 * @typedef {{caretPositionFromPoint?: (x: number, y: number)=> CaretPosition | null} & Document } DocumentMaybeWithCaretPositionFromPoint
 * @typedef {{ readonly offset: number; readonly offsetNode: Node; getClientRect(): DOMRect | null; }} CaretPosition
 */
//# sourceMappingURL=caret-range-from-point.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/hidden-caret-range-from-point.js
/**
 * Internal dependencies
 */


/**
 * Get a collapsed range for a given point.
 * Gives the container a temporary high z-index (above any UI).
 * This is preferred over getting the UI nodes and set styles there.
 *
 * @param {Document}    doc       The document of the range.
 * @param {number}      x         Horizontal position within the current viewport.
 * @param {number}      y         Vertical position within the current viewport.
 * @param {HTMLElement} container Container in which the range is expected to be found.
 *
 * @return {?Range} The best range for the given point.
 */

function hiddenCaretRangeFromPoint(doc, x, y, container) {
  const originalZIndex = container.style.zIndex;
  const originalPosition = container.style.position;
  const {
    position = 'static'
  } = getComputedStyle(container); // A z-index only works if the element position is not static.

  if (position === 'static') {
    container.style.position = 'relative';
  }

  container.style.zIndex = '10000';
  const range = caretRangeFromPoint(doc, x, y);
  container.style.zIndex = originalZIndex;
  container.style.position = originalPosition;
  return range;
}
//# sourceMappingURL=hidden-caret-range-from-point.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-rtl.js
/**
 * Internal dependencies
 */

/**
 * Whether the element's text direction is right-to-left.
 *
 * @param {Element} element The element to check.
 *
 * @return {boolean} True if rtl, false if ltr.
 */

function isRTL(element) {
  return getComputedStyle(element).direction === 'rtl';
}
//# sourceMappingURL=is-rtl.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/place-caret-at-edge.js
/**
 * Internal dependencies
 */




/**
 * Gets the range to place.
 *
 * @param {HTMLElement}      container Focusable element.
 * @param {boolean}          isReverse True for end, false for start.
 * @param {number|undefined} x         X coordinate to vertically position.
 *
 * @return {Range|null} The range to place.
 */

function getRange(container, isReverse, x) {
  const {
    ownerDocument
  } = container; // In the case of RTL scripts, the horizontal edge is at the opposite side.

  const isReverseDir = isRTL(container) ? !isReverse : isReverse;
  const containerRect = container.getBoundingClientRect(); // When placing at the end (isReverse), find the closest range to the bottom
  // right corner. When placing at the start, to the top left corner.
  // Ensure x is defined and within the container's boundaries. When it's
  // exactly at the boundary, it's not considered within the boundaries.

  if (x === undefined) {
    x = isReverse ? containerRect.right - 1 : containerRect.left + 1;
  } else if (x <= containerRect.left) {
    x = containerRect.left + 1;
  } else if (x >= containerRect.right) {
    x = containerRect.right - 1;
  }

  const y = isReverseDir ? containerRect.bottom - 1 : containerRect.top + 1;
  return hiddenCaretRangeFromPoint(ownerDocument, x, y, container);
}
/**
 * Places the caret at start or end of a given element.
 *
 * @param {HTMLElement}      container Focusable element.
 * @param {boolean}          isReverse True for end, false for start.
 * @param {number|undefined} x         X coordinate to vertically position.
 */


function placeCaretAtEdge(container, isReverse, x) {
  if (!container) {
    return;
  }

  container.focus();

  if (isInputOrTextArea(container)) {
    // The element may not support selection setting.
    if (typeof container.selectionStart !== 'number') {
      return;
    }

    if (isReverse) {
      container.selectionStart = container.value.length;
      container.selectionEnd = container.value.length;
    } else {
      container.selectionStart = 0;
      container.selectionEnd = 0;
    }

    return;
  }

  if (!container.isContentEditable) {
    return;
  }

  let range = getRange(container, isReverse, x); // If no range range can be created or it is outside the container, the
  // element may be out of view.

  if (!range || !range.startContainer || !container.contains(range.startContainer)) {
    container.scrollIntoView(isReverse);
    range = range = getRange(container, isReverse, x);

    if (!range || !range.startContainer || !container.contains(range.startContainer)) {
      return;
    }
  }

  const {
    ownerDocument
  } = container;
  const {
    defaultView
  } = ownerDocument;
  (0,assert_is_defined/* assertIsDefined */.e)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  selection.removeAllRanges();
  selection.addRange(range);
}
//# sourceMappingURL=place-caret-at-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/place-caret-at-horizontal-edge.js
/**
 * Internal dependencies
 */

/**
 * Places the caret at start or end of a given element.
 *
 * @param {HTMLElement} container Focusable element.
 * @param {boolean}     isReverse True for end, false for start.
 */

function placeCaretAtHorizontalEdge(container, isReverse) {
  return placeCaretAtEdge(container, isReverse, undefined);
}
//# sourceMappingURL=place-caret-at-horizontal-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/dom.js
const BLOCK_SELECTOR = '.block-editor-block-list__block';
const APPENDER_SELECTOR = '.block-list-appender';
const BLOCK_APPENDER_CLASS = '.block-editor-button-block-appender';
/**
 * Returns true if two elements are contained within the same block.
 *
 * @param {Element} a First element.
 * @param {Element} b Second element.
 *
 * @return {boolean} Whether elements are in the same block.
 */

function isInSameBlock(a, b) {
  return a.closest(BLOCK_SELECTOR) === b.closest(BLOCK_SELECTOR);
}
/**
 * Returns true if an element is considered part of the block and not its inner
 * blocks or appender.
 *
 * @param {Element} blockElement Block container element.
 * @param {Element} element      Element.
 *
 * @return {boolean} Whether an element is considered part of the block and not
 *                   its inner blocks or appender.
 */

function isInsideRootBlock(blockElement, element) {
  const parentBlock = element.closest([BLOCK_SELECTOR, APPENDER_SELECTOR, BLOCK_APPENDER_CLASS].join(','));
  return parentBlock === blockElement;
}
/**
 * Finds the block client ID given any DOM node inside the block.
 *
 * @param {Node?} node DOM node.
 *
 * @return {string|undefined} Client ID or undefined if the node is not part of
 *                            a block.
 */

function getBlockClientId(node) {
  while (node && node.nodeType !== node.ELEMENT_NODE) {
    node = node.parentNode;
  }

  if (!node) {
    return;
  }

  const elementNode =
  /** @type {Element} */
  node;
  const blockNode = elementNode.closest(BLOCK_SELECTOR);

  if (!blockNode) {
    return;
  }

  return blockNode.id.slice('block-'.length);
}
//# sourceMappingURL=dom.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Returns the initial position if the block needs to be focussed, `undefined`
 * otherwise. The initial position is either 0 (start) or -1 (end).
 *
 * @param {string} clientId Block client ID.
 *
 * @return {number} The initial position, either 0 (start) or -1 (end).
 */

function useInitialPosition(clientId) {
  return use_select_useSelect(select => {
    const {
      getSelectedBlocksInitialCaretPosition,
      isNavigationMode,
      isBlockSelected
    } = select(store_store);

    if (!isBlockSelected(clientId)) {
      return;
    }

    if (isNavigationMode()) {
      return;
    } // If there's no initial position, return 0 to focus the start.


    return getSelectedBlocksInitialCaretPosition();
  }, [clientId]);
}
/**
 * Transitions focus to the block or inner tabbable when the block becomes
 * selected and an initial position is set.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {RefObject} React ref with the block element.
 */


function useFocusFirstElement(clientId) {
  const ref = (0,react.useRef)();
  const initialPosition = useInitialPosition(clientId);
  const {
    isBlockSelected,
    isMultiSelecting
  } = use_select_useSelect(store_store);
  (0,react.useEffect)(() => {
    // Check if the block is still selected at the time this effect runs.
    if (!isBlockSelected(clientId) || isMultiSelecting()) {
      return;
    }

    if (initialPosition === undefined || initialPosition === null) {
      return;
    }

    if (!ref.current) {
      return;
    }

    const {
      ownerDocument
    } = ref.current; // Do not focus the block if it already contains the active element.

    if (ref.current.contains(ownerDocument.activeElement)) {
      return;
    } // Find all tabbables within node.


    const textInputs = dom_build_module/* focus */.XC.tabbable.find(ref.current).filter(node => isTextField(node)); // If reversed (e.g. merge via backspace), use the last in the set of
    // tabbables.

    const isReverse = -1 === initialPosition;
    const target = (isReverse ? lodash.last : lodash.first)(textInputs) || ref.current;

    if (!isInsideRootBlock(ref.current, target)) {
      ref.current.focus();
      return;
    } // Check to see if element is focussable before a generic caret insert.


    if (!ref.current.getAttribute('contenteditable')) {
      const focusElement = dom_build_module/* focus */.XC.tabbable.findNext(ref.current); // Make sure focusElement is valid, contained in the same block, and a form field.

      if (focusElement && isInsideRootBlock(ref.current, focusElement) && isFormElement(focusElement)) {
        focusElement.focus();
        return;
      }
    }

    placeCaretAtHorizontalEdge(target, isReverse);
  }, [initialPosition, clientId]);
  return ref;
}
//# sourceMappingURL=use-focus-first-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function listener(event) {
  if (event.defaultPrevented) {
    return;
  }

  const action = event.type === 'mouseover' ? 'add' : 'remove';
  event.preventDefault();
  event.currentTarget.classList[action]('is-hovered');
}
/**
 * Adds `is-hovered` class when the block is hovered and in navigation or
 * outline mode.
 */


function useIsHovered() {
  const isEnabled = use_select_useSelect(select => {
    const {
      isNavigationMode,
      getSettings
    } = select(store_store);
    return isNavigationMode() || getSettings().outlineMode;
  }, []);
  return (0,use_ref_effect/* default */.A)(node => {
    if (isEnabled) {
      node.addEventListener('mouseout', listener);
      node.addEventListener('mouseover', listener);
      return () => {
        node.removeEventListener('mouseout', listener);
        node.removeEventListener('mouseover', listener); // Remove class in case it lingers.

        node.classList.remove('is-hovered');
      };
    }
  }, [isEnabled]);
}
//# sourceMappingURL=use-is-hovered.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-class-names.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Returns the class names used for the different states of the block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The class names.
 */

function useBlockClassNames(clientId) {
  return use_select_useSelect(select => {
    const {
      isBlockBeingDragged,
      isBlockHighlighted,
      isBlockSelected,
      isBlockMultiSelected,
      getBlockName,
      getSettings,
      hasSelectedInnerBlock,
      isTyping,
      __unstableIsFullySelected
    } = select(store_store);
    const {
      outlineMode
    } = getSettings();
    const isDragging = isBlockBeingDragged(clientId);
    const isSelected = isBlockSelected(clientId);
    const name = getBlockName(clientId);
    const checkDeep = true; // "ancestor" is the more appropriate label due to "deep" check.

    const isAncestorOfSelectedBlock = hasSelectedInnerBlock(clientId, checkDeep);
    const isMultiSelected = isBlockMultiSelected(clientId);
    return classnames_default()({
      'is-selected': isSelected,
      'is-highlighted': isBlockHighlighted(clientId),
      'is-multi-selected': isMultiSelected,
      'is-partially-selected': isMultiSelected && !__unstableIsFullySelected(),
      'is-reusable': (0,build_module/* isReusableBlock */.tk)((0,build_module/* getBlockType */.E7)(name)),
      'is-dragging': isDragging,
      'has-child-selected': isAncestorOfSelectedBlock,
      'remove-outline': isSelected && outlineMode && isTyping()
    });
  }, [clientId]);
}
//# sourceMappingURL=use-block-class-names.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-default-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the default class name if the block is a light block and it supports
 * `className`.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The class name, e.g. `wp-block-paragraph`.
 */

function useBlockDefaultClassName(clientId) {
  return use_select_useSelect(select => {
    const name = select(store_store).getBlockName(clientId);
    const blockType = (0,build_module/* getBlockType */.E7)(name);
    const hasLightBlockWrapper = (blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) > 1;

    if (!hasLightBlockWrapper) {
      return;
    }

    return (0,build_module/* getBlockDefaultClassName */.KW)(name);
  }, [clientId]);
}
//# sourceMappingURL=use-block-default-class-name.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-custom-class-name.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the custom class name if the block is a light block.
 *
 * @param {string} clientId The block client ID.
 *
 * @return {string} The custom class name.
 */

function useBlockCustomClassName(clientId) {
  // It's good for this to be a separate selector because it will be executed
  // on every attribute change, while the other selectors are not re-evaluated
  // as much.
  return use_select_useSelect(select => {
    const {
      getBlockName,
      getBlockAttributes
    } = select(store_store);
    const attributes = getBlockAttributes(clientId);

    if (!(attributes !== null && attributes !== void 0 && attributes.className)) {
      return;
    }

    const blockType = (0,build_module/* getBlockType */.E7)(getBlockName(clientId));
    const hasLightBlockWrapper = (blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) > 1;

    if (!hasLightBlockWrapper) {
      return;
    }

    return attributes.className;
  }, [clientId]);
}
//# sourceMappingURL=use-block-custom-class-name.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-moving-mode-class-names.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns the class names used for block moving mode.
 *
 * @param {string} clientId The block client ID to insert above.
 *
 * @return {string} The class names.
 */

function useBlockMovingModeClassNames(clientId) {
  return use_select_useSelect(select => {
    const {
      hasBlockMovingClientId,
      canInsertBlockType,
      getBlockName,
      getBlockRootClientId,
      isBlockSelected
    } = select(store_store); // The classes are only relevant for the selected block. Avoid
    // re-rendering all blocks!

    if (!isBlockSelected(clientId)) {
      return;
    }

    const movingClientId = hasBlockMovingClientId();

    if (!movingClientId) {
      return;
    }

    return classnames_default()('is-block-moving-mode', {
      'can-insert-moving-block': canInsertBlockType(getBlockName(movingClientId), getBlockRootClientId(clientId))
    });
  }, [clientId]);
}
//# sourceMappingURL=use-block-moving-mode-class-names.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Selects the block if it receives focus.
 *
 * @param {string} clientId Block client ID.
 */

function useFocusHandler(clientId) {
  const {
    isBlockSelected
  } = use_select_useSelect(store_store);
  const {
    selectBlock,
    selectionChange
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    /**
     * Marks the block as selected when focused and not already
     * selected. This specifically handles the case where block does not
     * set focus on its own (via `setFocus`), typically if there is no
     * focusable input in the block.
     *
     * @param {FocusEvent} event Focus event.
     */
    function onFocus(event) {
      // When the whole editor is editable, let writing flow handle
      // selection.
      if (node.parentElement.closest('[contenteditable="true"]')) {
        return;
      } // Check synchronously because a non-selected block might be
      // getting data through `useSelect` asynchronously.


      if (isBlockSelected(clientId)) {
        // Potentially change selection away from rich text.
        if (!event.target.isContentEditable) {
          selectionChange(clientId);
        }

        return;
      } // If an inner block is focussed, that block is resposible for
      // setting the selected block.


      if (!isInsideRootBlock(node, event.target)) {
        return;
      }

      selectBlock(clientId);
    }

    node.addEventListener('focusin', onFocus);
    return () => {
      node.removeEventListener('focusin', onFocus);
    };
  }, [isBlockSelected, selectBlock]);
}
//# sourceMappingURL=use-focus-handler.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@3.47.0/node_modules/@wordpress/keycodes/build-module/index.js + 2 modules
var keycodes_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@3.47.0/node_modules/@wordpress/keycodes/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Adds block behaviour:
 *   - Removes the block on BACKSPACE.
 *   - Inserts a default block on ENTER.
 *   - Disables dragging of block contents.
 *
 * @param {string} clientId Block client ID.
 */

function useEventHandlers(clientId) {
  const isSelected = use_select_useSelect(select => select(store_store).isBlockSelected(clientId), [clientId]);
  const {
    getBlockRootClientId,
    getBlockIndex
  } = use_select_useSelect(store_store);
  const {
    insertDefaultBlock,
    removeBlock
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    if (!isSelected) {
      return;
    }
    /**
     * Interprets keydown event intent to remove or insert after block if
     * key event occurs on wrapper node. This can occur when the block has
     * no text fields of its own, particularly after initial insertion, to
     * allow for easy deletion and continuous writing flow to add additional
     * content.
     *
     * @param {KeyboardEvent} event Keydown event.
     */


    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;

      if (keyCode !== keycodes_build_module/* ENTER */.Fm && keyCode !== keycodes_build_module/* BACKSPACE */.G_ && keyCode !== keycodes_build_module/* DELETE */.SJ) {
        return;
      }

      if (target !== node || isTextField(target)) {
        return;
      }

      event.preventDefault();

      if (keyCode === keycodes_build_module/* ENTER */.Fm) {
        insertDefaultBlock({}, getBlockRootClientId(clientId), getBlockIndex(clientId) + 1);
      } else {
        removeBlock(clientId);
      }
    }
    /**
     * Prevents default dragging behavior within a block. To do: we must
     * handle this in the future and clean up the drag target.
     *
     * @param {DragEvent} event Drag event.
     */


    function onDragStart(event) {
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('dragstart', onDragStart);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('dragstart', onDragStart);
    };
  }, [clientId, isSelected, getBlockRootClientId, getBlockIndex, insertDefaultBlock, removeBlock]);
}
//# sourceMappingURL=use-selected-block-event-handlers.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-nav-mode-exit.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Allows navigation mode to be exited by clicking in the selected block.
 *
 * @param {string} clientId Block client ID.
 */

function useNavModeExit(clientId) {
  const {
    isNavigationMode,
    isBlockSelected
  } = use_select_useSelect(store_store);
  const {
    setNavigationMode,
    selectBlock
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onMouseDown(event) {
      // Don't select a block if it's already handled by a child
      // block.
      if (isNavigationMode() && !event.defaultPrevented) {
        // Prevent focus from moving to the block.
        event.preventDefault(); // When clicking on a selected block, exit navigation mode.

        if (isBlockSelected(clientId)) {
          setNavigationMode(false);
        } else {
          selectBlock(clientId);
        }
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.addEventListener('mousedown', onMouseDown);
    };
  }, [clientId, isNavigationMode, isBlockSelected, setNavigationMode]);
}
//# sourceMappingURL=use-nav-mode-exit.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function useIntersectionObserver() {
  const observer = (0,react.useContext)(block_list_IntersectionObserver);
  return (0,use_ref_effect/* default */.A)(node => {
    if (observer) {
      observer.observe(node);
      return () => {
        observer.unobserve(node);
      };
    }
  }, [observer]);
}
//# sourceMappingURL=use-intersection-observer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js
/* provided dependency */ var use_block_props_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */
















/**
 * If the block count exceeds the threshold, we disable the reordering animation
 * to avoid laginess.
 */

const BLOCK_ANIMATION_THRESHOLD = 200;
/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * @param {Object}  props                        Optional. Props to pass to the element. Must contain
 *                                               the ref if one is defined.
 * @param {Object}  options                      Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 * @param {boolean} options.__unstableIsDisabled Whether the block should be disabled.
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */

function useBlockProps() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let {
    __unstableIsHtml,
    __unstableIsDisabled = false
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    clientId,
    className,
    wrapperProps = {},
    isAligned
  } = (0,react.useContext)(BlockListBlockContext);
  const {
    index,
    mode,
    name,
    blockApiVersion,
    blockTitle,
    isPartOfSelection,
    adjustScrolling,
    enableAnimation
  } = use_select_useSelect(select => {
    const {
      getBlockIndex,
      getBlockMode,
      getBlockName,
      isTyping,
      getGlobalBlockCount,
      isBlockSelected,
      isBlockMultiSelected,
      isAncestorMultiSelected,
      isFirstMultiSelectedBlock
    } = select(store_store);
    const isSelected = isBlockSelected(clientId);
    const isPartOfMultiSelection = isBlockMultiSelected(clientId) || isAncestorMultiSelected(clientId);
    const blockName = getBlockName(clientId);
    const blockType = (0,build_module/* getBlockType */.E7)(blockName);
    return {
      index: getBlockIndex(clientId),
      mode: getBlockMode(clientId),
      name: blockName,
      blockApiVersion: (blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) || 1,
      blockTitle: blockType === null || blockType === void 0 ? void 0 : blockType.title,
      isPartOfSelection: isSelected || isPartOfMultiSelection,
      adjustScrolling: isSelected || isFirstMultiSelectedBlock(clientId),
      enableAnimation: !isTyping() && getGlobalBlockCount() <= BLOCK_ANIMATION_THRESHOLD
    };
  }, [clientId]); // translators: %s: Type of block (i.e. Text, Image etc)

  const blockLabel = (0,_wordpress_i18n_build_module/* sprintf */.nv)((0,_wordpress_i18n_build_module.__)('Block: %s'), blockTitle);
  const htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  const mergedRefs = (0,use_merge_refs/* default */.A)([props.ref, useFocusFirstElement(clientId), useBlockRefProvider(clientId), useFocusHandler(clientId), useEventHandlers(clientId), useNavModeExit(clientId), useIsHovered(), useIntersectionObserver(), use_moving_animation({
    isSelected: isPartOfSelection,
    adjustScrolling,
    enableAnimation,
    triggerAnimationOnChange: index
  }), use_disabled_useDisabled({
    isDisabled: !__unstableIsDisabled
  })]);
  const blockEditContext = context_useBlockEditContext(); // Ensures it warns only inside the `edit` implementation for the block.

  if (blockApiVersion < 2 && clientId === blockEditContext.clientId) {
    typeof use_block_props_process !== "undefined" && use_block_props_process.env && "production" !== "production" ? 0 : void 0;
  }

  return { ...wrapperProps,
    ...props,
    ref: mergedRefs,
    id: `block-${clientId}${htmlSuffix}`,
    tabIndex: 0,
    role: 'document',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    className: classnames_default()( // The wp-block className is important for editor styles.
    classnames_default()('block-editor-block-list__block', {
      'wp-block': !isAligned
    }), className, props.className, wrapperProps.className, useBlockClassNames(clientId), useBlockDefaultClassName(clientId), useBlockCustomClassName(clientId), useBlockMovingModeClassNames(clientId)),
    style: { ...wrapperProps.style,
      ...props.style
    }
  };
}
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */

useBlockProps.save = build_module/* __unstableGetBlockProps */.cV;
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/block.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */








const BlockListBlockContext = (0,react.createContext)();
/**
 * Merges wrapper props with special handling for classNames and styles.
 *
 * @param {Object} propsA
 * @param {Object} propsB
 *
 * @return {Object} Merged props.
 */

function mergeWrapperProps(propsA, propsB) {
  const newProps = { ...propsA,
    ...propsB
  };

  if (propsA !== null && propsA !== void 0 && propsA.className && propsB !== null && propsB !== void 0 && propsB.className) {
    newProps.className = classnames_default()(propsA.className, propsB.className);
  }

  if (propsA !== null && propsA !== void 0 && propsA.style && propsB !== null && propsB !== void 0 && propsB.style) {
    newProps.style = { ...propsA.style,
      ...propsB.style
    };
  }

  return newProps;
}

function Block(_ref) {
  let {
    children,
    isHtml,
    ...props
  } = _ref;
  return (0,react.createElement)("div", useBlockProps(props, {
    __unstableIsHtml: isHtml
  }), children);
}

function BlockListBlock(_ref2) {
  var _wrapperProps;

  let {
    block: {
      __unstableBlockSource
    },
    mode,
    isLocked,
    canRemove,
    clientId,
    isSelected,
    isSelectionEnabled,
    className,
    name,
    isValid,
    attributes,
    wrapperProps,
    setAttributes,
    onReplace,
    onInsertBlocksAfter,
    onMerge,
    toggleSelection
  } = _ref2;
  const themeSupportsLayout = use_select_useSelect(select => {
    const {
      getSettings
    } = select(store_store);
    return getSettings().supportsLayout;
  }, []);
  const {
    removeBlock
  } = use_dispatch(store_store);
  const onRemove = (0,react.useCallback)(() => removeBlock(clientId), [clientId]); // We wrap the BlockEdit component in a div that hides it when editing in
  // HTML mode. This allows us to render all of the ancillary pieces
  // (InspectorControls, etc.) which are inside `BlockEdit` but not
  // `BlockHTML`, even in HTML mode.

  let blockEdit = (0,react.createElement)(BlockEdit, {
    name: name,
    isSelected: isSelected,
    attributes: attributes,
    setAttributes: setAttributes,
    insertBlocksAfter: isLocked ? undefined : onInsertBlocksAfter,
    onReplace: canRemove ? onReplace : undefined,
    onRemove: canRemove ? onRemove : undefined,
    mergeBlocks: canRemove ? onMerge : undefined,
    clientId: clientId,
    isSelectionEnabled: isSelectionEnabled,
    toggleSelection: toggleSelection
  });
  const blockType = (0,build_module/* getBlockType */.E7)(name); // Determine whether the block has props to apply to the wrapper.

  if (blockType !== null && blockType !== void 0 && blockType.getEditWrapperProps) {
    wrapperProps = mergeWrapperProps(wrapperProps, blockType.getEditWrapperProps(attributes));
  }

  const isAligned = wrapperProps && !!wrapperProps['data-align'] && !themeSupportsLayout; // For aligned blocks, provide a wrapper element so the block can be
  // positioned relative to the block column.
  // This is only kept for classic themes that don't support layout
  // Historically we used to rely on extra divs and data-align to
  // provide the alignments styles in the editor.
  // Due to the differences between frontend and backend, we migrated
  // to the layout feature, and we're now aligning the markup of frontend
  // and backend.

  if (isAligned) {
    blockEdit = (0,react.createElement)("div", {
      className: "wp-block",
      "data-align": wrapperProps['data-align']
    }, blockEdit);
  }

  let block;

  if (!isValid) {
    const saveContent = __unstableBlockSource ? (0,build_module/* serializeRawBlock */.Kx)(__unstableBlockSource) : (0,build_module/* getSaveContent */.Z9)(blockType, attributes);
    block = (0,react.createElement)(Block, {
      className: "has-warning"
    }, (0,react.createElement)(block_invalid_warning, {
      clientId: clientId
    }), (0,react.createElement)(raw_html/* default */.A, null, (0,safe_html/* default */.A)(saveContent)));
  } else if (mode === 'html') {
    // Render blockEdit so the inspector controls don't disappear.
    // See #8969.
    block = (0,react.createElement)(react.Fragment, null, (0,react.createElement)("div", {
      style: {
        display: 'none'
      }
    }, blockEdit), (0,react.createElement)(Block, {
      isHtml: true
    }, (0,react.createElement)(block_html, {
      clientId: clientId
    })));
  } else if ((blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) > 1) {
    block = blockEdit;
  } else {
    block = (0,react.createElement)(Block, wrapperProps, blockEdit);
  }

  const value = {
    clientId,
    className: (_wrapperProps = wrapperProps) !== null && _wrapperProps !== void 0 && _wrapperProps['data-align'] && themeSupportsLayout ? classnames_default()(className, `align${wrapperProps['data-align']}`) : className,
    wrapperProps: (0,lodash.omit)(wrapperProps, ['data-align']),
    isAligned
  };
  const memoizedValue = (0,react.useMemo)(() => value, Object.values(value));
  return (0,react.createElement)(BlockListBlockContext.Provider, {
    value: memoizedValue
  }, (0,react.createElement)(block_crash_boundary, {
    fallback: (0,react.createElement)(Block, {
      className: "has-warning"
    }, (0,react.createElement)(block_crash_warning, null))
  }, block));
}

const applyWithSelect = with_select((select, _ref3) => {
  let {
    clientId,
    rootClientId
  } = _ref3;
  const {
    isBlockSelected,
    getBlockMode,
    isSelectionEnabled,
    getTemplateLock,
    __unstableGetBlockWithoutInnerBlocks,
    canRemoveBlock,
    canMoveBlock
  } = select(store_store);

  const block = __unstableGetBlockWithoutInnerBlocks(clientId);

  const isSelected = isBlockSelected(clientId);
  const templateLock = getTemplateLock(rootClientId);
  const canRemove = canRemoveBlock(clientId, rootClientId);
  const canMove = canMoveBlock(clientId, rootClientId); // The fallback to `{}` is a temporary fix.
  // This function should never be called when a block is not present in
  // the state. It happens now because the order in withSelect rendering
  // is not correct.

  const {
    name,
    attributes,
    isValid
  } = block || {}; // Do not add new properties here, use `useSelect` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).

  return {
    mode: getBlockMode(clientId),
    isSelectionEnabled: isSelectionEnabled(),
    isLocked: !!templateLock,
    canRemove,
    canMove,
    // Users of the editor.BlockListBlock filter used to be able to
    // access the block prop.
    // Ideally these blocks would rely on the clientId prop only.
    // This is kept for backward compatibility reasons.
    block,
    name,
    attributes,
    isValid,
    isSelected
  };
});
const applyWithDispatch = with_dispatch((dispatch, ownProps, _ref4) => {
  let {
    select
  } = _ref4;
  const {
    updateBlockAttributes,
    insertBlocks,
    mergeBlocks,
    replaceBlocks,
    toggleSelection,
    __unstableMarkLastChangeAsPersistent
  } = dispatch(store_store); // Do not add new properties here, use `useDispatch` instead to avoid
  // leaking new props to the public API (editor.BlockListBlock filter).

  return {
    setAttributes(newAttributes) {
      const {
        getMultiSelectedBlockClientIds
      } = select(store_store);
      const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
      const {
        clientId
      } = ownProps;
      const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
      updateBlockAttributes(clientIds, newAttributes);
    },

    onInsertBlocks(blocks, index) {
      const {
        rootClientId
      } = ownProps;
      insertBlocks(blocks, index, rootClientId);
    },

    onInsertBlocksAfter(blocks) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getBlockIndex
      } = select(store_store);
      const index = getBlockIndex(clientId);
      insertBlocks(blocks, index + 1, rootClientId);
    },

    onMerge(forward) {
      const {
        clientId,
        rootClientId
      } = ownProps;
      const {
        getPreviousBlockClientId,
        getNextBlockClientId,
        getBlock
      } = select(store_store);

      if (forward) {
        const nextBlockClientId = getNextBlockClientId(clientId);

        if (nextBlockClientId) {
          mergeBlocks(clientId, nextBlockClientId);
        }
      } else {
        const previousBlockClientId = getPreviousBlockClientId(clientId);

        if (previousBlockClientId) {
          mergeBlocks(previousBlockClientId, clientId);
        } else if (rootClientId) {
          // Attempt to "unwrap" the block contents when there's no
          // preceding block to merge with.
          const replacement = (0,build_module/* switchToBlockType */.bh)(getBlock(rootClientId), '*');

          if (replacement && replacement.length) {
            replaceBlocks(rootClientId, replacement, 0);
          }
        }
      }
    },

    onReplace(blocks, indexToSelect, initialPosition) {
      if (blocks.length && !(0,build_module/* isUnmodifiedDefaultBlock */.Xw)(blocks[blocks.length - 1])) {
        __unstableMarkLastChangeAsPersistent();
      }

      replaceBlocks([ownProps.clientId], blocks, indexToSelect, initialPosition);
    },

    toggleSelection(selectionEnabled) {
      toggleSelection(selectionEnabled);
    }

  };
});
/* harmony default export */ const block_list_block = ((0,compose/* default */.A)(pure/* default */.A, applyWithSelect, applyWithDispatch, // Block is sometimes not mounted at the right time, causing it be undefined
// see issue for more info
// https://github.com/WordPress/gutenberg/issues/17013
if_condition(_ref5 => {
  let {
    block
  } = _ref5;
  return !!block;
}), withFilters('editor.BlockListBlock'))(BlockListBlock));
//# sourceMappingURL=block.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+html-entities@3.24.0/node_modules/@wordpress/html-entities/build-module/index.js
var html_entities_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+html-entities@3.24.0/node_modules/@wordpress/html-entities/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/close-small.js

/**
 * WordPress dependencies
 */

const closeSmall = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z"
}));
/* harmony default export */ const close_small = (closeSmall);
//# sourceMappingURL=close-small.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/search.js

/**
 * WordPress dependencies
 */

const search = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M13 5c-3.3 0-6 2.7-6 6 0 1.4.5 2.7 1.3 3.7l-3.8 3.8 1.1 1.1 3.8-3.8c1 .8 2.3 1.3 3.7 1.3 3.3 0 6-2.7 6-6S16.3 5 13 5zm0 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"
}));
/* harmony default export */ const library_search = (search);
//# sourceMappingURL=search.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/search-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function SearchControl(_ref, forwardedRef) {
  let {
    className,
    onChange,
    onKeyDown,
    value,
    label,
    placeholder = (0,i18n_build_module.__)('Search'),
    hideLabelFromVision = true,
    help,
    onClose
  } = _ref;
  const searchRef = (0,react.useRef)();
  const instanceId = (0,use_instance_id/* default */.A)(SearchControl);
  const id = `components-search-control-${instanceId}`;

  const renderRightButton = () => {
    if (onClose) {
      return (0,react.createElement)(build_module_button, {
        icon: close_small,
        label: (0,i18n_build_module.__)('Close search'),
        onClick: onClose
      });
    }

    if (!!value) {
      return (0,react.createElement)(build_module_button, {
        icon: close_small,
        label: (0,i18n_build_module.__)('Reset search'),
        onClick: () => {
          onChange('');
          searchRef.current.focus();
        }
      });
    }

    return (0,react.createElement)(icon, {
      icon: library_search
    });
  };

  return (0,react.createElement)(base_control, {
    label: label,
    id: id,
    hideLabelFromVision: hideLabelFromVision,
    help: help,
    className: classnames_default()(className, 'components-search-control')
  }, (0,react.createElement)("div", {
    className: "components-search-control__input-wrapper"
  }, (0,react.createElement)("input", {
    ref: (0,use_merge_refs/* default */.A)([searchRef, forwardedRef]),
    className: "components-search-control__input",
    id: id,
    type: "search",
    placeholder: placeholder,
    onChange: event => onChange(event.target.value),
    onKeyDown: onKeyDown,
    autoComplete: "off",
    value: value || ''
  }), (0,react.createElement)("div", {
    className: "components-search-control__icon"
  }, renderRightButton())));
}

/* harmony default export */ const search_control = ((0,react.forwardRef)(SearchControl));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/create-interpolate-element.js
/**
 * Internal dependencies
 */

/** @typedef {import('./react').WPElement} WPElement */

let indoc, offset, output, stack;
/**
 * Matches tags in the localized string
 *
 * This is used for extracting the tag pattern groups for parsing the localized
 * string and along with the map converting it to a react element.
 *
 * There are four references extracted using this tokenizer:
 *
 * match: Full match of the tag (i.e. <strong>, </strong>, <br/>)
 * isClosing: The closing slash, if it exists.
 * name: The name portion of the tag (strong, br) (if )
 * isSelfClosed: The slash on a self closing tag, if it exists.
 *
 * @type {RegExp}
 */

const tokenizer = /<(\/)?(\w+)\s*(\/)?>/g;
/**
 * The stack frame tracking parse progress.
 *
 * @typedef Frame
 *
 * @property {WPElement}   element            A parent element which may still have
 * @property {number}      tokenStart         Offset at which parent element first
 *                                            appears.
 * @property {number}      tokenLength        Length of string marking start of parent
 *                                            element.
 * @property {number}      [prevOffset]       Running offset at which parsing should
 *                                            continue.
 * @property {number}      [leadingTextStart] Offset at which last closing element
 *                                            finished, used for finding text between
 *                                            elements.
 * @property {WPElement[]} children           Children.
 */

/**
 * Tracks recursive-descent parse state.
 *
 * This is a Stack frame holding parent elements until all children have been
 * parsed.
 *
 * @private
 * @param {WPElement} element            A parent element which may still have
 *                                       nested children not yet parsed.
 * @param {number}    tokenStart         Offset at which parent element first
 *                                       appears.
 * @param {number}    tokenLength        Length of string marking start of parent
 *                                       element.
 * @param {number}    [prevOffset]       Running offset at which parsing should
 *                                       continue.
 * @param {number}    [leadingTextStart] Offset at which last closing element
 *                                       finished, used for finding text between
 *                                       elements.
 *
 * @return {Frame} The stack frame tracking parse progress.
 */

function createFrame(element, tokenStart, tokenLength, prevOffset, leadingTextStart) {
  return {
    element,
    tokenStart,
    tokenLength,
    prevOffset,
    leadingTextStart,
    children: []
  };
}
/**
 * This function creates an interpolated element from a passed in string with
 * specific tags matching how the string should be converted to an element via
 * the conversion map value.
 *
 * @example
 * For example, for the given string:
 *
 * "This is a <span>string</span> with <a>a link</a> and a self-closing
 * <CustomComponentB/> tag"
 *
 * You would have something like this as the conversionMap value:
 *
 * ```js
 * {
 *     span: <span />,
 *     a: <a href={ 'https://github.com' } />,
 *     CustomComponentB: <CustomComponent />,
 * }
 * ```
 *
 * @param {string} interpolatedString The interpolation string to be parsed.
 * @param {Object} conversionMap      The map used to convert the string to
 *                                    a react element.
 * @throws {TypeError}
 * @return {WPElement}  A wp element.
 */


const createInterpolateElement = (interpolatedString, conversionMap) => {
  indoc = interpolatedString;
  offset = 0;
  output = [];
  stack = [];
  tokenizer.lastIndex = 0;

  if (!isValidConversionMap(conversionMap)) {
    throw new TypeError('The conversionMap provided is not valid. It must be an object with values that are WPElements');
  }

  do {// twiddle our thumbs
  } while (proceed(conversionMap));

  return (0,react.createElement)(react.Fragment, null, ...output);
};
/**
 * Validate conversion map.
 *
 * A map is considered valid if it's an object and every value in the object
 * is a WPElement
 *
 * @private
 *
 * @param {Object} conversionMap The map being validated.
 *
 * @return {boolean}  True means the map is valid.
 */


const isValidConversionMap = conversionMap => {
  const isObject = typeof conversionMap === 'object';
  const values = isObject && Object.values(conversionMap);
  return isObject && values.length && values.every(element => (0,react.isValidElement)(element));
};
/**
 * This is the iterator over the matches in the string.
 *
 * @private
 *
 * @param {Object} conversionMap The conversion map for the string.
 *
 * @return {boolean} true for continuing to iterate, false for finished.
 */


function proceed(conversionMap) {
  const next = nextToken();
  const [tokenType, name, startOffset, tokenLength] = next;
  const stackDepth = stack.length;
  const leadingTextStart = startOffset > offset ? offset : null;

  if (!conversionMap[name]) {
    addText();
    return false;
  }

  switch (tokenType) {
    case 'no-more-tokens':
      if (stackDepth !== 0) {
        const {
          leadingTextStart: stackLeadingText,
          tokenStart
        } = stack.pop();
        output.push(indoc.substr(stackLeadingText, tokenStart));
      }

      addText();
      return false;

    case 'self-closed':
      if (0 === stackDepth) {
        if (null !== leadingTextStart) {
          output.push(indoc.substr(leadingTextStart, startOffset - leadingTextStart));
        }

        output.push(conversionMap[name]);
        offset = startOffset + tokenLength;
        return true;
      } // Otherwise we found an inner element.


      addChild(createFrame(conversionMap[name], startOffset, tokenLength));
      offset = startOffset + tokenLength;
      return true;

    case 'opener':
      stack.push(createFrame(conversionMap[name], startOffset, tokenLength, startOffset + tokenLength, leadingTextStart));
      offset = startOffset + tokenLength;
      return true;

    case 'closer':
      // If we're not nesting then this is easy - close the block.
      if (1 === stackDepth) {
        closeOuterElement(startOffset);
        offset = startOffset + tokenLength;
        return true;
      } // Otherwise we're nested and we have to close out the current
      // block and add it as a innerBlock to the parent.


      const stackTop = stack.pop();
      const text = indoc.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);
      stackTop.children.push(text);
      stackTop.prevOffset = startOffset + tokenLength;
      const frame = createFrame(stackTop.element, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);
      frame.children = stackTop.children;
      addChild(frame);
      offset = startOffset + tokenLength;
      return true;

    default:
      addText();
      return false;
  }
}
/**
 * Grabs the next token match in the string and returns it's details.
 *
 * @private
 *
 * @return {Array}  An array of details for the token matched.
 */


function nextToken() {
  const matches = tokenizer.exec(indoc); // We have no more tokens.

  if (null === matches) {
    return ['no-more-tokens'];
  }

  const startedAt = matches.index;
  const [match, isClosing, name, isSelfClosed] = matches;
  const length = match.length;

  if (isSelfClosed) {
    return ['self-closed', name, startedAt, length];
  }

  if (isClosing) {
    return ['closer', name, startedAt, length];
  }

  return ['opener', name, startedAt, length];
}
/**
 * Pushes text extracted from the indoc string to the output stack given the
 * current rawLength value and offset (if rawLength is provided ) or the
 * indoc.length and offset.
 *
 * @private
 */


function addText() {
  const length = indoc.length - offset;

  if (0 === length) {
    return;
  }

  output.push(indoc.substr(offset, length));
}
/**
 * Pushes a child element to the associated parent element's children for the
 * parent currently active in the stack.
 *
 * @private
 *
 * @param {Frame} frame The Frame containing the child element and it's
 *                      token information.
 */


function addChild(frame) {
  const {
    element,
    tokenStart,
    tokenLength,
    prevOffset,
    children
  } = frame;
  const parent = stack[stack.length - 1];
  const text = indoc.substr(parent.prevOffset, tokenStart - parent.prevOffset);

  if (text) {
    parent.children.push(text);
  }

  parent.children.push((0,react.cloneElement)(element, null, ...children));
  parent.prevOffset = prevOffset ? prevOffset : tokenStart + tokenLength;
}
/**
 * This is called for closing tags. It creates the element currently active in
 * the stack.
 *
 * @private
 *
 * @param {number} endOffset Offset at which the closing tag for the element
 *                           begins in the string. If this is greater than the
 *                           prevOffset attached to the element, then this
 *                           helps capture any remaining nested text nodes in
 *                           the element.
 */


function closeOuterElement(endOffset) {
  const {
    element,
    leadingTextStart,
    prevOffset,
    tokenStart,
    children
  } = stack.pop();
  const text = endOffset ? indoc.substr(prevOffset, endOffset - prevOffset) : indoc.substr(prevOffset);

  if (text) {
    children.push(text);
  }

  if (null !== leadingTextStart) {
    output.push(indoc.substr(leadingTextStart, tokenStart - leadingTextStart));
  }

  output.push((0,react.cloneElement)(element, null, ...children));
}

/* harmony default export */ const create_interpolate_element = (createInterpolateElement);
//# sourceMappingURL=create-interpolate-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/tip.js

/**
 * WordPress dependencies
 */

const tip = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M12 15.8c-3.7 0-6.8-3-6.8-6.8s3-6.8 6.8-6.8c3.7 0 6.8 3 6.8 6.8s-3.1 6.8-6.8 6.8zm0-12C9.1 3.8 6.8 6.1 6.8 9s2.4 5.2 5.2 5.2c2.9 0 5.2-2.4 5.2-5.2S14.9 3.8 12 3.8zM8 17.5h8V19H8zM10 20.5h4V22h-4z"
}));
/* harmony default export */ const library_tip = (tip);
//# sourceMappingURL=tip.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tip/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function Tip(props) {
  const {
    children
  } = props;
  return (0,react.createElement)("div", {
    className: "components-tip"
  }, (0,react.createElement)(icon, {
    icon: library_tip
  }), (0,react.createElement)("p", null, children));
}
/* harmony default export */ const build_module_tip = (Tip);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/tips.js


/**
 * WordPress dependencies
 */



const globalTips = [create_interpolate_element((0,_wordpress_i18n_build_module.__)('While writing, you can press <kbd>/</kbd> to quickly insert new blocks.'), {
  kbd: (0,react.createElement)("kbd", null)
}), create_interpolate_element((0,_wordpress_i18n_build_module.__)('Indent a list by pressing <kbd>space</kbd> at the beginning of a line.'), {
  kbd: (0,react.createElement)("kbd", null)
}), create_interpolate_element((0,_wordpress_i18n_build_module.__)('Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line.'), {
  kbd: (0,react.createElement)("kbd", null)
}), (0,_wordpress_i18n_build_module.__)('Drag files into the editor to automatically insert media blocks.'), (0,_wordpress_i18n_build_module.__)("Change a block's type by pressing the block icon on the toolbar.")];

function Tips() {
  const [randomIndex] = (0,react.useState)( // Disable Reason: I'm not generating an HTML id.
  // eslint-disable-next-line no-restricted-syntax
  Math.floor(Math.random() * globalTips.length));
  return (0,react.createElement)(build_module_tip, null, globalTips[randomIndex]);
}

/* harmony default export */ const tips = (Tips);
//# sourceMappingURL=tips.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/block-default.js

/**
 * WordPress dependencies
 */

const blockDefault = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z"
}));
/* harmony default export */ const block_default = (blockDefault);
//# sourceMappingURL=block-default.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-icon/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function BlockIcon(_ref) {
  var _icon;

  let {
    icon,
    showColors = false,
    className
  } = _ref;

  if (((_icon = icon) === null || _icon === void 0 ? void 0 : _icon.src) === 'block-default') {
    icon = {
      src: block_default
    };
  }

  const renderedIcon = (0,react.createElement)(build_module_icon, {
    icon: icon && icon.src ? icon.src : icon
  });
  const style = showColors ? {
    backgroundColor: icon && icon.background,
    color: icon && icon.foreground
  } : {};
  return (0,react.createElement)("span", {
    style: style,
    className: classnames_default()('block-editor-block-icon', className, {
      'has-colors': showColors
    })
  }, renderedIcon);
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-icon/README.md
 */


/* harmony default export */ const block_icon = ((0,react.memo)(BlockIcon));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-card/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function BlockCard(_ref) {
  let {
    title,
    icon,
    description,
    blockType
  } = _ref;

  if (blockType) {
    (0,deprecated_build_module/* default */.A)('`blockType` property in `BlockCard component`', {
      since: '5.7',
      alternative: '`title, icon and description` properties'
    });
    ({
      title,
      icon,
      description
    } = blockType);
  }

  return (0,react.createElement)("div", {
    className: "block-editor-block-card"
  }, (0,react.createElement)(block_icon, {
    icon: icon,
    showColors: true
  }), (0,react.createElement)("div", {
    className: "block-editor-block-card__content"
  }, (0,react.createElement)("h2", {
    className: "block-editor-block-card__title"
  }, title), (0,react.createElement)("span", {
    className: "block-editor-block-card__description"
  }, description)));
}

/* harmony default export */ const block_card = (BlockCard);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/with-registry/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Higher-order component which renders the original component with the current
 * registry context passed as its `registry` prop.
 *
 * @param {WPComponent} OriginalComponent Original component.
 *
 * @return {WPComponent} Enhanced component.
 */

const withRegistry = (0,create_higher_order_component/* createHigherOrderComponent */.f)(OriginalComponent => props => (0,react.createElement)(RegistryConsumer, null, registry => (0,react.createElement)(OriginalComponent, (0,helpers_esm_extends/* default */.A)({}, props, {
  registry: registry
}))), 'withRegistry');
/* harmony default export */ const with_registry = (withRegistry);
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/registry.js + 1 modules
var build_module_registry = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/registry.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/provider/with-registry-provider.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const withRegistryProvider = (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => {
  return with_registry(_ref => {
    let {
      useSubRegistry = true,
      registry,
      ...props
    } = _ref;

    if (!useSubRegistry) {
      return (0,react.createElement)(WrappedComponent, (0,esm_extends/* default */.A)({
        registry: registry
      }, props));
    }

    const [subRegistry, setSubRegistry] = (0,react.useState)(null);
    (0,react.useEffect)(() => {
      const newRegistry = (0,build_module_registry/* createRegistry */.I)({}, registry);
      newRegistry.registerStore(constants_STORE_NAME, storeConfig);
      setSubRegistry(newRegistry);
    }, [registry]);

    if (!subRegistry) {
      return null;
    }

    return (0,react.createElement)(registry_provider_context, {
      value: subRegistry
    }, (0,react.createElement)(WrappedComponent, (0,esm_extends/* default */.A)({
      registry: subRegistry
    }, props)));
  });
}, 'withRegistryProvider');
/* harmony default export */ const with_registry_provider = (withRegistryProvider);
//# sourceMappingURL=with-registry-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/provider/use-block-sync.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



const use_block_sync_noop = () => {};
/**
 * A function to call when the block value has been updated in the block-editor
 * store.
 *
 * @callback onBlockUpdate
 * @param {Object[]} blocks  The updated blocks.
 * @param {Object}   options The updated block options, such as selectionStart
 *                           and selectionEnd.
 */

/**
 * useBlockSync is a side effect which handles bidirectional sync between the
 * block-editor store and a controlling data source which provides blocks. This
 * is most commonly used by the BlockEditorProvider to synchronize the contents
 * of the block-editor store with the root entity, like a post.
 *
 * Another example would be the template part block, which provides blocks from
 * a separate entity data source than a root entity. This hook syncs edits to
 * the template part in the block editor back to the entity and vice-versa.
 *
 * Here are some of its basic functions:
 * - Initalizes the block-editor store for the given clientID to the blocks
 *   given via props.
 * - Adds incoming changes (like undo) to the block-editor store.
 * - Adds outgoing changes (like editing content) to the controlling entity,
 *   determining if a change should be considered persistent or not.
 * - Handles edge cases and race conditions which occur in those operations.
 * - Ignores changes which happen to other entities (like nested inner block
 *   controllers.
 * - Passes selection state from the block-editor store to the controlling entity.
 *
 * @param {Object}        props           Props for the block sync hook
 * @param {string}        props.clientId  The client ID of the inner block controller.
 *                                        If none is passed, then it is assumed to be a
 *                                        root controller rather than an inner block
 *                                        controller.
 * @param {Object[]}      props.value     The control value for the blocks. This value
 *                                        is used to initalize the block-editor store
 *                                        and for resetting the blocks to incoming
 *                                        changes like undo.
 * @param {Object}        props.selection The selection state responsible to restore the selection on undo/redo.
 * @param {onBlockUpdate} props.onChange  Function to call when a persistent
 *                                        change has been made in the block-editor blocks
 *                                        for the given clientId. For example, after
 *                                        this function is called, an entity is marked
 *                                        dirty because it has changes to save.
 * @param {onBlockUpdate} props.onInput   Function to call when a non-persistent
 *                                        change has been made in the block-editor blocks
 *                                        for the given clientId. When this is called,
 *                                        controlling sources do not become dirty.
 */


function useBlockSync(_ref) {
  let {
    clientId = null,
    value: controlledBlocks,
    selection: controlledSelection,
    onChange = use_block_sync_noop,
    onInput = use_block_sync_noop
  } = _ref;
  const registry = use_registry_useRegistry();
  const {
    resetBlocks,
    resetSelection,
    replaceInnerBlocks,
    setHasControlledInnerBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = registry.dispatch(store_store);
  const {
    getBlockName,
    getBlocks
  } = registry.select(store_store);
  const isControlled = use_select_useSelect(select => {
    return !clientId || select(store_store).areInnerBlocksControlled(clientId);
  }, [clientId]);
  const pendingChanges = (0,react.useRef)({
    incoming: null,
    outgoing: []
  });
  const subscribed = (0,react.useRef)(false);

  const setControlledBlocks = () => {
    if (!controlledBlocks) {
      return;
    } // We don't need to persist this change because we only replace
    // controlled inner blocks when the change was caused by an entity,
    // and so it would already be persisted.


    __unstableMarkNextChangeAsNotPersistent();

    if (clientId) {
      // It is important to batch here because otherwise,
      // as soon as `setHasControlledInnerBlocks` is called
      // the effect to restore might be triggered
      // before the actual blocks get set properly in state.
      registry.batch(() => {
        setHasControlledInnerBlocks(clientId, true);
        const storeBlocks = controlledBlocks.map(block => (0,build_module/* cloneBlock */.JB)(block));

        if (subscribed.current) {
          pendingChanges.current.incoming = storeBlocks;
        }

        __unstableMarkNextChangeAsNotPersistent();

        replaceInnerBlocks(clientId, storeBlocks);
      });
    } else {
      if (subscribed.current) {
        pendingChanges.current.incoming = controlledBlocks;
      }

      resetBlocks(controlledBlocks);
    }
  }; // Add a subscription to the block-editor registry to detect when changes
  // have been made. This lets us inform the data source of changes. This
  // is an effect so that the subscriber can run synchronously without
  // waiting for React renders for changes.


  const onInputRef = (0,react.useRef)(onInput);
  const onChangeRef = (0,react.useRef)(onChange);
  (0,react.useEffect)(() => {
    onInputRef.current = onInput;
    onChangeRef.current = onChange;
  }, [onInput, onChange]); // Determine if blocks need to be reset when they change.

  (0,react.useEffect)(() => {
    if (pendingChanges.current.outgoing.includes(controlledBlocks)) {
      // Skip block reset if the value matches expected outbound sync
      // triggered by this component by a preceding change detection.
      // Only skip if the value matches expectation, since a reset should
      // still occur if the value is modified (not equal by reference),
      // to allow that the consumer may apply modifications to reflect
      // back on the editor.
      if ((0,lodash.last)(pendingChanges.current.outgoing) === controlledBlocks) {
        pendingChanges.current.outgoing = [];
      }
    } else if (getBlocks(clientId) !== controlledBlocks) {
      // Reset changing value in all other cases than the sync described
      // above. Since this can be reached in an update following an out-
      // bound sync, unset the outbound value to avoid considering it in
      // subsequent renders.
      pendingChanges.current.outgoing = [];
      setControlledBlocks();

      if (controlledSelection) {
        resetSelection(controlledSelection.selectionStart, controlledSelection.selectionEnd, controlledSelection.initialPosition);
      }
    }
  }, [controlledBlocks, clientId]);
  (0,react.useEffect)(() => {
    // When the block becomes uncontrolled, it means its inner state has been reset
    // we need to take the blocks again from the external value property.
    if (!isControlled) {
      pendingChanges.current.outgoing = [];
      setControlledBlocks();
    }
  }, [isControlled]);
  (0,react.useEffect)(() => {
    const {
      getSelectionStart,
      getSelectionEnd,
      getSelectedBlocksInitialCaretPosition,
      isLastBlockChangePersistent,
      __unstableIsLastBlockChangeIgnored,
      areInnerBlocksControlled
    } = registry.select(store_store);
    let blocks = getBlocks(clientId);
    let isPersistent = isLastBlockChangePersistent();
    let previousAreBlocksDifferent = false;
    subscribed.current = true;
    const unsubscribe = registry.subscribe(() => {
      // Sometimes, when changing block lists, lingering subscriptions
      // might trigger before they are cleaned up. If the block for which
      // the subscription runs is no longer in the store, this would clear
      // its parent entity's block list. To avoid this, we bail out if
      // the subscription is triggering for a block (`clientId !== null`)
      // and its block name can't be found because it's not on the list.
      // (`getBlockName( clientId ) === null`).
      if (clientId !== null && getBlockName(clientId) === null) return; // When RESET_BLOCKS on parent blocks get called, the controlled blocks
      // can reset to uncontrolled, in these situations, it means we need to populate
      // the blocks again from the external blocks (the value property here)
      // and we should stop triggering onChange

      const isStillControlled = !clientId || areInnerBlocksControlled(clientId);

      if (!isStillControlled) {
        return;
      }

      const newIsPersistent = isLastBlockChangePersistent();
      const newBlocks = getBlocks(clientId);
      const areBlocksDifferent = newBlocks !== blocks;
      blocks = newBlocks;

      if (areBlocksDifferent && (pendingChanges.current.incoming || __unstableIsLastBlockChangeIgnored())) {
        pendingChanges.current.incoming = null;
        isPersistent = newIsPersistent;
        return;
      } // Since we often dispatch an action to mark the previous action as
      // persistent, we need to make sure that the blocks changed on the
      // previous action before committing the change.


      const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;

      if (areBlocksDifferent || didPersistenceChange) {
        isPersistent = newIsPersistent; // We know that onChange/onInput will update controlledBlocks.
        // We need to be aware that it was caused by an outgoing change
        // so that we do not treat it as an incoming change later on,
        // which would cause a block reset.

        pendingChanges.current.outgoing.push(blocks); // Inform the controlling entity that changes have been made to
        // the block-editor store they should be aware about.

        const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
        updateParent(blocks, {
          selection: {
            selectionStart: getSelectionStart(),
            selectionEnd: getSelectionEnd(),
            initialPosition: getSelectedBlocksInitialCaretPosition()
          }
        });
      }

      previousAreBlocksDifferent = areBlocksDifferent;
    });
    return () => unsubscribe();
  }, [registry, clientId]);
}
//# sourceMappingURL=use-block-sync.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/provider/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/** @typedef {import('@wordpress/data').WPDataRegistry} WPDataRegistry */

function provider_BlockEditorProvider(props) {
  const {
    children,
    settings
  } = props;
  const {
    updateSettings
  } = use_dispatch(store_store);
  (0,react.useEffect)(() => {
    updateSettings(settings);
  }, [settings]); // Syncs the entity provider with changes in the block-editor store.

  useBlockSync(props);
  return (0,react.createElement)(BlockRefsProvider, null, children);
}

/* harmony default export */ const provider = (with_registry_provider(provider_BlockEditorProvider));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/disabled/styles/disabled-styles.js


function disabled_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */
const StyledWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e13jgla80"
} : 0)( true ? {
  name: "u2jump",
  styles: "position:relative;pointer-events:none;&::after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;}*{pointer-events:none;}"
} : 0);
//# sourceMappingURL=disabled-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/disabled/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


const disabled_Context = (0,react.createContext)(false);
const {
  Consumer: disabled_Consumer,
  Provider: disabled_Provider
} = disabled_Context;
/**
 * `Disabled` is a component which disables descendant tabbable elements and prevents pointer interaction.
 *
 * ```jsx
 * import { Button, Disabled, TextControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyDisabled = () => {
 * 	const [ isDisabled, setIsDisabled ] = useState( true );
 *
 * 	let input = <TextControl label="Input" onChange={ () => {} } />;
 * 	if ( isDisabled ) {
 * 		input = <Disabled>{ input }</Disabled>;
 * 	}
 *
 * 	const toggleDisabled = () => {
 * 		setIsDisabled( ( state ) => ! state );
 * 	};
 *
 * 	return (
 * 		<div>
 * 			{ input }
 * 			<Button variant="primary" onClick={ toggleDisabled }>
 * 				Toggle Disabled
 * 			</Button>
 * 		</div>
 * 	);
 * };
 * ```
 */

function Disabled(_ref) {
  let {
    className,
    children,
    isDisabled = true,
    ...props
  } = _ref;
  const ref = use_disabled_useDisabled();

  if (!isDisabled) {
    return (0,react.createElement)(disabled_Provider, {
      value: false
    }, children);
  }

  return (0,react.createElement)(disabled_Provider, {
    value: true
  }, (0,react.createElement)(StyledWrapper, (0,helpers_esm_extends/* default */.A)({
    ref: ref,
    className: classnames_default()(className, 'components-disabled')
  }, props), children));
}

Disabled.Context = disabled_Context;
Disabled.Consumer = disabled_Consumer;
/* harmony default export */ const disabled = (Disabled);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-preview/live.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function LiveBlockPreview(_ref) {
  let {
    onClick
  } = _ref;
  return (0,react.createElement)("div", {
    tabIndex: 0,
    role: "button",
    onClick: onClick,
    onKeyPress: onClick
  }, (0,react.createElement)(disabled, null, (0,react.createElement)(BlockList, null)));
}
//# sourceMappingURL=live.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-resize-observer/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


// This of course could've been more streamlined with internal state instead of
// refs, but then host hooks / components could not opt out of renders.
// This could've been exported to its own module, but the current build doesn't
// seem to work with module imports and I had no more time to spend on this...
function useResolvedElement(subscriber, refOrElement) {
  const callbackRefElement = (0,react.useRef)(null);
  const lastReportRef = (0,react.useRef)(null);
  const cleanupRef = (0,react.useRef)();
  const callSubscriber = (0,react.useCallback)(() => {
    let element = null;

    if (callbackRefElement.current) {
      element = callbackRefElement.current;
    } else if (refOrElement) {
      if (refOrElement instanceof HTMLElement) {
        element = refOrElement;
      } else {
        element = refOrElement.current;
      }
    }

    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.reporter === callSubscriber) {
      return;
    }

    if (cleanupRef.current) {
      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.

      cleanupRef.current = null;
    }

    lastReportRef.current = {
      reporter: callSubscriber,
      element
    }; // Only calling the subscriber, if there's an actual element to report.

    if (element) {
      cleanupRef.current = subscriber(element);
    }
  }, [refOrElement, subscriber]); // On each render, we check whether a ref changed, or if we got a new raw
  // element.

  (0,react.useEffect)(() => {
    // With this we're *technically* supporting cases where ref objects' current value changes, but only if there's a
    // render accompanying that change as well.
    // To guarantee we always have the right element, one must use the ref callback provided instead, but we support
    // RefObjects to make the hook API more convenient in certain cases.
    callSubscriber();
  }, [callSubscriber]);
  return (0,react.useCallback)(element => {
    callbackRefElement.current = element;
    callSubscriber();
  }, [callSubscriber]);
}

// We're only using the first element of the size sequences, until future versions of the spec solidify on how
// exactly it'll be used for fragments in multi-column scenarios:
// From the spec:
// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,
// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not
// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single
// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.
// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.
// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)
//
// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,
// regardless of the "box" option.
// The spec states the following on this:
// > This does not have any impact on which box dimensions are returned to the defined callback when the event
// > is fired, it solely defines which box the author wishes to observe layout changes on.
// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)
// I'm not exactly clear on what this means, especially when you consider a later section stating the following:
// > This section is non-normative. An author may desire to observe more than one CSS box.
// > In this case, author will need to use multiple ResizeObservers.
// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)
// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.
// For this reason I decided to only return the requested size,
// even though it seems we have access to results for all box types.
// This also means that we get to keep the current api, being able to return a simple { width, height } pair,
// regardless of box option.
const extractSize = (entry, boxProp, sizeType) => {
  if (!entry[boxProp]) {
    if (boxProp === 'contentBoxSize') {
      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.
      // See the 6th step in the description for the RO algorithm:
      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h
      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of "content-box".
      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.
      return entry.contentRect[sizeType === 'inlineSize' ? 'width' : 'height'];
    }

    return undefined;
  } // A couple bytes smaller than calling Array.isArray() and just as effective here.


  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current
  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.
  // @ts-ignore
  entry[boxProp][sizeType];
};

function useResizeObserver() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Saving the callback as a ref. With this, I don't need to put onResize in the
  // effect dep array, and just passing in an anonymous function without memoising
  // will not reinstantiate the hook's ResizeObserver.
  const onResize = opts.onResize;
  const onResizeRef = (0,react.useRef)(undefined);
  onResizeRef.current = onResize;
  const round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime

  const resizeObserverRef = (0,react.useRef)();
  const [size, setSize] = (0,react.useState)({
    width: undefined,
    height: undefined
  }); // In certain edge cases the RO might want to report a size change just after
  // the component unmounted.

  const didUnmount = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    return () => {
      didUnmount.current = true;
    };
  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.

  const previous = (0,react.useRef)({
    width: undefined,
    height: undefined
  }); // This block is kinda like a useEffect, only it's called whenever a new
  // element could be resolved based on the ref option. It also has a cleanup
  // function.

  const refCallback = useResolvedElement((0,react.useCallback)(element => {
    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.
    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.
    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {
      resizeObserverRef.current = {
        box: opts.box,
        round,
        instance: new ResizeObserver(entries => {
          const entry = entries[0];
          let boxProp = 'borderBoxSize';

          if (opts.box === 'border-box') {
            boxProp = 'borderBoxSize';
          } else {
            boxProp = opts.box === 'device-pixel-content-box' ? 'devicePixelContentBoxSize' : 'contentBoxSize';
          }

          const reportedWidth = extractSize(entry, boxProp, 'inlineSize');
          const reportedHeight = extractSize(entry, boxProp, 'blockSize');
          const newWidth = reportedWidth ? round(reportedWidth) : undefined;
          const newHeight = reportedHeight ? round(reportedHeight) : undefined;

          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
            const newSize = {
              width: newWidth,
              height: newHeight
            };
            previous.current.width = newWidth;
            previous.current.height = newHeight;

            if (onResizeRef.current) {
              onResizeRef.current(newSize);
            } else if (!didUnmount.current) {
              setSize(newSize);
            }
          }
        })
      };
    }

    resizeObserverRef.current.instance.observe(element, {
      box: opts.box
    });
    return () => {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.instance.unobserve(element);
      }
    };
  }, [opts.box, round]), opts.ref);
  return (0,react.useMemo)(() => ({
    ref: refCallback,
    width: size.width,
    height: size.height
  }), [refCallback, size ? size.width : null, size ? size.height : null]);
}
/**
 * Hook which allows to listen the resize event of any target element when it changes sizes.
 * _Note: `useResizeObserver` will report `null` until after first render.
 *
 * @example
 *
 * ```js
 * const App = () => {
 * 	const [ resizeListener, sizes ] = useResizeObserver();
 *
 * 	return (
 * 		<div>
 * 			{ resizeListener }
 * 			Your content here
 * 		</div>
 * 	);
 * };
 * ```
 */


function useResizeAware() {
  const {
    ref,
    width,
    height
  } = useResizeObserver();
  const sizes = (0,react.useMemo)(() => {
    return {
      width: width !== null && width !== void 0 ? width : null,
      height: height !== null && height !== void 0 ? height : null
    };
  }, [width, height]);
  const resizeListener = (0,react.createElement)("div", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      pointerEvents: 'none',
      opacity: 0,
      overflow: 'hidden',
      zIndex: -1
    },
    "aria-hidden": "true",
    ref: ref
  });
  return [resizeListener, sizes];
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-selection-clearer/index.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Pass the returned ref callback to an element that should clear block
 * selection. Selection will only be cleared if the element is clicked directly,
 * not if a child element is clicked.
 *
 * @return {import('react').RefCallback} Ref callback.
 */

function useBlockSelectionClearer() {
  const {
    hasSelectedBlock,
    hasMultiSelection
  } = use_select_useSelect(store_store);
  const {
    clearSelectedBlock
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onMouseDown(event) {
      if (!hasSelectedBlock() && !hasMultiSelection()) {
        return;
      } // Only handle clicks on the element, not the children.


      if (event.target !== node) {
        return;
      }

      clearSelectedBlock();
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [hasSelectedBlock, hasMultiSelection, clearSelectedBlock]);
}
function BlockSelectionClearer(props) {
  return createElement("div", _extends({
    ref: useBlockSelectionClearer()
  }, props));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-multi-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function selector(select) {
  const {
    isMultiSelecting,
    getMultiSelectedBlockClientIds,
    hasMultiSelection,
    getSelectedBlockClientId,
    getSelectedBlocksInitialCaretPosition,
    __unstableIsFullySelected
  } = select(store_store);
  return {
    isMultiSelecting: isMultiSelecting(),
    multiSelectedBlockClientIds: getMultiSelectedBlockClientIds(),
    hasMultiSelection: hasMultiSelection(),
    selectedBlockClientId: getSelectedBlockClientId(),
    initialPosition: getSelectedBlocksInitialCaretPosition(),
    isFullSelection: __unstableIsFullySelected()
  };
}

function useMultiSelection() {
  const {
    initialPosition,
    isMultiSelecting,
    multiSelectedBlockClientIds,
    hasMultiSelection,
    selectedBlockClientId,
    isFullSelection
  } = use_select_useSelect(selector, []);
  /**
   * When the component updates, and there is multi selection, we need to
   * select the entire block contents.
   */

  return (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument; // Allow initialPosition to bypass focus behavior. This is useful
    // for the list view or other areas where we don't want to transfer
    // focus to the editor canvas.

    if (initialPosition === undefined || initialPosition === null) {
      return;
    }

    if (!hasMultiSelection || isMultiSelecting) {
      return;
    }

    const {
      length
    } = multiSelectedBlockClientIds;

    if (length < 2) {
      return;
    }

    if (!isFullSelection) {
      return;
    } // Allow cross contentEditable selection by temporarily making
    // all content editable. We can't rely on using the store and
    // React because re-rending happens too slowly. We need to be
    // able to select across instances immediately.


    node.contentEditable = true; // For some browsers, like Safari, it is important that focus
    // happens BEFORE selection removal.

    node.focus();
    defaultView.getSelection().removeAllRanges();
  }, [hasMultiSelection, isMultiSelecting, multiSelectedBlockClientIds, selectedBlockClientId, initialPosition, isFullSelection]);
}
//# sourceMappingURL=use-multi-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-tab-nav.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useTabNav() {
  const container = (0,react.useRef)();
  const focusCaptureBeforeRef = (0,react.useRef)();
  const focusCaptureAfterRef = (0,react.useRef)();
  const lastFocus = (0,react.useRef)();
  const {
    hasMultiSelection,
    getSelectedBlockClientId,
    getBlockCount
  } = use_select_useSelect(store_store);
  const {
    setNavigationMode
  } = use_dispatch(store_store);
  const isNavigationMode = use_select_useSelect(select => select(store_store).isNavigationMode(), []); // Don't allow tabbing to this element in Navigation mode.

  const focusCaptureTabIndex = !isNavigationMode ? '0' : undefined; // Reference that holds the a flag for enabling or disabling
  // capturing on the focus capture elements.

  const noCapture = (0,react.useRef)();

  function onFocusCapture(event) {
    // Do not capture incoming focus if set by us in WritingFlow.
    if (noCapture.current) {
      noCapture.current = null;
    } else if (hasMultiSelection()) {
      container.current.focus();
    } else if (getSelectedBlockClientId()) {
      lastFocus.current.focus();
    } else {
      setNavigationMode(true);
      const isBefore = // eslint-disable-next-line no-bitwise
      event.target.compareDocumentPosition(container.current) & event.target.DOCUMENT_POSITION_FOLLOWING;
      const action = isBefore ? 'findNext' : 'findPrevious';
      dom_build_module/* focus */.XC.tabbable[action](event.target).focus();
    }
  }

  const before = (0,react.createElement)("div", {
    ref: focusCaptureBeforeRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const after = (0,react.createElement)("div", {
    ref: focusCaptureAfterRef,
    tabIndex: focusCaptureTabIndex,
    onFocus: onFocusCapture
  });
  const ref = (0,use_ref_effect/* default */.A)(node => {
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (event.keyCode === keycodes_build_module/* ESCAPE */._f) {
        event.preventDefault();
        setNavigationMode(true);
        return;
      } // In Edit mode, Tab should focus the first tabbable element after
      // the content, which is normally the sidebar (with block controls)
      // and Shift+Tab should focus the first tabbable element before the
      // content, which is normally the block toolbar.
      // Arrow keys can be used, and Tab and arrow keys can be used in
      // Navigation mode (press Esc), to navigate through blocks.


      if (event.keyCode !== keycodes_build_module/* TAB */.wn) {
        return;
      }

      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';

      if (!hasMultiSelection() && !getSelectedBlockClientId()) {
        // Preserve the behaviour of entering navigation mode when
        // tabbing into the content without a block selection.
        // `onFocusCapture` already did this previously, but we need to
        // do it again here because after clearing block selection,
        // focus land on the writing flow container and pressing Tab
        // will no longer send focus through the focus capture element.
        if (event.target === node) setNavigationMode(true);
        return;
      } // Allow tabbing from the block wrapper to a form element,
      // and between form elements rendered in a block,
      // such as inside a placeholder. Form elements are generally
      // meant to be UI rather than part of the content. Ideally
      // these are not rendered in the content and perhaps in the
      // future they can be rendered in an iframe or shadow DOM.


      if ((isFormElement(event.target) || event.target.getAttribute('data-block') === getSelectedBlockClientId()) && isFormElement(dom_build_module/* focus */.XC.tabbable[direction](event.target))) {
        return;
      }

      const next = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef; // Disable focus capturing on the focus capture element, so it
      // doesn't refocus this block and so it allows default behaviour
      // (moving focus to the next tabbable element).

      noCapture.current = true; // Focusing the focus capture element, which is located above and
      // below the editor, should not scroll the page all the way up or
      // down.

      next.current.focus({
        preventScroll: true
      });
    }

    function onFocusOut(event) {
      lastFocus.current = event.target;
      const {
        ownerDocument
      } = node; // If focus disappears due to there being no blocks, move focus to
      // the writing flow wrapper.

      if (!event.relatedTarget && ownerDocument.activeElement === ownerDocument.body && getBlockCount() === 0) {
        node.focus();
      }
    } // When tabbing back to an element in block list, this event handler prevents scrolling if the
    // focus capture divs (before/after) are outside of the viewport. (For example shift+tab back to a paragraph
    // when focus is on a sidebar element. This prevents the scrollable writing area from jumping either to the
    // top or bottom of the document.
    //
    // Note that it isn't possible to disable scrolling in the onFocus event. We need to intercept this
    // earlier in the keypress handler, and call focus( { preventScroll: true } ) instead.
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus#parameters


    function preventScrollOnTab(event) {
      var _event$target;

      if (event.keyCode !== keycodes_build_module/* TAB */.wn) {
        return;
      }

      if (((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.getAttribute('role')) === 'region') {
        return;
      }

      if (container.current === event.target) {
        return;
      }

      const isShift = event.shiftKey;
      const direction = isShift ? 'findPrevious' : 'findNext';
      const target = dom_build_module/* focus */.XC.tabbable[direction](event.target); // Only do something when the next tabbable is a focus capture div (before/after)

      if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
        event.preventDefault();
        target.focus({
          preventScroll: true
        });
      }
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    defaultView.addEventListener('keydown', preventScrollOnTab);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('focusout', onFocusOut);
    return () => {
      defaultView.removeEventListener('keydown', preventScrollOnTab);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('focusout', onFocusOut);
    };
  }, []);
  const mergedRefs = (0,use_merge_refs/* default */.A)([container, ref]);
  return [before, mergedRefs, after];
}
//# sourceMappingURL=use-tab-nav.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/get-range-height.js
/**
 * Gets the height of the range without ignoring zero width rectangles, which
 * some browsers ignore when creating a union.
 *
 * @param {Range} range The range to check.
 * @return {number | undefined} Height of the range or undefined if the range has no client rectangles.
 */
function getRangeHeight(range) {
  const rects = Array.from(range.getClientRects());

  if (!rects.length) {
    return;
  }

  const highestTop = Math.min(...rects.map(_ref => {
    let {
      top
    } = _ref;
    return top;
  }));
  const lowestBottom = Math.max(...rects.map(_ref2 => {
    let {
      bottom
    } = _ref2;
    return bottom;
  }));
  return lowestBottom - highestTop;
}
//# sourceMappingURL=get-range-height.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/get-rectangle-from-range.js
/**
 * Internal dependencies
 */

/**
 * Get the rectangle of a given Range. Returns `null` if no suitable rectangle
 * can be found.
 *
 * @param {Range} range The range.
 *
 * @return {DOMRect?} The rectangle.
 */

function getRectangleFromRange(range) {
  // For uncollapsed ranges, get the rectangle that bounds the contents of the
  // range; this a rectangle enclosing the union of the bounding rectangles
  // for all the elements in the range.
  if (!range.collapsed) {
    const rects = Array.from(range.getClientRects()); // If there's just a single rect, return it.

    if (rects.length === 1) {
      return rects[0];
    } // Ignore tiny selection at the edge of a range.


    const filteredRects = rects.filter(_ref => {
      let {
        width
      } = _ref;
      return width > 1;
    }); // If it's full of tiny selections, return browser default.

    if (filteredRects.length === 0) {
      return range.getBoundingClientRect();
    }

    if (filteredRects.length === 1) {
      return filteredRects[0];
    }

    let {
      top: furthestTop,
      bottom: furthestBottom,
      left: furthestLeft,
      right: furthestRight
    } = filteredRects[0];

    for (const {
      top,
      bottom,
      left,
      right
    } of filteredRects) {
      if (top < furthestTop) furthestTop = top;
      if (bottom > furthestBottom) furthestBottom = bottom;
      if (left < furthestLeft) furthestLeft = left;
      if (right > furthestRight) furthestRight = right;
    }

    return new window.DOMRect(furthestLeft, furthestTop, furthestRight - furthestLeft, furthestBottom - furthestTop);
  }

  const {
    startContainer
  } = range;
  const {
    ownerDocument
  } = startContainer; // Correct invalid "BR" ranges. The cannot contain any children.

  if (startContainer.nodeName === 'BR') {
    const {
      parentNode
    } = startContainer;
    (0,assert_is_defined/* assertIsDefined */.e)(parentNode, 'parentNode');
    const index =
    /** @type {Node[]} */
    Array.from(parentNode.childNodes).indexOf(startContainer);
    (0,assert_is_defined/* assertIsDefined */.e)(ownerDocument, 'ownerDocument');
    range = ownerDocument.createRange();
    range.setStart(parentNode, index);
    range.setEnd(parentNode, index);
  }

  const rects = range.getClientRects(); // If we have multiple rectangles for a collapsed range, there's no way to
  // know which it is, so don't return anything.

  if (rects.length > 1) {
    return null;
  }

  let rect = rects[0]; // If the collapsed range starts (and therefore ends) at an element node,
  // `getClientRects` can be empty in some browsers. This can be resolved
  // by adding a temporary text node with zero-width space to the range.
  //
  // See: https://stackoverflow.com/a/6847328/995445

  if (!rect) {
    (0,assert_is_defined/* assertIsDefined */.e)(ownerDocument, 'ownerDocument');
    const padNode = ownerDocument.createTextNode('\u200b'); // Do not modify the live range.

    range = range.cloneRange();
    range.insertNode(padNode);
    rect = range.getClientRects()[0];
    (0,assert_is_defined/* assertIsDefined */.e)(padNode.parentNode, 'padNode.parentNode');
    padNode.parentNode.removeChild(padNode);
  }

  return rect;
}
//# sourceMappingURL=get-rectangle-from-range.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-selection-forward.js
/**
 * Internal dependencies
 */

/**
 * Returns true if the given selection object is in the forward direction, or
 * false otherwise.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
 *
 * @param {Selection} selection Selection object to check.
 *
 * @return {boolean} Whether the selection is forward.
 */

function isSelectionForward(selection) {
  const {
    anchorNode,
    focusNode,
    anchorOffset,
    focusOffset
  } = selection;
  (0,assert_is_defined/* assertIsDefined */.e)(anchorNode, 'anchorNode');
  (0,assert_is_defined/* assertIsDefined */.e)(focusNode, 'focusNode');
  const position = anchorNode.compareDocumentPosition(focusNode); // Disable reason: `Node#compareDocumentPosition` returns a bitmask value,
  // so bitwise operators are intended.

  /* eslint-disable no-bitwise */
  // Compare whether anchor node precedes focus node. If focus node (where
  // end of selection occurs) is after the anchor node, it is forward.

  if (position & anchorNode.DOCUMENT_POSITION_PRECEDING) {
    return false;
  }

  if (position & anchorNode.DOCUMENT_POSITION_FOLLOWING) {
    return true;
  }
  /* eslint-enable no-bitwise */
  // `compareDocumentPosition` returns 0 when passed the same node, in which
  // case compare offsets.


  if (position === 0) {
    return anchorOffset <= focusOffset;
  } // This should never be reached, but return true as default case.


  return true;
}
//# sourceMappingURL=is-selection-forward.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-edge.js
/**
 * Internal dependencies
 */







/**
 * Check whether the selection is at the edge of the container. Checks for
 * horizontal position by default. Set `onlyVertical` to true to check only
 * vertically.
 *
 * @param {Element} container            Focusable element.
 * @param {boolean} isReverse            Set to true to check left, false to check right.
 * @param {boolean} [onlyVertical=false] Set to true to check only vertical position.
 *
 * @return {boolean} True if at the edge, false if not.
 */

function isEdge(container, isReverse) {
  let onlyVertical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (isInputOrTextArea(container) && typeof container.selectionStart === 'number') {
    if (container.selectionStart !== container.selectionEnd) {
      return false;
    }

    if (isReverse) {
      return container.selectionStart === 0;
    }

    return container.value.length === container.selectionStart;
  }

  if (!
  /** @type {HTMLElement} */
  container.isContentEditable) {
    return true;
  }

  const {
    ownerDocument
  } = container;
  const {
    defaultView
  } = ownerDocument;
  (0,assert_is_defined/* assertIsDefined */.e)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();

  if (!selection || !selection.rangeCount) {
    return false;
  }

  const range = selection.getRangeAt(0);
  const collapsedRange = range.cloneRange();
  const isForward = isSelectionForward(selection);
  const isCollapsed = selection.isCollapsed; // Collapse in direction of selection.

  if (!isCollapsed) {
    collapsedRange.collapse(!isForward);
  }

  const collapsedRangeRect = getRectangleFromRange(collapsedRange);
  const rangeRect = getRectangleFromRange(range);

  if (!collapsedRangeRect || !rangeRect) {
    return false;
  } // Only consider the multiline selection at the edge if the direction is
  // towards the edge. The selection is multiline if it is taller than the
  // collapsed  selection.


  const rangeHeight = getRangeHeight(range);

  if (!isCollapsed && rangeHeight && rangeHeight > collapsedRangeRect.height && isForward === isReverse) {
    return false;
  } // In the case of RTL scripts, the horizontal edge is at the opposite side.


  const isReverseDir = isRTL(container) ? !isReverse : isReverse;
  const containerRect = container.getBoundingClientRect(); // To check if a selection is at the edge, we insert a test selection at the
  // edge of the container and check if the selections have the same vertical
  // or horizontal position. If they do, the selection is at the edge.
  // This method proves to be better than a DOM-based calculation for the
  // horizontal edge, since it ignores empty textnodes and a trailing line
  // break element. In other words, we need to check visual positioning, not
  // DOM positioning.
  // It also proves better than using the computed style for the vertical
  // edge, because we cannot know the padding and line height reliably in
  // pixels. `getComputedStyle` may return a value with different units.

  const x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;
  const y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;
  const testRange = hiddenCaretRangeFromPoint(ownerDocument, x, y,
  /** @type {HTMLElement} */
  container);

  if (!testRange) {
    return false;
  }

  const testRect = getRectangleFromRange(testRange);

  if (!testRect) {
    return false;
  }

  const verticalSide = isReverse ? 'top' : 'bottom';
  const horizontalSide = isReverseDir ? 'left' : 'right';
  const verticalDiff = testRect[verticalSide] - rangeRect[verticalSide];
  const horizontalDiff = testRect[horizontalSide] - collapsedRangeRect[horizontalSide]; // Allow the position to be 1px off.

  const hasVerticalDiff = Math.abs(verticalDiff) <= 1;
  const hasHorizontalDiff = Math.abs(horizontalDiff) <= 1;
  return onlyVertical ? hasVerticalDiff : hasVerticalDiff && hasHorizontalDiff;
}
//# sourceMappingURL=is-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-vertical-edge.js
/**
 * Internal dependencies
 */

/**
 * Check whether the selection is vertically at the edge of the container.
 *
 * @param {Element} container Focusable element.
 * @param {boolean} isReverse Set to true to check top, false for bottom.
 *
 * @return {boolean} True if at the vertical edge, false if not.
 */

function isVerticalEdge(container, isReverse) {
  return isEdge(container, isReverse, true);
}
//# sourceMappingURL=is-vertical-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-horizontal-edge.js
/**
 * Internal dependencies
 */

/**
 * Check whether the selection is horizontally at the edge of the container.
 *
 * @param {Element} container Focusable element.
 * @param {boolean} isReverse Set to true to check left, false for right.
 *
 * @return {boolean} True if at the horizontal edge, false if not.
 */

function isHorizontalEdge(container, isReverse) {
  return isEdge(container, isReverse);
}
//# sourceMappingURL=is-horizontal-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/compute-caret-rect.js
/**
 * Internal dependencies
 */


/**
 * Get the rectangle for the selection in a container.
 *
 * @param {Window} win The window of the selection.
 *
 * @return {DOMRect | null} The rectangle.
 */

function computeCaretRect(win) {
  const selection = win.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  const range = selection.rangeCount ? selection.getRangeAt(0) : null;

  if (!range) {
    return null;
  }

  return getRectangleFromRange(range);
}
//# sourceMappingURL=compute-caret-rect.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/place-caret-at-vertical-edge.js
/**
 * Internal dependencies
 */

/**
 * Places the caret at the top or bottom of a given element.
 *
 * @param {HTMLElement} container Focusable element.
 * @param {boolean}     isReverse True for bottom, false for top.
 * @param {DOMRect}     [rect]    The rectangle to position the caret with.
 */

function placeCaretAtVerticalEdge(container, isReverse, rect) {
  return placeCaretAtEdge(container, isReverse, rect === null || rect === void 0 ? void 0 : rect.left);
}
//# sourceMappingURL=place-caret-at-vertical-edge.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-arrow-nav.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * Returns true if the element should consider edge navigation upon a keyboard
 * event of the given directional key code, or false otherwise.
 *
 * @param {Element} element     HTML element to test.
 * @param {number}  keyCode     KeyboardEvent keyCode to test.
 * @param {boolean} hasModifier Whether a modifier is pressed.
 *
 * @return {boolean} Whether element should consider edge navigation.
 */

function isNavigationCandidate(element, keyCode, hasModifier) {
  const isVertical = keyCode === keycodes_build_module.UP || keyCode === keycodes_build_module/* DOWN */.PX; // Currently, all elements support unmodified vertical navigation.

  if (isVertical && !hasModifier) {
    return true;
  }

  const {
    tagName
  } = element; // Native inputs should not navigate horizontally, unless they are simple types that don't need left/right arrow keys.

  if (tagName === 'INPUT') {
    const simpleInputTypes = ['button', 'checkbox', 'color', 'file', 'image', 'radio', 'reset', 'submit'];
    return simpleInputTypes.includes(element.getAttribute('type'));
  } // Native textareas should not navigate horizontally.


  return tagName !== 'TEXTAREA';
}
/**
 * Returns the optimal tab target from the given focused element in the desired
 * direction. A preference is made toward text fields, falling back to the block
 * focus stop if no other candidates exist for the block.
 *
 * @param {Element} target           Currently focused text field.
 * @param {boolean} isReverse        True if considering as the first field.
 * @param {Element} containerElement Element containing all blocks.
 * @param {boolean} onlyVertical     Whether to only consider tabbable elements
 *                                   that are visually above or under the
 *                                   target.
 *
 * @return {?Element} Optimal tab target, if one exists.
 */

function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
  // Since the current focus target is not guaranteed to be a text field, find
  // all focusables. Tabbability is considered later.
  let focusableNodes = dom_build_module/* focus */.XC.focusable.find(containerElement);

  if (isReverse) {
    focusableNodes.reverse();
  } // Consider as candidates those focusables after the current target. It's
  // assumed this can only be reached if the target is focusable (on its
  // keydown event), so no need to verify it exists in the set.


  focusableNodes = focusableNodes.slice(focusableNodes.indexOf(target) + 1);
  let targetRect;

  if (onlyVertical) {
    targetRect = target.getBoundingClientRect();
  }

  function isTabCandidate(node) {
    // Not a candidate if the node is not tabbable.
    if (!dom_build_module/* focus */.XC.tabbable.isTabbableIndex(node)) {
      return false;
    } // Skip focusable elements such as links within content editable nodes.


    if (node.isContentEditable && node.contentEditable !== 'true') {
      return false;
    }

    if (onlyVertical) {
      const nodeRect = node.getBoundingClientRect();

      if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
        return false;
      }
    }

    return true;
  }

  return focusableNodes.find(isTabCandidate);
}
function useArrowNav() {
  const {
    getMultiSelectedBlocksStartClientId,
    getMultiSelectedBlocksEndClientId,
    getSettings,
    hasMultiSelection,
    __unstableIsFullySelected
  } = use_select_useSelect(store_store);
  const {
    selectBlock
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    // Here a DOMRect is stored while moving the caret vertically so
    // vertical position of the start position can be restored. This is to
    // recreate browser behaviour across blocks.
    let verticalRect;

    function onMouseDown() {
      verticalRect = null;
    }

    function isClosestTabbableABlock(target, isReverse) {
      const closestTabbable = getClosestTabbable(target, isReverse, node);
      return closestTabbable && getBlockClientId(closestTabbable);
    }

    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;
      const isUp = keyCode === keycodes_build_module.UP;
      const isDown = keyCode === keycodes_build_module/* DOWN */.PX;
      const isLeft = keyCode === keycodes_build_module/* LEFT */.M3;
      const isRight = keyCode === keycodes_build_module/* RIGHT */.NS;
      const isReverse = isUp || isLeft;
      const isHorizontal = isLeft || isRight;
      const isVertical = isUp || isDown;
      const isNav = isHorizontal || isVertical;
      const isShift = event.shiftKey;
      const hasModifier = isShift || event.ctrlKey || event.altKey || event.metaKey;
      const isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument; // If there is a multi-selection, the arrow keys should collapse the
      // selection to the start or end of the selection.

      if (hasMultiSelection()) {
        // Only handle if we have a full selection (not a native partial
        // selection).
        if (!__unstableIsFullySelected()) {
          return;
        }

        if (event.defaultPrevented) {
          return;
        }

        if (!isNav) {
          return;
        }

        if (isShift) {
          return;
        }

        event.preventDefault();

        if (isReverse) {
          selectBlock(getMultiSelectedBlocksStartClientId());
        } else {
          selectBlock(getMultiSelectedBlocksEndClientId(), -1);
        }

        return;
      } // When presing any key other than up or down, the initial vertical
      // position must ALWAYS be reset. The vertical position is saved so
      // it can be restored as well as possible on sebsequent vertical
      // arrow key presses. It may not always be possible to restore the
      // exact same position (such as at an empty line), so it wouldn't be
      // good to compute the position right before any vertical arrow key
      // press.


      if (!isVertical) {
        verticalRect = null;
      } else if (!verticalRect) {
        verticalRect = computeCaretRect(defaultView);
      } // Abort if navigation has already been handled (e.g. RichText
      // inline boundaries).


      if (event.defaultPrevented) {
        return;
      }

      if (!isNav) {
        return;
      } // Abort if our current target is not a candidate for navigation
      // (e.g. preserve native input behaviors).


      if (!isNavigationCandidate(target, keyCode, hasModifier)) {
        return;
      } // In the case of RTL scripts, right means previous and left means
      // next, which is the exact reverse of LTR.


      const isReverseDir = isRTL(target) ? !isReverse : isReverse;
      const {
        keepCaretInsideBlock
      } = getSettings();

      if (isShift) {
        if (isClosestTabbableABlock(target, isReverse) && isNavEdge(target, isReverse)) {
          node.contentEditable = true; // Firefox doesn't automatically move focus.

          node.focus();
        }
      } else if (isVertical && isVerticalEdge(target, isReverse) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverse, node, true);

        if (closestTabbable) {
          placeCaretAtVerticalEdge(closestTabbable, isReverse, verticalRect);
          event.preventDefault();
        }
      } else if (isHorizontal && defaultView.getSelection().isCollapsed && isHorizontalEdge(target, isReverseDir) && !keepCaretInsideBlock) {
        const closestTabbable = getClosestTabbable(target, isReverseDir, node);
        placeCaretAtHorizontalEdge(closestTabbable, isReverse);
        event.preventDefault();
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}
//# sourceMappingURL=use-arrow-nav.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-entirely-selected.js
/**
 * Internal dependencies
 */


/**
 * Check whether the contents of the element have been entirely selected.
 * Returns true if there is no possibility of selection.
 *
 * @param {HTMLElement} element The element to check.
 *
 * @return {boolean} True if entirely selected, false if not.
 */

function isEntirelySelected(element) {
  if (isInputOrTextArea(element)) {
    return element.selectionStart === 0 && element.value.length === element.selectionEnd;
  }

  if (!element.isContentEditable) {
    return true;
  }

  const {
    ownerDocument
  } = element;
  const {
    defaultView
  } = ownerDocument;
  (0,assert_is_defined/* assertIsDefined */.e)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();
  (0,assert_is_defined/* assertIsDefined */.e)(selection, 'selection');
  const range = selection.rangeCount ? selection.getRangeAt(0) : null;

  if (!range) {
    return true;
  }

  const {
    startContainer,
    endContainer,
    startOffset,
    endOffset
  } = range;

  if (startContainer === element && endContainer === element && startOffset === 0 && endOffset === element.childNodes.length) {
    return true;
  }

  const lastChild = element.lastChild;
  (0,assert_is_defined/* assertIsDefined */.e)(lastChild, 'lastChild');
  const endContainerContentLength = endContainer.nodeType === endContainer.TEXT_NODE ?
  /** @type {Text} */
  endContainer.data.length : endContainer.childNodes.length;
  return isDeepChild(startContainer, element, 'firstChild') && isDeepChild(endContainer, element, 'lastChild') && startOffset === 0 && endOffset === endContainerContentLength;
}
/**
 * Check whether the contents of the element have been entirely selected.
 * Returns true if there is no possibility of selection.
 *
 * @param {HTMLElement|Node}         query     The element to check.
 * @param {HTMLElement}              container The container that we suspect "query" may be a first or last child of.
 * @param {"firstChild"|"lastChild"} propName  "firstChild" or "lastChild"
 *
 * @return {boolean} True if query is a deep first/last child of container, false otherwise.
 */

function isDeepChild(query, container, propName) {
  /** @type {HTMLElement | ChildNode | null} */
  let candidate = container;

  do {
    if (query === candidate) {
      return true;
    }

    candidate = candidate[propName];
  } while (candidate);

  return false;
}
//# sourceMappingURL=is-entirely-selected.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/reducer.js
/**
 * Reducer returning the registered shortcuts
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */
function reducer_reducer() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'REGISTER_SHORTCUT':
      return { ...state,
        [action.name]: {
          category: action.category,
          keyCombination: action.keyCombination,
          aliases: action.aliases,
          description: action.description
        }
      };

    case 'UNREGISTER_SHORTCUT':
      const {
        [action.name]: actionName,
        ...remainingState
      } = state;
      return remainingState;
  }

  return state;
}

/* harmony default export */ const build_module_store_reducer = (reducer_reducer);
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
/** @typedef {import('@wordpress/keycodes').WPKeycodeModifier} WPKeycodeModifier */

/**
 * Keyboard key combination.
 *
 * @typedef {Object} WPShortcutKeyCombination
 *
 * @property {string}                      character Character.
 * @property {WPKeycodeModifier|undefined} modifier  Modifier.
 */

/**
 * Configuration of a registered keyboard shortcut.
 *
 * @typedef {Object} WPShortcutConfig
 *
 * @property {string}                     name           Shortcut name.
 * @property {string}                     category       Shortcut category.
 * @property {string}                     description    Shortcut description.
 * @property {WPShortcutKeyCombination}   keyCombination Shortcut key combination.
 * @property {WPShortcutKeyCombination[]} [aliases]      Shortcut aliases.
 */

/**
 * Returns an action object used to register a new keyboard shortcut.
 *
 * @param {WPShortcutConfig} config Shortcut config.
 *
 * @return {Object} action.
 */
function registerShortcut(_ref) {
  let {
    name,
    category,
    description,
    keyCombination,
    aliases
  } = _ref;
  return {
    type: 'REGISTER_SHORTCUT',
    name,
    category,
    keyCombination,
    aliases,
    description
  };
}
/**
 * Returns an action object used to unregister a keyboard shortcut.
 *
 * @param {string} name Shortcut name.
 *
 * @return {Object} action.
 */

function unregisterShortcut(name) {
  return {
    type: 'UNREGISTER_SHORTCUT',
    name
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/** @typedef {import('./actions').WPShortcutKeyCombination} WPShortcutKeyCombination */

/** @typedef {import('@wordpress/keycodes').WPKeycodeHandlerByModifier} WPKeycodeHandlerByModifier */

/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array<any>}
 */

const selectors_EMPTY_ARRAY = [];
/**
 * Shortcut formatting methods.
 *
 * @property {WPKeycodeHandlerByModifier} display     Display formatting.
 * @property {WPKeycodeHandlerByModifier} rawShortcut Raw shortcut formatting.
 * @property {WPKeycodeHandlerByModifier} ariaLabel   ARIA label formatting.
 */

const FORMATTING_METHODS = {
  display: displayShortcut,
  raw: rawShortcut,
  ariaLabel: shortcutAriaLabel
};
/**
 * Returns a string representing the key combination.
 *
 * @param {?WPShortcutKeyCombination} shortcut       Key combination.
 * @param {keyof FORMATTING_METHODS}  representation Type of representation
 *                                                   (display, raw, ariaLabel).
 *
 * @return {string?} Shortcut representation.
 */

function getKeyCombinationRepresentation(shortcut, representation) {
  if (!shortcut) {
    return null;
  }

  return shortcut.modifier ? FORMATTING_METHODS[representation][shortcut.modifier](shortcut.character) : shortcut.character;
}
/**
 * Returns the main key combination for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {WPShortcutKeyCombination?} Key combination.
 */


function getShortcutKeyCombination(state, name) {
  return state[name] ? state[name].keyCombination : null;
}
/**
 * Returns a string representing the main key combination for a given shortcut name.
 *
 * @param {Object}                   state          Global state.
 * @param {string}                   name           Shortcut name.
 * @param {keyof FORMATTING_METHODS} representation Type of representation
 *                                                  (display, raw, ariaLabel).
 *
 * @return {string?} Shortcut representation.
 */

function getShortcutRepresentation(state, name) {
  let representation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'display';
  const shortcut = getShortcutKeyCombination(state, name);
  return getKeyCombinationRepresentation(shortcut, representation);
}
/**
 * Returns the shortcut description given its name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {string?} Shortcut description.
 */

function getShortcutDescription(state, name) {
  return state[name] ? state[name].description : null;
}
/**
 * Returns the aliases for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {WPShortcutKeyCombination[]} Key combinations.
 */

function getShortcutAliases(state, name) {
  return state[name] && state[name].aliases ? state[name].aliases : selectors_EMPTY_ARRAY;
}
const getAllShortcutKeyCombinations = (0,rememo/* default */.A)((state, name) => {
  return [getShortcutKeyCombination(state, name), ...getShortcutAliases(state, name)].filter(Boolean);
}, (state, name) => [state[name]]);
/**
 * Returns the raw representation of all the keyboard combinations of a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {string[]} Shortcuts.
 */

const getAllShortcutRawKeyCombinations = (0,rememo/* default */.A)((state, name) => {
  return getAllShortcutKeyCombinations(state, name).map(combination => getKeyCombinationRepresentation(combination, 'raw'));
}, (state, name) => [state[name]]);
/**
 * Returns the shortcut names list for a given category name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Category name.
 *
 * @return {string[]} Shortcut names.
 */

const getCategoryShortcuts = (0,rememo/* default */.A)((state, categoryName) => {
  return Object.entries(state).filter(_ref => {
    let [, shortcut] = _ref;
    return shortcut.category === categoryName;
  }).map(_ref2 => {
    let [name] = _ref2;
    return name;
  });
}, state => [state]);
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const store_STORE_NAME = 'core/keyboard-shortcuts';
/**
 * Store definition for the keyboard shortcuts namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const build_module_store_store = (0,redux_store/* default */.A)(store_STORE_NAME, {
  reducer: build_module_store_reducer,
  actions: build_module_store_actions_namespaceObject,
  selectors: build_module_store_selectors_namespaceObject
});
(0,data_build_module/* register */.kz)(build_module_store_store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut-event-match.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns a function to check if a keyboard event matches a shortcut name.
 *
 * @return {Function} A function to check if a keyboard event matches a
 *                    predefined shortcut combination.
 */

function useShortcutEventMatch() {
  const {
    getAllShortcutKeyCombinations
  } = use_select_useSelect(build_module_store_store);
  /**
   * A function to check if a keyboard event matches a predefined shortcut
   * combination.
   *
   * @param {string}        name  Shortcut name.
   * @param {KeyboardEvent} event Event to check.
   *
   * @return {boolean} True if the event matches any shortcuts, false if not.
   */

  function isMatch(name, event) {
    return getAllShortcutKeyCombinations(name).some(_ref => {
      let {
        modifier,
        character
      } = _ref;
      return isKeyboardEvent[modifier](event, character);
    });
  }

  return isMatch;
}
//# sourceMappingURL=use-shortcut-event-match.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/context.js
/**
 * WordPress dependencies
 */

const context_context = (0,react.createContext)();
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



/**
 * Attach a keyboard shortcut handler.
 *
 * @param {string}   name               Shortcut name.
 * @param {Function} callback           Shortcut callback.
 * @param {Object}   options            Shortcut options.
 * @param {boolean}  options.isDisabled Whether to disable to shortut.
 */

function useShortcut(name, callback) {
  let {
    isDisabled
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const shortcuts = (0,react.useContext)(context_context);
  const isMatch = useShortcutEventMatch();
  const callbackRef = (0,react.useRef)();
  callbackRef.current = callback;
  (0,react.useEffect)(() => {
    if (isDisabled) {
      return;
    }

    function _callback(event) {
      if (isMatch(name, event)) {
        callbackRef.current(event);
      }
    }

    shortcuts.current.add(_callback);
    return () => {
      shortcuts.current.delete(_callback);
    };
  }, [name, isDisabled]);
}
//# sourceMappingURL=use-shortcut.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/components/shortcut-provider.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const {
  Provider: shortcut_provider_Provider
} = context_context;
/**
 * Handles callbacks added to context by `useShortcut`.
 *
 * @param {Object} props Props to pass to `div`.
 *
 * @return {import('@wordpress/element').WPElement} Component.
 */

function ShortcutProvider(props) {
  const keyboardShortcuts = useRef(new Set());

  function onKeyDown(event) {
    if (props.onKeyDown) props.onKeyDown(event);

    for (const keyboardShortcut of keyboardShortcuts.current) {
      keyboardShortcut(event);
    }
  }
  /* eslint-disable jsx-a11y/no-static-element-interactions */


  return createElement(shortcut_provider_Provider, {
    value: keyboardShortcuts
  }, createElement("div", _extends({}, props, {
    onKeyDown: onKeyDown
  })));
  /* eslint-enable jsx-a11y/no-static-element-interactions */
}
//# sourceMappingURL=shortcut-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.20.0_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-select-all.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


function useSelectAll() {
  const {
    getBlockOrder,
    getSelectedBlockClientIds,
    getBlockRootClientId
  } = use_select_useSelect(store_store);
  const {
    multiSelect,
    selectBlock
  } = use_dispatch(store_store);
  const isMatch = useShortcutEventMatch();
  return (0,use_ref_effect/* default */.A)(node => {
    function onKeyDown(event) {
      if (!isMatch('core/block-editor/select-all', event)) {
        return;
      }

      const selectedClientIds = getSelectedBlockClientIds();

      if (selectedClientIds.length < 2 && !isEntirelySelected(event.target)) {
        return;
      }

      const [firstSelectedClientId] = selectedClientIds;
      const rootClientId = getBlockRootClientId(firstSelectedClientId);
      let blockClientIds = getBlockOrder(rootClientId); // If we have selected all sibling nested blocks, try selecting up a
      // level. See: https://github.com/WordPress/gutenberg/pull/31859/

      if (selectedClientIds.length === blockClientIds.length) {
        blockClientIds = getBlockOrder(getBlockRootClientId(rootClientId));
      }

      const firstClientId = (0,lodash.first)(blockClientIds);
      const lastClientId = (0,lodash.last)(blockClientIds);

      if (firstClientId === lastClientId) {
        selectBlock(firstClientId);
        return;
      }

      multiSelect(firstClientId, lastClientId);
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}
//# sourceMappingURL=use-select-all.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-drag-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Sets the `contenteditable` wrapper element to `value`.
 *
 * @param {HTMLElement} node  Block element.
 * @param {boolean}     value `contentEditable` value (true or false)
 */

function setContentEditableWrapper(node, value) {
  node.contentEditable = value; // Firefox doesn't automatically move focus.

  if (value) node.focus();
}
/**
 * Sets a multi-selection based on the native selection across blocks.
 */


function useDragSelection() {
  const {
    startMultiSelect,
    stopMultiSelect
  } = use_dispatch(store_store);
  const {
    isSelectionEnabled,
    hasMultiSelection,
    isDraggingBlocks
  } = use_select_useSelect(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    let anchorElement;
    let rafId;

    function onMouseUp() {
      stopMultiSelect(); // Equivalent to attaching the listener once.

      defaultView.removeEventListener('mouseup', onMouseUp); // The browser selection won't have updated yet at this point,
      // so wait until the next animation frame to get the browser
      // selection.

      rafId = defaultView.requestAnimationFrame(() => {
        if (hasMultiSelection()) {
          return;
        } // If the selection is complete (on mouse up), and no
        // multiple blocks have been selected, set focus back to the
        // anchor element. if the anchor element contains the
        // selection. Additionally, the contentEditable wrapper can
        // now be disabled again.


        setContentEditableWrapper(node, false);
        const selection = defaultView.getSelection();

        if (selection.rangeCount) {
          const {
            commonAncestorContainer
          } = selection.getRangeAt(0);

          if (anchorElement.contains(commonAncestorContainer)) {
            anchorElement.focus();
          }
        }
      });
    }

    function onMouseLeave(_ref) {
      let {
        buttons,
        target
      } = _ref;

      // Avoid triggering a multi-selection if the user is already
      // dragging blocks.
      if (isDraggingBlocks()) {
        return;
      } // The primary button must be pressed to initiate selection.
      // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons


      if (buttons !== 1) {
        return;
      } // Check the attribute, not the contentEditable attribute. All
      // child elements of the content editable wrapper are editable
      // and return true for this property. We only want to start
      // multi selecting when the mouse leaves the wrapper.


      if (!target.getAttribute('contenteditable')) {
        return;
      }

      if (!isSelectionEnabled()) {
        return;
      }

      anchorElement = ownerDocument.activeElement;
      startMultiSelect(); // `onSelectionStart` is called after `mousedown` and
      // `mouseleave` (from a block). The selection ends when
      // `mouseup` happens anywhere in the window.

      defaultView.addEventListener('mouseup', onMouseUp); // Allow cross contentEditable selection by temporarily making
      // all content editable. We can't rely on using the store and
      // React because re-rending happens too slowly. We need to be
      // able to select across instances immediately.

      setContentEditableWrapper(node, true);
    }

    node.addEventListener('mouseout', onMouseLeave);
    return () => {
      node.removeEventListener('mouseout', onMouseLeave);
      defaultView.removeEventListener('mouseup', onMouseUp);
      defaultView.cancelAnimationFrame(rafId);
    };
  }, [startMultiSelect, stopMultiSelect, isSelectionEnabled, hasMultiSelection]);
}
//# sourceMappingURL=use-drag-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-selection-observer.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Extract the selection start node from the selection. When the anchor node is
 * not a text node, the selection offset is the index of a child node.
 *
 * @param {Selection} selection The selection.
 *
 * @return {Element} The selection start node.
 */

function extractSelectionStartNode(selection) {
  const {
    anchorNode,
    anchorOffset
  } = selection;

  if (anchorNode.nodeType === anchorNode.TEXT_NODE) {
    return anchorNode;
  }

  if (anchorOffset === 0) {
    return anchorNode;
  }

  return anchorNode.childNodes[anchorOffset - 1];
}
/**
 * Extract the selection end node from the selection. When the focus node is not
 * a text node, the selection offset is the index of a child node. The selection
 * reaches up to but excluding that child node.
 *
 * @param {Selection} selection The selection.
 *
 * @return {Element} The selection start node.
 */


function extractSelectionEndNode(selection) {
  const {
    focusNode,
    focusOffset
  } = selection;

  if (focusNode.nodeType === focusNode.TEXT_NODE) {
    return focusNode;
  }

  if (focusOffset === focusNode.childNodes.length) {
    return focusNode;
  }

  return focusNode.childNodes[focusOffset];
}

function findDepth(a, b) {
  let depth = 0;

  while (a[depth] === b[depth]) {
    depth++;
  }

  return depth;
}
/**
 * Sets the `contenteditable` wrapper element to `value`.
 *
 * @param {HTMLElement} node  Block element.
 * @param {boolean}     value `contentEditable` value (true or false)
 */


function use_selection_observer_setContentEditableWrapper(node, value) {
  node.contentEditable = value; // Firefox doesn't automatically move focus.

  if (value) node.focus();
}
/**
 * Sets a multi-selection based on the native selection across blocks.
 */


function useSelectionObserver() {
  const {
    multiSelect,
    selectBlock,
    selectionChange
  } = use_dispatch(store_store);
  const {
    getBlockParents,
    getBlockSelectionStart
  } = use_select_useSelect(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;

    function onSelectionChange(event) {
      const selection = defaultView.getSelection();

      if (!selection.rangeCount) {
        return;
      } // If selection is collapsed and we haven't used `shift+click`,
      // end multi selection and disable the contentEditable wrapper.
      // We have to check about `shift+click` case because elements
      // that don't support text selection might be involved, and we might
      // update the clientIds to multi-select blocks.
      // For now we check if the event is a `mouse` event.


      const isClickShift = event.shiftKey && event.type === 'mouseup';

      if (selection.isCollapsed && !isClickShift) {
        use_selection_observer_setContentEditableWrapper(node, false);
        return;
      }

      let startClientId = getBlockClientId(extractSelectionStartNode(selection));
      let endClientId = getBlockClientId(extractSelectionEndNode(selection)); // If the selection has changed and we had pressed `shift+click`,
      // we need to check if in an element that doesn't support
      // text selection has been clicked.

      if (isClickShift) {
        const selectedClientId = getBlockSelectionStart();
        const clickedClientId = getBlockClientId(event.target); // `endClientId` is not defined if we end the selection by clicking a non-selectable block.
        // We need to check if there was already a selection with a non-selectable focusNode.

        const focusNodeIsNonSelectable = clickedClientId !== endClientId;

        if (startClientId === endClientId && selection.isCollapsed || !endClientId || focusNodeIsNonSelectable) {
          endClientId = clickedClientId;
        } // Handle the case when we have a non-selectable block
        // selected and click another one.


        if (startClientId !== selectedClientId) {
          startClientId = selectedClientId;
        }
      } // If the selection did not involve a block, return.


      if (startClientId === undefined && endClientId === undefined) {
        use_selection_observer_setContentEditableWrapper(node, false);
        return;
      }

      const isSingularSelection = startClientId === endClientId;

      if (isSingularSelection) {
        selectBlock(startClientId);
      } else {
        const startPath = [...getBlockParents(startClientId), startClientId];
        const endPath = [...getBlockParents(endClientId), endClientId];
        const depth = findDepth(startPath, endPath);
        multiSelect(startPath[depth], endPath[depth]);
      }
    }

    function addListeners() {
      ownerDocument.addEventListener('selectionchange', onSelectionChange);
      defaultView.addEventListener('mouseup', onSelectionChange);
    }

    function removeListeners() {
      ownerDocument.removeEventListener('selectionchange', onSelectionChange);
      defaultView.removeEventListener('mouseup', onSelectionChange);
    }

    function resetListeners() {
      removeListeners();
      addListeners();
    }

    addListeners(); // We must allow rich text to set selection first. This ensures that
    // our `selectionchange` listener is always reset to be called after
    // the rich text one.

    node.addEventListener('focusin', resetListeners);
    return () => {
      removeListeners();
      node.removeEventListener('focusin', resetListeners);
    };
  }, [multiSelect, selectBlock, selectionChange, getBlockParents]);
}
//# sourceMappingURL=use-selection-observer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-click-selection.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function useClickSelection() {
  const {
    selectBlock
  } = use_dispatch(store_store);
  const {
    isSelectionEnabled,
    getBlockSelectionStart,
    hasMultiSelection
  } = use_select_useSelect(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onMouseDown(event) {
      // The main button.
      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
      if (!isSelectionEnabled() || event.button !== 0) {
        return;
      }

      const startClientId = getBlockSelectionStart();
      const clickedClientId = getBlockClientId(event.target);

      if (event.shiftKey) {
        if (startClientId !== clickedClientId) {
          node.contentEditable = true; // Firefox doesn't automatically move focus.

          node.focus();
        }
      } else if (hasMultiSelection()) {
        // Allow user to escape out of a multi-selection to a
        // singular selection of a block via click. This is handled
        // here since focus handling excludes blocks when there is
        // multiselection, as focus can be incurred by starting a
        // multiselection (focus moved to first block's multi-
        // controls).
        selectBlock(clickedClientId);
      }
    }

    node.addEventListener('mousedown', onMouseDown);
    return () => {
      node.removeEventListener('mousedown', onMouseDown);
    };
  }, [selectBlock, isSelectionEnabled, getBlockSelectionStart, hasMultiSelection]);
}
//# sourceMappingURL=use-click-selection.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-input.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Handles input for selections across blocks.
 */

function useInput() {
  const {
    __unstableIsFullySelected,
    getSelectedBlockClientIds,
    __unstableIsSelectionMergeable,
    hasMultiSelection
  } = use_select_useSelect(store_store);
  const {
    replaceBlocks,
    __unstableSplitSelection,
    removeBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    function onBeforeInput(event) {
      var _event$inputType;

      if (!hasMultiSelection()) {
        return;
      } // Prevent the browser to format something when we have multiselection.


      if ((_event$inputType = event.inputType) !== null && _event$inputType !== void 0 && _event$inputType.startsWith('format')) {
        event.preventDefault();
      }
    }

    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }

      if (!hasMultiSelection()) {
        return;
      }

      if (event.keyCode === keycodes_build_module/* ENTER */.Fm) {
        node.contentEditable = false;
        event.preventDefault();

        if (__unstableIsFullySelected()) {
          replaceBlocks(getSelectedBlockClientIds(), (0,build_module/* createBlock */.Wv)((0,build_module/* getDefaultBlockName */.K$)()));
        } else {
          __unstableSplitSelection();
        }
      } else if (event.keyCode === keycodes_build_module/* BACKSPACE */.G_ || event.keyCode === keycodes_build_module/* DELETE */.SJ) {
        node.contentEditable = false;
        event.preventDefault();

        if (__unstableIsFullySelected()) {
          removeBlocks(getSelectedBlockClientIds());
        } else if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === keycodes_build_module/* DELETE */.SJ);
        } else {
          __unstableExpandSelection();
        }
      } else if ( // If key.length is longer than 1, it's a control key that doesn't
      // input anything.
      event.key.length === 1 && !(event.metaKey || event.ctrlKey)) {
        node.contentEditable = false;

        if (__unstableIsSelectionMergeable()) {
          __unstableDeleteSelection(event.keyCode === keycodes_build_module/* DELETE */.SJ);
        } else {
          event.preventDefault(); // Safari does not stop default behaviour with either
          // event.preventDefault() or node.contentEditable = false, so
          // remove the selection to stop browser manipulation.

          node.ownerDocument.defaultView.getSelection().removeAllRanges();
        }
      }
    }

    function onCompositionStart(event) {
      if (!hasMultiSelection()) {
        return;
      }

      node.contentEditable = false;

      if (__unstableIsSelectionMergeable()) {
        __unstableDeleteSelection();
      } else {
        event.preventDefault(); // Safari does not stop default behaviour with either
        // event.preventDefault() or node.contentEditable = false, so
        // remove the selection to stop browser manipulation.

        node.ownerDocument.defaultView.getSelection().removeAllRanges();
      }
    }

    node.addEventListener('beforeinput', onBeforeInput);
    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('compositionstart', onCompositionStart);
    return () => {
      node.removeEventListener('beforeinput', onBeforeInput);
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('compositionstart', onCompositionStart);
    };
  }, []);
}
//# sourceMappingURL=use-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */










function useWritingFlow() {
  const [before, ref, after] = useTabNav();
  const hasMultiSelection = use_select_useSelect(select => select(store_store).hasMultiSelection(), []);
  return [before, (0,use_merge_refs/* default */.A)([ref, useInput(), useDragSelection(), useSelectionObserver(), useClickSelection(), useMultiSelection(), useSelectAll(), useArrowNav(), (0,use_ref_effect/* default */.A)(node => {
    node.tabIndex = -1;
    node.contentEditable = hasMultiSelection;

    if (!hasMultiSelection) {
      return;
    }

    node.setAttribute('aria-label', (0,_wordpress_i18n_build_module.__)('Multiple selected blocks'));
    return () => {
      node.removeAttribute('aria-label');
    };
  }, [hasMultiSelection])]), after];
}

function WritingFlow(_ref, forwardedRef) {
  let {
    children,
    ...props
  } = _ref;
  const [before, ref, after] = useWritingFlow();
  return (0,react.createElement)(react.Fragment, null, before, (0,react.createElement)("div", (0,esm_extends/* default */.A)({}, props, {
    ref: (0,use_merge_refs/* default */.A)([ref, forwardedRef]),
    className: classnames_default()(props.className, 'block-editor-writing-flow')
  }), children), after);
}
/**
 * Handles selection and navigation across blocks. This component should be
 * wrapped around BlockList.
 *
 * @param {Object}    props          Component properties.
 * @param {WPElement} props.children Children to be rendered.
 */


/* harmony default export */ const writing_flow = ((0,react.forwardRef)(WritingFlow));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/iframe/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const BODY_CLASS_NAME = 'editor-styles-wrapper';
const BLOCK_PREFIX = 'wp-block';
/**
 * Clones stylesheets targetting the editor canvas to the given document. A
 * stylesheet is considered targetting the editor a canvas if it contains the
 * `editor-styles-wrapper`, `wp-block`, or `wp-block-*` class selectors.
 *
 * Ideally, this hook should be removed in the future and styles should be added
 * explicitly as editor styles.
 */

function useStylesCompatibility() {
  return (0,use_ref_effect/* default */.A)(node => {
    // Search the document for stylesheets targetting the editor canvas.
    Array.from(document.styleSheets).forEach(styleSheet => {
      try {
        // May fail for external styles.
        // eslint-disable-next-line no-unused-expressions
        styleSheet.cssRules;
      } catch (e) {
        return;
      }

      const {
        ownerNode,
        cssRules
      } = styleSheet;

      if (!cssRules) {
        return;
      } // Generally, ignore inline styles. We add inline styles belonging to a
      // stylesheet later, which may or may not match the selectors.


      if (ownerNode.tagName !== 'LINK') {
        return;
      } // Don't try to add the reset styles, which were removed as a dependency
      // from `edit-blocks` for the iframe since we don't need to reset admin
      // styles.


      if (ownerNode.id === 'wp-reset-editor-styles-css') {
        return;
      }

      function matchFromRules(_cssRules) {
        return Array.from(_cssRules).find(_ref => {
          let {
            selectorText,
            conditionText,
            cssRules: __cssRules
          } = _ref;

          // If the rule is conditional then it will not have selector text.
          // Recurse into child CSS ruleset to determine selector eligibility.
          if (conditionText) {
            return matchFromRules(__cssRules);
          }

          return selectorText && (selectorText.includes(`.${BODY_CLASS_NAME}`) || selectorText.includes(`.${BLOCK_PREFIX}`));
        });
      }

      const isMatch = matchFromRules(cssRules);

      if (isMatch && !node.ownerDocument.getElementById(ownerNode.id)) {
        // Display warning once we have a way to add style dependencies to the editor.
        // See: https://github.com/WordPress/gutenberg/pull/37466.
        node.appendChild(ownerNode.cloneNode(true)); // Add inline styles belonging to the stylesheet.

        const inlineCssId = ownerNode.id.replace('-css', '-inline-css');
        const inlineCssElement = document.getElementById(inlineCssId);

        if (inlineCssElement) {
          node.appendChild(inlineCssElement.cloneNode(true));
        }
      }
    });
  }, []);
}
/**
 * Bubbles some event types (keydown, keypress, and dragover) to parent document
 * document to ensure that the keyboard shortcuts and drag and drop work.
 *
 * Ideally, we should remove event bubbling in the future. Keyboard shortcuts
 * should be context dependent, e.g. actions on blocks like Cmd+A should not
 * work globally outside the block editor.
 *
 * @param {Document} doc Document to attach listeners to.
 */


function bubbleEvents(doc) {
  const {
    defaultView
  } = doc;
  const {
    frameElement
  } = defaultView;

  function bubbleEvent(event) {
    const prototype = Object.getPrototypeOf(event);
    const constructorName = prototype.constructor.name;
    const Constructor = window[constructorName];
    const init = {};

    for (const key in event) {
      init[key] = event[key];
    }

    if (event instanceof defaultView.MouseEvent) {
      const rect = frameElement.getBoundingClientRect();
      init.clientX += rect.left;
      init.clientY += rect.top;
    }

    const newEvent = new Constructor(event.type, init);
    const cancelled = !frameElement.dispatchEvent(newEvent);

    if (cancelled) {
      event.preventDefault();
    }
  }

  const eventTypes = ['dragover'];

  for (const name of eventTypes) {
    doc.addEventListener(name, bubbleEvent);
  }
}

function useParsedAssets(html) {
  return (0,react.useMemo)(() => {
    const doc = document.implementation.createHTMLDocument('');
    doc.body.innerHTML = html;
    return Array.from(doc.body.children);
  }, [html]);
}

async function loadScript(head, _ref2) {
  let {
    id,
    src
  } = _ref2;
  return new Promise((resolve, reject) => {
    const script = head.ownerDocument.createElement('script');
    script.id = id;

    if (src) {
      script.src = src;

      script.onload = () => resolve();

      script.onerror = () => reject();
    } else {
      resolve();
    }

    head.appendChild(script);
  });
}

function Iframe(_ref3, ref) {
  let {
    contentRef,
    children,
    head,
    tabIndex = 0,
    assets,
    ...props
  } = _ref3;
  const [, forceRender] = (0,react.useReducer)(() => ({}));
  const [iframeDocument, setIframeDocument] = (0,react.useState)();
  const [bodyClasses, setBodyClasses] = (0,react.useState)([]);
  const styles = useParsedAssets(assets === null || assets === void 0 ? void 0 : assets.styles);
  const scripts = useParsedAssets(assets === null || assets === void 0 ? void 0 : assets.scripts);
  const clearerRef = useBlockSelectionClearer();
  const [before, writingFlowRef, after] = useWritingFlow();
  const setRef = (0,use_ref_effect/* default */.A)(node => {
    function setDocumentIfReady() {
      const {
        contentDocument,
        ownerDocument
      } = node;
      const {
        readyState,
        documentElement
      } = contentDocument;

      if (readyState !== 'interactive' && readyState !== 'complete') {
        return false;
      }

      bubbleEvents(contentDocument);
      setIframeDocument(contentDocument);
      clearerRef(documentElement); // Ideally ALL classes that are added through get_body_class should
      // be added in the editor too, which we'll somehow have to get from
      // the server in the future (which will run the PHP filters).

      setBodyClasses(Array.from(ownerDocument.body.classList).filter(name => name.startsWith('admin-color-') || name.startsWith('post-type-') || name === 'wp-embed-responsive'));
      contentDocument.dir = ownerDocument.dir;
      documentElement.removeChild(contentDocument.head);
      documentElement.removeChild(contentDocument.body);
      return true;
    } // Document set with srcDoc is not immediately ready.


    node.addEventListener('load', setDocumentIfReady);
    return () => node.removeEventListener('load', setDocumentIfReady);
  }, []);
  const headRef = (0,use_ref_effect/* default */.A)(element => {
    scripts.reduce((promise, script) => promise.then(() => loadScript(element, script)), Promise.resolve()).finally(() => {
      // When script are loaded, re-render blocks to allow them
      // to initialise.
      forceRender();
    });
  }, []);
  const bodyRef = (0,use_merge_refs/* default */.A)([contentRef, clearerRef, writingFlowRef]);
  const styleCompatibilityRef = useStylesCompatibility();
  head = (0,react.createElement)(react.Fragment, null, (0,react.createElement)("style", null, 'body{margin:0}'), styles.map(_ref4 => {
    let {
      tagName,
      href,
      id,
      rel,
      media,
      textContent
    } = _ref4;
    const TagName = tagName.toLowerCase();

    if (TagName === 'style') {
      return (0,react.createElement)(TagName, {
        id,
        key: id
      }, textContent);
    }

    return (0,react.createElement)(TagName, {
      href,
      id,
      rel,
      media,
      key: id
    });
  }), head);
  return (0,react.createElement)(react.Fragment, null, tabIndex >= 0 && before, (0,react.createElement)("iframe", (0,esm_extends/* default */.A)({}, props, {
    ref: (0,use_merge_refs/* default */.A)([ref, setRef]),
    tabIndex: tabIndex // Correct doctype is required to enable rendering in standards mode
    ,
    srcDoc: "<!doctype html>",
    title: (0,_wordpress_i18n_build_module.__)('Editor canvas')
  }), iframeDocument && (0,react_dom.createPortal)((0,react.createElement)(react.Fragment, null, (0,react.createElement)("head", {
    ref: headRef
  }, head), (0,react.createElement)("body", {
    ref: bodyRef,
    className: classnames_default()(BODY_CLASS_NAME, ...bodyClasses)
  }, (0,react.createElement)("div", {
    style: {
      display: 'none'
    },
    ref: styleCompatibilityRef
  }), (0,react.createElement)(style_provider, {
    document: iframeDocument
  }, children))), iframeDocument.documentElement)), tabIndex >= 0 && after);
}

/* harmony default export */ const iframe = ((0,react.forwardRef)(Iframe));
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs
var a11y = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/traverse@0.6.7/node_modules/traverse/index.js
var traverse = __webpack_require__("../../node_modules/.pnpm/traverse@0.6.7/node_modules/traverse/index.js");
var traverse_default = /*#__PURE__*/__webpack_require__.n(traverse);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/parse.js
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.
// http://www.w3.org/TR/CSS21/grammar.htm
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
const commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
/* harmony default export */ function parse(css, options) {
  options = options || {};
  /**
   * Positional.
   */

  let lineno = 1;
  let column = 1;
  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    const lines = str.match(/\n/g);

    if (lines) {
      lineno += lines.length;
    }

    const i = str.lastIndexOf('\n'); // eslint-disable-next-line no-bitwise

    column = ~i ? str.length - i : column + str.length;
  }
  /**
   * Mark position and patch `node.position`.
   */


  function position() {
    const start = {
      line: lineno,
      column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }
  /**
   * Store position information for a node
   */


  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column
    };
    this.source = options.source;
  }
  /**
   * Non-enumerable source string
   */


  Position.prototype.content = css;
  /**
   * Error `msg`.
   */

  const errorsList = [];

  function error(msg) {
    const err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }
  /**
   * Parse stylesheet.
   */


  function stylesheet() {
    const rulesList = rules();
    return {
      type: 'stylesheet',
      stylesheet: {
        source: options.source,
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }
  /**
   * Opening brace.
   */


  function open() {
    return match(/^{\s*/);
  }
  /**
   * Closing brace.
   */


  function close() {
    return match(/^}/);
  }
  /**
   * Parse ruleset.
   */


  function rules() {
    let node;
    const accumulator = [];
    whitespace();
    comments(accumulator);

    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
      if (node !== false) {
        accumulator.push(node);
        comments(accumulator);
      }
    }

    return accumulator;
  }
  /**
   * Match `re` and return captures.
   */


  function match(re) {
    const m = re.exec(css);

    if (!m) {
      return;
    }

    const str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }
  /**
   * Parse whitespace.
   */


  function whitespace() {
    match(/^\s*/);
  }
  /**
   * Parse comments;
   */


  function comments(accumulator) {
    let c;
    accumulator = accumulator || []; // eslint-disable-next-line no-cond-assign

    while (c = comment()) {
      if (c !== false) {
        accumulator.push(c);
      }
    }

    return accumulator;
  }
  /**
   * Parse comment.
   */


  function comment() {
    const pos = position();

    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {
      return;
    }

    let i = 2;

    while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {
      ++i;
    }

    i += 2;

    if ('' === css.charAt(i - 1)) {
      return error('End of comment missing');
    }

    const str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;
    return pos({
      type: 'comment',
      comment: str
    });
  }
  /**
   * Parse selector.
   */


  function selector() {
    const m = match(/^([^{]+)/);

    if (!m) {
      return;
    } // FIXME: Remove all comments from selectors http://ostermiller.org/findcomment.html


    return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '').replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (matched) {
      return matched.replace(/,/g, '\u200C');
    }).split(/\s*(?![^(]*\)),\s*/).map(function (s) {
      return s.replace(/\u200C/g, ',');
    });
  }
  /**
   * Parse declaration.
   */


  function declaration() {
    const pos = position(); // prop.

    let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);

    if (!prop) {
      return;
    }

    prop = trim(prop[0]); // :

    if (!match(/^:\s*/)) {
      return error("property missing ':'");
    } // val.


    const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    const ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    }); // ;

    match(/^[;\s]*/);
    return ret;
  }
  /**
   * Parse declarations.
   */


  function declarations() {
    const decls = [];

    if (!open()) {
      return error("missing '{'");
    }

    comments(decls); // declarations.

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) {
      return error("missing '}'");
    }

    return decls;
  }
  /**
   * Parse keyframe.
   */


  function keyframe() {
    let m;
    const vals = [];
    const pos = position(); // eslint-disable-next-line no-cond-assign

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) {
      return;
    }

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }
  /**
   * Parse keyframes.
   */


  function atkeyframes() {
    const pos = position();
    let m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) {
      return;
    }

    const vendor = m[1]; // identifier

    m = match(/^([-\w]+)\s*/);

    if (!m) {
      return error('@keyframes missing name');
    }

    const name = m[1];

    if (!open()) {
      return error("@keyframes missing '{'");
    }

    let frame;
    let frames = comments(); // eslint-disable-next-line no-cond-assign

    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) {
      return error("@keyframes missing '}'");
    }

    return pos({
      type: 'keyframes',
      name,
      vendor,
      keyframes: frames
    });
  }
  /**
   * Parse supports.
   */


  function atsupports() {
    const pos = position();
    const m = match(/^@supports *([^{]+)/);

    if (!m) {
      return;
    }

    const supports = trim(m[1]);

    if (!open()) {
      return error("@supports missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@supports missing '}'");
    }

    return pos({
      type: 'supports',
      supports,
      rules: style
    });
  }
  /**
   * Parse host.
   */


  function athost() {
    const pos = position();
    const m = match(/^@host\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@host missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@host missing '}'");
    }

    return pos({
      type: 'host',
      rules: style
    });
  }
  /**
   * Parse media.
   */


  function atmedia() {
    const pos = position();
    const m = match(/^@media *([^{]+)/);

    if (!m) {
      return;
    }

    const media = trim(m[1]);

    if (!open()) {
      return error("@media missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@media missing '}'");
    }

    return pos({
      type: 'media',
      media,
      rules: style
    });
  }
  /**
   * Parse custom-media.
   */


  function atcustommedia() {
    const pos = position();
    const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);

    if (!m) {
      return;
    }

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }
  /**
   * Parse paged media.
   */


  function atpage() {
    const pos = position();
    const m = match(/^@page */);

    if (!m) {
      return;
    }

    const sel = selector() || [];

    if (!open()) {
      return error("@page missing '{'");
    }

    let decls = comments(); // declarations.

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@page missing '}'");
    }

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }
  /**
   * Parse document.
   */


  function atdocument() {
    const pos = position();
    const m = match(/^@([-\w]+)?document *([^{]+)/);

    if (!m) {
      return;
    }

    const vendor = trim(m[1]);
    const doc = trim(m[2]);

    if (!open()) {
      return error("@document missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@document missing '}'");
    }

    return pos({
      type: 'document',
      document: doc,
      vendor,
      rules: style
    });
  }
  /**
   * Parse font-face.
   */


  function atfontface() {
    const pos = position();
    const m = match(/^@font-face\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@font-face missing '{'");
    }

    let decls = comments(); // declarations.

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@font-face missing '}'");
    }

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }
  /**
   * Parse import
   */


  const atimport = _compileAtrule('import');
  /**
   * Parse charset
   */


  const atcharset = _compileAtrule('charset');
  /**
   * Parse namespace
   */


  const atnamespace = _compileAtrule('namespace');
  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    const re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function () {
      const pos = position();
      const m = match(re);

      if (!m) {
        return;
      }

      const ret = {
        type: name
      };
      ret[name] = m[1].trim();
      return pos(ret);
    };
  }
  /**
   * Parse at rule.
   */


  function atrule() {
    if (css[0] !== '@') {
      return;
    }

    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  }
  /**
   * Parse rule.
   */


  function rule() {
    const pos = position();
    const sel = selector();

    if (!sel) {
      return error('selector missing');
    }

    comments();
    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
}
/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */


function addParent(obj, parent) {
  const isNode = obj && typeof obj.type === 'string';
  const childParent = isNode ? obj : parent;

  for (const k in obj) {
    const value = obj[k];

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        addParent(v, childParent);
      });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}
/* eslint-enable @wordpress/no-unused-vars-before-return */
//# sourceMappingURL=parse.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var inherits_browser = __webpack_require__("../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
var inherits_browser_default = /*#__PURE__*/__webpack_require__.n(inherits_browser);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compiler.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Expose `Compiler`.
 */
/* harmony default export */ const compiler = (Compiler);
/**
 * Initialize a compiler.
 */

function Compiler(opts) {
  this.options = opts || {};
}
/**
 * Emit `str`
 */


Compiler.prototype.emit = function (str) {
  return str;
};
/**
 * Visit `node`.
 */


Compiler.prototype.visit = function (node) {
  return this[node.type](node);
};
/**
 * Map visit over array of `nodes`, optionally using a `delim`
 */


Compiler.prototype.mapVisit = function (nodes, delim) {
  let buf = '';
  delim = delim || '';

  for (let i = 0, length = nodes.length; i < length; i++) {
    buf += this.visit(nodes[i]);

    if (delim && i < length - 1) {
      buf += this.emit(delim);
    }
  }

  return buf;
};
//# sourceMappingURL=compiler.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compress.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ const compress = (compress_Compiler);
/**
 * Initialize a new `Compiler`.
 */

function compress_Compiler(options) {
  compiler.call(this, options);
}
/**
 * Inherit from `Base.prototype`.
 */


inherits_browser_default()(compress_Compiler, compiler);
/**
 * Compile `node`.
 */

compress_Compiler.prototype.compile = function (node) {
  return node.stylesheet.rules.map(this.visit, this).join('');
};
/**
 * Visit comment node.
 */


compress_Compiler.prototype.comment = function (node) {
  return this.emit('', node.position);
};
/**
 * Visit import node.
 */


compress_Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


compress_Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit document node.
 */


compress_Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit charset node.
 */


compress_Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


compress_Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


compress_Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit keyframes node.
 */


compress_Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit('{') + this.mapVisit(node.keyframes) + this.emit('}');
};
/**
 * Visit keyframe node.
 */


compress_Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(node.values.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit page node.
 */


compress_Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit font-face node.
 */


compress_Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face', node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit host node.
 */


compress_Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit custom-media node.
 */


compress_Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


compress_Compiler.prototype.rule = function (node) {
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit declaration node.
 */


compress_Compiler.prototype.declaration = function (node) {
  return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
};
//# sourceMappingURL=compress.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/identity.js
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ const stringify_identity = (identity_Compiler);
/**
 * Initialize a new `Compiler`.
 */

function identity_Compiler(options) {
  options = options || {};
  compiler.call(this, options);
  this.indentation = options.indent;
}
/**
 * Inherit from `Base.prototype`.
 */


inherits_browser_default()(identity_Compiler, compiler);
/**
 * Compile `node`.
 */

identity_Compiler.prototype.compile = function (node) {
  return this.stylesheet(node);
};
/**
 * Visit stylesheet node.
 */


identity_Compiler.prototype.stylesheet = function (node) {
  return this.mapVisit(node.stylesheet.rules, '\n\n');
};
/**
 * Visit comment node.
 */


identity_Compiler.prototype.comment = function (node) {
  return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
};
/**
 * Visit import node.
 */


identity_Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


identity_Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit document node.
 */


identity_Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit(' ' + ' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit charset node.
 */


identity_Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


identity_Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


identity_Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit keyframes node.
 */


identity_Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.keyframes, '\n') + this.emit(this.indent(-1) + '}');
};
/**
 * Visit keyframe node.
 */


identity_Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(this.indent()) + this.emit(node.values.join(', '), node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1) + '\n' + this.indent() + '}\n');
};
/**
 * Visit page node.
 */


identity_Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') + ' ' : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit font-face node.
 */


identity_Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face ', node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit host node.
 */


identity_Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit custom-media node.
 */


identity_Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


identity_Compiler.prototype.rule = function (node) {
  const indent = this.indent();
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.map(function (s) {
    return indent + s;
  }).join(',\n'), node.position) + this.emit(' {\n') + this.emit(this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1)) + this.emit('\n' + this.indent() + '}');
};
/**
 * Visit declaration node.
 */


identity_Compiler.prototype.declaration = function (node) {
  return this.emit(this.indent()) + this.emit(node.property + ': ' + node.value, node.position) + this.emit(';');
};
/**
 * Increase, decrease or return current indentation.
 */


identity_Compiler.prototype.indent = function (level) {
  this.level = this.level || 1;

  if (null !== level) {
    this.level += level;
    return '';
  }

  return Array(this.level).join(this.indentation || '  ');
};
/* eslint-enable @wordpress/no-unused-vars-before-return */
//# sourceMappingURL=identity.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/index.js
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Internal dependencies
 */


/**
 * Stringfy the given AST `node`.
 *
 * Options:
 *
 *  - `compress` space-optimized output
 *  - `sourcemap` return an object with `.code` and `.map`
 *
 * @param {Object} node
 * @param {Object} [options]
 * @return {string}
 */

/* harmony default export */ function stringify(node, options) {
  options = options || {};
  const compiler = options.compress ? new compress(options) : new stringify_identity(options);
  const code = compiler.compile(node);
  return code;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/traverse.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function traverseCSS(css, callback) {
  try {
    const parsed = parse(css);
    const updated = traverse_default().map(parsed, function (node) {
      if (!node) {
        return node;
      }

      const updatedNode = callback(node);
      return this.update(updatedNode);
    });
    return stringify(updated);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn('Error while traversing the CSS: ' + err);
    return null;
  }
}

/* harmony default export */ const transform_styles_traverse = (traverseCSS);
//# sourceMappingURL=traverse.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/url-rewrite.js
/**
 * Return `true` if the given path is http/https.
 *
 * @param {string} filePath path
 *
 * @return {boolean} is remote path.
 */
function isRemotePath(filePath) {
  return /^(?:https?:)?\/\//.test(filePath);
}
/**
 * Return `true` if the given filePath is an absolute url.
 *
 * @param {string} filePath path
 *
 * @return {boolean} is absolute path.
 */


function isAbsolutePath(filePath) {
  return /^\/(?!\/)/.test(filePath);
}
/**
 * Whether or not the url should be inluded.
 *
 * @param {Object} meta url meta info
 *
 * @return {boolean} is valid.
 */


function isValidURL(meta) {
  // Ignore hashes or data uris.
  if (meta.value.indexOf('data:') === 0 || meta.value.indexOf('#') === 0) {
    return false;
  }

  if (isAbsolutePath(meta.value)) {
    return false;
  } // Do not handle the http/https urls if `includeRemote` is false.


  if (isRemotePath(meta.value)) {
    return false;
  }

  return true;
}
/**
 * Get the absolute path of the url, relative to the basePath
 *
 * @param {string} str     the url
 * @param {string} baseURL base URL
 *
 * @return {string} the full path to the file
 */


function getResourcePath(str, baseURL) {
  return new URL(str, baseURL).toString();
}
/**
 * Process the single `url()` pattern
 *
 * @param {string} baseURL the base URL for relative URLs.
 *
 * @return {Promise} the Promise.
 */


function processURL(baseURL) {
  return meta => ({ ...meta,
    newUrl: 'url(' + meta.before + meta.quote + getResourcePath(meta.value, baseURL) + meta.quote + meta.after + ')'
  });
}
/**
 * Get all `url()`s, and return the meta info
 *
 * @param {string} value decl.value.
 *
 * @return {Array} the urls.
 */


function getURLs(value) {
  const reg = /url\((\s*)(['"]?)(.+?)\2(\s*)\)/g;
  let match;
  const URLs = [];

  while ((match = reg.exec(value)) !== null) {
    const meta = {
      source: match[0],
      before: match[1],
      quote: match[2],
      value: match[3],
      after: match[4]
    };

    if (isValidURL(meta)) {
      URLs.push(meta);
    }
  }

  return URLs;
}
/**
 * Replace the raw value's `url()` segment to the new value
 *
 * @param {string} raw  the raw value.
 * @param {Array}  URLs the URLs to replace.
 *
 * @return {string} the new value.
 */


function replaceURLs(raw, URLs) {
  URLs.forEach(item => {
    raw = raw.replace(item.source, item.newUrl);
  });
  return raw;
}

const rewrite = rootURL => node => {
  if (node.type === 'declaration') {
    const updatedURLs = getURLs(node.value).map(processURL(rootURL));
    return { ...node,
      value: replaceURLs(node.value, updatedURLs)
    };
  }

  return node;
};

/* harmony default export */ const url_rewrite = (rewrite);
//# sourceMappingURL=url-rewrite.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/wrap.js
/**
 * @constant string IS_ROOT_TAG Regex to check if the selector is a root tag selector.
 */
const IS_ROOT_TAG = /^(body|html|:root).*$/;
/**
 * Creates a callback to modify selectors so they only apply within a certain
 * namespace.
 *
 * @param {string}   namespace Namespace to prefix selectors with.
 * @param {string[]} ignore    Selectors to not prefix.
 *
 * @return {(node: Object) => Object} Callback to wrap selectors.
 */

const wrap = function (namespace) {
  let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return node => {
    /**
     * Updates selector if necessary.
     *
     * @param {string} selector Selector to modify.
     *
     * @return {string} Updated selector.
     */
    const updateSelector = selector => {
      if (ignore.includes(selector.trim())) {
        return selector;
      } // Anything other than a root tag is always prefixed.


      {
        if (!selector.match(IS_ROOT_TAG)) {
          return namespace + ' ' + selector;
        }
      } // HTML and Body elements cannot be contained within our container so lets extract their styles.

      return selector.replace(/^(body|html|:root)/, namespace);
    };

    if (node.type === 'rule') {
      return { ...node,
        selectors: node.selectors.map(updateSelector)
      };
    }

    return node;
  };
};

/* harmony default export */ const transforms_wrap = (wrap);
//# sourceMappingURL=wrap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Applies a series of CSS rule transforms to wrap selectors inside a given class and/or rewrite URLs depending on the parameters passed.
 *
 * @param {Array}  styles           CSS rules.
 * @param {string} wrapperClassName Wrapper Class Name.
 * @return {Array} converted rules.
 */

const transform_styles_transformStyles = function (styles) {
  let wrapperClassName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return (0,lodash.map)(styles, _ref => {
    let {
      css,
      baseURL
    } = _ref;
    const transforms = [];

    if (wrapperClassName) {
      transforms.push(transforms_wrap(wrapperClassName));
    }

    if (baseURL) {
      transforms.push(url_rewrite(baseURL));
    }

    if (transforms.length) {
      return transform_styles_traverse(css, (0,compose/* default */.A)(transforms));
    }

    return css;
  });
};

/* harmony default export */ const transform_styles = (transform_styles_transformStyles);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/editor-styles/index.js


/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const EDITOR_STYLES_SELECTOR = '.editor-styles-wrapper';
(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);

function useDarkThemeBodyClassName(styles) {
  return (0,react.useCallback)(node => {
    if (!node) {
      return;
    }

    const {
      ownerDocument
    } = node;
    const {
      defaultView,
      body
    } = ownerDocument;
    const canvas = ownerDocument.querySelector(EDITOR_STYLES_SELECTOR);
    let backgroundColor;

    if (!canvas) {
      // The real .editor-styles-wrapper element might not exist in the
      // DOM, so calculate the background color by creating a fake
      // wrapper.
      const tempCanvas = ownerDocument.createElement('div');
      tempCanvas.classList.add('editor-styles-wrapper');
      body.appendChild(tempCanvas);
      backgroundColor = defaultView.getComputedStyle(tempCanvas, null).getPropertyValue('background-color');
      body.removeChild(tempCanvas);
    } else {
      backgroundColor = defaultView.getComputedStyle(canvas, null).getPropertyValue('background-color');
    }

    const colordBackgroundColor = (0,node_modules_colord/* colord */.Mj)(backgroundColor); // If background is transparent, it should be treated as light color.

    if (colordBackgroundColor.luminance() > 0.5 || colordBackgroundColor.alpha() === 0) {
      body.classList.remove('is-dark-theme');
    } else {
      body.classList.add('is-dark-theme');
    }
  }, [styles]);
}

function EditorStyles(_ref) {
  let {
    styles
  } = _ref;
  const transformedStyles = (0,react.useMemo)(() => transform_styles(styles, EDITOR_STYLES_SELECTOR), [styles]);
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)("style", {
    ref: useDarkThemeBodyClassName(styles)
  }), transformedStyles.map((css, index) => (0,react.createElement)("style", {
    key: index
  }, css)));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/duotone/utils.js
/**
 * External dependencies
 */

/**
 * Convert a list of colors to an object of R, G, and B values.
 *
 * @param {string[]} colors Array of RBG color strings.
 *
 * @return {Object} R, G, and B values.
 */

function getValuesFromColors() {
  let colors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  const values = {
    r: [],
    g: [],
    b: [],
    a: []
  };
  colors.forEach(color => {
    const rgbColor = (0,node_modules_colord/* colord */.Mj)(color).toRgb();
    values.r.push(rgbColor.r / 255);
    values.g.push(rgbColor.g / 255);
    values.b.push(rgbColor.b / 255);
    values.a.push(rgbColor.a);
  });
  return values;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/duotone/components.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * SVG and stylesheet needed for rendering the duotone filter.
 *
 * @param {Object} props          Duotone props.
 * @param {string} props.selector Selector to apply the filter to.
 * @param {string} props.id       Unique id for this duotone filter.
 *
 * @return {WPElement} Duotone element.
 */

function DuotoneStylesheet(_ref) {
  let {
    selector,
    id
  } = _ref;
  const css = `
${selector} {
	filter: url( #${id} );
}
`;
  return (0,react.createElement)("style", null, css);
}
/**
 * Stylesheet for disabling a global styles duotone filter.
 *
 * @param {Object} props          Duotone props.
 * @param {string} props.selector Selector to disable the filter for.
 *
 * @return {WPElement} Filter none style element.
 */

function DuotoneUnsetStylesheet(_ref2) {
  let {
    selector
  } = _ref2;
  const css = `
${selector} {
	filter: none;
}
`;
  return (0,react.createElement)("style", null, css);
}
/**
 * The SVG part of the duotone filter.
 *
 * @param {Object}   props        Duotone props.
 * @param {string}   props.id     Unique id for this duotone filter.
 * @param {string[]} props.colors Color strings from dark to light.
 *
 * @return {WPElement} Duotone SVG.
 */

function DuotoneFilter(_ref3) {
  let {
    id,
    colors
  } = _ref3;
  const values = getValuesFromColors(colors);
  return (0,react.createElement)(svg/* SVG */.t4, {
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    viewBox: "0 0 0 0",
    width: "0",
    height: "0",
    focusable: "false",
    role: "none",
    style: {
      visibility: 'hidden',
      position: 'absolute',
      left: '-9999px',
      overflow: 'hidden'
    }
  }, (0,react.createElement)("defs", null, (0,react.createElement)("filter", {
    id: id
  }, (0,react.createElement)("feColorMatrix", {
    // Use sRGB instead of linearRGB so transparency looks correct.
    colorInterpolationFilters: "sRGB",
    type: "matrix" // Use perceptual brightness to convert to grayscale.
    ,
    values: " .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 "
  }), (0,react.createElement)("feComponentTransfer", {
    // Use sRGB instead of linearRGB to be consistent with how CSS gradients work.
    colorInterpolationFilters: "sRGB"
  }, (0,react.createElement)("feFuncR", {
    type: "table",
    tableValues: values.r.join(' ')
  }), (0,react.createElement)("feFuncG", {
    type: "table",
    tableValues: values.g.join(' ')
  }), (0,react.createElement)("feFuncB", {
    type: "table",
    tableValues: values.b.join(' ')
  }), (0,react.createElement)("feFuncA", {
    type: "table",
    tableValues: values.a.join(' ')
  })), (0,react.createElement)("feComposite", {
    // Re-mask the image with the original transparency since the feColorMatrix above loses that information.
    in2: "SourceGraphic",
    operator: "in"
  }))));
}
/**
 * SVG from a duotone preset
 *
 * @param {Object} props        Duotone props.
 * @param {Object} props.preset Duotone preset settings.
 *
 * @return {WPElement} Duotone element.
 */

function PresetDuotoneFilter(_ref4) {
  let {
    preset
  } = _ref4;
  return (0,react.createElement)(DuotoneFilter, {
    id: `wp-duotone-${preset.slug}`,
    colors: preset.colors
  });
}
//# sourceMappingURL=components.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-preview/auto.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





 // This is used to avoid rendering the block list if the sizes change.

let MemoizedBlockList;
const MAX_HEIGHT = 2000;

function AutoBlockPreview(_ref) {
  let {
    viewportWidth,
    __experimentalPadding,
    __experimentalMinHeight
  } = _ref;
  const [containerResizeListener, {
    width: containerWidth
  }] = useResizeAware();
  const [contentResizeListener, {
    height: contentHeight
  }] = useResizeAware();
  const {
    styles,
    assets,
    duotone
  } = use_select_useSelect(select => {
    var _settings$__experimen, _settings$__experimen2;

    const settings = select(store_store).getSettings();
    return {
      styles: settings.styles,
      assets: settings.__unstableResolvedAssets,
      duotone: (_settings$__experimen = settings.__experimentalFeatures) === null || _settings$__experimen === void 0 ? void 0 : (_settings$__experimen2 = _settings$__experimen.color) === null || _settings$__experimen2 === void 0 ? void 0 : _settings$__experimen2.duotone
    };
  }, []); // Avoid scrollbars for pattern previews.

  const editorStyles = (0,react.useMemo)(() => {
    if (styles) {
      return [...styles, {
        css: 'body{height:auto;overflow:hidden;}',
        __unstableType: 'presets'
      }];
    }

    return styles;
  }, [styles]);
  const svgFilters = (0,react.useMemo)(() => {
    var _duotone$default, _duotone$theme;

    return [...((_duotone$default = duotone === null || duotone === void 0 ? void 0 : duotone.default) !== null && _duotone$default !== void 0 ? _duotone$default : []), ...((_duotone$theme = duotone === null || duotone === void 0 ? void 0 : duotone.theme) !== null && _duotone$theme !== void 0 ? _duotone$theme : [])];
  }, [duotone]); // Initialize on render instead of module top level, to avoid circular dependency issues.

  MemoizedBlockList = MemoizedBlockList || (0,pure/* default */.A)(BlockList);
  const scale = containerWidth / viewportWidth;
  return (0,react.createElement)("div", {
    className: "block-editor-block-preview__container"
  }, containerResizeListener, (0,react.createElement)(disabled, {
    className: "block-editor-block-preview__content",
    style: {
      transform: `scale(${scale})`,
      height: contentHeight * scale,
      maxHeight: contentHeight > MAX_HEIGHT ? MAX_HEIGHT * scale : undefined,
      minHeight: __experimentalMinHeight
    }
  }, (0,react.createElement)(iframe, {
    head: (0,react.createElement)(EditorStyles, {
      styles: editorStyles
    }),
    assets: assets,
    contentRef: (0,use_ref_effect/* default */.A)(bodyElement => {
      const {
        ownerDocument: {
          documentElement
        }
      } = bodyElement;
      documentElement.classList.add('block-editor-block-preview__content-iframe');
      documentElement.style.position = 'absolute';
      documentElement.style.width = '100%';
      bodyElement.style.padding = __experimentalPadding + 'px'; // necessary for contentResizeListener to work.

      bodyElement.style.position = 'relative';
    }, []),
    "aria-hidden": true,
    tabIndex: -1,
    style: {
      position: 'absolute',
      width: viewportWidth,
      height: contentHeight,
      pointerEvents: 'none',
      // This is a catch-all max-height for patterns.
      // See: https://github.com/WordPress/gutenberg/pull/38175.
      maxHeight: MAX_HEIGHT,
      minHeight: scale !== 0 && scale < 1 && __experimentalMinHeight ? __experimentalMinHeight / scale : __experimentalMinHeight
    }
  }, contentResizeListener,
  /* Filters need to be rendered before children to avoid Safari rendering issues. */
  svgFilters.map(preset => (0,react.createElement)(PresetDuotoneFilter, {
    preset: preset,
    key: preset.slug
  })), (0,react.createElement)(MemoizedBlockList, {
    renderAppender: false
  }))));
}

/* harmony default export */ const auto = (AutoBlockPreview);
//# sourceMappingURL=auto.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






function BlockPreview(_ref) {
  let {
    blocks,
    __experimentalPadding = 0,
    viewportWidth = 1200,
    __experimentalLive = false,
    __experimentalOnClick,
    __experimentalMinHeight
  } = _ref;
  const originalSettings = use_select_useSelect(select => select(store_store).getSettings(), []);
  const settings = (0,react.useMemo)(() => {
    const _settings = { ...originalSettings
    };
    _settings.__experimentalBlockPatterns = [];
    return _settings;
  }, [originalSettings]);
  const renderedBlocks = (0,react.useMemo)(() => (0,lodash.castArray)(blocks), [blocks]);

  if (!blocks || blocks.length === 0) {
    return null;
  }

  return (0,react.createElement)(provider, {
    value: renderedBlocks,
    settings: settings
  }, __experimentalLive ? (0,react.createElement)(LiveBlockPreview, {
    onClick: __experimentalOnClick
  }) : (0,react.createElement)(auto, {
    viewportWidth: viewportWidth,
    __experimentalPadding: __experimentalPadding,
    __experimentalMinHeight: __experimentalMinHeight
  }));
}
/**
 * BlockPreview renders a preview of a block or array of blocks.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-preview/README.md
 *
 * @param {Object}       preview               options for how the preview should be shown
 * @param {Array|Object} preview.blocks        A block instance (object) or an array of blocks to be previewed.
 * @param {number}       preview.viewportWidth Width of the preview container in pixels. Controls at what size the blocks will be rendered inside the preview. Default: 700.
 *
 * @return {WPComponent} The component to be rendered.
 */

/* harmony default export */ const block_preview = ((0,react.memo)(BlockPreview));
/**
 * This hook is used to lightly mark an element as a block preview wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * a block preview wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object}    options                      Preview options.
 * @param {WPBlock[]} options.blocks               Block objects.
 * @param {Object}    options.props                Optional. Props to pass to the element. Must contain
 *                                                 the ref if one is defined.
 * @param {Object}    options.__experimentalLayout Layout settings to be used in the preview.
 *
 */

function useBlockPreview(_ref2) {
  let {
    blocks,
    props = {},
    __experimentalLayout
  } = _ref2;
  const originalSettings = useSelect(select => select(blockEditorStore).getSettings(), []);
  const disabledRef = useDisabled();
  const ref = useMergeRefs([props.ref, disabledRef]);
  const settings = useMemo(() => ({ ...originalSettings,
    __experimentalBlockPatterns: []
  }), [originalSettings]);
  const renderedBlocks = useMemo(() => castArray(blocks), [blocks]);
  const children = createElement(BlockEditorProvider, {
    value: renderedBlocks,
    settings: settings
  }, createElement(BlockListItems, {
    renderAppender: false,
    __experimentalLayout: __experimentalLayout
  }));
  return { ...props,
    ref,
    className: classnames(props.className, 'block-editor-block-preview__live-content', 'components-disabled'),
    children: blocks !== null && blocks !== void 0 && blocks.length ? children : null
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/preview-panel.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




function InserterPreviewPanel(_ref) {
  var _example$viewportWidt;

  let {
    item
  } = _ref;
  const {
    name,
    title,
    icon,
    description,
    initialAttributes,
    example
  } = item;
  const isReusable = (0,build_module/* isReusableBlock */.tk)(item);
  return (0,react.createElement)("div", {
    className: "block-editor-inserter__preview-container"
  }, (0,react.createElement)("div", {
    className: "block-editor-inserter__preview"
  }, isReusable || example ? (0,react.createElement)("div", {
    className: "block-editor-inserter__preview-content"
  }, (0,react.createElement)(block_preview, {
    __experimentalPadding: 16,
    viewportWidth: (_example$viewportWidt = example === null || example === void 0 ? void 0 : example.viewportWidth) !== null && _example$viewportWidt !== void 0 ? _example$viewportWidt : 500,
    blocks: example ? (0,build_module/* getBlockFromExample */.KL)(item.name, {
      attributes: { ...example.attributes,
        ...initialAttributes
      },
      innerBlocks: example.innerBlocks
    }) : (0,build_module/* createBlock */.Wv)(name, initialAttributes)
  })) : (0,react.createElement)("div", {
    className: "block-editor-inserter__preview-content-missing"
  }, (0,_wordpress_i18n_build_module.__)('No Preview Available.'))), !isReusable && (0,react.createElement)(block_card, {
    title: title,
    icon: icon,
    description: description
  }));
}

/* harmony default export */ const preview_panel = (InserterPreviewPanel);
//# sourceMappingURL=preview-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-async-list/index.js
/**
 * WordPress dependencies
 */



/**
 * Returns the first items from list that are present on state.
 *
 * @param  list  New array.
 * @param  state Current state.
 * @return First items present iin state.
 */
function getFirstItemsPresentInState(list, state) {
  const firstItems = [];

  for (let i = 0; i < list.length; i++) {
    const item = list[i];

    if (!state.includes(item)) {
      break;
    }

    firstItems.push(item);
  }

  return firstItems;
}
/**
 * React hook returns an array which items get asynchronously appended from a source array.
 * This behavior is useful if we want to render a list of items asynchronously for performance reasons.
 *
 * @param  list   Source array.
 * @param  config Configuration object.
 *
 * @return Async array.
 */


function useAsyncList(list) {
  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    step: 1
  };
  const {
    step = 1
  } = config;
  const [current, setCurrent] = (0,react.useState)([]);
  (0,react.useEffect)(() => {
    // On reset, we keep the first items that were previously rendered.
    let firstItems = getFirstItemsPresentInState(list, current);

    if (firstItems.length < step) {
      firstItems = firstItems.concat(list.slice(firstItems.length, step));
    }

    setCurrent(firstItems);
    let nextIndex = firstItems.length;
    const asyncQueue = (0,priority_queue_build_module/* createQueue */.y)();

    const append = () => {
      if (list.length <= nextIndex) {
        return;
      }

      setCurrent(state => [...state, ...list.slice(nextIndex, nextIndex + step)]);
      nextIndex += step;
      asyncQueue.add({}, append);
    };

    asyncQueue.add({}, append);
    return () => asyncQueue.reset();
  }, [list]);
  return current;
}

/* harmony default export */ const use_async_list = (useAsyncList);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/truncate/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedTruncate(props, forwardedRef) {
  const truncateProps = useTruncate(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({
    as: "span"
  }, truncateProps, {
    ref: forwardedRef
  }));
}
/**
 * `Truncate` is a typography primitive that trims text content.
 * For almost all cases, it is recommended that `Text`, `Heading`, or
 * `Subheading` is used to render text content. However,`Truncate` is
 * available for custom implementations.
 *
 * ```jsx
 * import { __experimentalTruncate as Truncate } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<Truncate>
 * 			Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc ex
 * 			neque, vulputate a diam et, luctus convallis lacus. Vestibulum ac
 * 			mollis mi. Morbi id elementum massa.
 * 		</Truncate>
 * 	);
 * }
 * ```
 */


const component_Truncate = contextConnect(UnconnectedTruncate, 'Truncate');
/* harmony default export */ const truncate_component = (component_Truncate);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@3.47.0/node_modules/@wordpress/keycodes/build-module/platform.js
var build_module_platform = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@3.47.0/node_modules/@wordpress/keycodes/build-module/platform.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/CompositeItem.js + 6 modules
var CompositeItem = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/CompositeItem.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/context.js
/**
 * WordPress dependencies
 */

const InserterListboxContext = (0,react.createContext)();
/* harmony default export */ const inserter_listbox_context = (InserterListboxContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/item.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function InserterListboxItem(_ref, ref) {
  let {
    isFirst,
    as: Component,
    children,
    ...props
  } = _ref;
  const state = (0,react.useContext)(inserter_listbox_context);
  return (0,react.createElement)(CompositeItem/* CompositeItem */.l, (0,esm_extends/* default */.A)({
    ref: ref,
    state: state,
    role: "option" // Use the CompositeItem `focusable` prop over Button's
    // isFocusable. The latter was shown to cause an issue
    // with tab order in the inserter list.
    ,
    focusable: true
  }, props), htmlProps => {
    const propsWithTabIndex = { ...htmlProps,
      tabIndex: isFirst ? 0 : htmlProps.tabIndex
    };

    if (Component) {
      return (0,react.createElement)(Component, propsWithTabIndex, children);
    }

    if (typeof children === 'function') {
      return children(propsWithTabIndex);
    }

    return (0,react.createElement)(build_module_button, propsWithTabIndex, children);
  });
}

/* harmony default export */ const inserter_listbox_item = ((0,react.forwardRef)(InserterListboxItem));
//# sourceMappingURL=item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/draggable/index.js


/**
 * WordPress dependencies
 */

/**
 * External dependencies
 */


const dragImageClass = 'components-draggable__invisible-drag-image';
const cloneWrapperClass = 'components-draggable__clone';
const clonePadding = 0;
const bodyClass = 'is-dragging-components-draggable';
/**
 * @typedef RenderProp
 * @property {(event: import('react').DragEvent) => void} onDraggableStart `onDragStart` handler.
 * @property {(event: import('react').DragEvent) => void} onDraggableEnd   `onDragEnd` handler.
 */

/**
 * @typedef Props
 * @property {(props: RenderProp) => JSX.Element | null}  children                         Children.
 * @property {(event: import('react').DragEvent) => void} [onDragStart]                    Callback when dragging starts.
 * @property {(event: import('react').DragEvent) => void} [onDragOver]                     Callback when dragging happens over the document.
 * @property {(event: import('react').DragEvent) => void} [onDragEnd]                      Callback when dragging ends.
 * @property {string}                                     [cloneClassname]                 Classname for the cloned element.
 * @property {string}                                     [elementId]                      ID for the element.
 * @property {any}                                        [transferData]                   Transfer data for the drag event.
 * @property {string}                                     [__experimentalTransferDataType] The transfer data type to set.
 * @property {import('react').ReactNode}                  __experimentalDragComponent      Component to show when dragging.
 */

/**
 * @param {Props} props
 * @return {JSX.Element} A draggable component.
 */

function Draggable(_ref) {
  let {
    children,
    onDragStart,
    onDragOver,
    onDragEnd,
    cloneClassname,
    elementId,
    transferData,
    __experimentalTransferDataType: transferDataType = 'text',
    __experimentalDragComponent: dragComponent
  } = _ref;

  /** @type {import('react').MutableRefObject<HTMLDivElement | null>} */
  const dragComponentRef = (0,react.useRef)(null);
  const cleanup = (0,react.useRef)(() => {});
  /**
   * Removes the element clone, resets cursor, and removes drag listener.
   *
   * @param {import('react').DragEvent} event The non-custom DragEvent.
   */

  function end(event) {
    event.preventDefault();
    cleanup.current();

    if (onDragEnd) {
      onDragEnd(event);
    }
  }
  /**
   * This method does a couple of things:
   *
   * - Clones the current element and spawns clone over original element.
   * - Adds a fake temporary drag image to avoid browser defaults.
   * - Sets transfer data.
   * - Adds dragover listener.
   *
   * @param {import('react').DragEvent} event The non-custom DragEvent.
   */


  function start(event) {
    // @ts-ignore We know that ownerDocument does exist on an Element
    const {
      ownerDocument
    } = event.target;
    event.dataTransfer.setData(transferDataType, JSON.stringify(transferData));
    const cloneWrapper = ownerDocument.createElement('div'); // Reset position to 0,0. Natural stacking order will position this lower, even with a transform otherwise.

    cloneWrapper.style.top = 0;
    cloneWrapper.style.left = 0;
    const dragImage = ownerDocument.createElement('div'); // Set a fake drag image to avoid browser defaults. Remove from DOM
    // right after. event.dataTransfer.setDragImage is not supported yet in
    // IE, we need to check for its existence first.

    if ('function' === typeof event.dataTransfer.setDragImage) {
      dragImage.classList.add(dragImageClass);
      ownerDocument.body.appendChild(dragImage);
      event.dataTransfer.setDragImage(dragImage, 0, 0);
    }

    cloneWrapper.classList.add(cloneWrapperClass);

    if (cloneClassname) {
      cloneWrapper.classList.add(cloneClassname);
    }

    let x = 0;
    let y = 0; // If a dragComponent is defined, the following logic will clone the
    // HTML node and inject it into the cloneWrapper.

    if (dragComponentRef.current) {
      // Position dragComponent at the same position as the cursor.
      x = event.clientX;
      y = event.clientY;
      cloneWrapper.style.transform = `translate( ${x}px, ${y}px )`;
      const clonedDragComponent = ownerDocument.createElement('div');
      clonedDragComponent.innerHTML = dragComponentRef.current.innerHTML;
      cloneWrapper.appendChild(clonedDragComponent); // Inject the cloneWrapper into the DOM.

      ownerDocument.body.appendChild(cloneWrapper);
    } else {
      const element = ownerDocument.getElementById(elementId); // Prepare element clone and append to element wrapper.

      const elementRect = element.getBoundingClientRect();
      const elementWrapper = element.parentNode;
      const elementTopOffset = parseInt(elementRect.top, 10);
      const elementLeftOffset = parseInt(elementRect.left, 10);
      cloneWrapper.style.width = `${elementRect.width + clonePadding * 2}px`;
      const clone = element.cloneNode(true);
      clone.id = `clone-${elementId}`; // Position clone right over the original element (20px padding).

      x = elementLeftOffset - clonePadding;
      y = elementTopOffset - clonePadding;
      cloneWrapper.style.transform = `translate( ${x}px, ${y}px )`; // Hack: Remove iFrames as it's causing the embeds drag clone to freeze.

      Array.from(clone.querySelectorAll('iframe')).forEach(child => child.parentNode.removeChild(child));
      cloneWrapper.appendChild(clone); // Inject the cloneWrapper into the DOM.

      elementWrapper.appendChild(cloneWrapper);
    } // Mark the current cursor coordinates.


    let cursorLeft = event.clientX;
    let cursorTop = event.clientY;
    /**
     * @param {import('react').DragEvent<Element>} e
     */

    function over(e) {
      // Skip doing any work if mouse has not moved.
      if (cursorLeft === e.clientX && cursorTop === e.clientY) {
        return;
      }

      const nextX = x + e.clientX - cursorLeft;
      const nextY = y + e.clientY - cursorTop;
      cloneWrapper.style.transform = `translate( ${nextX}px, ${nextY}px )`;
      cursorLeft = e.clientX;
      cursorTop = e.clientY;
      x = nextX;
      y = nextY;

      if (onDragOver) {
        onDragOver(e);
      }
    } // Aim for 60fps (16 ms per frame) for now. We can potentially use requestAnimationFrame (raf) instead,
    // note that browsers may throttle raf below 60fps in certain conditions.


    const throttledDragOver = (0,lodash.throttle)(over, 16);
    ownerDocument.addEventListener('dragover', throttledDragOver); // Update cursor to 'grabbing', document wide.

    ownerDocument.body.classList.add(bodyClass); // Allow the Synthetic Event to be accessed from asynchronous code.
    // https://reactjs.org/docs/events.html#event-pooling

    event.persist();
    /** @type {number | undefined} */

    let timerId;

    if (onDragStart) {
      timerId = setTimeout(() => onDragStart(event));
    }

    cleanup.current = () => {
      // Remove drag clone.
      if (cloneWrapper && cloneWrapper.parentNode) {
        cloneWrapper.parentNode.removeChild(cloneWrapper);
      }

      if (dragImage && dragImage.parentNode) {
        dragImage.parentNode.removeChild(dragImage);
      } // Reset cursor.


      ownerDocument.body.classList.remove(bodyClass);
      ownerDocument.removeEventListener('dragover', throttledDragOver);
      clearTimeout(timerId);
    };
  }

  (0,react.useEffect)(() => () => {
    cleanup.current();
  }, []);
  return (0,react.createElement)(react.Fragment, null, children({
    onDraggableStart: start,
    onDraggableEnd: end
  }), dragComponent && (0,react.createElement)("div", {
    className: "components-draggable-drag-component-root",
    style: {
      display: 'none'
    },
    ref: dragComponentRef
  }, dragComponent));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/drag-handle.js

/**
 * WordPress dependencies
 */

const dragHandle = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  width: "24",
  height: "24",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M8 7h2V5H8v2zm0 6h2v-2H8v2zm0 6h2v-2H8v2zm6-14v2h2V5h-2zm0 8h2v-2h-2v2zm0 6h2v-2h-2v2z"
}));
/* harmony default export */ const drag_handle = (dragHandle);
//# sourceMappingURL=drag-handle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-draggable/draggable-chip.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function BlockDraggableChip(_ref) {
  let {
    count,
    icon
  } = _ref;
  return (0,react.createElement)("div", {
    className: "block-editor-block-draggable-chip-wrapper"
  }, (0,react.createElement)("div", {
    className: "block-editor-block-draggable-chip"
  }, (0,react.createElement)(flex_component, {
    justify: "center",
    className: "block-editor-block-draggable-chip__content"
  }, (0,react.createElement)(flex_item_component, null, icon ? (0,react.createElement)(block_icon, {
    icon: icon
  }) : (0,_wordpress_i18n_build_module/* sprintf */.nv)(
  /* translators: %d: Number of blocks. */
  (0,_wordpress_i18n_build_module._n)('%d block', '%d blocks', count), count)), (0,react.createElement)(flex_item_component, null, (0,react.createElement)(block_icon, {
    icon: drag_handle
  })))));
}
//# sourceMappingURL=draggable-chip.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-draggable-blocks/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



const InserterDraggableBlocks = _ref => {
  let {
    isEnabled,
    blocks,
    icon,
    children
  } = _ref;
  const transferData = {
    type: 'inserter',
    blocks
  };
  return (0,react.createElement)(Draggable, {
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    __experimentalDragComponent: (0,react.createElement)(BlockDraggableChip, {
      count: blocks.length,
      icon: icon
    })
  }, _ref2 => {
    let {
      onDraggableStart,
      onDraggableEnd
    } = _ref2;
    return children({
      draggable: isEnabled,
      onDragStart: isEnabled ? onDraggableStart : undefined,
      onDragEnd: isEnabled ? onDraggableEnd : undefined
    });
  });
};

/* harmony default export */ const inserter_draggable_blocks = (InserterDraggableBlocks);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function InserterListItem(_ref) {
  let {
    className,
    isFirst,
    item,
    onSelect,
    onHover,
    isDraggable,
    ...props
  } = _ref;
  const isDragging = (0,react.useRef)(false);
  const itemIconStyle = item.icon ? {
    backgroundColor: item.icon.background,
    color: item.icon.foreground
  } : {};
  const blocks = (0,react.useMemo)(() => {
    return [(0,build_module/* createBlock */.Wv)(item.name, item.initialAttributes, (0,build_module/* createBlocksFromInnerBlocksTemplate */.to)(item.innerBlocks))];
  }, [item.name, item.initialAttributes, item.initialAttributes]);
  return (0,react.createElement)(inserter_draggable_blocks, {
    isEnabled: isDraggable && !item.disabled,
    blocks: blocks,
    icon: item.icon
  }, _ref2 => {
    let {
      draggable,
      onDragStart,
      onDragEnd
    } = _ref2;
    return (0,react.createElement)("div", {
      className: "block-editor-block-types-list__list-item",
      draggable: draggable,
      onDragStart: event => {
        isDragging.current = true;

        if (onDragStart) {
          onHover(null);
          onDragStart(event);
        }
      },
      onDragEnd: event => {
        isDragging.current = false;

        if (onDragEnd) {
          onDragEnd(event);
        }
      }
    }, (0,react.createElement)(inserter_listbox_item, (0,esm_extends/* default */.A)({
      isFirst: isFirst,
      className: classnames_default()('block-editor-block-types-list__item', className),
      disabled: item.isDisabled,
      onClick: event => {
        event.preventDefault();
        onSelect(item, (0,build_module_platform/* isAppleOS */.H)() ? event.metaKey : event.ctrlKey);
        onHover(null);
      },
      onKeyDown: event => {
        const {
          keyCode
        } = event;

        if (keyCode === keycodes_build_module/* ENTER */.Fm) {
          event.preventDefault();
          onSelect(item, (0,build_module_platform/* isAppleOS */.H)() ? event.metaKey : event.ctrlKey);
          onHover(null);
        }
      },
      onFocus: () => {
        if (isDragging.current) {
          return;
        }

        onHover(item);
      },
      onMouseEnter: () => {
        if (isDragging.current) {
          return;
        }

        onHover(item);
      },
      onMouseLeave: () => onHover(null),
      onBlur: () => onHover(null)
    }, props), (0,react.createElement)("span", {
      className: "block-editor-block-types-list__item-icon",
      style: itemIconStyle
    }, (0,react.createElement)(block_icon, {
      icon: item.icon,
      showColors: true
    })), (0,react.createElement)("span", {
      className: "block-editor-block-types-list__item-title"
    }, (0,react.createElement)(truncate_component, {
      numberOfLines: 3
    }, item.title))));
  });
}

/* harmony default export */ const inserter_list_item = ((0,react.memo)(InserterListItem));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/group.js



/**
 * WordPress dependencies
 */




function InserterListboxGroup(props, ref) {
  const [shouldSpeak, setShouldSpeak] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    if (shouldSpeak) {
      speak((0,_wordpress_i18n_build_module.__)('Use left and right arrow keys to move through blocks'));
    }
  }, [shouldSpeak]);
  return (0,react.createElement)("div", (0,esm_extends/* default */.A)({
    ref: ref,
    role: "listbox",
    "aria-orientation": "horizontal",
    onFocus: () => {
      setShouldSpeak(true);
    },
    onBlur: event => {
      const focusingOutsideGroup = !event.currentTarget.contains(event.relatedTarget);

      if (focusingOutsideGroup) {
        setShouldSpeak(false);
      }
    }
  }, props));
}

/* harmony default export */ const group = ((0,react.forwardRef)(InserterListboxGroup));
//# sourceMappingURL=group.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/_rollupPluginBabelHelpers-1f0bf8c2.js
var _rollupPluginBabelHelpers_1f0bf8c2 = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/_rollupPluginBabelHelpers-1f0bf8c2.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-system@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-system/es/createComponent.js + 4 modules
var createComponent = __webpack_require__("../../node_modules/.pnpm/reakit-system@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-system/es/createComponent.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-system@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-system/es/createHook.js + 4 modules
var createHook = __webpack_require__("../../node_modules/.pnpm/reakit-system@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-system/es/createHook.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useForkRef.js
var useForkRef = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useForkRef.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useIsomorphicEffect.js
var useIsomorphicEffect = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useIsomorphicEffect.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/findEnabledItemById-8ddca752.js
var findEnabledItemById_8ddca752 = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/findEnabledItemById-8ddca752.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/__keys-6742f591.js
var _keys_6742f591 = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/__keys-6742f591.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Id/Id.js
var Id = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Id/Id.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Role/Role.js
var Role = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Role/Role.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Group/Group.js






// Automatically generated
var GROUP_KEYS = [];

var useGroup = (0,createHook/* createHook */.a)({
  name: "Group",
  compose: Role/* useRole */.I,
  keys: GROUP_KEYS,
  useProps: function useProps(_, htmlProps) {
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      role: "group"
    }, htmlProps);
  }
});
var Group = (0,createComponent/* createComponent */.a)({
  as: "div",
  useHook: useGroup
});



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/CompositeGroup.js














var useCompositeGroup = (0,createHook/* createHook */.a)({
  name: "CompositeGroup",
  compose: [useGroup, Id/* unstable_useId */.W],
  keys: _keys_6742f591.a,
  propsAreEqual: function propsAreEqual(prev, next) {
    if (!next.id || prev.id !== next.id) {
      return useGroup.unstable_propsAreEqual(prev, next);
    }

    var prevCurrentId = prev.currentId,
        prevMoves = prev.unstable_moves,
        prevProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(prev, ["currentId", "unstable_moves"]);

    var nextCurrentId = next.currentId,
        nextMoves = next.unstable_moves,
        nextProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(next, ["currentId", "unstable_moves"]);

    if (prev.items && next.items) {
      var prevCurrentItem = (0,findEnabledItemById_8ddca752.f)(prev.items, prevCurrentId);
      var nextCurrentItem = (0,findEnabledItemById_8ddca752.f)(next.items, nextCurrentId);
      var prevGroupId = prevCurrentItem === null || prevCurrentItem === void 0 ? void 0 : prevCurrentItem.groupId;
      var nextGroupId = nextCurrentItem === null || nextCurrentItem === void 0 ? void 0 : nextCurrentItem.groupId;

      if (next.id === nextGroupId || next.id === prevGroupId) {
        return false;
      }
    }

    return useGroup.unstable_propsAreEqual(prevProps, nextProps);
  },
  useProps: function useProps(options, _ref) {
    var htmlRef = _ref.ref,
        htmlProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref, ["ref"]);

    var ref = (0,react.useRef)(null);
    var id = options.id; // We need this to be called before CompositeItems' register

    (0,useIsomorphicEffect/* useIsomorphicEffect */.o)(function () {
      var _options$registerGrou;

      if (!id) return undefined;
      (_options$registerGrou = options.registerGroup) === null || _options$registerGrou === void 0 ? void 0 : _options$registerGrou.call(options, {
        id: id,
        ref: ref
      });
      return function () {
        var _options$unregisterGr;

        (_options$unregisterGr = options.unregisterGroup) === null || _options$unregisterGr === void 0 ? void 0 : _options$unregisterGr.call(options, id);
      };
    }, [id, options.registerGroup, options.unregisterGroup]);
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      ref: (0,useForkRef/* useForkRef */.N)(ref, htmlRef)
    }, htmlProps);
  }
});
var CompositeGroup = (0,createComponent/* createComponent */.a)({
  as: "div",
  useHook: useCompositeGroup
});



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/row.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function InserterListboxRow(props, ref) {
  const state = (0,react.useContext)(inserter_listbox_context);
  return (0,react.createElement)(CompositeGroup, (0,esm_extends/* default */.A)({
    state: state,
    role: "presentation",
    ref: ref
  }, props));
}

/* harmony default export */ const inserter_listbox_row = ((0,react.forwardRef)(InserterListboxRow));
//# sourceMappingURL=row.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-types-list/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function chunk(array, size) {
  const chunks = [];

  for (let i = 0, j = array.length; i < j; i += size) {
    chunks.push(array.slice(i, i + size));
  }

  return chunks;
}

function BlockTypesList(_ref) {
  let {
    items = [],
    onSelect,
    onHover = () => {},
    children,
    label,
    isDraggable = true
  } = _ref;
  return (0,react.createElement)(group, {
    className: "block-editor-block-types-list",
    "aria-label": label
  }, chunk(items, 3).map((row, i) => (0,react.createElement)(inserter_listbox_row, {
    key: i
  }, row.map((item, j) => (0,react.createElement)(inserter_list_item, {
    key: item.id,
    item: item,
    className: (0,build_module/* getBlockMenuDefaultClassName */.HK)(item.id),
    onSelect: onSelect,
    onHover: onHover,
    isDraggable: isDraggable && !item.isDisabled,
    isFirst: i === 0 && j === 0
  })))), children);
}

/* harmony default export */ const block_types_list = (BlockTypesList);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/panel.js


/**
 * WordPress dependencies
 */


function InserterPanel(_ref) {
  let {
    title,
    icon,
    children
  } = _ref;
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)("div", {
    className: "block-editor-inserter__panel-header"
  }, (0,react.createElement)("h2", {
    className: "block-editor-inserter__panel-title"
  }, title), (0,react.createElement)(build_module_icon, {
    icon: icon
  })), (0,react.createElement)("div", {
    className: "block-editor-inserter__panel-content"
  }, children));
}

/* harmony default export */ const panel = (InserterPanel);
//# sourceMappingURL=panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-block-types-state.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Retrieves the block types inserter state.
 *
 * @param {string=}  rootClientId Insertion's root client ID.
 * @param {Function} onInsert     function called when inserter a list of blocks.
 * @return {Array} Returns the block types state. (block types, categories, collections, onSelect handler)
 */

const useBlockTypesState = (rootClientId, onInsert) => {
  const {
    categories,
    collections,
    items
  } = use_select_useSelect(select => {
    const {
      getInserterItems
    } = select(store_store);
    const {
      getCategories,
      getCollections
    } = select(build_module/* store */.M_);
    return {
      categories: getCategories(),
      collections: getCollections(),
      items: getInserterItems(rootClientId)
    };
  }, [rootClientId]);
  const onSelectItem = (0,react.useCallback)((_ref, shouldFocusBlock) => {
    let {
      name,
      initialAttributes,
      innerBlocks
    } = _ref;
    const insertedBlock = (0,build_module/* createBlock */.Wv)(name, initialAttributes, (0,build_module/* createBlocksFromInnerBlocksTemplate */.to)(innerBlocks));
    onInsert(insertedBlock, undefined, shouldFocusBlock);
  }, [onInsert]);
  return [items, categories, collections, onSelectItem];
};

/* harmony default export */ const use_block_types_state = (useBlockTypesState);
//# sourceMappingURL=use-block-types-state.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/CompositeState.js + 1 modules
var CompositeState = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/CompositeState.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/index.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






function InserterListbox(_ref) {
  let {
    children
  } = _ref;
  const compositeState = (0,CompositeState/* useCompositeState */.A)({
    shift: true,
    wrap: 'horizontal'
  });
  return (0,react.createElement)(inserter_listbox_context.Provider, {
    value: compositeState
  }, children);
}

/* harmony default export */ const inserter_listbox = (InserterListbox);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */






const getBlockNamespace = item => item.name.split('/')[0];

const MAX_SUGGESTED_ITEMS = 6;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation and rerendering the component.
 *
 * @type {Array}
 */

const block_types_tab_EMPTY_ARRAY = [];
function BlockTypesTab(_ref) {
  let {
    rootClientId,
    onInsert,
    onHover,
    showMostUsedBlocks
  } = _ref;
  const [items, categories, collections, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  const suggestedItems = (0,react.useMemo)(() => {
    return (0,lodash.orderBy)(items, ['frecency'], ['desc']).slice(0, MAX_SUGGESTED_ITEMS);
  }, [items]);
  const uncategorizedItems = (0,react.useMemo)(() => {
    return items.filter(item => !item.category);
  }, [items]);
  const itemsPerCategory = (0,react.useMemo)(() => {
    return (0,lodash.flow)(itemList => itemList.filter(item => item.category && item.category !== 'reusable'), itemList => (0,lodash.groupBy)(itemList, 'category'))(items);
  }, [items]);
  const itemsPerCollection = (0,react.useMemo)(() => {
    // Create a new Object to avoid mutating collection.
    const result = { ...collections
    };
    Object.keys(collections).forEach(namespace => {
      result[namespace] = items.filter(item => getBlockNamespace(item) === namespace);

      if (result[namespace].length === 0) {
        delete result[namespace];
      }
    });
    return result;
  }, [items, collections]); // Hide block preview on unmount.

  (0,react.useEffect)(() => () => onHover(null), []);
  /**
   * The inserter contains a big number of blocks and opening it is a costful operation.
   * The rendering is the most costful part of it, in order to improve the responsiveness
   * of the "opening" action, these lazy lists allow us to render the inserter category per category,
   * once all the categories are rendered, we start rendering the collections and the uncategorized block types.
   */

  const currentlyRenderedCategories = use_async_list(categories);
  const didRenderAllCategories = categories.length === currentlyRenderedCategories.length; // Async List requires an array.

  const collectionEntries = (0,react.useMemo)(() => {
    return Object.entries(collections);
  }, [collections]);
  const currentlyRenderedCollections = use_async_list(didRenderAllCategories ? collectionEntries : block_types_tab_EMPTY_ARRAY);
  return (0,react.createElement)(inserter_listbox, null, (0,react.createElement)("div", null, showMostUsedBlocks && !!suggestedItems.length && (0,react.createElement)(panel, {
    title: (0,_wordpress_i18n_build_module._x)('Most used', 'blocks')
  }, (0,react.createElement)(block_types_list, {
    items: suggestedItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: (0,_wordpress_i18n_build_module._x)('Most used', 'blocks')
  })), (0,lodash.map)(currentlyRenderedCategories, category => {
    const categoryItems = itemsPerCategory[category.slug];

    if (!categoryItems || !categoryItems.length) {
      return null;
    }

    return (0,react.createElement)(panel, {
      key: category.slug,
      title: category.title,
      icon: category.icon
    }, (0,react.createElement)(block_types_list, {
      items: categoryItems,
      onSelect: onSelectItem,
      onHover: onHover,
      label: category.title
    }));
  }), didRenderAllCategories && uncategorizedItems.length > 0 && (0,react.createElement)(panel, {
    className: "block-editor-inserter__uncategorized-blocks-panel",
    title: (0,_wordpress_i18n_build_module.__)('Uncategorized')
  }, (0,react.createElement)(block_types_list, {
    items: uncategorizedItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: (0,_wordpress_i18n_build_module.__)('Uncategorized')
  })), (0,lodash.map)(currentlyRenderedCollections, _ref2 => {
    let [namespace, collection] = _ref2;
    const collectionItems = itemsPerCollection[namespace];

    if (!collectionItems || !collectionItems.length) {
      return null;
    }

    return (0,react.createElement)(panel, {
      key: namespace,
      title: collection.title,
      icon: collection.icon
    }, (0,react.createElement)(block_types_list, {
      items: collectionItems,
      onSelect: onSelectItem,
      onHover: onHover,
      label: collection.title
    }));
  })));
}
/* harmony default export */ const block_types_tab = (BlockTypesTab);
//# sourceMappingURL=block-types-tab.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/select-control/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const select_control_noop = () => {};

function select_control_useUniqueId(idProp) {
  const instanceId = (0,use_instance_id/* default */.A)(SelectControl);
  const id = `inspector-select-control-${instanceId}`;
  return idProp || id;
}

function UnforwardedSelectControl(_ref, ref) {
  let {
    className,
    disabled = false,
    help,
    hideLabelFromVision,
    id: idProp,
    label,
    multiple = false,
    onBlur = select_control_noop,
    onChange = select_control_noop,
    onFocus = select_control_noop,
    options = [],
    size = 'default',
    value: valueProp,
    labelPosition = 'top',
    children,
    prefix,
    suffix,
    __next36pxDefaultSize = false,
    __nextHasNoMarginBottom = false,
    ...props
  } = _ref;
  const [isFocused, setIsFocused] = (0,react.useState)(false);
  const id = select_control_useUniqueId(idProp);
  const helpId = help ? `${id}__help` : undefined; // Disable reason: A select with an onchange throws a warning.

  if (!(options !== null && options !== void 0 && options.length) && !children) return null;

  const handleOnBlur = event => {
    onBlur(event);
    setIsFocused(false);
  };

  const handleOnFocus = event => {
    onFocus(event);
    setIsFocused(true);
  };

  const handleOnChange = event => {
    if (multiple) {
      const selectedOptions = Array.from(event.target.options).filter(_ref2 => {
        let {
          selected
        } = _ref2;
        return selected;
      });
      const newValues = selectedOptions.map(_ref3 => {
        let {
          value
        } = _ref3;
        return value;
      });
      onChange(newValues);
      return;
    }

    onChange(event.target.value, {
      event
    });
  };

  const classes = classnames_default()('components-select-control', className);
  /* eslint-disable jsx-a11y/no-onchange */

  return (0,react.createElement)(base_control, {
    help: help,
    id: id,
    __nextHasNoMarginBottom: __nextHasNoMarginBottom
  }, (0,react.createElement)(input_base, {
    className: classes,
    disabled: disabled,
    hideLabelFromVision: hideLabelFromVision,
    id: id,
    isFocused: isFocused,
    label: label,
    size: size,
    suffix: suffix || (0,react.createElement)(select_control_chevron_down, null),
    prefix: prefix,
    labelPosition: labelPosition,
    __next36pxDefaultSize: __next36pxDefaultSize
  }, (0,react.createElement)(Select, (0,helpers_esm_extends/* default */.A)({}, props, {
    __next36pxDefaultSize: __next36pxDefaultSize,
    "aria-describedby": helpId,
    className: "components-select-control__input",
    disabled: disabled,
    id: id,
    multiple: multiple,
    onBlur: handleOnBlur,
    onChange: handleOnChange,
    onFocus: handleOnFocus,
    ref: ref,
    selectSize: size,
    value: valueProp
  }), children || options.map((option, index) => {
    const key = option.id || `${option.label}-${option.value}-${index}`;
    return (0,react.createElement)("option", {
      key: key,
      value: option.value,
      disabled: option.disabled
    }, option.label);
  }))));
  /* eslint-enable jsx-a11y/no-onchange */
}
/**
 * `SelectControl` allows users to select from a single or multiple option menu.
 * It functions as a wrapper around the browser's native `<select>` element.
 *
 * @example
 * import { SelectControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MySelectControl = () => {
 *   const [ size, setSize ] = useState( '50%' );
 *
 *   return (
 *     <SelectControl
 *       label="Size"
 *       value={ size }
 *       options={ [
 *         { label: 'Big', value: '100%' },
 *         { label: 'Medium', value: '50%' },
 *         { label: 'Small', value: '25%' },
 *       ] }
 *       onChange={ setSize }
 *     />
 *   );
 * };
 */


const SelectControl = (0,react.forwardRef)(UnforwardedSelectControl);
/* harmony default export */ const select_control = (SelectControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/pattern-panel.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





function PatternInserterPanel(_ref) {
  let {
    selectedCategory,
    patternCategories,
    onClickCategory,
    openPatternExplorer
  } = _ref;
  const isMobile = (0,use_viewport_match/* default */.A)('medium', '<');

  const categoryOptions = () => {
    const options = [];
    patternCategories.map(patternCategory => {
      return options.push({
        value: patternCategory.name,
        label: patternCategory.label
      });
    });
    return options;
  };

  const onChangeSelect = selected => {
    onClickCategory(patternCategories.find(patternCategory => selected === patternCategory.name));
  };

  const className = classnames_default()('block-editor-inserter__panel-header', 'block-editor-inserter__panel-header-patterns'); // In iOS-based mobile devices, the onBlur will fire when selecting an option
  // from a Select element. To prevent closing the useDialog on iOS devices, we
  // stop propagating the onBlur event if there is no relatedTarget, which means
  // that the user most likely did not click on an element within the editor canvas.

  const onBlur = event => {
    if (!(event !== null && event !== void 0 && event.relatedTarget)) {
      event.stopPropagation();
    }
  };

  return (0,react.createElement)(flex_component, {
    justify: "space-between",
    align: "start",
    gap: "4",
    className: className
  }, (0,react.createElement)(flex_item_component, {
    isBlock: true
  }, (0,react.createElement)(select_control, {
    className: "block-editor-inserter__panel-dropdown",
    label: (0,_wordpress_i18n_build_module.__)('Filter patterns'),
    hideLabelFromVision: true,
    value: selectedCategory.name,
    onChange: onChangeSelect,
    onBlur: onBlur,
    options: categoryOptions()
  })), !isMobile && (0,react.createElement)(flex_item_component, null, (0,react.createElement)(build_module_button, {
    variant: "secondary",
    className: "block-editor-inserter__patterns-explorer-expand",
    label: (0,_wordpress_i18n_build_module.__)('Explore all patterns'),
    onClick: () => openPatternExplorer()
  }, (0,_wordpress_i18n_build_module._x)('Explore', 'Label for showing all block patterns'))));
}

/* harmony default export */ const pattern_panel = (PatternInserterPanel);
//# sourceMappingURL=pattern-panel.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/redux@4.2.1/node_modules/redux/es/redux.js + 5 modules
var redux = __webpack_require__("../../node_modules/.pnpm/redux@4.2.1/node_modules/redux/es/redux.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/equivalent-key-map@0.2.2/node_modules/equivalent-key-map/equivalent-key-map.js
var equivalent_key_map = __webpack_require__("../../node_modules/.pnpm/equivalent-key-map@0.2.2/node_modules/equivalent-key-map/equivalent-key-map.js");
var equivalent_key_map_default = /*#__PURE__*/__webpack_require__.n(equivalent_key_map);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+redux-routine@4.57.0_redux@4.2.1/node_modules/@wordpress/redux-routine/build-module/is-generator.js
/* eslint-disable jsdoc/valid-types */
/**
 * Returns true if the given object is a generator, or false otherwise.
 *
 * @see https://www.ecma-international.org/ecma-262/6.0/#sec-generator-objects
 *
 * @param {any} object Object to test.
 *
 * @return {object is Generator} Whether object is a generator.
 */
function isGenerator(object) {
  /* eslint-enable jsdoc/valid-types */
  // Check that iterator (next) and iterable (Symbol.iterator) interfaces are satisfied.
  // These checks seem to be compatible with several generator helpers as well as the native implementation.
  return !!object && typeof object[Symbol.iterator] === 'function' && typeof object.next === 'function';
}
//# sourceMappingURL=is-generator.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/rungen@0.3.2/node_modules/rungen/dist/index.js
var rungen_dist = __webpack_require__("../../node_modules/.pnpm/rungen@0.3.2/node_modules/rungen/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/is-promise@4.0.0/node_modules/is-promise/index.mjs
var is_promise = __webpack_require__("../../node_modules/.pnpm/is-promise@4.0.0/node_modules/is-promise/index.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs
var is_plain_object = __webpack_require__("../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+redux-routine@4.57.0_redux@4.2.1/node_modules/@wordpress/redux-routine/build-module/is-action.js
/**
 * External dependencies
 */


/* eslint-disable jsdoc/valid-types */
/**
 * Returns true if the given object quacks like an action.
 *
 * @param {any} object Object to test
 *
 * @return {object is import('redux').AnyAction}  Whether object is an action.
 */
function isAction(object) {
  return (0,is_plain_object/* isPlainObject */.Q)(object) && typeof object.type === 'string';
}

/**
 * Returns true if the given object quacks like an action and has a specific
 * action type
 *
 * @param {unknown} object       Object to test
 * @param {string}  expectedType The expected type for the action.
 *
 * @return {object is import('redux').AnyAction} Whether object is an action and is of specific type.
 */
function isActionOfType(object, expectedType) {
  /* eslint-enable jsdoc/valid-types */
  return isAction(object) && object.type === expectedType;
}
//# sourceMappingURL=is-action.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+redux-routine@4.57.0_redux@4.2.1/node_modules/@wordpress/redux-routine/build-module/runtime.js
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Create a co-routine runtime.
 *
 * @param controls Object of control handlers.
 * @param dispatch Unhandled action dispatch.
 */
function createRuntime(controls = {}, dispatch) {
  const rungenControls = Object.entries(controls).map(([actionType, control]) => (value, next, iterate, yieldNext, yieldError) => {
    if (!isActionOfType(value, actionType)) {
      return false;
    }
    const routine = control(value);
    if ((0,is_promise/* default */.A)(routine)) {
      // Async control routine awaits resolution.
      routine.then(yieldNext, yieldError);
    } else {
      yieldNext(routine);
    }
    return true;
  });
  const unhandledActionControl = (value, next) => {
    if (!isAction(value)) {
      return false;
    }
    dispatch(value);
    next();
    return true;
  };
  rungenControls.push(unhandledActionControl);
  const rungenRuntime = (0,rungen_dist.create)(rungenControls);
  return action => new Promise((resolve, reject) => rungenRuntime(action, result => {
    if (isAction(result)) {
      dispatch(result);
    }
    resolve(result);
  }, reject));
}
//# sourceMappingURL=runtime.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+redux-routine@4.57.0_redux@4.2.1/node_modules/@wordpress/redux-routine/build-module/index.js
/**
 * Internal dependencies
 */



/**
 * Creates a Redux middleware, given an object of controls where each key is an
 * action type for which to act upon, the value a function which returns either
 * a promise which is to resolve when evaluation of the action should continue,
 * or a value. The value or resolved promise value is assigned on the return
 * value of the yield assignment. If the control handler returns undefined, the
 * execution is not continued.
 *
 * @param {Record<string, (value: import('redux').AnyAction) => Promise<boolean> | boolean>} controls Object of control handlers.
 *
 * @return {import('redux').Middleware} Co-routine runtime
 */
function createMiddleware(controls = {}) {
  return store => {
    const runtime = createRuntime(controls, store.dispatch);
    return next => action => {
      if (!isGenerator(action)) {
        return next(action);
      }
      return runtime(action);
    };
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@6.34.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/pipe.js
/**
 * Parts of this source were derived and modified from lodash,
 * released under the MIT license.
 *
 * https://github.com/lodash/lodash
 *
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 *
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 * DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>
 *
 * This software consists of voluntary contributions made by many
 * individuals. For exact contribution history, see the revision history
 * available at https://github.com/lodash/lodash
 *
 * The following license applies to all parts of this software except as
 * documented below:
 *
 * ====
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Creates a pipe function.
 *
 * Allows to choose whether to perform left-to-right or right-to-left composition.
 *
 * @see https://docs-lodash.com/v4/flow/
 *
 * @param {boolean} reverse True if right-to-left, false for left-to-right composition.
 */
const basePipe = (reverse = false) => (...funcs) => (...args) => {
  const functions = funcs.flat();
  if (reverse) {
    functions.reverse();
  }
  return functions.reduce((prev, func) => [func(...prev)], args)[0];
};

/**
 * Composes multiple higher-order components into a single higher-order component. Performs left-to-right function
 * composition, where each successive invocation is supplied the return value of the previous.
 *
 * This is inspired by `lodash`'s `flow` function.
 *
 * @see https://docs-lodash.com/v4/flow/
 */
const pipe = basePipe();

/* harmony default export */ const higher_order_pipe = ((/* unused pure expression or super */ null && (pipe)));
//# sourceMappingURL=pipe.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@6.34.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/compose.js
/**
 * Internal dependencies
 */


/**
 * Composes multiple higher-order components into a single higher-order component. Performs right-to-left function
 * composition, where each successive invocation is supplied the return value of the previous.
 *
 * This is inspired by `lodash`'s `flowRight` function.
 *
 * @see https://docs-lodash.com/v4/flow-right/
 */
const compose_compose = basePipe(true);
/* harmony default export */ const higher_order_compose = (compose_compose);
//# sourceMappingURL=compose.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/combine-reducers.js
function combineReducers(reducers) {
  const keys = Object.keys(reducers);
  return function combinedReducer(state = {}, action) {
    const nextState = {};
    let hasChanged = false;
    for (const key of keys) {
      const reducer = reducers[key];
      const prevStateForKey = state[key];
      const nextStateForKey = reducer(prevStateForKey, action);
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== prevStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
//# sourceMappingURL=combine-reducers.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/factory.js
/**
 * Creates a selector function that takes additional curried argument with the
 * registry `select` function. While a regular selector has signature
 * ```js
 * ( state, ...selectorArgs ) => ( result )
 * ```
 * that allows to select data from the store's `state`, a registry selector
 * has signature:
 * ```js
 * ( select ) => ( state, ...selectorArgs ) => ( result )
 * ```
 * that supports also selecting from other registered stores.
 *
 * @example
 * ```js
 * import { store as coreStore } from '@wordpress/core-data';
 * import { store as editorStore } from '@wordpress/editor';
 *
 * const getCurrentPostId = createRegistrySelector( ( select ) => ( state ) => {
 *   return select( editorStore ).getCurrentPostId();
 * } );
 *
 * const getPostEdits = createRegistrySelector( ( select ) => ( state ) => {
 *   // calling another registry selector just like any other function
 *   const postType = getCurrentPostType( state );
 *   const postId = getCurrentPostId( state );
 *	 return select( coreStore ).getEntityRecordEdits( 'postType', postType, postId );
 * } );
 * ```
 *
 * Note how the `getCurrentPostId` selector can be called just like any other function,
 * (it works even inside a regular non-registry selector) and we don't need to pass the
 * registry as argument. The registry binding happens automatically when registering the selector
 * with a store.
 *
 * @param {Function} registrySelector Function receiving a registry `select`
 *                                    function and returning a state selector.
 *
 * @return {Function} Registry selector that can be registered with a store.
 */
function createRegistrySelector(registrySelector) {
  const selectorsByRegistry = new WeakMap();
  // Create a selector function that is bound to the registry referenced by `selector.registry`
  // and that has the same API as a regular selector. Binding it in such a way makes it
  // possible to call the selector directly from another selector.
  const wrappedSelector = (...args) => {
    let selector = selectorsByRegistry.get(wrappedSelector.registry);
    // We want to make sure the cache persists even when new registry
    // instances are created. For example patterns create their own editors
    // with their own core/block-editor stores, so we should keep track of
    // the cache for each registry instance.
    if (!selector) {
      selector = registrySelector(wrappedSelector.registry.select);
      selectorsByRegistry.set(wrappedSelector.registry, selector);
    }
    return selector(...args);
  };

  /**
   * Flag indicating that the selector is a registry selector that needs the correct registry
   * reference to be assigned to `selector.registry` to make it work correctly.
   * be mapped as a registry selector.
   *
   * @type {boolean}
   */
  wrappedSelector.isRegistrySelector = true;
  return wrappedSelector;
}

/**
 * Creates a control function that takes additional curried argument with the `registry` object.
 * While a regular control has signature
 * ```js
 * ( action ) => ( iteratorOrPromise )
 * ```
 * where the control works with the `action` that it's bound to, a registry control has signature:
 * ```js
 * ( registry ) => ( action ) => ( iteratorOrPromise )
 * ```
 * A registry control is typically used to select data or dispatch an action to a registered
 * store.
 *
 * When registering a control created with `createRegistryControl` with a store, the store
 * knows which calling convention to use when executing the control.
 *
 * @param {Function} registryControl Function receiving a registry object and returning a control.
 *
 * @return {Function} Registry control that can be registered with a store.
 */
function createRegistryControl(registryControl) {
  registryControl.isRegistryControl = true;
  return registryControl;
}
//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/controls.js
/**
 * Internal dependencies
 */


/** @typedef {import('./types').StoreDescriptor} StoreDescriptor */

const SELECT = '@@data/SELECT';
const RESOLVE_SELECT = '@@data/RESOLVE_SELECT';
const DISPATCH = '@@data/DISPATCH';
function isObject(object) {
  return object !== null && typeof object === 'object';
}

/**
 * Dispatches a control action for triggering a synchronous registry select.
 *
 * Note: This control synchronously returns the current selector value, triggering the
 * resolution, but not waiting for it.
 *
 * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store
 * @param {string}                 selectorName          The name of the selector.
 * @param {Array}                  args                  Arguments for the selector.
 *
 * @example
 * ```js
 * import { controls } from '@wordpress/data';
 *
 * // Action generator using `select`.
 * export function* myAction() {
 *   const isEditorSideBarOpened = yield controls.select( 'core/edit-post', 'isEditorSideBarOpened' );
 *   // Do stuff with the result from the `select`.
 * }
 * ```
 *
 * @return {Object} The control descriptor.
 */
function controls_select(storeNameOrDescriptor, selectorName, ...args) {
  return {
    type: SELECT,
    storeKey: isObject(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor,
    selectorName,
    args
  };
}

/**
 * Dispatches a control action for triggering and resolving a registry select.
 *
 * Note: when this control action is handled, it automatically considers
 * selectors that may have a resolver. In such case, it will return a `Promise` that resolves
 * after the selector finishes resolving, with the final result value.
 *
 * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store
 * @param {string}                 selectorName          The name of the selector
 * @param {Array}                  args                  Arguments for the selector.
 *
 * @example
 * ```js
 * import { controls } from '@wordpress/data';
 *
 * // Action generator using resolveSelect
 * export function* myAction() {
 * 	const isSidebarOpened = yield controls.resolveSelect( 'core/edit-post', 'isEditorSideBarOpened' );
 * 	// do stuff with the result from the select.
 * }
 * ```
 *
 * @return {Object} The control descriptor.
 */
function resolveSelect(storeNameOrDescriptor, selectorName, ...args) {
  return {
    type: RESOLVE_SELECT,
    storeKey: isObject(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor,
    selectorName,
    args
  };
}

/**
 * Dispatches a control action for triggering a registry dispatch.
 *
 * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store
 * @param {string}                 actionName            The name of the action to dispatch
 * @param {Array}                  args                  Arguments for the dispatch action.
 *
 * @example
 * ```js
 * import { controls } from '@wordpress/data-controls';
 *
 * // Action generator using dispatch
 * export function* myAction() {
 *   yield controls.dispatch( 'core/editor', 'togglePublishSidebar' );
 *   // do some other things.
 * }
 * ```
 *
 * @return {Object}  The control descriptor.
 */
function dispatch(storeNameOrDescriptor, actionName, ...args) {
  return {
    type: DISPATCH,
    storeKey: isObject(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor,
    actionName,
    args
  };
}
const controls = {
  select: controls_select,
  resolveSelect,
  dispatch
};
const builtinControls = {
  [SELECT]: createRegistryControl(registry => ({
    storeKey,
    selectorName,
    args
  }) => registry.select(storeKey)[selectorName](...args)),
  [RESOLVE_SELECT]: createRegistryControl(registry => ({
    storeKey,
    selectorName,
    args
  }) => {
    const method = registry.select(storeKey)[selectorName].hasResolver ? 'resolveSelect' : 'select';
    return registry[method](storeKey)[selectorName](...args);
  }),
  [DISPATCH]: createRegistryControl(registry => ({
    storeKey,
    actionName,
    args
  }) => registry.dispatch(storeKey)[actionName](...args))
};
//# sourceMappingURL=controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+private-apis@0.39.0/node_modules/@wordpress/private-apis/build-module/implementation.js
/* provided dependency */ var implementation_process = __webpack_require__("../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js");
/**
 * wordpress/private-apis – the utilities to enable private cross-package
 * exports of private APIs.
 *
 * This "implementation.js" file is needed for the sake of the unit tests. It
 * exports more than the public API of the package to aid in testing.
 */

/**
 * The list of core modules allowed to opt-in to the private APIs.
 */
const CORE_MODULES_USING_PRIVATE_APIS = ['@wordpress/block-directory', '@wordpress/block-editor', '@wordpress/block-library', '@wordpress/blocks', '@wordpress/commands', '@wordpress/components', '@wordpress/core-commands', '@wordpress/core-data', '@wordpress/customize-widgets', '@wordpress/data', '@wordpress/edit-post', '@wordpress/edit-site', '@wordpress/edit-widgets', '@wordpress/editor', '@wordpress/format-library', '@wordpress/interface', '@wordpress/patterns', '@wordpress/preferences', '@wordpress/reusable-blocks', '@wordpress/router', '@wordpress/dataviews'];

/**
 * A list of core modules that already opted-in to
 * the privateApis package.
 *
 * @type {string[]}
 */
const registeredPrivateApis = [];

/*
 * Warning for theme and plugin developers.
 *
 * The use of private developer APIs is intended for use by WordPress Core
 * and the Gutenberg plugin exclusively.
 *
 * Dangerously opting in to using these APIs is NOT RECOMMENDED. Furthermore,
 * the WordPress Core philosophy to strive to maintain backward compatibility
 * for third-party developers DOES NOT APPLY to private APIs.
 *
 * THE CONSENT STRING FOR OPTING IN TO THESE APIS MAY CHANGE AT ANY TIME AND
 * WITHOUT NOTICE. THIS CHANGE WILL BREAK EXISTING THIRD-PARTY CODE. SUCH A
 * CHANGE MAY OCCUR IN EITHER A MAJOR OR MINOR RELEASE.
 */
const requiredConsent = 'I know using unstable features means my theme or plugin will inevitably break in the next version of WordPress.';

/** @type {boolean} */
let allowReRegistration;
// The safety measure is meant for WordPress core where IS_WORDPRESS_CORE
// is set to true.
// For the general use-case, the re-registration should be allowed by default
// Let's default to true, then. Try/catch will fall back to "true" even if the
// environment variable is not explicitly defined.
try {
  allowReRegistration = implementation_process.env.IS_WORDPRESS_CORE ? false : true;
} catch (error) {
  allowReRegistration = true;
}

/**
 * Called by a @wordpress package wishing to opt-in to accessing or exposing
 * private private APIs.
 *
 * @param {string} consent    The consent string.
 * @param {string} moduleName The name of the module that is opting in.
 * @return {{lock: typeof lock, unlock: typeof unlock}} An object containing the lock and unlock functions.
 */
const __dangerousOptInToUnstableAPIsOnlyForCoreModules = (consent, moduleName) => {
  if (!CORE_MODULES_USING_PRIVATE_APIS.includes(moduleName)) {
    throw new Error(`You tried to opt-in to unstable APIs as module "${moduleName}". ` + 'This feature is only for JavaScript modules shipped with WordPress core. ' + 'Please do not use it in plugins and themes as the unstable APIs will be removed ' + 'without a warning. If you ignore this error and depend on unstable features, ' + 'your product will inevitably break on one of the next WordPress releases.');
  }
  if (!allowReRegistration && registeredPrivateApis.includes(moduleName)) {
    // This check doesn't play well with Story Books / Hot Module Reloading
    // and isn't included in the Gutenberg plugin. It only matters in the
    // WordPress core release.
    throw new Error(`You tried to opt-in to unstable APIs as module "${moduleName}" which is already registered. ` + 'This feature is only for JavaScript modules shipped with WordPress core. ' + 'Please do not use it in plugins and themes as the unstable APIs will be removed ' + 'without a warning. If you ignore this error and depend on unstable features, ' + 'your product will inevitably break on one of the next WordPress releases.');
  }
  if (consent !== requiredConsent) {
    throw new Error(`You tried to opt-in to unstable APIs without confirming you know the consequences. ` + 'This feature is only for JavaScript modules shipped with WordPress core. ' + 'Please do not use it in plugins and themes as the unstable APIs will removed ' + 'without a warning. If you ignore this error and depend on unstable features, ' + 'your product will inevitably break on the next WordPress release.');
  }
  registeredPrivateApis.push(moduleName);
  return {
    lock,
    unlock
  };
};

/**
 * Binds private data to an object.
 * It does not alter the passed object in any way, only
 * registers it in an internal map of private data.
 *
 * The private data can't be accessed by any other means
 * than the `unlock` function.
 *
 * @example
 * ```js
 * const object = {};
 * const privateData = { a: 1 };
 * lock( object, privateData );
 *
 * object
 * // {}
 *
 * unlock( object );
 * // { a: 1 }
 * ```
 *
 * @param {any} object      The object to bind the private data to.
 * @param {any} privateData The private data to bind to the object.
 */
function lock(object, privateData) {
  if (!object) {
    throw new Error('Cannot lock an undefined object.');
  }
  if (!(__private in object)) {
    object[__private] = {};
  }
  lockedData.set(object[__private], privateData);
}

/**
 * Unlocks the private data bound to an object.
 *
 * It does not alter the passed object in any way, only
 * returns the private data paired with it using the `lock()`
 * function.
 *
 * @example
 * ```js
 * const object = {};
 * const privateData = { a: 1 };
 * lock( object, privateData );
 *
 * object
 * // {}
 *
 * unlock( object );
 * // { a: 1 }
 * ```
 *
 * @param {any} object The object to unlock the private data from.
 * @return {any} The private data bound to the object.
 */
function unlock(object) {
  if (!object) {
    throw new Error('Cannot unlock an undefined object.');
  }
  if (!(__private in object)) {
    throw new Error('Cannot unlock an object that was not locked before. ');
  }
  return lockedData.get(object[__private]);
}
const lockedData = new WeakMap();

/**
 * Used by lock() and unlock() to uniquely identify the private data
 * related to a containing object.
 */
const __private = Symbol('Private API ID');

// Unit tests utilities:

/**
 * Private function to allow the unit tests to allow
 * a mock module to access the private APIs.
 *
 * @param {string} name The name of the module.
 */
function allowCoreModule(name) {
  CORE_MODULES_USING_PRIVATE_APIS.push(name);
}

/**
 * Private function to allow the unit tests to set
 * a custom list of allowed modules.
 */
function resetAllowedCoreModules() {
  while (CORE_MODULES_USING_PRIVATE_APIS.length) {
    CORE_MODULES_USING_PRIVATE_APIS.pop();
  }
}
/**
 * Private function to allow the unit tests to reset
 * the list of registered private apis.
 */
function resetRegisteredPrivateApis() {
  while (registeredPrivateApis.length) {
    registeredPrivateApis.pop();
  }
}
//# sourceMappingURL=implementation.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/lock-unlock.js
/**
 * WordPress dependencies
 */

const {
  lock: lock_unlock_lock,
  unlock: lock_unlock_unlock
} = __dangerousOptInToUnstableAPIsOnlyForCoreModules('I know using unstable features means my theme or plugin will inevitably break in the next version of WordPress.', '@wordpress/data');
//# sourceMappingURL=lock-unlock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/promise-middleware.js
/**
 * External dependencies
 */


/**
 * Simplest possible promise redux middleware.
 *
 * @type {import('redux').Middleware}
 */
const promiseMiddleware = () => next => action => {
  if ((0,is_promise/* default */.A)(action)) {
    return action.then(resolvedAction => {
      if (resolvedAction) {
        return next(resolvedAction);
      }
    });
  }
  return next(action);
};
/* harmony default export */ const promise_middleware = (promiseMiddleware);
//# sourceMappingURL=promise-middleware.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/resolvers-cache-middleware.js
/** @typedef {import('./registry').WPDataRegistry} WPDataRegistry */

/**
 * Creates a middleware handling resolvers cache invalidation.
 *
 * @param {WPDataRegistry} registry  Registry for which to create the middleware.
 * @param {string}         storeName Name of the store for which to create the middleware.
 *
 * @return {Function} Middleware function.
 */
const createResolversCacheMiddleware = (registry, storeName) => () => next => action => {
  const resolvers = registry.select(storeName).getCachedResolvers();
  const resolverEntries = Object.entries(resolvers);
  resolverEntries.forEach(([selectorName, resolversByArgs]) => {
    const resolver = registry.stores[storeName]?.resolvers?.[selectorName];
    if (!resolver || !resolver.shouldInvalidate) {
      return;
    }
    resolversByArgs.forEach((value, args) => {
      // Works around a bug in `EquivalentKeyMap` where `map.delete` merely sets an entry value
      // to `undefined` and `map.forEach` then iterates also over these orphaned entries.
      if (value === undefined) {
        return;
      }

      // resolversByArgs is the map Map([ args ] => boolean) storing the cache resolution status for a given selector.
      // If the value is "finished" or "error" it means this resolver has finished its resolution which means we need
      // to invalidate it, if it's true it means it's inflight and the invalidation is not necessary.
      if (value.status !== 'finished' && value.status !== 'error') {
        return;
      }
      if (!resolver.shouldInvalidate(action, ...args)) {
        return;
      }

      // Trigger cache invalidation
      registry.dispatch(storeName).invalidateResolution(selectorName, args);
    });
  });
  return next(action);
};
/* harmony default export */ const resolvers_cache_middleware = (createResolversCacheMiddleware);
//# sourceMappingURL=resolvers-cache-middleware.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/thunk-middleware.js
function createThunkMiddleware(args) {
  return () => next => action => {
    if (typeof action === 'function') {
      return action(args);
    }
    return next(action);
  };
}
//# sourceMappingURL=thunk-middleware.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/metadata/utils.js
/**
 * External dependencies
 */

/**
 * Higher-order reducer creator which creates a combined reducer object, keyed
 * by a property on the action object.
 *
 * @param actionProperty Action property by which to key object.
 * @return Higher-order reducer.
 */
const onSubKey = actionProperty => reducer => (state = {}, action) => {
  // Retrieve subkey from action. Do not track if undefined; useful for cases
  // where reducer is scoped by action shape.
  const key = action[actionProperty];
  if (key === undefined) {
    return state;
  }

  // Avoid updating state if unchanged. Note that this also accounts for a
  // reducer which returns undefined on a key which is not yet tracked.
  const nextKeyState = reducer(state[key], action);
  if (nextKeyState === state[key]) {
    return state;
  }
  return {
    ...state,
    [key]: nextKeyState
  };
};

/**
 * Normalize selector argument array by defaulting `undefined` value to an empty array
 * and removing trailing `undefined` values.
 *
 * @param args Selector argument array
 * @return Normalized state key array
 */
function selectorArgsToStateKey(args) {
  if (args === undefined || args === null) {
    return [];
  }
  const len = args.length;
  let idx = len;
  while (idx > 0 && args[idx - 1] === undefined) {
    idx--;
  }
  return idx === len ? args : args.slice(0, idx);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/metadata/reducer.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Reducer function returning next state for selector resolution of
 * subkeys, object form:
 *
 *  selectorName -> EquivalentKeyMap<Array,boolean>
 */
const subKeysIsResolved = onSubKey('selectorName')((state = new (equivalent_key_map_default())(), action) => {
  switch (action.type) {
    case 'START_RESOLUTION':
      {
        const nextState = new (equivalent_key_map_default())(state);
        nextState.set(selectorArgsToStateKey(action.args), {
          status: 'resolving'
        });
        return nextState;
      }
    case 'FINISH_RESOLUTION':
      {
        const nextState = new (equivalent_key_map_default())(state);
        nextState.set(selectorArgsToStateKey(action.args), {
          status: 'finished'
        });
        return nextState;
      }
    case 'FAIL_RESOLUTION':
      {
        const nextState = new (equivalent_key_map_default())(state);
        nextState.set(selectorArgsToStateKey(action.args), {
          status: 'error',
          error: action.error
        });
        return nextState;
      }
    case 'START_RESOLUTIONS':
      {
        const nextState = new (equivalent_key_map_default())(state);
        for (const resolutionArgs of action.args) {
          nextState.set(selectorArgsToStateKey(resolutionArgs), {
            status: 'resolving'
          });
        }
        return nextState;
      }
    case 'FINISH_RESOLUTIONS':
      {
        const nextState = new (equivalent_key_map_default())(state);
        for (const resolutionArgs of action.args) {
          nextState.set(selectorArgsToStateKey(resolutionArgs), {
            status: 'finished'
          });
        }
        return nextState;
      }
    case 'FAIL_RESOLUTIONS':
      {
        const nextState = new (equivalent_key_map_default())(state);
        action.args.forEach((resolutionArgs, idx) => {
          const resolutionState = {
            status: 'error',
            error: undefined
          };
          const error = action.errors[idx];
          if (error) {
            resolutionState.error = error;
          }
          nextState.set(selectorArgsToStateKey(resolutionArgs), resolutionState);
        });
        return nextState;
      }
    case 'INVALIDATE_RESOLUTION':
      {
        const nextState = new (equivalent_key_map_default())(state);
        nextState.delete(selectorArgsToStateKey(action.args));
        return nextState;
      }
  }
  return state;
});

/**
 * Reducer function returning next state for selector resolution, object form:
 *
 *   selectorName -> EquivalentKeyMap<Array, boolean>
 *
 * @param state  Current state.
 * @param action Dispatched action.
 *
 * @return Next state.
 */
const isResolved = (state = {}, action) => {
  switch (action.type) {
    case 'INVALIDATE_RESOLUTION_FOR_STORE':
      return {};
    case 'INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR':
      {
        if (action.selectorName in state) {
          const {
            [action.selectorName]: removedSelector,
            ...restState
          } = state;
          return restState;
        }
        return state;
      }
    case 'START_RESOLUTION':
    case 'FINISH_RESOLUTION':
    case 'FAIL_RESOLUTION':
    case 'START_RESOLUTIONS':
    case 'FINISH_RESOLUTIONS':
    case 'FAIL_RESOLUTIONS':
    case 'INVALIDATE_RESOLUTION':
      return subKeysIsResolved(state, action);
  }
  return state;
};
/* harmony default export */ const metadata_reducer = (isResolved);
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+deprecated@3.57.0/node_modules/@wordpress/deprecated/build-module/index.js
/**
 * WordPress dependencies
 */


/**
 * Object map tracking messages which have been logged, for use in ensuring a
 * message is only logged once.
 *
 * @type {Record<string, true | undefined>}
 */
const logged = Object.create(null);

/**
 * Logs a message to notify developers about a deprecated feature.
 *
 * @param {string} feature               Name of the deprecated feature.
 * @param {Object} [options]             Personalisation options
 * @param {string} [options.since]       Version in which the feature was deprecated.
 * @param {string} [options.version]     Version in which the feature will be removed.
 * @param {string} [options.alternative] Feature to use instead
 * @param {string} [options.plugin]      Plugin name if it's a plugin feature
 * @param {string} [options.link]        Link to documentation
 * @param {string} [options.hint]        Additional message to help transition away from the deprecated feature.
 *
 * @example
 * ```js
 * import deprecated from '@wordpress/deprecated';
 *
 * deprecated( 'Eating meat', {
 * 	since: '2019.01.01'
 * 	version: '2020.01.01',
 * 	alternative: 'vegetables',
 * 	plugin: 'the earth',
 * 	hint: 'You may find it beneficial to transition gradually.',
 * } );
 *
 * // Logs: 'Eating meat is deprecated since version 2019.01.01 and will be removed from the earth in version 2020.01.01. Please use vegetables instead. Note: You may find it beneficial to transition gradually.'
 * ```
 */
function deprecated(feature, options = {}) {
  const {
    since,
    version,
    alternative,
    plugin,
    link,
    hint
  } = options;
  const pluginMessage = plugin ? ` from ${plugin}` : '';
  const sinceMessage = since ? ` since version ${since}` : '';
  const versionMessage = version ? ` and will be removed${pluginMessage} in version ${version}` : '';
  const useInsteadMessage = alternative ? ` Please use ${alternative} instead.` : '';
  const linkMessage = link ? ` See: ${link}` : '';
  const hintMessage = hint ? ` Note: ${hint}` : '';
  const message = `${feature} is deprecated${sinceMessage}${versionMessage}.${useInsteadMessage}${linkMessage}${hintMessage}`;

  // Skip if already logged.
  if (message in logged) {
    return;
  }

  /**
   * Fires whenever a deprecated feature is encountered
   *
   * @param {string}  feature             Name of the deprecated feature.
   * @param {?Object} options             Personalisation options
   * @param {string}  options.since       Version in which the feature was deprecated.
   * @param {?string} options.version     Version in which the feature will be removed.
   * @param {?string} options.alternative Feature to use instead
   * @param {?string} options.plugin      Plugin name if it's a plugin feature
   * @param {?string} options.link        Link to documentation
   * @param {?string} options.hint        Additional message to help transition away from the deprecated feature.
   * @param {?string} message             Message sent to console.warn
   */
  (0,hooks_build_module/* doAction */.Eo)('deprecated', feature, options, message);

  // eslint-disable-next-line no-console
  console.warn(message);
  logged[message] = true;
}

/** @typedef {import('utility-types').NonUndefined<Parameters<typeof deprecated>[1]>} DeprecatedOptions */
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/metadata/selectors.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/** @typedef {Record<string, import('./reducer').State>} State */
/** @typedef {import('./reducer').StateValue} StateValue */
/** @typedef {import('./reducer').Status} Status */

/**
 * Returns the raw resolution state value for a given selector name,
 * and arguments set. May be undefined if the selector has never been resolved
 * or not resolved for the given set of arguments, otherwise true or false for
 * resolution started and completed respectively.
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {StateValue|undefined} isResolving value.
 */
function getResolutionState(state, selectorName, args) {
  const map = state[selectorName];
  if (!map) {
    return;
  }
  return map.get(selectorArgsToStateKey(args));
}

/**
 * Returns an `isResolving`-like value for a given selector name and arguments set.
 * Its value is either `undefined` if the selector has never been resolved or has been
 * invalidated, or a `true`/`false` boolean value if the resolution is in progress or
 * has finished, respectively.
 *
 * This is a legacy selector that was implemented when the "raw" internal data had
 * this `undefined | boolean` format. Nowadays the internal value is an object that
 * can be retrieved with `getResolutionState`.
 *
 * @deprecated
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {boolean | undefined} isResolving value.
 */
function getIsResolving(state, selectorName, args) {
  deprecated('wp.data.select( store ).getIsResolving', {
    since: '6.6',
    version: '6.8',
    alternative: 'wp.data.select( store ).getResolutionState'
  });
  const resolutionState = getResolutionState(state, selectorName, args);
  return resolutionState && resolutionState.status === 'resolving';
}

/**
 * Returns true if resolution has already been triggered for a given
 * selector name, and arguments set.
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {boolean} Whether resolution has been triggered.
 */
function hasStartedResolution(state, selectorName, args) {
  return getResolutionState(state, selectorName, args) !== undefined;
}

/**
 * Returns true if resolution has completed for a given selector
 * name, and arguments set.
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {boolean} Whether resolution has completed.
 */
function hasFinishedResolution(state, selectorName, args) {
  const status = getResolutionState(state, selectorName, args)?.status;
  return status === 'finished' || status === 'error';
}

/**
 * Returns true if resolution has failed for a given selector
 * name, and arguments set.
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {boolean} Has resolution failed
 */
function hasResolutionFailed(state, selectorName, args) {
  return getResolutionState(state, selectorName, args)?.status === 'error';
}

/**
 * Returns the resolution error for a given selector name, and arguments set.
 * Note it may be of an Error type, but may also be null, undefined, or anything else
 * that can be `throw`-n.
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {Error|unknown} Last resolution error
 */
function getResolutionError(state, selectorName, args) {
  const resolutionState = getResolutionState(state, selectorName, args);
  return resolutionState?.status === 'error' ? resolutionState.error : null;
}

/**
 * Returns true if resolution has been triggered but has not yet completed for
 * a given selector name, and arguments set.
 *
 * @param {State}      state        Data state.
 * @param {string}     selectorName Selector name.
 * @param {unknown[]?} args         Arguments passed to selector.
 *
 * @return {boolean} Whether resolution is in progress.
 */
function isResolving(state, selectorName, args) {
  return getResolutionState(state, selectorName, args)?.status === 'resolving';
}

/**
 * Returns the list of the cached resolvers.
 *
 * @param {State} state Data state.
 *
 * @return {State} Resolvers mapped by args and selectorName.
 */
function getCachedResolvers(state) {
  return state;
}

/**
 * Whether the store has any currently resolving selectors.
 *
 * @param {State} state Data state.
 *
 * @return {boolean} True if one or more selectors are resolving, false otherwise.
 */
function hasResolvingSelectors(state) {
  return Object.values(state).some(selectorState =>
  /**
   * This uses the internal `_map` property of `EquivalentKeyMap` for
   * optimization purposes, since the `EquivalentKeyMap` implementation
   * does not support a `.values()` implementation.
   *
   * @see https://github.com/aduth/equivalent-key-map
   */
  Array.from(selectorState._map.values()).some(resolution => resolution[1]?.status === 'resolving'));
}

/**
 * Retrieves the total number of selectors, grouped per status.
 *
 * @param {State} state Data state.
 *
 * @return {Object} Object, containing selector totals by status.
 */
const countSelectorsByStatus = (0,rememo/* default */.A)(state => {
  const selectorsByStatus = {};
  Object.values(state).forEach(selectorState =>
  /**
   * This uses the internal `_map` property of `EquivalentKeyMap` for
   * optimization purposes, since the `EquivalentKeyMap` implementation
   * does not support a `.values()` implementation.
   *
   * @see https://github.com/aduth/equivalent-key-map
   */
  Array.from(selectorState._map.values()).forEach(resolution => {
    var _resolution$1$status;
    const currentStatus = (_resolution$1$status = resolution[1]?.status) !== null && _resolution$1$status !== void 0 ? _resolution$1$status : 'error';
    if (!selectorsByStatus[currentStatus]) {
      selectorsByStatus[currentStatus] = 0;
    }
    selectorsByStatus[currentStatus]++;
  }));
  return selectorsByStatus;
}, state => [state]);
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/metadata/actions.js
/**
 * Returns an action object used in signalling that selector resolution has
 * started.
 *
 * @param {string}    selectorName Name of selector for which resolver triggered.
 * @param {unknown[]} args         Arguments to associate for uniqueness.
 *
 * @return {{ type: 'START_RESOLUTION', selectorName: string, args: unknown[] }} Action object.
 */
function startResolution(selectorName, args) {
  return {
    type: 'START_RESOLUTION',
    selectorName,
    args
  };
}

/**
 * Returns an action object used in signalling that selector resolution has
 * completed.
 *
 * @param {string}    selectorName Name of selector for which resolver triggered.
 * @param {unknown[]} args         Arguments to associate for uniqueness.
 *
 * @return {{ type: 'FINISH_RESOLUTION', selectorName: string, args: unknown[] }} Action object.
 */
function finishResolution(selectorName, args) {
  return {
    type: 'FINISH_RESOLUTION',
    selectorName,
    args
  };
}

/**
 * Returns an action object used in signalling that selector resolution has
 * failed.
 *
 * @param {string}        selectorName Name of selector for which resolver triggered.
 * @param {unknown[]}     args         Arguments to associate for uniqueness.
 * @param {Error|unknown} error        The error that caused the failure.
 *
 * @return {{ type: 'FAIL_RESOLUTION', selectorName: string, args: unknown[], error: Error|unknown }} Action object.
 */
function failResolution(selectorName, args, error) {
  return {
    type: 'FAIL_RESOLUTION',
    selectorName,
    args,
    error
  };
}

/**
 * Returns an action object used in signalling that a batch of selector resolutions has
 * started.
 *
 * @param {string}      selectorName Name of selector for which resolver triggered.
 * @param {unknown[][]} args         Array of arguments to associate for uniqueness, each item
 *                                   is associated to a resolution.
 *
 * @return {{ type: 'START_RESOLUTIONS', selectorName: string, args: unknown[][] }} Action object.
 */
function startResolutions(selectorName, args) {
  return {
    type: 'START_RESOLUTIONS',
    selectorName,
    args
  };
}

/**
 * Returns an action object used in signalling that a batch of selector resolutions has
 * completed.
 *
 * @param {string}      selectorName Name of selector for which resolver triggered.
 * @param {unknown[][]} args         Array of arguments to associate for uniqueness, each item
 *                                   is associated to a resolution.
 *
 * @return {{ type: 'FINISH_RESOLUTIONS', selectorName: string, args: unknown[][] }} Action object.
 */
function finishResolutions(selectorName, args) {
  return {
    type: 'FINISH_RESOLUTIONS',
    selectorName,
    args
  };
}

/**
 * Returns an action object used in signalling that a batch of selector resolutions has
 * completed and at least one of them has failed.
 *
 * @param {string}            selectorName Name of selector for which resolver triggered.
 * @param {unknown[]}         args         Array of arguments to associate for uniqueness, each item
 *                                         is associated to a resolution.
 * @param {(Error|unknown)[]} errors       Array of errors to associate for uniqueness, each item
 *                                         is associated to a resolution.
 * @return {{ type: 'FAIL_RESOLUTIONS', selectorName: string, args: unknown[], errors: Array<Error|unknown> }} Action object.
 */
function failResolutions(selectorName, args, errors) {
  return {
    type: 'FAIL_RESOLUTIONS',
    selectorName,
    args,
    errors
  };
}

/**
 * Returns an action object used in signalling that we should invalidate the resolution cache.
 *
 * @param {string}    selectorName Name of selector for which resolver should be invalidated.
 * @param {unknown[]} args         Arguments to associate for uniqueness.
 *
 * @return {{ type: 'INVALIDATE_RESOLUTION', selectorName: string, args: any[] }} Action object.
 */
function invalidateResolution(selectorName, args) {
  return {
    type: 'INVALIDATE_RESOLUTION',
    selectorName,
    args
  };
}

/**
 * Returns an action object used in signalling that the resolution
 * should be invalidated.
 *
 * @return {{ type: 'INVALIDATE_RESOLUTION_FOR_STORE' }} Action object.
 */
function invalidateResolutionForStore() {
  return {
    type: 'INVALIDATE_RESOLUTION_FOR_STORE'
  };
}

/**
 * Returns an action object used in signalling that the resolution cache for a
 * given selectorName should be invalidated.
 *
 * @param {string} selectorName Name of selector for which all resolvers should
 *                              be invalidated.
 *
 * @return  {{ type: 'INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR', selectorName: string }} Action object.
 */
function invalidateResolutionForStoreSelector(selectorName) {
  return {
    type: 'INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR',
    selectorName
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */











/** @typedef {import('../types').DataRegistry} DataRegistry */
/** @typedef {import('../types').ListenerFunction} ListenerFunction */
/**
 * @typedef {import('../types').StoreDescriptor<C>} StoreDescriptor
 * @template {import('../types').AnyConfig} C
 */
/**
 * @typedef {import('../types').ReduxStoreConfig<State,Actions,Selectors>} ReduxStoreConfig
 * @template State
 * @template {Record<string,import('../types').ActionCreator>} Actions
 * @template Selectors
 */

const trimUndefinedValues = array => {
  const result = [...array];
  for (let i = result.length - 1; i >= 0; i--) {
    if (result[i] === undefined) {
      result.splice(i, 1);
    }
  }
  return result;
};

/**
 * Creates a new object with the same keys, but with `callback()` called as
 * a transformer function on each of the values.
 *
 * @param {Object}   obj      The object to transform.
 * @param {Function} callback The function to transform each object value.
 * @return {Array} Transformed object.
 */
const redux_store_mapValues = (obj, callback) => Object.fromEntries(Object.entries(obj !== null && obj !== void 0 ? obj : {}).map(([key, value]) => [key, callback(value, key)]));

// Convert  non serializable types to plain objects
const devToolsReplacer = (key, state) => {
  if (state instanceof Map) {
    return Object.fromEntries(state);
  }
  if (state instanceof window.HTMLElement) {
    return null;
  }
  return state;
};

/**
 * Create a cache to track whether resolvers started running or not.
 *
 * @return {Object} Resolvers Cache.
 */
function createResolversCache() {
  const cache = {};
  return {
    isRunning(selectorName, args) {
      return cache[selectorName] && cache[selectorName].get(trimUndefinedValues(args));
    },
    clear(selectorName, args) {
      if (cache[selectorName]) {
        cache[selectorName].delete(trimUndefinedValues(args));
      }
    },
    markAsRunning(selectorName, args) {
      if (!cache[selectorName]) {
        cache[selectorName] = new (equivalent_key_map_default())();
      }
      cache[selectorName].set(trimUndefinedValues(args), true);
    }
  };
}
function createBindingCache(bind) {
  const cache = new WeakMap();
  return {
    get(item, itemName) {
      let boundItem = cache.get(item);
      if (!boundItem) {
        boundItem = bind(item, itemName);
        cache.set(item, boundItem);
      }
      return boundItem;
    }
  };
}

/**
 * Creates a data store descriptor for the provided Redux store configuration containing
 * properties describing reducer, actions, selectors, controls and resolvers.
 *
 * @example
 * ```js
 * import { createReduxStore } from '@wordpress/data';
 *
 * const store = createReduxStore( 'demo', {
 *     reducer: ( state = 'OK' ) => state,
 *     selectors: {
 *         getValue: ( state ) => state,
 *     },
 * } );
 * ```
 *
 * @template State
 * @template {Record<string,import('../types').ActionCreator>} Actions
 * @template Selectors
 * @param {string}                                    key     Unique namespace identifier.
 * @param {ReduxStoreConfig<State,Actions,Selectors>} options Registered store options, with properties
 *                                                            describing reducer, actions, selectors,
 *                                                            and resolvers.
 *
 * @return   {StoreDescriptor<ReduxStoreConfig<State,Actions,Selectors>>} Store Object.
 */
function createReduxStore(key, options) {
  const privateActions = {};
  const privateSelectors = {};
  const privateRegistrationFunctions = {
    privateActions,
    registerPrivateActions: actions => {
      Object.assign(privateActions, actions);
    },
    privateSelectors,
    registerPrivateSelectors: selectors => {
      Object.assign(privateSelectors, selectors);
    }
  };
  const storeDescriptor = {
    name: key,
    instantiate: registry => {
      /**
       * Stores listener functions registered with `subscribe()`.
       *
       * When functions register to listen to store changes with
       * `subscribe()` they get added here. Although Redux offers
       * its own `subscribe()` function directly, by wrapping the
       * subscription in this store instance it's possible to
       * optimize checking if the state has changed before calling
       * each listener.
       *
       * @type {Set<ListenerFunction>}
       */
      const listeners = new Set();
      const reducer = options.reducer;
      const thunkArgs = {
        registry,
        get dispatch() {
          return thunkActions;
        },
        get select() {
          return thunkSelectors;
        },
        get resolveSelect() {
          return getResolveSelectors();
        }
      };
      const store = instantiateReduxStore(key, options, registry, thunkArgs);
      // Expose the private registration functions on the store
      // so they can be copied to a sub registry in registry.js.
      lock_unlock_lock(store, privateRegistrationFunctions);
      const resolversCache = createResolversCache();
      function bindAction(action) {
        return (...args) => Promise.resolve(store.dispatch(action(...args)));
      }
      const actions = {
        ...redux_store_mapValues(metadata_actions_namespaceObject, bindAction),
        ...redux_store_mapValues(options.actions, bindAction)
      };
      const boundPrivateActions = createBindingCache(bindAction);
      const allActions = new Proxy(() => {}, {
        get: (target, prop) => {
          const privateAction = privateActions[prop];
          return privateAction ? boundPrivateActions.get(privateAction, prop) : actions[prop];
        }
      });
      const thunkActions = new Proxy(allActions, {
        apply: (target, thisArg, [action]) => store.dispatch(action)
      });
      lock_unlock_lock(actions, allActions);
      const resolvers = options.resolvers ? mapResolvers(options.resolvers) : {};
      function bindSelector(selector, selectorName) {
        if (selector.isRegistrySelector) {
          selector.registry = registry;
        }
        const boundSelector = (...args) => {
          args = normalize(selector, args);
          const state = store.__unstableOriginalGetState();
          // Before calling the selector, switch to the correct
          // registry.
          if (selector.isRegistrySelector) {
            selector.registry = registry;
          }
          return selector(state.root, ...args);
        };

        // Expose normalization method on the bound selector
        // in order that it can be called when fullfilling
        // the resolver.
        boundSelector.__unstableNormalizeArgs = selector.__unstableNormalizeArgs;
        const resolver = resolvers[selectorName];
        if (!resolver) {
          boundSelector.hasResolver = false;
          return boundSelector;
        }
        return mapSelectorWithResolver(boundSelector, selectorName, resolver, store, resolversCache);
      }
      function bindMetadataSelector(metaDataSelector) {
        const boundSelector = (...args) => {
          const state = store.__unstableOriginalGetState();
          const originalSelectorName = args && args[0];
          const originalSelectorArgs = args && args[1];
          const targetSelector = options?.selectors?.[originalSelectorName];

          // Normalize the arguments passed to the target selector.
          if (originalSelectorName && targetSelector) {
            args[1] = normalize(targetSelector, originalSelectorArgs);
          }
          return metaDataSelector(state.metadata, ...args);
        };
        boundSelector.hasResolver = false;
        return boundSelector;
      }
      const selectors = {
        ...redux_store_mapValues(metadata_selectors_namespaceObject, bindMetadataSelector),
        ...redux_store_mapValues(options.selectors, bindSelector)
      };
      const boundPrivateSelectors = createBindingCache(bindSelector);

      // Pre-bind the private selectors that have been registered by the time of
      // instantiation, so that registry selectors are bound to the registry.
      for (const [selectorName, selector] of Object.entries(privateSelectors)) {
        boundPrivateSelectors.get(selector, selectorName);
      }
      const allSelectors = new Proxy(() => {}, {
        get: (target, prop) => {
          const privateSelector = privateSelectors[prop];
          return privateSelector ? boundPrivateSelectors.get(privateSelector, prop) : selectors[prop];
        }
      });
      const thunkSelectors = new Proxy(allSelectors, {
        apply: (target, thisArg, [selector]) => selector(store.__unstableOriginalGetState())
      });
      lock_unlock_lock(selectors, allSelectors);
      const resolveSelectors = mapResolveSelectors(selectors, store);
      const suspendSelectors = mapSuspendSelectors(selectors, store);
      const getSelectors = () => selectors;
      const getActions = () => actions;
      const getResolveSelectors = () => resolveSelectors;
      const getSuspendSelectors = () => suspendSelectors;

      // We have some modules monkey-patching the store object
      // It's wrong to do so but until we refactor all of our effects to controls
      // We need to keep the same "store" instance here.
      store.__unstableOriginalGetState = store.getState;
      store.getState = () => store.__unstableOriginalGetState().root;

      // Customize subscribe behavior to call listeners only on effective change,
      // not on every dispatch.
      const subscribe = store && (listener => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      });
      let lastState = store.__unstableOriginalGetState();
      store.subscribe(() => {
        const state = store.__unstableOriginalGetState();
        const hasChanged = state !== lastState;
        lastState = state;
        if (hasChanged) {
          for (const listener of listeners) {
            listener();
          }
        }
      });

      // This can be simplified to just { subscribe, getSelectors, getActions }
      // Once we remove the use function.
      return {
        reducer,
        store,
        actions,
        selectors,
        resolvers,
        getSelectors,
        getResolveSelectors,
        getSuspendSelectors,
        getActions,
        subscribe
      };
    }
  };

  // Expose the private registration functions on the store
  // descriptor. That's a natural choice since that's where the
  // public actions and selectors are stored .
  lock_unlock_lock(storeDescriptor, privateRegistrationFunctions);
  return storeDescriptor;
}

/**
 * Creates a redux store for a namespace.
 *
 * @param {string}       key       Unique namespace identifier.
 * @param {Object}       options   Registered store options, with properties
 *                                 describing reducer, actions, selectors,
 *                                 and resolvers.
 * @param {DataRegistry} registry  Registry reference.
 * @param {Object}       thunkArgs Argument object for the thunk middleware.
 * @return {Object} Newly created redux store.
 */
function instantiateReduxStore(key, options, registry, thunkArgs) {
  const controls = {
    ...options.controls,
    ...builtinControls
  };
  const normalizedControls = redux_store_mapValues(controls, control => control.isRegistryControl ? control(registry) : control);
  const middlewares = [resolvers_cache_middleware(registry, key), promise_middleware, createMiddleware(normalizedControls), createThunkMiddleware(thunkArgs)];
  const enhancers = [(0,redux/* applyMiddleware */.Tw)(...middlewares)];
  if (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
    enhancers.push(window.__REDUX_DEVTOOLS_EXTENSION__({
      name: key,
      instanceId: key,
      serialize: {
        replacer: devToolsReplacer
      }
    }));
  }
  const {
    reducer,
    initialState
  } = options;
  const enhancedReducer = combineReducers({
    metadata: metadata_reducer,
    root: reducer
  });
  return (0,redux/* createStore */.y$)(enhancedReducer, {
    root: initialState
  }, higher_order_compose(enhancers));
}

/**
 * Maps selectors to functions that return a resolution promise for them
 *
 * @param {Object} selectors Selectors to map.
 * @param {Object} store     The redux store the selectors select from.
 *
 * @return {Object} Selectors mapped to their resolution functions.
 */
function mapResolveSelectors(selectors, store) {
  const {
    getIsResolving,
    hasStartedResolution,
    hasFinishedResolution,
    hasResolutionFailed,
    isResolving,
    getCachedResolvers,
    getResolutionState,
    getResolutionError,
    hasResolvingSelectors,
    countSelectorsByStatus,
    ...storeSelectors
  } = selectors;
  return redux_store_mapValues(storeSelectors, (selector, selectorName) => {
    // If the selector doesn't have a resolver, just convert the return value
    // (including exceptions) to a Promise, no additional extra behavior is needed.
    if (!selector.hasResolver) {
      return async (...args) => selector.apply(null, args);
    }
    return (...args) => {
      return new Promise((resolve, reject) => {
        const hasFinished = () => selectors.hasFinishedResolution(selectorName, args);
        const finalize = result => {
          const hasFailed = selectors.hasResolutionFailed(selectorName, args);
          if (hasFailed) {
            const error = selectors.getResolutionError(selectorName, args);
            reject(error);
          } else {
            resolve(result);
          }
        };
        const getResult = () => selector.apply(null, args);
        // Trigger the selector (to trigger the resolver)
        const result = getResult();
        if (hasFinished()) {
          return finalize(result);
        }
        const unsubscribe = store.subscribe(() => {
          if (hasFinished()) {
            unsubscribe();
            finalize(getResult());
          }
        });
      });
    };
  });
}

/**
 * Maps selectors to functions that throw a suspense promise if not yet resolved.
 *
 * @param {Object} selectors Selectors to map.
 * @param {Object} store     The redux store the selectors select from.
 *
 * @return {Object} Selectors mapped to their suspense functions.
 */
function mapSuspendSelectors(selectors, store) {
  return redux_store_mapValues(selectors, (selector, selectorName) => {
    // Selector without a resolver doesn't have any extra suspense behavior.
    if (!selector.hasResolver) {
      return selector;
    }
    return (...args) => {
      const result = selector.apply(null, args);
      if (selectors.hasFinishedResolution(selectorName, args)) {
        if (selectors.hasResolutionFailed(selectorName, args)) {
          throw selectors.getResolutionError(selectorName, args);
        }
        return result;
      }
      throw new Promise(resolve => {
        const unsubscribe = store.subscribe(() => {
          if (selectors.hasFinishedResolution(selectorName, args)) {
            resolve();
            unsubscribe();
          }
        });
      });
    };
  });
}

/**
 * Convert resolvers to a normalized form, an object with `fulfill` method and
 * optional methods like `isFulfilled`.
 *
 * @param {Object} resolvers Resolver to convert
 */
function mapResolvers(resolvers) {
  return redux_store_mapValues(resolvers, resolver => {
    if (resolver.fulfill) {
      return resolver;
    }
    return {
      ...resolver,
      // Copy the enumerable properties of the resolver function.
      fulfill: resolver // Add the fulfill method.
    };
  });
}

/**
 * Returns a selector with a matched resolver.
 * Resolvers are side effects invoked once per argument set of a given selector call,
 * used in ensuring that the data needs for the selector are satisfied.
 *
 * @param {Object} selector       The selector function to be bound.
 * @param {string} selectorName   The selector name.
 * @param {Object} resolver       Resolver to call.
 * @param {Object} store          The redux store to which the resolvers should be mapped.
 * @param {Object} resolversCache Resolvers Cache.
 */
function mapSelectorWithResolver(selector, selectorName, resolver, store, resolversCache) {
  function fulfillSelector(args) {
    const state = store.getState();
    if (resolversCache.isRunning(selectorName, args) || typeof resolver.isFulfilled === 'function' && resolver.isFulfilled(state, ...args)) {
      return;
    }
    const {
      metadata
    } = store.__unstableOriginalGetState();
    if (hasStartedResolution(metadata, selectorName, args)) {
      return;
    }
    resolversCache.markAsRunning(selectorName, args);
    setTimeout(async () => {
      resolversCache.clear(selectorName, args);
      store.dispatch(startResolution(selectorName, args));
      try {
        const action = resolver.fulfill(...args);
        if (action) {
          await store.dispatch(action);
        }
        store.dispatch(finishResolution(selectorName, args));
      } catch (error) {
        store.dispatch(failResolution(selectorName, args, error));
      }
    }, 0);
  }
  const selectorResolver = (...args) => {
    args = normalize(selector, args);
    fulfillSelector(args);
    return selector(...args);
  };
  selectorResolver.hasResolver = true;
  return selectorResolver;
}

/**
 * Applies selector's normalization function to the given arguments
 * if it exists.
 *
 * @param {Object} selector The selector potentially with a normalization method property.
 * @param {Array}  args     selector arguments to normalize.
 * @return {Array} Potentially normalized arguments.
 */
function normalize(selector, args) {
  if (selector.__unstableNormalizeArgs && typeof selector.__unstableNormalizeArgs === 'function' && args?.length) {
    return selector.__unstableNormalizeArgs(args);
  }
  return args;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/store/index.js
const coreDataStore = {
  name: 'core/data',
  instantiate(registry) {
    const getCoreDataSelector = selectorName => (key, ...args) => {
      return registry.select(key)[selectorName](...args);
    };
    const getCoreDataAction = actionName => (key, ...args) => {
      return registry.dispatch(key)[actionName](...args);
    };
    return {
      getSelectors() {
        return Object.fromEntries(['getIsResolving', 'hasStartedResolution', 'hasFinishedResolution', 'isResolving', 'getCachedResolvers'].map(selectorName => [selectorName, getCoreDataSelector(selectorName)]));
      },
      getActions() {
        return Object.fromEntries(['startResolution', 'finishResolution', 'invalidateResolution', 'invalidateResolutionForStore', 'invalidateResolutionForStoreSelector'].map(actionName => [actionName, getCoreDataAction(actionName)]));
      },
      subscribe() {
        // There's no reasons to trigger any listener when we subscribe to this store
        // because there's no state stored in this store that need to retrigger selectors
        // if a change happens, the corresponding store where the tracking stated live
        // would have already triggered a "subscribe" call.
        return () => () => {};
      }
    };
  }
};
/* harmony default export */ const build_module_store = (coreDataStore);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/utils/emitter.js
/**
 * Create an event emitter.
 *
 * @return {import("../types").DataEmitter} Emitter.
 */
function createEmitter() {
  let isPaused = false;
  let isPending = false;
  const listeners = new Set();
  const notifyListeners = () =>
  // We use Array.from to clone the listeners Set
  // This ensures that we don't run a listener
  // that was added as a response to another listener.
  Array.from(listeners).forEach(listener => listener());
  return {
    get isPaused() {
      return isPaused;
    },
    subscribe(listener) {
      listeners.add(listener);
      return () => listeners.delete(listener);
    },
    pause() {
      isPaused = true;
    },
    resume() {
      isPaused = false;
      if (isPending) {
        isPending = false;
        notifyListeners();
      }
    },
    emit() {
      if (isPaused) {
        isPending = true;
        return;
      }
      notifyListeners();
    }
  };
}
//# sourceMappingURL=emitter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/registry.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/** @typedef {import('./types').StoreDescriptor} StoreDescriptor */

/**
 * @typedef {Object} WPDataRegistry An isolated orchestrator of store registrations.
 *
 * @property {Function} registerGenericStore Given a namespace key and settings
 *                                           object, registers a new generic
 *                                           store.
 * @property {Function} registerStore        Given a namespace key and settings
 *                                           object, registers a new namespace
 *                                           store.
 * @property {Function} subscribe            Given a function callback, invokes
 *                                           the callback on any change to state
 *                                           within any registered store.
 * @property {Function} select               Given a namespace key, returns an
 *                                           object of the  store's registered
 *                                           selectors.
 * @property {Function} dispatch             Given a namespace key, returns an
 *                                           object of the store's registered
 *                                           action dispatchers.
 */

/**
 * @typedef {Object} WPDataPlugin An object of registry function overrides.
 *
 * @property {Function} registerStore registers store.
 */

function getStoreName(storeNameOrDescriptor) {
  return typeof storeNameOrDescriptor === 'string' ? storeNameOrDescriptor : storeNameOrDescriptor.name;
}
/**
 * Creates a new store registry, given an optional object of initial store
 * configurations.
 *
 * @param {Object}  storeConfigs Initial store configurations.
 * @param {Object?} parent       Parent registry.
 *
 * @return {WPDataRegistry} Data registry.
 */
function createRegistry(storeConfigs = {}, parent = null) {
  const stores = {};
  const emitter = createEmitter();
  let listeningStores = null;

  /**
   * Global listener called for each store's update.
   */
  function globalListener() {
    emitter.emit();
  }

  /**
   * Subscribe to changes to any data, either in all stores in registry, or
   * in one specific store.
   *
   * @param {Function}                listener              Listener function.
   * @param {string|StoreDescriptor?} storeNameOrDescriptor Optional store name.
   *
   * @return {Function} Unsubscribe function.
   */
  const subscribe = (listener, storeNameOrDescriptor) => {
    // subscribe to all stores
    if (!storeNameOrDescriptor) {
      return emitter.subscribe(listener);
    }

    // subscribe to one store
    const storeName = getStoreName(storeNameOrDescriptor);
    const store = stores[storeName];
    if (store) {
      return store.subscribe(listener);
    }

    // Trying to access a store that hasn't been registered,
    // this is a pattern rarely used but seen in some places.
    // We fallback to global `subscribe` here for backward-compatibility for now.
    // See https://github.com/WordPress/gutenberg/pull/27466 for more info.
    if (!parent) {
      return emitter.subscribe(listener);
    }
    return parent.subscribe(listener, storeNameOrDescriptor);
  };

  /**
   * Calls a selector given the current state and extra arguments.
   *
   * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store
   *                                                       or the store descriptor.
   *
   * @return {*} The selector's returned value.
   */
  function select(storeNameOrDescriptor) {
    const storeName = getStoreName(storeNameOrDescriptor);
    listeningStores?.add(storeName);
    const store = stores[storeName];
    if (store) {
      return store.getSelectors();
    }
    return parent?.select(storeName);
  }
  function __unstableMarkListeningStores(callback, ref) {
    listeningStores = new Set();
    try {
      return callback.call(this);
    } finally {
      ref.current = Array.from(listeningStores);
      listeningStores = null;
    }
  }

  /**
   * Given a store descriptor, returns an object containing the store's selectors pre-bound to
   * state so that you only need to supply additional arguments, and modified so that they return
   * promises that resolve to their eventual values, after any resolvers have ran.
   *
   * @param {StoreDescriptor|string} storeNameOrDescriptor The store descriptor. The legacy calling
   *                                                       convention of passing the store name is
   *                                                       also supported.
   *
   * @return {Object} Each key of the object matches the name of a selector.
   */
  function resolveSelect(storeNameOrDescriptor) {
    const storeName = getStoreName(storeNameOrDescriptor);
    listeningStores?.add(storeName);
    const store = stores[storeName];
    if (store) {
      return store.getResolveSelectors();
    }
    return parent && parent.resolveSelect(storeName);
  }

  /**
   * Given a store descriptor, returns an object containing the store's selectors pre-bound to
   * state so that you only need to supply additional arguments, and modified so that they throw
   * promises in case the selector is not resolved yet.
   *
   * @param {StoreDescriptor|string} storeNameOrDescriptor The store descriptor. The legacy calling
   *                                                       convention of passing the store name is
   *                                                       also supported.
   *
   * @return {Object} Object containing the store's suspense-wrapped selectors.
   */
  function suspendSelect(storeNameOrDescriptor) {
    const storeName = getStoreName(storeNameOrDescriptor);
    listeningStores?.add(storeName);
    const store = stores[storeName];
    if (store) {
      return store.getSuspendSelectors();
    }
    return parent && parent.suspendSelect(storeName);
  }

  /**
   * Returns the available actions for a part of the state.
   *
   * @param {string|StoreDescriptor} storeNameOrDescriptor Unique namespace identifier for the store
   *                                                       or the store descriptor.
   *
   * @return {*} The action's returned value.
   */
  function dispatch(storeNameOrDescriptor) {
    const storeName = getStoreName(storeNameOrDescriptor);
    const store = stores[storeName];
    if (store) {
      return store.getActions();
    }
    return parent && parent.dispatch(storeName);
  }

  //
  // Deprecated
  // TODO: Remove this after `use()` is removed.
  function withPlugins(attributes) {
    return Object.fromEntries(Object.entries(attributes).map(([key, attribute]) => {
      if (typeof attribute !== 'function') {
        return [key, attribute];
      }
      return [key, function () {
        return registry[key].apply(null, arguments);
      }];
    }));
  }

  /**
   * Registers a store instance.
   *
   * @param {string}   name        Store registry name.
   * @param {Function} createStore Function that creates a store object (getSelectors, getActions, subscribe).
   */
  function registerStoreInstance(name, createStore) {
    if (stores[name]) {
      // eslint-disable-next-line no-console
      console.error('Store "' + name + '" is already registered.');
      return stores[name];
    }
    const store = createStore();
    if (typeof store.getSelectors !== 'function') {
      throw new TypeError('store.getSelectors must be a function');
    }
    if (typeof store.getActions !== 'function') {
      throw new TypeError('store.getActions must be a function');
    }
    if (typeof store.subscribe !== 'function') {
      throw new TypeError('store.subscribe must be a function');
    }
    // The emitter is used to keep track of active listeners when the registry
    // get paused, that way, when resumed we should be able to call all these
    // pending listeners.
    store.emitter = createEmitter();
    const currentSubscribe = store.subscribe;
    store.subscribe = listener => {
      const unsubscribeFromEmitter = store.emitter.subscribe(listener);
      const unsubscribeFromStore = currentSubscribe(() => {
        if (store.emitter.isPaused) {
          store.emitter.emit();
          return;
        }
        listener();
      });
      return () => {
        unsubscribeFromStore?.();
        unsubscribeFromEmitter?.();
      };
    };
    stores[name] = store;
    store.subscribe(globalListener);

    // Copy private actions and selectors from the parent store.
    if (parent) {
      try {
        lock_unlock_unlock(store.store).registerPrivateActions(lock_unlock_unlock(parent).privateActionsOf(name));
        lock_unlock_unlock(store.store).registerPrivateSelectors(lock_unlock_unlock(parent).privateSelectorsOf(name));
      } catch (e) {
        // unlock() throws if store.store was not locked.
        // The error indicates there's nothing to do here so let's
        // ignore it.
      }
    }
    return store;
  }

  /**
   * Registers a new store given a store descriptor.
   *
   * @param {StoreDescriptor} store Store descriptor.
   */
  function register(store) {
    registerStoreInstance(store.name, () => store.instantiate(registry));
  }
  function registerGenericStore(name, store) {
    deprecated('wp.data.registerGenericStore', {
      since: '5.9',
      alternative: 'wp.data.register( storeDescriptor )'
    });
    registerStoreInstance(name, () => store);
  }

  /**
   * Registers a standard `@wordpress/data` store.
   *
   * @param {string} storeName Unique namespace identifier.
   * @param {Object} options   Store description (reducer, actions, selectors, resolvers).
   *
   * @return {Object} Registered store object.
   */
  function registerStore(storeName, options) {
    if (!options.reducer) {
      throw new TypeError('Must specify store reducer');
    }
    const store = registerStoreInstance(storeName, () => createReduxStore(storeName, options).instantiate(registry));
    return store.store;
  }
  function batch(callback) {
    // If we're already batching, just call the callback.
    if (emitter.isPaused) {
      callback();
      return;
    }
    emitter.pause();
    Object.values(stores).forEach(store => store.emitter.pause());
    callback();
    emitter.resume();
    Object.values(stores).forEach(store => store.emitter.resume());
  }
  let registry = {
    batch,
    stores,
    namespaces: stores,
    // TODO: Deprecate/remove this.
    subscribe,
    select,
    resolveSelect,
    suspendSelect,
    dispatch,
    use,
    register,
    registerGenericStore,
    registerStore,
    __unstableMarkListeningStores
  };

  //
  // TODO:
  // This function will be deprecated as soon as it is no longer internally referenced.
  function use(plugin, options) {
    if (!plugin) {
      return;
    }
    registry = {
      ...registry,
      ...plugin(registry, options)
    };
    return registry;
  }
  registry.register(build_module_store);
  for (const [name, config] of Object.entries(storeConfigs)) {
    registry.register(createReduxStore(name, config));
  }
  if (parent) {
    parent.subscribe(globalListener);
  }
  const registryWithPlugins = withPlugins(registry);
  lock_unlock_lock(registryWithPlugins, {
    privateActionsOf: name => {
      try {
        return lock_unlock_unlock(stores[name].store).privateActions;
      } catch (e) {
        // unlock() throws an error the store was not locked – this means
        // there no private actions are available
        return {};
      }
    },
    privateSelectorsOf: name => {
      try {
        return lock_unlock_unlock(stores[name].store).privateSelectors;
      } catch (e) {
        return {};
      }
    }
  });
  return registryWithPlugins;
}
//# sourceMappingURL=registry.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/default-registry.js
/**
 * Internal dependencies
 */

/* harmony default export */ const build_module_default_registry = (createRegistry());
//# sourceMappingURL=default-registry.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@9.27.0_react@17.0.2/node_modules/@wordpress/data/build-module/index.js
/**
 * Internal dependencies
 */




/** @typedef {import('./types').StoreDescriptor} StoreDescriptor */
















/**
 * Object of available plugins to use with a registry.
 *
 * @see [use](#use)
 *
 * @type {Object}
 */


/**
 * The combineReducers helper function turns an object whose values are different
 * reducing functions into a single reducing function you can pass to registerReducer.
 *
 * @type  {import('./types').combineReducers}
 * @param {Object} reducers An object whose values correspond to different reducing
 *                          functions that need to be combined into one.
 *
 * @example
 * ```js
 * import { combineReducers, createReduxStore, register } from '@wordpress/data';
 *
 * const prices = ( state = {}, action ) => {
 * 	return action.type === 'SET_PRICE' ?
 * 		{
 * 			...state,
 * 			[ action.item ]: action.price,
 * 		} :
 * 		state;
 * };
 *
 * const discountPercent = ( state = 0, action ) => {
 * 	return action.type === 'START_SALE' ?
 * 		action.discountPercent :
 * 		state;
 * };
 *
 * const store = createReduxStore( 'my-shop', {
 * 	reducer: combineReducers( {
 * 		prices,
 * 		discountPercent,
 * 	} ),
 * } );
 * register( store );
 * ```
 *
 * @return {Function} A reducer that invokes every reducer inside the reducers
 *                    object, and constructs a state object with the same shape.
 */
const build_module_combineReducers = (/* unused pure expression or super */ null && (combineReducersModule));

/**
 * Given a store descriptor, returns an object containing the store's selectors pre-bound to state
 * so that you only need to supply additional arguments, and modified so that they return promises
 * that resolve to their eventual values, after any resolvers have ran.
 *
 * @param {StoreDescriptor|string} storeNameOrDescriptor The store descriptor. The legacy calling
 *                                                       convention of passing the store name is
 *                                                       also supported.
 *
 * @example
 * ```js
 * import { resolveSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * resolveSelect( myCustomStore ).getPrice( 'hammer' ).then(console.log)
 * ```
 *
 * @return {Object} Object containing the store's promise-wrapped selectors.
 */
const build_module_resolveSelect = build_module_default_registry.resolveSelect;

/**
 * Given a store descriptor, returns an object containing the store's selectors pre-bound to state
 * so that you only need to supply additional arguments, and modified so that they throw promises
 * in case the selector is not resolved yet.
 *
 * @param {StoreDescriptor|string} storeNameOrDescriptor The store descriptor. The legacy calling
 *                                                       convention of passing the store name is
 *                                                       also supported.
 *
 * @return {Object} Object containing the store's suspense-wrapped selectors.
 */
const suspendSelect = build_module_default_registry.suspendSelect;

/**
 * Given a listener function, the function will be called any time the state value
 * of one of the registered stores has changed. If you specify the optional
 * `storeNameOrDescriptor` parameter, the listener function will be called only
 * on updates on that one specific registered store.
 *
 * This function returns an `unsubscribe` function used to stop the subscription.
 *
 * @param {Function}                listener              Callback function.
 * @param {string|StoreDescriptor?} storeNameOrDescriptor Optional store name.
 *
 * @example
 * ```js
 * import { subscribe } from '@wordpress/data';
 *
 * const unsubscribe = subscribe( () => {
 * 	// You could use this opportunity to test whether the derived result of a
 * 	// selector has subsequently changed as the result of a state update.
 * } );
 *
 * // Later, if necessary...
 * unsubscribe();
 * ```
 */
const subscribe = build_module_default_registry.subscribe;

/**
 * Registers a generic store instance.
 *
 * @deprecated Use `register( storeDescriptor )` instead.
 *
 * @param {string} name  Store registry name.
 * @param {Object} store Store instance (`{ getSelectors, getActions, subscribe }`).
 */
const registerGenericStore = build_module_default_registry.registerGenericStore;

/**
 * Registers a standard `@wordpress/data` store.
 *
 * @deprecated Use `register` instead.
 *
 * @param {string} storeName Unique namespace identifier for the store.
 * @param {Object} options   Store description (reducer, actions, selectors, resolvers).
 *
 * @return {Object} Registered store object.
 */
const registerStore = build_module_default_registry.registerStore;

/**
 * Extends a registry to inherit functionality provided by a given plugin. A
 * plugin is an object with properties aligning to that of a registry, merged
 * to extend the default registry behavior.
 *
 * @param {Object} plugin Plugin object.
 */
const use = build_module_default_registry.use;

/**
 * Registers a standard `@wordpress/data` store descriptor.
 *
 * @example
 * ```js
 * import { createReduxStore, register } from '@wordpress/data';
 *
 * const store = createReduxStore( 'demo', {
 *     reducer: ( state = 'OK' ) => state,
 *     selectors: {
 *         getValue: ( state ) => state,
 *     },
 * } );
 * register( store );
 * ```
 *
 * @param {StoreDescriptor} store Store descriptor.
 */
const register = build_module_default_registry.register;
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/utils/on-sub-key.js
/**
 * Higher-order reducer creator which creates a combined reducer object, keyed
 * by a property on the action object.
 *
 * @param {string} actionProperty Action property by which to key object.
 *
 * @return {Function} Higher-order reducer.
 */
const on_sub_key_onSubKey = actionProperty => reducer => function () {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;
  // Retrieve subkey from action. Do not track if undefined; useful for cases
  // where reducer is scoped by action shape.
  const key = action[actionProperty];

  if (key === undefined) {
    return state;
  } // Avoid updating state if unchanged. Note that this also accounts for a
  // reducer which returns undefined on a key which is not yet tracked.


  const nextKeyState = reducer(state[key], action);

  if (nextKeyState === state[key]) {
    return state;
  }

  return { ...state,
    [key]: nextKeyState
  };
};
/* harmony default export */ const on_sub_key = (on_sub_key_onSubKey);
//# sourceMappingURL=on-sub-key.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/reducer.js
/**
 * Internal dependencies
 */

/**
 * Reducer returning the next notices state. The notices state is an object
 * where each key is a context, its value an array of notice objects.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

const notices = on_sub_key('context')(function () {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'CREATE_NOTICE':
      // Avoid duplicates on ID.
      return [...state.filter(_ref => {
        let {
          id
        } = _ref;
        return id !== action.notice.id;
      }), action.notice];

    case 'REMOVE_NOTICE':
      return state.filter(_ref2 => {
        let {
          id
        } = _ref2;
        return id !== action.id;
      });
  }

  return state;
});
/* harmony default export */ const notices_build_module_store_reducer = (notices);
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/constants.js
/**
 * Default context to use for notice grouping when not otherwise specified. Its
 * specific value doesn't hold much meaning, but it must be reasonably unique
 * and, more importantly, referenced consistently in the store implementation.
 *
 * @type {string}
 */
const DEFAULT_CONTEXT = 'global';
/**
 * Default notice status.
 *
 * @type {string}
 */

const DEFAULT_STATUS = 'info';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/actions.js
/**
 * Internal dependencies
 */

/**
 * @typedef {Object} WPNoticeAction Object describing a user action option associated with a notice.
 *
 * @property {string}    label   Message to use as action label.
 * @property {?string}   url     Optional URL of resource if action incurs
 *                               browser navigation.
 * @property {?Function} onClick Optional function to invoke when action is
 *                               triggered by user.
 *
 */

let uniqueId = 0;
/**
 * Returns an action object used in signalling that a notice is to be created.
 *
 * @param {string}                [status='info']              Notice status.
 * @param {string}                content                      Notice message.
 * @param {Object}                [options]                    Notice options.
 * @param {string}                [options.context='global']   Context under which to
 *                                                             group notice.
 * @param {string}                [options.id]                 Identifier for notice.
 *                                                             Automatically assigned
 *                                                             if not specified.
 * @param {boolean}               [options.isDismissible=true] Whether the notice can
 *                                                             be dismissed by user.
 * @param {string}                [options.type='default']     Type of notice, one of
 *                                                             `default`, or `snackbar`.
 * @param {boolean}               [options.speak=true]         Whether the notice
 *                                                             content should be
 *                                                             announced to screen
 *                                                             readers.
 * @param {Array<WPNoticeAction>} [options.actions]            User actions to be
 *                                                             presented with notice.
 * @param {string}                [options.icon]               An icon displayed with the notice.
 *                                                             Only used when type is set to `snackbar`.
 * @param {boolean}               [options.explicitDismiss]    Whether the notice includes
 *                                                             an explicit dismiss button and
 *                                                             can't be dismissed by clicking
 *                                                             the body of the notice. Only applies
 *                                                             when type is set to `snackbar`.
 * @param {Function}              [options.onDismiss]          Called when the notice is dismissed.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () => createNotice( 'success', __( 'Notice message' ) ) }
 *         >
 *             { __( 'Generate a success notice!' ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */

function createNotice() {
  let status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATUS;
  let content = arguments.length > 1 ? arguments[1] : undefined;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    speak = true,
    isDismissible = true,
    context = DEFAULT_CONTEXT,
    id = `${context}${++uniqueId}`,
    actions = [],
    type = 'default',
    __unstableHTML,
    icon = null,
    explicitDismiss = false,
    onDismiss
  } = options; // The supported value shape of content is currently limited to plain text
  // strings. To avoid setting expectation that e.g. a WPElement could be
  // supported, cast to a string.

  content = String(content);
  return {
    type: 'CREATE_NOTICE',
    context,
    notice: {
      id,
      status,
      content,
      spokenMessage: speak ? content : null,
      __unstableHTML,
      isDismissible,
      actions,
      type,
      icon,
      explicitDismiss,
      onDismiss
    }
  };
}
/**
 * Returns an action object used in signalling that a success notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createSuccessNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 createSuccessNotice( __( 'Success!' ), {
 *                     type: 'snackbar',
 *                     icon: '🔥',
 *                 } )
 *             }
 *         >
 *             { __( 'Generate a snackbar success notice!' ) }
 *        </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */

function createSuccessNotice(content, options) {
  return createNotice('success', content, options);
}
/**
 * Returns an action object used in signalling that an info notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createInfoNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                createInfoNotice( __( 'Something happened!' ), {
 *                   isDismissible: false,
 *                } )
 *             }
 *         >
 *         { __( 'Generate a notice that cannot be dismissed.' ) }
 *       </Button>
 *       );
 * };
 *```
 *
 * @return {Object} Action object.
 */

function createInfoNotice(content, options) {
  return createNotice('info', content, options);
}
/**
 * Returns an action object used in signalling that an error notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createErrorNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 createErrorNotice( __( 'An error occurred!' ), {
 *                     type: 'snackbar',
 *                     explicitDismiss: true,
 *                 } )
 *             }
 *         >
 *             { __(
 *                 'Generate an snackbar error notice with explicit dismiss button.'
 *             ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */

function createErrorNotice(content, options) {
  return createNotice('error', content, options);
}
/**
 * Returns an action object used in signalling that a warning notice is to be
 * created. Refer to `createNotice` for options documentation.
 *
 * @see createNotice
 *
 * @param {string} content   Notice message.
 * @param {Object} [options] Optional notice options.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     const { createWarningNotice, createInfoNotice } = useDispatch( noticesStore );
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 createWarningNotice( __( 'Warning!' ), {
 *                     onDismiss: () => {
 *                         createInfoNotice(
 *                             __( 'The warning has been dismissed!' )
 *                         );
 *                     },
 *                 } )
 *             }
 *         >
 *             { __( 'Generates a warning notice with onDismiss callback' ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {Object} Action object.
 */

function createWarningNotice(content, options) {
  return createNotice('warning', content, options);
}
/**
 * Returns an action object used in signalling that a notice is to be removed.
 *
 * @param {string} id                 Notice unique identifier.
 * @param {string} [context='global'] Optional context (grouping) in which the notice is
 *                                    intended to appear. Defaults to default context.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { useDispatch } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *    const notices = useSelect( ( select ) => select( noticesStore ).getNotices() );
 *    const { createWarningNotice, removeNotice } = useDispatch( noticesStore );
 *
 *    return (
 *         <>
 *             <Button
 *                 onClick={ () =>
 *                     createWarningNotice( __( 'Warning!' ), {
 *                         isDismissible: false,
 *                     } )
 *                 }
 *             >
 *                 { __( 'Generate a notice' ) }
 *             </Button>
 *             { notices.length > 0 && (
 *                 <Button onClick={ () => removeNotice( notices[ 0 ].id ) }>
 *                     { __( 'Remove the notice' ) }
 *                 </Button>
 *             ) }
 *         </>
 *     );
 *};
 * ```
 *
 * @return {Object} Action object.
 */

function removeNotice(id) {
  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CONTEXT;
  return {
    type: 'REMOVE_NOTICE',
    id,
    context
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/selectors.js
/**
 * Internal dependencies
 */

/** @typedef {import('./actions').WPNoticeAction} WPNoticeAction */

/**
 * The default empty set of notices to return when there are no notices
 * assigned for a given notices context. This can occur if the getNotices
 * selector is called without a notice ever having been created for the
 * context. A shared value is used to ensure referential equality between
 * sequential selector calls, since otherwise `[] !== []`.
 *
 * @type {Array}
 */

const DEFAULT_NOTICES = [];
/**
 * @typedef {Object} WPNotice Notice object.
 *
 * @property {string}           id             Unique identifier of notice.
 * @property {string}           status         Status of notice, one of `success`,
 *                                             `info`, `error`, or `warning`. Defaults
 *                                             to `info`.
 * @property {string}           content        Notice message.
 * @property {string}           spokenMessage  Audibly announced message text used by
 *                                             assistive technologies.
 * @property {string}           __unstableHTML Notice message as raw HTML. Intended to
 *                                             serve primarily for compatibility of
 *                                             server-rendered notices, and SHOULD NOT
 *                                             be used for notices. It is subject to
 *                                             removal without notice.
 * @property {boolean}          isDismissible  Whether the notice can be dismissed by
 *                                             user. Defaults to `true`.
 * @property {string}           type           Type of notice, one of `default`,
 *                                             or `snackbar`. Defaults to `default`.
 * @property {boolean}          speak          Whether the notice content should be
 *                                             announced to screen readers. Defaults to
 *                                             `true`.
 * @property {WPNoticeAction[]} actions        User actions to present with notice.
 *
 */

/**
 * Returns all notices as an array, optionally for a given context. Defaults to
 * the global context.
 *
 * @param {Object}  state   Notices state.
 * @param {?string} context Optional grouping context.
 *
 * @example
 *
 *```js
 * import { useSelect } from '@wordpress/data';
 * import { store as noticesStore } from '@wordpress/notices';
 *
 * const ExampleComponent = () => {
 *     const notices = useSelect( ( select ) => select( noticesStore ).getNotices() );
 *     return (
 *         <ul>
 *         { notices.map( ( notice ) => (
 *             <li key={ notice.ID }>{ notice.content }</li>
 *         ) ) }
 *        </ul>
 *    )
 * };
 *```
 *
 * @return {WPNotice[]} Array of notices.
 */

function getNotices(state) {
  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CONTEXT;
  return state[context] || DEFAULT_NOTICES;
}
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Store definition for the notices namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const notices_build_module_store_store = createReduxStore('core/notices', {
  reducer: notices_build_module_store_reducer,
  actions: notices_build_module_store_actions_namespaceObject,
  selectors: notices_build_module_store_selectors_namespaceObject
});
register(notices_build_module_store_store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+notices@3.31.0_react@17.0.2/node_modules/@wordpress/notices/build-module/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-state.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/**
 * Retrieves the block patterns inserter state.
 *
 * @param {Function} onInsert     function called when inserter a list of blocks.
 * @param {string=}  rootClientId Insertion's root client ID.
 *
 * @return {Array} Returns the patterns state. (patterns, categories, onSelect handler)
 */

const usePatternsState = (onInsert, rootClientId) => {
  const {
    patternCategories,
    patterns
  } = use_select_useSelect(select => {
    const {
      __experimentalGetAllowedPatterns,
      getSettings
    } = select(store_store);
    return {
      patterns: __experimentalGetAllowedPatterns(rootClientId),
      patternCategories: getSettings().__experimentalBlockPatternCategories
    };
  }, [rootClientId]);
  const {
    createSuccessNotice
  } = use_dispatch(notices_build_module_store_store);
  const onClickPattern = (0,react.useCallback)((pattern, blocks) => {
    onInsert((0,lodash.map)(blocks, block => (0,build_module/* cloneBlock */.JB)(block)), pattern.name);
    createSuccessNotice((0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %s: block pattern title. */
    (0,_wordpress_i18n_build_module.__)('Block pattern "%s" inserted.'), pattern.title), {
      type: 'snackbar'
    });
  }, []);
  return [patterns, patternCategories, onClickPattern];
};

/* harmony default export */ const use_patterns_state = (usePatternsState);
//# sourceMappingURL=use-patterns-state.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/Composite.js + 3 modules
var Composite = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Composite/Composite.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-patterns-list/index.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function BlockPattern(_ref) {
  let {
    isDraggable,
    pattern,
    onClick,
    composite
  } = _ref;
  const {
    blocks,
    viewportWidth
  } = pattern;
  const instanceId = (0,use_instance_id/* default */.A)(BlockPattern);
  const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;
  return (0,react.createElement)(inserter_draggable_blocks, {
    isEnabled: isDraggable,
    blocks: blocks
  }, _ref2 => {
    let {
      draggable,
      onDragStart,
      onDragEnd
    } = _ref2;
    return (0,react.createElement)("div", {
      className: "block-editor-block-patterns-list__list-item",
      "aria-label": pattern.title,
      "aria-describedby": pattern.description ? descriptionId : undefined,
      draggable: draggable,
      onDragStart: onDragStart,
      onDragEnd: onDragEnd
    }, (0,react.createElement)(CompositeItem/* CompositeItem */.l, (0,esm_extends/* default */.A)({
      role: "option",
      as: "div"
    }, composite, {
      className: "block-editor-block-patterns-list__item",
      onClick: () => onClick(pattern, blocks)
    }), (0,react.createElement)(block_preview, {
      blocks: blocks,
      viewportWidth: viewportWidth
    }), (0,react.createElement)("div", {
      className: "block-editor-block-patterns-list__item-title"
    }, pattern.title), !!pattern.description && (0,react.createElement)(visually_hidden_component, {
      id: descriptionId
    }, pattern.description)));
  });
}

function BlockPatternPlaceholder() {
  return (0,react.createElement)("div", {
    className: "block-editor-block-patterns-list__item is-placeholder"
  });
}

function BlockPatternList(_ref3) {
  let {
    isDraggable,
    blockPatterns,
    shownPatterns,
    onClickPattern,
    orientation,
    label = (0,_wordpress_i18n_build_module.__)('Block Patterns')
  } = _ref3;
  const composite = (0,CompositeState/* useCompositeState */.A)({
    orientation
  });
  return (0,react.createElement)(Composite/* Composite */.e, (0,esm_extends/* default */.A)({}, composite, {
    role: "listbox",
    className: "block-editor-block-patterns-list",
    "aria-label": label
  }), blockPatterns.map(pattern => {
    const isShown = shownPatterns.includes(pattern);
    return isShown ? (0,react.createElement)(BlockPattern, {
      key: pattern.name,
      pattern: pattern,
      onClick: onClickPattern,
      isDraggable: isDraggable,
      composite: composite
    }) : (0,react.createElement)(BlockPatternPlaceholder, {
      key: pattern.name
    });
  }));
}

/* harmony default export */ const block_patterns_list = (BlockPatternList);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/sidebar.js


/**
 * WordPress dependencies
 */



function PatternCategoriesList(_ref) {
  let {
    selectedCategory,
    patternCategories,
    onClickCategory
  } = _ref;
  const baseClassName = 'block-editor-block-patterns-explorer__sidebar';
  return (0,react.createElement)("div", {
    className: `${baseClassName}__categories-list`
  }, patternCategories.map(_ref2 => {
    let {
      name,
      label
    } = _ref2;
    return (0,react.createElement)(build_module_button, {
      key: name,
      label: label,
      className: `${baseClassName}__categories-list__item`,
      isPressed: selectedCategory === name,
      onClick: () => {
        onClickCategory(name);
      }
    }, label);
  }));
}

function PatternsExplorerSearch(_ref3) {
  let {
    filterValue,
    setFilterValue
  } = _ref3;
  const baseClassName = 'block-editor-block-patterns-explorer__search';
  return (0,react.createElement)("div", {
    className: baseClassName
  }, (0,react.createElement)(search_control, {
    onChange: setFilterValue,
    value: filterValue,
    label: (0,_wordpress_i18n_build_module.__)('Search for patterns'),
    placeholder: (0,_wordpress_i18n_build_module.__)('Search')
  }));
}

function PatternExplorerSidebar(_ref4) {
  let {
    selectedCategory,
    patternCategories,
    onClickCategory,
    filterValue,
    setFilterValue
  } = _ref4;
  const baseClassName = 'block-editor-block-patterns-explorer__sidebar';
  return (0,react.createElement)("div", {
    className: baseClassName
  }, (0,react.createElement)(PatternsExplorerSearch, {
    filterValue: filterValue,
    setFilterValue: setFilterValue
  }), !filterValue && (0,react.createElement)(PatternCategoriesList, {
    selectedCategory: selectedCategory,
    patternCategories: patternCategories,
    onClickCategory: onClickCategory
  }));
}

/* harmony default export */ const sidebar = (PatternExplorerSidebar);
//# sourceMappingURL=sidebar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/no-results.js


/**
 * WordPress dependencies
 */



function InserterNoResults() {
  return (0,react.createElement)("div", {
    className: "block-editor-inserter__no-results"
  }, (0,react.createElement)(icon, {
    className: "block-editor-inserter__no-results-icon",
    icon: block_default
  }), (0,react.createElement)("p", null, (0,_wordpress_i18n_build_module.__)('No results found.')));
}

/* harmony default export */ const no_results = (InserterNoResults);
//# sourceMappingURL=no-results.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-insertion-point.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */


/**
 * @typedef WPInserterConfig
 *
 * @property {string=}   rootClientId   If set, insertion will be into the
 *                                      block with this ID.
 * @property {number=}   insertionIndex If set, insertion will be into this
 *                                      explicit position.
 * @property {string=}   clientId       If set, insertion will be after the
 *                                      block with this ID.
 * @property {boolean=}  isAppender     Whether the inserter is an appender
 *                                      or not.
 * @property {Function=} onSelect       Called after insertion.
 */

/**
 * Returns the insertion point state given the inserter config.
 *
 * @param {WPInserterConfig} config Inserter Config.
 * @return {Array} Insertion Point State (rootClientID, onInsertBlocks and onToggle).
 */

function useInsertionPoint(_ref) {
  let {
    rootClientId = '',
    insertionIndex,
    clientId,
    isAppender,
    onSelect,
    shouldFocusBlock = true
  } = _ref;
  const {
    getSelectedBlock
  } = use_select_useSelect(store_store);
  const {
    destinationRootClientId,
    destinationIndex
  } = use_select_useSelect(select => {
    const {
      getSelectedBlockClientId,
      getBlockRootClientId,
      getBlockIndex,
      getBlockOrder
    } = select(store_store);
    const selectedBlockClientId = getSelectedBlockClientId();
    let _destinationRootClientId = rootClientId;

    let _destinationIndex;

    if (insertionIndex !== undefined) {
      // Insert into a specific index.
      _destinationIndex = insertionIndex;
    } else if (clientId) {
      // Insert after a specific client ID.
      _destinationIndex = getBlockIndex(clientId);
    } else if (!isAppender && selectedBlockClientId) {
      _destinationRootClientId = getBlockRootClientId(selectedBlockClientId);
      _destinationIndex = getBlockIndex(selectedBlockClientId) + 1;
    } else {
      // Insert at the end of the list.
      _destinationIndex = getBlockOrder(_destinationRootClientId).length;
    }

    return {
      destinationRootClientId: _destinationRootClientId,
      destinationIndex: _destinationIndex
    };
  }, [rootClientId, insertionIndex, clientId, isAppender]);
  const {
    replaceBlocks,
    insertBlocks,
    showInsertionPoint,
    hideInsertionPoint
  } = use_dispatch(store_store);
  const onInsertBlocks = (0,react.useCallback)(function (blocks, meta) {
    let shouldForceFocusBlock = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const selectedBlock = getSelectedBlock();

    if (!isAppender && selectedBlock && (0,build_module/* isUnmodifiedDefaultBlock */.Xw)(selectedBlock)) {
      replaceBlocks(selectedBlock.clientId, blocks, null, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    } else {
      insertBlocks(blocks, destinationIndex, destinationRootClientId, true, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
    }

    const message = (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %d: the name of the block that has been added
    (0,_wordpress_i18n_build_module._n)('%d block added.', '%d blocks added.', (0,lodash.castArray)(blocks).length), (0,lodash.castArray)(blocks).length);
    speak(message);

    if (onSelect) {
      onSelect();
    }
  }, [isAppender, getSelectedBlock, replaceBlocks, insertBlocks, destinationRootClientId, destinationIndex, onSelect, shouldFocusBlock]);
  const onToggleInsertionPoint = (0,react.useCallback)(show => {
    if (show) {
      showInsertionPoint(destinationRootClientId, destinationIndex);
    } else {
      hideInsertionPoint();
    }
  }, [showInsertionPoint, hideInsertionPoint, destinationRootClientId, destinationIndex]);
  return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
}

/* harmony default export */ const use_insertion_point = (useInsertionPoint);
//# sourceMappingURL=use-insertion-point.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js + 1 modules
var dist_es2015 = __webpack_require__("../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/remove-accents@0.4.4/node_modules/remove-accents/index.js
var remove_accents = __webpack_require__("../../node_modules/.pnpm/remove-accents@0.4.4/node_modules/remove-accents/index.js");
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/search-items.js
/**
 * External dependencies
 */


 // Default search helpers.

const defaultGetName = item => item.name || '';

const defaultGetTitle = item => item.title;

const defaultGetDescription = item => item.description || '';

const defaultGetKeywords = item => item.keywords || [];

const defaultGetCategory = item => item.category;

const defaultGetCollection = () => null;
/**
 * Sanitizes the search input string.
 *
 * @param {string} input The search input to normalize.
 *
 * @return {string} The normalized search input.
 */


function normalizeSearchInput() {
  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  // Disregard diacritics.
  //  Input: "média"
  input = remove_accents_default()(input); // Accommodate leading slash, matching autocomplete expectations.
  //  Input: "/media"

  input = input.replace(/^\//, ''); // Lowercase.
  //  Input: "MEDIA"

  input = input.toLowerCase();
  return input;
}
/**
 * Extracts words from an input string.
 *
 * @param {string} input The input string.
 *
 * @return {Array} Words, extracted from the input string.
 */


function extractWords() {
  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return (0,dist_es2015/* noCase */.W)(input).split(' ').filter(Boolean);
}
/**
 * Converts the search term into a list of normalized terms.
 *
 * @param {string} input The search term to normalize.
 *
 * @return {string[]} The normalized list of search terms.
 */


const getNormalizedSearchTerms = function () {
  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return extractWords(normalizeSearchInput(input));
};

const removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
  return unmatchedTerms.filter(term => !getNormalizedSearchTerms(unprocessedTerms).some(unprocessedTerm => unprocessedTerm.includes(term)));
};

const searchBlockItems = (items, categories, collections, searchInput) => {
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const config = {
    getCategory: item => {
      var _find;

      return (_find = (0,lodash.find)(categories, {
        slug: item.category
      })) === null || _find === void 0 ? void 0 : _find.title;
    },
    getCollection: item => {
      var _collections$item$nam;

      return (_collections$item$nam = collections[item.name.split('/')[0]]) === null || _collections$item$nam === void 0 ? void 0 : _collections$item$nam.title;
    }
  };
  return searchItems(items, searchInput, config);
};
/**
 * Filters an item list given a search term.
 *
 * @param {Array}  items       Item list
 * @param {string} searchInput Search input.
 * @param {Object} config      Search Config.
 *
 * @return {Array} Filtered item list.
 */

const searchItems = function () {
  let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let searchInput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);

  if (normalizedSearchTerms.length === 0) {
    return items;
  }

  const rankedItems = items.map(item => {
    return [item, getItemSearchRank(item, searchInput, config)];
  }).filter(_ref => {
    let [, rank] = _ref;
    return rank > 0;
  });
  rankedItems.sort((_ref2, _ref3) => {
    let [, rank1] = _ref2;
    let [, rank2] = _ref3;
    return rank2 - rank1;
  });
  return rankedItems.map(_ref4 => {
    let [item] = _ref4;
    return item;
  });
};
/**
 * Get the search rank for a given item and a specific search term.
 * The better the match, the higher the rank.
 * If the rank equals 0, it should be excluded from the results.
 *
 * @param {Object} item       Item to filter.
 * @param {string} searchTerm Search term.
 * @param {Object} config     Search Config.
 *
 * @return {number} Search Rank.
 */

function getItemSearchRank(item, searchTerm) {
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    getName = defaultGetName,
    getTitle = defaultGetTitle,
    getDescription = defaultGetDescription,
    getKeywords = defaultGetKeywords,
    getCategory = defaultGetCategory,
    getCollection = defaultGetCollection
  } = config;
  const name = getName(item);
  const title = getTitle(item);
  const description = getDescription(item);
  const keywords = getKeywords(item);
  const category = getCategory(item);
  const collection = getCollection(item);
  const normalizedSearchInput = normalizeSearchInput(searchTerm);
  const normalizedTitle = normalizeSearchInput(title);
  let rank = 0; // Prefers exact matches
  // Then prefers if the beginning of the title matches the search term
  // name, keywords, categories, collection, variations match come later.

  if (normalizedSearchInput === normalizedTitle) {
    rank += 30;
  } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
    rank += 20;
  } else {
    const terms = [name, title, description, ...keywords, category, collection].join(' ');
    const normalizedSearchTerms = extractWords(normalizedSearchInput);
    const unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, terms);

    if (unmatchedTerms.length === 0) {
      rank += 10;
    }
  } // Give a better rank to "core" namespaced items.


  if (rank !== 0 && name.startsWith('core/')) {
    const isCoreBlockVariation = name !== item.id; // Give a bit better rank to "core" blocks over "core" block variations.

    rank += isCoreBlockVariation ? 1 : 2;
  }

  return rank;
}
//# sourceMappingURL=search-items.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/patterns-list.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */







const INITIAL_INSERTER_RESULTS = 2;

function PatternsListHeader(_ref) {
  let {
    filterValue,
    filteredBlockPatternsLength
  } = _ref;

  if (!filterValue) {
    return null;
  }

  return (0,react.createElement)(heading_component, {
    level: 2,
    lineHeight: '48px',
    className: "block-editor-block-patterns-explorer__search-results-count"
  }, (0,_wordpress_i18n_build_module/* sprintf */.nv)(
  /* translators: %d: number of patterns. %s: block pattern search query */
  (0,_wordpress_i18n_build_module._n)('%1$d pattern found for "%2$s"', '%1$d patterns found for "%2$s"', filteredBlockPatternsLength), filteredBlockPatternsLength, filterValue));
}

function PatternList(_ref2) {
  let {
    filterValue,
    selectedCategory,
    patternCategories
  } = _ref2;
  const debouncedSpeak = (0,use_debounce/* default */.A)(speak, 500);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    shouldFocusBlock: true
  });
  const [allPatterns,, onSelectBlockPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const registeredPatternCategories = (0,react.useMemo)(() => patternCategories.map(patternCategory => patternCategory.name), [patternCategories]);
  const filteredBlockPatterns = (0,react.useMemo)(() => {
    if (!filterValue) {
      return allPatterns.filter(pattern => {
        var _pattern$categories, _pattern$categories2;

        return selectedCategory === 'uncategorized' ? !((_pattern$categories = pattern.categories) !== null && _pattern$categories !== void 0 && _pattern$categories.length) || pattern.categories.every(category => !registeredPatternCategories.includes(category)) : (_pattern$categories2 = pattern.categories) === null || _pattern$categories2 === void 0 ? void 0 : _pattern$categories2.includes(selectedCategory);
      });
    }

    return searchItems(allPatterns, filterValue);
  }, [filterValue, selectedCategory, allPatterns]); // Announce search results on change.

  (0,react.useEffect)(() => {
    if (!filterValue) {
      return;
    }

    const count = filteredBlockPatterns.length;
    const resultsFoundMessage = (0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %d: number of results. */
    (0,_wordpress_i18n_build_module._n)('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [filterValue, debouncedSpeak]);
  const currentShownPatterns = use_async_list(filteredBlockPatterns, {
    step: INITIAL_INSERTER_RESULTS
  });
  const hasItems = !!(filteredBlockPatterns !== null && filteredBlockPatterns !== void 0 && filteredBlockPatterns.length);
  return (0,react.createElement)("div", {
    className: "block-editor-block-patterns-explorer__list"
  }, hasItems && (0,react.createElement)(PatternsListHeader, {
    filterValue: filterValue,
    filteredBlockPatternsLength: filteredBlockPatterns.length
  }), (0,react.createElement)(inserter_listbox, null, !hasItems && (0,react.createElement)(no_results, null), hasItems && (0,react.createElement)(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: filteredBlockPatterns,
    onClickPattern: onSelectBlockPattern,
    isDraggable: false
  })));
}

/* harmony default export */ const patterns_list = (PatternList);
//# sourceMappingURL=patterns-list.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/explorer.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function PatternsExplorer(_ref) {
  let {
    initialCategory,
    patternCategories
  } = _ref;
  const [filterValue, setFilterValue] = (0,react.useState)('');
  const [selectedCategory, setSelectedCategory] = (0,react.useState)(initialCategory === null || initialCategory === void 0 ? void 0 : initialCategory.name);
  return (0,react.createElement)("div", {
    className: "block-editor-block-patterns-explorer"
  }, (0,react.createElement)(sidebar, {
    selectedCategory: selectedCategory,
    patternCategories: patternCategories,
    onClickCategory: setSelectedCategory,
    filterValue: filterValue,
    setFilterValue: setFilterValue
  }), (0,react.createElement)(patterns_list, {
    filterValue: filterValue,
    selectedCategory: selectedCategory,
    patternCategories: patternCategories
  }));
}

function PatternsExplorerModal(_ref2) {
  let {
    onModalClose,
    ...restProps
  } = _ref2;
  return (0,react.createElement)(modal, {
    title: (0,_wordpress_i18n_build_module.__)('Patterns'),
    closeLabel: (0,_wordpress_i18n_build_module.__)('Close'),
    onRequestClose: onModalClose,
    isFullScreen: true
  }, (0,react.createElement)(PatternsExplorer, restProps));
}

/* harmony default export */ const explorer = (PatternsExplorerModal);
//# sourceMappingURL=explorer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






function BlockPatternsCategory(_ref) {
  let {
    rootClientId,
    onInsert,
    selectedCategory,
    populatedCategories
  } = _ref;
  const [allPatterns,, onClick] = use_patterns_state(onInsert, rootClientId);
  const getPatternIndex = (0,react.useCallback)(pattern => {
    var _pattern$categories;

    if (!((_pattern$categories = pattern.categories) !== null && _pattern$categories !== void 0 && _pattern$categories.length)) {
      return Infinity;
    }

    const indexedCategories = populatedCategories.reduce((accumulator, _ref2, index) => {
      let {
        name
      } = _ref2;
      accumulator[name] = index;
      return accumulator;
    }, {});
    return Math.min(...pattern.categories.map(cat => indexedCategories[cat] !== undefined ? indexedCategories[cat] : Infinity));
  }, [populatedCategories]);
  const currentCategoryPatterns = (0,react.useMemo)(() => allPatterns.filter(pattern => {
    var _pattern$categories2;

    return selectedCategory.name === 'uncategorized' ? getPatternIndex(pattern) === Infinity : (_pattern$categories2 = pattern.categories) === null || _pattern$categories2 === void 0 ? void 0 : _pattern$categories2.includes(selectedCategory.name);
  }), [allPatterns, selectedCategory]); // Ordering the patterns is important for the async rendering.

  const orderedPatterns = (0,react.useMemo)(() => {
    return currentCategoryPatterns.sort((a, b) => {
      return getPatternIndex(a) - getPatternIndex(b);
    });
  }, [currentCategoryPatterns, getPatternIndex]);
  const currentShownPatterns = use_async_list(orderedPatterns);

  if (!currentCategoryPatterns.length) {
    return null;
  }

  return (0,react.createElement)("div", {
    className: "block-editor-inserter__panel-content"
  }, (0,react.createElement)(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: currentCategoryPatterns,
    onClickPattern: onClick,
    label: selectedCategory.label,
    orientation: "vertical",
    isDraggable: true
  }));
}

function BlockPatternsTabs(_ref3) {
  let {
    rootClientId,
    onInsert,
    onClickCategory,
    selectedCategory
  } = _ref3;
  const [showPatternsExplorer, setShowPatternsExplorer] = (0,react.useState)(false);
  const [allPatterns, allCategories] = use_patterns_state();
  const hasRegisteredCategory = (0,react.useCallback)(pattern => {
    if (!pattern.categories || !pattern.categories.length) {
      return false;
    }

    return pattern.categories.some(cat => allCategories.some(category => category.name === cat));
  }, [allCategories]); // Remove any empty categories.

  const populatedCategories = (0,react.useMemo)(() => {
    const categories = allCategories.filter(category => allPatterns.some(pattern => {
      var _pattern$categories3;

      return (_pattern$categories3 = pattern.categories) === null || _pattern$categories3 === void 0 ? void 0 : _pattern$categories3.includes(category.name);
    })).sort((_ref4, _ref5) => {
      let {
        name: currentName
      } = _ref4;
      let {
        name: nextName
      } = _ref5;

      if (![currentName, nextName].includes('featured')) {
        return 0;
      }

      return currentName === 'featured' ? -1 : 1;
    });

    if (allPatterns.some(pattern => !hasRegisteredCategory(pattern)) && !categories.find(category => category.name === 'uncategorized')) {
      categories.push({
        name: 'uncategorized',
        label: (0,_wordpress_i18n_build_module._x)('Uncategorized')
      });
    }

    return categories;
  }, [allPatterns, allCategories]);
  const patternCategory = selectedCategory ? selectedCategory : populatedCategories[0];
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(pattern_panel, {
    selectedCategory: patternCategory,
    patternCategories: populatedCategories,
    onClickCategory: onClickCategory,
    openPatternExplorer: () => setShowPatternsExplorer(true)
  }), !showPatternsExplorer && (0,react.createElement)(BlockPatternsCategory, {
    rootClientId: rootClientId,
    onInsert: onInsert,
    selectedCategory: patternCategory,
    populatedCategories: populatedCategories
  }), showPatternsExplorer && (0,react.createElement)(explorer, {
    initialCategory: patternCategory,
    patternCategories: populatedCategories,
    onModalClose: () => setShowPatternsExplorer(false)
  }));
}

/* harmony default export */ const block_patterns_tab = (BlockPatternsTabs);
//# sourceMappingURL=block-patterns-tab.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@3.48.0/node_modules/@wordpress/url/build-module/safe-decode-uri-component.js
/**
 * Safely decodes a URI component with `decodeURIComponent`. Returns the URI component unmodified if
 * `decodeURIComponent` throws an error.
 *
 * @param {string} uriComponent URI component to decode.
 *
 * @return {string} Decoded URI component if possible.
 */
function safeDecodeURIComponent(uriComponent) {
  try {
    return decodeURIComponent(uriComponent);
  } catch (uriComponentError) {
    return uriComponent;
  }
}
//# sourceMappingURL=safe-decode-uri-component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@3.48.0/node_modules/@wordpress/url/build-module/get-query-string.js
/**
 * Returns the query string part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const queryString = getQueryString( 'http://localhost:8080/this/is/a/test?query=true#fragment' ); // 'query=true'
 * ```
 *
 * @return {string|void} The query string part of the URL.
 */
function getQueryString(url) {
  let query;
  try {
    query = new URL(url, 'http://example.com').search.substring(1);
  } catch (error) {}
  if (query) {
    return query;
  }
}
//# sourceMappingURL=get-query-string.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@3.48.0/node_modules/@wordpress/url/build-module/get-query-args.js
/**
 * Internal dependencies
 */



/** @typedef {import('./get-query-arg').QueryArgParsed} QueryArgParsed */

/**
 * @typedef {Record<string,QueryArgParsed>} QueryArgs
 */

/**
 * Sets a value in object deeply by a given array of path segments. Mutates the
 * object reference.
 *
 * @param {Record<string,*>} object Object in which to assign.
 * @param {string[]}         path   Path segment at which to set value.
 * @param {*}                value  Value to set.
 */
function setPath(object, path, value) {
  const length = path.length;
  const lastIndex = length - 1;
  for (let i = 0; i < length; i++) {
    let key = path[i];
    if (!key && Array.isArray(object)) {
      // If key is empty string and next value is array, derive key from
      // the current length of the array.
      key = object.length.toString();
    }
    key = ['__proto__', 'constructor', 'prototype'].includes(key) ? key.toUpperCase() : key;

    // If the next key in the path is numeric (or empty string), it will be
    // created as an array. Otherwise, it will be created as an object.
    const isNextKeyArrayIndex = !isNaN(Number(path[i + 1]));
    object[key] = i === lastIndex ?
    // If at end of path, assign the intended value.
    value :
    // Otherwise, advance to the next object in the path, creating
    // it if it does not yet exist.
    object[key] || (isNextKeyArrayIndex ? [] : {});
    if (Array.isArray(object[key]) && !isNextKeyArrayIndex) {
      // If we current key is non-numeric, but the next value is an
      // array, coerce the value to an object.
      object[key] = {
        ...object[key]
      };
    }

    // Update working reference object to the next in the path.
    object = object[key];
  }
}

/**
 * Returns an object of query arguments of the given URL. If the given URL is
 * invalid or has no querystring, an empty object is returned.
 *
 * @param {string} url URL.
 *
 * @example
 * ```js
 * const foo = getQueryArgs( 'https://wordpress.org?foo=bar&bar=baz' );
 * // { "foo": "bar", "bar": "baz" }
 * ```
 *
 * @return {QueryArgs} Query args object.
 */
function getQueryArgs(url) {
  return (getQueryString(url) || ''
  // Normalize space encoding, accounting for PHP URL encoding
  // corresponding to `application/x-www-form-urlencoded`.
  //
  // See: https://tools.ietf.org/html/rfc1866#section-8.2.1
  ).replace(/\+/g, '%20').split('&').reduce((accumulator, keyValue) => {
    const [key, value = ''] = keyValue.split('=')
    // Filtering avoids decoding as `undefined` for value, where
    // default is restored in destructuring assignment.
    .filter(Boolean).map(safeDecodeURIComponent);
    if (key) {
      const segments = key.replace(/\]/g, '').split('[');
      setPath(accumulator, segments, value);
    }
    return accumulator;
  }, Object.create(null));
}
//# sourceMappingURL=get-query-args.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@3.48.0/node_modules/@wordpress/url/build-module/build-query-string.js
/**
 * Generates URL-encoded query string using input query data.
 *
 * It is intended to behave equivalent as PHP's `http_build_query`, configured
 * with encoding type PHP_QUERY_RFC3986 (spaces as `%20`).
 *
 * @example
 * ```js
 * const queryString = buildQueryString( {
 *    simple: 'is ok',
 *    arrays: [ 'are', 'fine', 'too' ],
 *    objects: {
 *       evenNested: {
 *          ok: 'yes',
 *       },
 *    },
 * } );
 * // "simple=is%20ok&arrays%5B0%5D=are&arrays%5B1%5D=fine&arrays%5B2%5D=too&objects%5BevenNested%5D%5Bok%5D=yes"
 * ```
 *
 * @param {Record<string,*>} data Data to encode.
 *
 * @return {string} Query string.
 */
function buildQueryString(data) {
  let string = '';
  const stack = Object.entries(data);
  let pair;
  while (pair = stack.shift()) {
    let [key, value] = pair;

    // Support building deeply nested data, from array or object values.
    const hasNestedData = Array.isArray(value) || value && value.constructor === Object;
    if (hasNestedData) {
      // Push array or object values onto the stack as composed of their
      // original key and nested index or key, retaining order by a
      // combination of Array#reverse and Array#unshift onto the stack.
      const valuePairs = Object.entries(value).reverse();
      for (const [member, memberValue] of valuePairs) {
        stack.unshift([`${key}[${member}]`, memberValue]);
      }
    } else if (value !== undefined) {
      // Null is treated as special case, equivalent to empty string.
      if (value === null) {
        value = '';
      }
      string += '&' + [key, value].map(encodeURIComponent).join('=');
    }
  }

  // Loop will concatenate with leading `&`, but it's only expected for all
  // but the first query parameter. This strips the leading `&`, while still
  // accounting for the case that the string may in-fact be empty.
  return string.substr(1);
}
//# sourceMappingURL=build-query-string.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+url@3.48.0/node_modules/@wordpress/url/build-module/add-query-args.js
/**
 * Internal dependencies
 */



/**
 * Appends arguments as querystring to the provided URL. If the URL already
 * includes query arguments, the arguments are merged with (and take precedent
 * over) the existing set.
 *
 * @param {string} [url=''] URL to which arguments should be appended. If omitted,
 *                          only the resulting querystring is returned.
 * @param {Object} [args]   Query arguments to apply to URL.
 *
 * @example
 * ```js
 * const newURL = addQueryArgs( 'https://google.com', { q: 'test' } ); // https://google.com/?q=test
 * ```
 *
 * @return {string} URL with arguments applied.
 */
function addQueryArgs(url = '', args) {
  // If no arguments are to be appended, return original URL.
  if (!args || !Object.keys(args).length) {
    return url;
  }
  let baseUrl = url;

  // Determine whether URL already had query arguments.
  const queryStringIndex = url.indexOf('?');
  if (queryStringIndex !== -1) {
    // Merge into existing query arguments.
    args = Object.assign(getQueryArgs(url), args);

    // Change working base URL to omit previous query arguments.
    baseUrl = baseUrl.substr(0, queryStringIndex);
  }
  return baseUrl + '?' + buildQueryString(args);
}
//# sourceMappingURL=add-query-args.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/reusable-blocks-tab.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






function ReusableBlocksList(_ref) {
  let {
    onHover,
    onInsert,
    rootClientId
  } = _ref;
  const [items,,, onSelectItem] = use_block_types_state(rootClientId, onInsert);
  const filteredItems = (0,react.useMemo)(() => {
    return items.filter(_ref2 => {
      let {
        category
      } = _ref2;
      return category === 'reusable';
    });
  }, [items]);

  if (filteredItems.length === 0) {
    return (0,react.createElement)(no_results, null);
  }

  return (0,react.createElement)(panel, {
    title: (0,_wordpress_i18n_build_module.__)('Reusable blocks')
  }, (0,react.createElement)(block_types_list, {
    items: filteredItems,
    onSelect: onSelectItem,
    onHover: onHover,
    label: (0,_wordpress_i18n_build_module.__)('Reusable blocks')
  }));
} // The unwrapped component is only exported for use by unit tests.

/**
 * List of reusable blocks shown in the "Reusable" tab of the inserter.
 *
 * @param {Object}   props              Component props.
 * @param {?string}  props.rootClientId Client id of block to insert into.
 * @param {Function} props.onInsert     Callback to run when item is inserted.
 * @param {Function} props.onHover      Callback to run when item is hovered.
 *
 * @return {WPComponent} The component.
 */


function ReusableBlocksTab(_ref3) {
  let {
    rootClientId,
    onInsert,
    onHover
  } = _ref3;
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(ReusableBlocksList, {
    onHover: onHover,
    onInsert: onInsert,
    rootClientId: rootClientId
  }), (0,react.createElement)("div", {
    className: "block-editor-inserter__manage-reusable-blocks-container"
  }, (0,react.createElement)("a", {
    className: "block-editor-inserter__manage-reusable-blocks",
    href: addQueryArgs('edit.php', {
      post_type: 'wp_block'
    })
  }, (0,_wordpress_i18n_build_module.__)('Manage Reusable blocks'))));
}
/* harmony default export */ const reusable_blocks_tab = (ReusableBlocksTab);
//# sourceMappingURL=reusable-blocks-tab.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter-menu-extension/index.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableInserterMenuExtension,
  Slot: inserter_menu_extension_Slot
} = createSlotFill('__unstableInserterMenuExtension');
__unstableInserterMenuExtension.Slot = inserter_menu_extension_Slot;
/* harmony default export */ const inserter_menu_extension = (__unstableInserterMenuExtension);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */











const search_results_INITIAL_INSERTER_RESULTS = 9;
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation and rerendering the component.
 *
 * @type {Array}
 */

const search_results_EMPTY_ARRAY = [];

function InserterSearchResults(_ref) {
  let {
    filterValue,
    onSelect,
    onHover,
    rootClientId,
    clientId,
    isAppender,
    __experimentalInsertionIndex,
    maxBlockPatterns,
    maxBlockTypes,
    showBlockDirectory = false,
    isDraggable = true,
    shouldFocusBlock = true,
    prioritizePatterns
  } = _ref;
  const debouncedSpeak = (0,use_debounce/* default */.A)(speak, 500);
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const [blockTypes, blockTypeCategories, blockTypeCollections, onSelectBlockType] = use_block_types_state(destinationRootClientId, onInsertBlocks);
  const [patterns,, onSelectBlockPattern] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const filteredBlockPatterns = (0,react.useMemo)(() => {
    if (maxBlockPatterns === 0) {
      return [];
    }

    const results = searchItems(patterns, filterValue);
    return maxBlockPatterns !== undefined ? results.slice(0, maxBlockPatterns) : results;
  }, [filterValue, patterns, maxBlockPatterns]);
  let maxBlockTypesToShow = maxBlockTypes;

  if (prioritizePatterns && filteredBlockPatterns.length > 2) {
    maxBlockTypesToShow = 0;
  }

  const filteredBlockTypes = (0,react.useMemo)(() => {
    if (maxBlockTypesToShow === 0) {
      return [];
    }

    const results = searchBlockItems((0,lodash.orderBy)(blockTypes, ['frecency'], ['desc']), blockTypeCategories, blockTypeCollections, filterValue);
    return maxBlockTypesToShow !== undefined ? results.slice(0, maxBlockTypesToShow) : results;
  }, [filterValue, blockTypes, blockTypeCategories, blockTypeCollections, maxBlockTypes]); // Announce search results on change.

  (0,react.useEffect)(() => {
    if (!filterValue) {
      return;
    }

    const count = filteredBlockTypes.length + filteredBlockPatterns.length;
    const resultsFoundMessage = (0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %d: number of results. */
    (0,_wordpress_i18n_build_module._n)('%d result found.', '%d results found.', count), count);
    debouncedSpeak(resultsFoundMessage);
  }, [filterValue, debouncedSpeak]);
  const currentShownBlockTypes = use_async_list(filteredBlockTypes, {
    step: search_results_INITIAL_INSERTER_RESULTS
  });
  const currentShownPatterns = use_async_list(currentShownBlockTypes.length === filteredBlockTypes.length ? filteredBlockPatterns : search_results_EMPTY_ARRAY);
  const hasItems = !(0,lodash.isEmpty)(filteredBlockTypes) || !(0,lodash.isEmpty)(filteredBlockPatterns);
  const blocksUI = !!filteredBlockTypes.length && (0,react.createElement)(panel, {
    title: (0,react.createElement)(visually_hidden_component, null, (0,_wordpress_i18n_build_module.__)('Blocks'))
  }, (0,react.createElement)(block_types_list, {
    items: currentShownBlockTypes,
    onSelect: onSelectBlockType,
    onHover: onHover,
    label: (0,_wordpress_i18n_build_module.__)('Blocks'),
    isDraggable: isDraggable
  }));
  const patternsUI = !!filteredBlockPatterns.length && (0,react.createElement)(panel, {
    title: (0,react.createElement)(visually_hidden_component, null, (0,_wordpress_i18n_build_module.__)('Block Patterns'))
  }, (0,react.createElement)("div", {
    className: "block-editor-inserter__quick-inserter-patterns"
  }, (0,react.createElement)(block_patterns_list, {
    shownPatterns: currentShownPatterns,
    blockPatterns: filteredBlockPatterns,
    onClickPattern: onSelectBlockPattern,
    isDraggable: isDraggable
  })));
  return (0,react.createElement)(inserter_listbox, null, !showBlockDirectory && !hasItems && (0,react.createElement)(no_results, null), prioritizePatterns ? patternsUI : blocksUI, !!filteredBlockTypes.length && !!filteredBlockPatterns.length && (0,react.createElement)("div", {
    className: "block-editor-inserter__quick-inserter-separator"
  }), prioritizePatterns ? blocksUI : patternsUI, showBlockDirectory && (0,react.createElement)(inserter_menu_extension.Slot, {
    fillProps: {
      onSelect: onSelectBlockType,
      onHover,
      filterValue,
      hasItems,
      rootClientId: destinationRootClientId
    }
  }, fills => {
    if (fills.length) {
      return fills;
    }

    if (!hasItems) {
      return (0,react.createElement)(no_results, null);
    }

    return null;
  }));
}

/* harmony default export */ const search_results = (InserterSearchResults);
//# sourceMappingURL=search-results.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/tab-panel/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const tab_panel_noop = () => {};

const TabButton = _ref => {
  let {
    tabId,
    onClick,
    children,
    selected,
    ...rest
  } = _ref;
  return (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    role: "tab",
    tabIndex: selected ? null : -1,
    "aria-selected": selected,
    id: tabId,
    onClick: onClick
  }, rest), children);
};

function TabPanel(_ref2) {
  var _selectedTab$name;

  let {
    className,
    children,
    tabs,
    initialTabName,
    orientation = 'horizontal',
    activeClass = 'is-active',
    onSelect = tab_panel_noop
  } = _ref2;
  const instanceId = (0,use_instance_id/* default */.A)(TabPanel, 'tab-panel');
  const [selected, setSelected] = (0,react.useState)(null);

  const handleClick = tabKey => {
    setSelected(tabKey);
    onSelect(tabKey);
  };

  const onNavigate = (childIndex, child) => {
    child.click();
  };

  const selectedTab = (0,lodash.find)(tabs, {
    name: selected
  });
  const selectedId = `${instanceId}-${(_selectedTab$name = selectedTab === null || selectedTab === void 0 ? void 0 : selectedTab.name) !== null && _selectedTab$name !== void 0 ? _selectedTab$name : 'none'}`;
  (0,react.useEffect)(() => {
    const newSelectedTab = (0,lodash.find)(tabs, {
      name: selected
    });

    if (!newSelectedTab) {
      setSelected(initialTabName || (tabs.length > 0 ? tabs[0].name : null));
    }
  }, [tabs]);
  return (0,react.createElement)("div", {
    className: className
  }, (0,react.createElement)(navigable_container_menu, {
    role: "tablist",
    orientation: orientation,
    onNavigate: onNavigate,
    className: "components-tab-panel__tabs"
  }, tabs.map(tab => (0,react.createElement)(TabButton, {
    className: classnames_default()('components-tab-panel__tabs-item', tab.className, {
      [activeClass]: tab.name === selected
    }),
    tabId: `${instanceId}-${tab.name}`,
    "aria-controls": `${instanceId}-${tab.name}-view`,
    selected: tab.name === selected,
    key: tab.name,
    onClick: (0,lodash.partial)(handleClick, tab.name)
  }, tab.title))), selectedTab && (0,react.createElement)("div", {
    key: selectedId,
    "aria-labelledby": selectedId,
    role: "tabpanel",
    id: `${selectedId}-view`,
    className: "components-tab-panel__tab-content"
  }, children(selectedTab)));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/tabs.js


/**
 * WordPress dependencies
 */



const blocksTab = {
  name: 'blocks',

  /* translators: Blocks tab title in the block inserter. */
  title: (0,_wordpress_i18n_build_module.__)('Blocks')
};
const patternsTab = {
  name: 'patterns',

  /* translators: Patterns tab title in the block inserter. */
  title: (0,_wordpress_i18n_build_module.__)('Patterns')
};
const reusableBlocksTab = {
  name: 'reusable',

  /* translators: Reusable blocks tab title in the block inserter. */
  title: (0,_wordpress_i18n_build_module.__)('Reusable')
};

function InserterTabs(_ref) {
  let {
    children,
    showPatterns = false,
    showReusableBlocks = false,
    onSelect
  } = _ref;
  const tabs = (0,react.useMemo)(() => {
    const tempTabs = [blocksTab];

    if (showPatterns) {
      tempTabs.push(patternsTab);
    }

    if (showReusableBlocks) {
      tempTabs.push(reusableBlocksTab);
    }

    return tempTabs;
  }, [blocksTab, showPatterns, patternsTab, showReusableBlocks, reusableBlocksTab]);
  return (0,react.createElement)(TabPanel, {
    className: "block-editor-inserter__tabs",
    tabs: tabs,
    onSelect: onSelect
  }, children);
}

/* harmony default export */ const tabs = (InserterTabs);
//# sourceMappingURL=tabs.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */











function InserterMenu(_ref, ref) {
  let {
    rootClientId,
    clientId,
    isAppender,
    __experimentalInsertionIndex,
    onSelect,
    showInserterHelpPanel,
    showMostUsedBlocks,
    __experimentalFilterValue = '',
    shouldFocusBlock = true
  } = _ref;
  const [filterValue, setFilterValue] = (0,react.useState)(__experimentalFilterValue);
  const [hoveredItem, setHoveredItem] = (0,react.useState)(null);
  const [selectedPatternCategory, setSelectedPatternCategory] = (0,react.useState)(null);
  const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point({
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const {
    showPatterns,
    hasReusableBlocks
  } = use_select_useSelect(select => {
    var _getSettings$__experi;

    const {
      __experimentalGetAllowedPatterns,
      getSettings
    } = select(store_store);
    return {
      showPatterns: !!__experimentalGetAllowedPatterns(destinationRootClientId).length,
      hasReusableBlocks: !!((_getSettings$__experi = getSettings().__experimentalReusableBlocks) !== null && _getSettings$__experi !== void 0 && _getSettings$__experi.length)
    };
  }, [destinationRootClientId]);
  const onInsert = (0,react.useCallback)((blocks, meta, shouldForceFocusBlock) => {
    onInsertBlocks(blocks, meta, shouldForceFocusBlock);
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onInsertPattern = (0,react.useCallback)((blocks, patternName) => {
    onInsertBlocks(blocks, {
      patternName
    });
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onHover = (0,react.useCallback)(item => {
    onToggleInsertionPoint(!!item);
    setHoveredItem(item);
  }, [onToggleInsertionPoint, setHoveredItem]);
  const onClickPatternCategory = (0,react.useCallback)(patternCategory => {
    setSelectedPatternCategory(patternCategory);
  }, [setSelectedPatternCategory]);
  const blocksTab = (0,react.useMemo)(() => (0,react.createElement)(react.Fragment, null, (0,react.createElement)("div", {
    className: "block-editor-inserter__block-list"
  }, (0,react.createElement)(block_types_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    onHover: onHover,
    showMostUsedBlocks: showMostUsedBlocks
  })), showInserterHelpPanel && (0,react.createElement)("div", {
    className: "block-editor-inserter__tips"
  }, (0,react.createElement)(visually_hidden_component, {
    as: "h2"
  }, (0,_wordpress_i18n_build_module.__)('A tip for using the block editor')), (0,react.createElement)(tips, null))), [destinationRootClientId, onInsert, onHover, filterValue, showMostUsedBlocks, showInserterHelpPanel]);
  const patternsTab = (0,react.useMemo)(() => (0,react.createElement)(block_patterns_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsertPattern,
    onClickCategory: onClickPatternCategory,
    selectedCategory: selectedPatternCategory
  }), [destinationRootClientId, onInsertPattern, onClickPatternCategory, selectedPatternCategory]);
  const reusableBlocksTab = (0,react.useMemo)(() => (0,react.createElement)(reusable_blocks_tab, {
    rootClientId: destinationRootClientId,
    onInsert: onInsert,
    onHover: onHover
  }), [destinationRootClientId, onInsert, onHover]);
  const getCurrentTab = (0,react.useCallback)(tab => {
    if (tab.name === 'blocks') {
      return blocksTab;
    } else if (tab.name === 'patterns') {
      return patternsTab;
    }

    return reusableBlocksTab;
  }, [blocksTab, patternsTab, reusableBlocksTab]);
  const searchRef = (0,react.useRef)();
  (0,react.useImperativeHandle)(ref, () => ({
    focusSearch: () => {
      searchRef.current.focus();
    }
  }));
  return (0,react.createElement)("div", {
    className: "block-editor-inserter__menu"
  }, (0,react.createElement)("div", {
    className: "block-editor-inserter__main-area"
  }, (0,react.createElement)("div", {
    className: "block-editor-inserter__content"
  }, (0,react.createElement)(search_control, {
    className: "block-editor-inserter__search",
    onChange: value => {
      if (hoveredItem) setHoveredItem(null);
      setFilterValue(value);
    },
    value: filterValue,
    label: (0,_wordpress_i18n_build_module.__)('Search for blocks and patterns'),
    placeholder: (0,_wordpress_i18n_build_module.__)('Search'),
    ref: searchRef
  }), !!filterValue && (0,react.createElement)(search_results, {
    filterValue: filterValue,
    onSelect: onSelect,
    onHover: onHover,
    rootClientId: rootClientId,
    clientId: clientId,
    isAppender: isAppender,
    __experimentalInsertionIndex: __experimentalInsertionIndex,
    showBlockDirectory: true,
    shouldFocusBlock: shouldFocusBlock
  }), !filterValue && (showPatterns || hasReusableBlocks) && (0,react.createElement)(tabs, {
    showPatterns: showPatterns,
    showReusableBlocks: hasReusableBlocks
  }, getCurrentTab), !filterValue && !showPatterns && !hasReusableBlocks && blocksTab)), showInserterHelpPanel && hoveredItem && (0,react.createElement)(preview_panel, {
    item: hoveredItem
  }));
}

/* harmony default export */ const inserter_menu = ((0,react.forwardRef)(InserterMenu));
//# sourceMappingURL=menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/quick-inserter.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






const SEARCH_THRESHOLD = 6;
const SHOWN_BLOCK_TYPES = 6;
const SHOWN_BLOCK_PATTERNS = 2;
const SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION = 4;
function QuickInserter(_ref) {
  let {
    onSelect,
    rootClientId,
    clientId,
    isAppender,
    prioritizePatterns
  } = _ref;
  const [filterValue, setFilterValue] = (0,react.useState)('');
  const [destinationRootClientId, onInsertBlocks] = use_insertion_point({
    onSelect,
    rootClientId,
    clientId,
    isAppender
  });
  const [blockTypes] = use_block_types_state(destinationRootClientId, onInsertBlocks);
  const [patterns] = use_patterns_state(onInsertBlocks, destinationRootClientId);
  const {
    setInserterIsOpened,
    insertionIndex
  } = use_select_useSelect(select => {
    const {
      getSettings,
      getBlockIndex,
      getBlockCount
    } = select(store_store);
    const settings = getSettings();
    const index = getBlockIndex(clientId);
    const blockCount = getBlockCount();
    return {
      setInserterIsOpened: settings.__experimentalSetIsInserterOpened,
      insertionIndex: index === -1 ? blockCount : index
    };
  }, [clientId]);
  const showPatterns = patterns.length && (!!filterValue || prioritizePatterns);
  const showSearch = showPatterns && patterns.length > SEARCH_THRESHOLD || blockTypes.length > SEARCH_THRESHOLD;
  (0,react.useEffect)(() => {
    if (setInserterIsOpened) {
      setInserterIsOpened(false);
    }
  }, [setInserterIsOpened]); // When clicking Browse All select the appropriate block so as
  // the insertion point can work as expected.

  const onBrowseAll = () => {
    setInserterIsOpened({
      rootClientId,
      insertionIndex,
      filterValue
    });
  };

  let maxBlockPatterns = 0;

  if (showPatterns) {
    maxBlockPatterns = prioritizePatterns ? SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION : SHOWN_BLOCK_PATTERNS;
  }

  return (0,react.createElement)("div", {
    className: classnames_default()('block-editor-inserter__quick-inserter', {
      'has-search': showSearch,
      'has-expand': setInserterIsOpened
    })
  }, showSearch && (0,react.createElement)(search_control, {
    className: "block-editor-inserter__search",
    value: filterValue,
    onChange: value => {
      setFilterValue(value);
    },
    label: (0,_wordpress_i18n_build_module.__)('Search for blocks and patterns'),
    placeholder: (0,_wordpress_i18n_build_module.__)('Search')
  }), (0,react.createElement)("div", {
    className: "block-editor-inserter__quick-inserter-results"
  }, (0,react.createElement)(search_results, {
    filterValue: filterValue,
    onSelect: onSelect,
    rootClientId: rootClientId,
    clientId: clientId,
    isAppender: isAppender,
    maxBlockPatterns: maxBlockPatterns,
    maxBlockTypes: SHOWN_BLOCK_TYPES,
    isDraggable: false,
    prioritizePatterns: prioritizePatterns
  })), setInserterIsOpened && (0,react.createElement)(build_module_button, {
    className: "block-editor-inserter__quick-inserter-expand",
    onClick: onBrowseAll,
    "aria-label": (0,_wordpress_i18n_build_module.__)('Browse all. This will open the main inserter panel in the editor toolbar.')
  }, (0,_wordpress_i18n_build_module.__)('Browse all')));
}
//# sourceMappingURL=quick-inserter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inserter/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */





const defaultRenderToggle = _ref => {
  let {
    onToggle,
    disabled,
    isOpen,
    blockTitle,
    hasSingleBlockType,
    toggleProps = {},
    prioritizePatterns
  } = _ref;
  let label;

  if (hasSingleBlockType) {
    label = (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: the name of the block when there is only one
    (0,_wordpress_i18n_build_module._x)('Add %s', 'directly add the only allowed block'), blockTitle);
  } else if (prioritizePatterns) {
    label = (0,_wordpress_i18n_build_module.__)('Add pattern');
  } else {
    label = (0,_wordpress_i18n_build_module._x)('Add block', 'Generic label for block inserter button');
  }

  const {
    onClick,
    ...rest
  } = toggleProps; // Handle both onClick functions from the toggle and the parent component.

  function handleClick(event) {
    if (onToggle) {
      onToggle(event);
    }

    if (onClick) {
      onClick(event);
    }
  }

  return (0,react.createElement)(build_module_button, (0,esm_extends/* default */.A)({
    icon: library_plus,
    label: label,
    tooltipPosition: "bottom",
    onClick: handleClick,
    className: "block-editor-inserter__toggle",
    "aria-haspopup": !hasSingleBlockType ? 'true' : false,
    "aria-expanded": !hasSingleBlockType ? isOpen : false,
    disabled: disabled
  }, rest));
};

class Inserter extends react.Component {
  constructor() {
    super(...arguments);
    this.onToggle = this.onToggle.bind(this);
    this.renderToggle = this.renderToggle.bind(this);
    this.renderContent = this.renderContent.bind(this);
  }

  onToggle(isOpen) {
    const {
      onToggle
    } = this.props; // Surface toggle callback to parent component.

    if (onToggle) {
      onToggle(isOpen);
    }
  }
  /**
   * Render callback to display Dropdown toggle element.
   *
   * @param {Object}   options
   * @param {Function} options.onToggle Callback to invoke when toggle is
   *                                    pressed.
   * @param {boolean}  options.isOpen   Whether dropdown is currently open.
   *
   * @return {WPElement} Dropdown toggle element.
   */


  renderToggle(_ref2) {
    let {
      onToggle,
      isOpen
    } = _ref2;
    const {
      disabled,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      hasItems,
      renderToggle = defaultRenderToggle,
      prioritizePatterns
    } = this.props;
    return renderToggle({
      onToggle,
      isOpen,
      disabled: disabled || !hasItems,
      blockTitle,
      hasSingleBlockType,
      directInsertBlock,
      toggleProps,
      prioritizePatterns
    });
  }
  /**
   * Render callback to display Dropdown content element.
   *
   * @param {Object}   options
   * @param {Function} options.onClose Callback to invoke when dropdown is
   *                                   closed.
   *
   * @return {WPElement} Dropdown content element.
   */


  renderContent(_ref3) {
    let {
      onClose
    } = _ref3;
    const {
      rootClientId,
      clientId,
      isAppender,
      showInserterHelpPanel,
      // This prop is experimental to give some time for the quick inserter to mature
      // Feel free to make them stable after a few releases.
      __experimentalIsQuick: isQuick,
      prioritizePatterns
    } = this.props;

    if (isQuick) {
      return (0,react.createElement)(QuickInserter, {
        onSelect: () => {
          onClose();
        },
        rootClientId: rootClientId,
        clientId: clientId,
        isAppender: isAppender,
        prioritizePatterns: prioritizePatterns
      });
    }

    return (0,react.createElement)(inserter_menu, {
      onSelect: () => {
        onClose();
      },
      rootClientId: rootClientId,
      clientId: clientId,
      isAppender: isAppender,
      showInserterHelpPanel: showInserterHelpPanel
    });
  }

  render() {
    const {
      position,
      hasSingleBlockType,
      directInsertBlock,
      insertOnlyAllowedBlock,
      __experimentalIsQuick: isQuick,
      onSelectOrClose
    } = this.props;

    if (hasSingleBlockType || directInsertBlock) {
      return this.renderToggle({
        onToggle: insertOnlyAllowedBlock
      });
    }

    return (0,react.createElement)(Dropdown, {
      className: "block-editor-inserter",
      contentClassName: classnames_default()('block-editor-inserter__popover', {
        'is-quick': isQuick
      }),
      position: position,
      onToggle: this.onToggle,
      expandOnMobile: true,
      headerTitle: (0,_wordpress_i18n_build_module.__)('Add a block'),
      renderToggle: this.renderToggle,
      renderContent: this.renderContent,
      onClose: onSelectOrClose
    });
  }

}

/* harmony default export */ const inserter = ((0,compose/* default */.A)([with_select((select, _ref4) => {
  var _getBlockVariations;

  let {
    clientId,
    rootClientId
  } = _ref4;
  const {
    getBlockRootClientId,
    hasInserterItems,
    __experimentalGetAllowedBlocks,
    __experimentalGetDirectInsertBlock,
    getBlockIndex,
    getBlockCount,
    getSettings
  } = select(store_store);
  const {
    getBlockVariations
  } = select(build_module/* store */.M_);
  rootClientId = rootClientId || getBlockRootClientId(clientId) || undefined;

  const allowedBlocks = __experimentalGetAllowedBlocks(rootClientId);

  const directInsertBlock = __experimentalGetDirectInsertBlock(rootClientId);

  const index = getBlockIndex(clientId);
  const blockCount = getBlockCount();
  const settings = getSettings();
  const hasSingleBlockType = (allowedBlocks === null || allowedBlocks === void 0 ? void 0 : allowedBlocks.length) === 1 && ((_getBlockVariations = getBlockVariations(allowedBlocks[0].name, 'inserter')) === null || _getBlockVariations === void 0 ? void 0 : _getBlockVariations.length) === 0;
  let allowedBlockType = false;

  if (hasSingleBlockType) {
    allowedBlockType = allowedBlocks[0];
  }

  return {
    hasItems: hasInserterItems(rootClientId),
    hasSingleBlockType,
    blockTitle: allowedBlockType ? allowedBlockType.title : '',
    allowedBlockType,
    directInsertBlock,
    rootClientId,
    prioritizePatterns: settings.__experimentalPreferPatternsOnRoot && !rootClientId && index > 0 && (index < blockCount || blockCount === 0)
  };
}), with_dispatch((dispatch, ownProps, _ref5) => {
  let {
    select
  } = _ref5;
  return {
    insertOnlyAllowedBlock() {
      const {
        rootClientId,
        clientId,
        isAppender,
        hasSingleBlockType,
        allowedBlockType,
        directInsertBlock,
        onSelectOrClose
      } = ownProps;

      if (!hasSingleBlockType && !directInsertBlock) {
        return;
      }

      function getAdjacentBlockAttributes(attributesToCopy) {
        const {
          getBlock,
          getPreviousBlockClientId
        } = select(store_store);

        if (!attributesToCopy || !clientId && !rootClientId) {
          return {};
        }

        const result = {};
        let adjacentAttributes = {}; // If there is no clientId, then attempt to get attributes
        // from the last block within innerBlocks of the root block.

        if (!clientId) {
          var _parentBlock$innerBlo;

          const parentBlock = getBlock(rootClientId);

          if (parentBlock !== null && parentBlock !== void 0 && (_parentBlock$innerBlo = parentBlock.innerBlocks) !== null && _parentBlock$innerBlo !== void 0 && _parentBlock$innerBlo.length) {
            const lastInnerBlock = parentBlock.innerBlocks[parentBlock.innerBlocks.length - 1];

            if (directInsertBlock && (directInsertBlock === null || directInsertBlock === void 0 ? void 0 : directInsertBlock.name) === lastInnerBlock.name) {
              adjacentAttributes = lastInnerBlock.attributes;
            }
          }
        } else {
          // Otherwise, attempt to get attributes from the
          // previous block relative to the current clientId.
          const currentBlock = getBlock(clientId);
          const previousBlock = getBlock(getPreviousBlockClientId(clientId));

          if ((currentBlock === null || currentBlock === void 0 ? void 0 : currentBlock.name) === (previousBlock === null || previousBlock === void 0 ? void 0 : previousBlock.name)) {
            adjacentAttributes = (previousBlock === null || previousBlock === void 0 ? void 0 : previousBlock.attributes) || {};
          }
        } // Copy over only those attributes flagged to be copied.


        attributesToCopy.forEach(attribute => {
          if (adjacentAttributes.hasOwnProperty(attribute)) {
            result[attribute] = adjacentAttributes[attribute];
          }
        });
        return result;
      }

      function getInsertionIndex() {
        const {
          getBlockIndex,
          getBlockSelectionEnd,
          getBlockOrder,
          getBlockRootClientId
        } = select(store_store); // If the clientId is defined, we insert at the position of the block.

        if (clientId) {
          return getBlockIndex(clientId);
        } // If there a selected block, we insert after the selected block.


        const end = getBlockSelectionEnd();

        if (!isAppender && end && getBlockRootClientId(end) === rootClientId) {
          return getBlockIndex(end) + 1;
        } // Otherwise, we insert at the end of the current rootClientId.


        return getBlockOrder(rootClientId).length;
      }

      const {
        insertBlock
      } = dispatch(store_store);
      let blockToInsert; // Attempt to augment the directInsertBlock with attributes from an adjacent block.
      // This ensures styling from nearby blocks is preserved in the newly inserted block.
      // See: https://github.com/WordPress/gutenberg/issues/37904

      if (directInsertBlock) {
        const newAttributes = getAdjacentBlockAttributes(directInsertBlock.attributesToCopy);
        blockToInsert = (0,build_module/* createBlock */.Wv)(directInsertBlock.name, { ...(directInsertBlock.attributes || {}),
          ...newAttributes
        });
      } else {
        blockToInsert = (0,build_module/* createBlock */.Wv)(allowedBlockType.name);
      }

      insertBlock(blockToInsert, getInsertionIndex(), rootClientId);

      if (onSelectOrClose) {
        onSelectOrClose();
      }

      const message = (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: the name of the block that has been added
      (0,_wordpress_i18n_build_module.__)('%s block added'), allowedBlockType.title);
      speak(message);
    }

  };
}), // The global inserter should always be visible, we are using ( ! isAppender && ! rootClientId && ! clientId ) as
// a way to detect the global Inserter.
if_condition(_ref6 => {
  let {
    hasItems,
    isAppender,
    rootClientId,
    clientId
  } = _ref6;
  return hasItems || !isAppender && !rootClientId && !clientId;
})])(Inserter));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



/**
 * Zero width non-breaking space, used as padding for the paragraph when it is
 * empty.
 */

const default_block_appender_ZWNBSP = '\ufeff';
function DefaultBlockAppender(_ref) {
  let {
    isLocked,
    onAppend,
    showPrompt,
    placeholder,
    rootClientId
  } = _ref;

  if (isLocked) {
    return null;
  }

  const value = (0,html_entities_build_module/* decodeEntities */.S)(placeholder) || (0,_wordpress_i18n_build_module.__)('Type / to choose a block');

  return (0,react.createElement)("div", {
    "data-root-client-id": rootClientId || '',
    className: classnames_default()('block-editor-default-block-appender', {
      'has-visible-prompt': showPrompt
    })
  }, (0,react.createElement)("p", {
    tabIndex: "0" // We want this element to be styled as a paragraph by themes.
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role
    ,
    role: "button",
    "aria-label": (0,_wordpress_i18n_build_module.__)('Add default block') // A wrapping container for this one already has the wp-block className.
    ,
    className: "block-editor-default-block-appender__content",
    onKeyDown: event => {
      if (keycodes_build_module/* ENTER */.Fm === event.keyCode || keycodes_build_module/* SPACE */.t6 === event.keyCode) {
        onAppend();
      }
    },
    onClick: () => onAppend(),
    onFocus: () => {
      if (showPrompt) {
        onAppend();
      }
    }
  }, showPrompt ? value : default_block_appender_ZWNBSP), (0,react.createElement)(inserter, {
    rootClientId: rootClientId,
    position: "bottom right",
    isAppender: true,
    __experimentalIsQuick: true
  }));
}
/* harmony default export */ const default_block_appender = ((0,compose/* default */.A)(with_select((select, ownProps) => {
  const {
    getBlockCount,
    getSettings,
    getTemplateLock
  } = select(store_store);
  const isEmpty = !getBlockCount(ownProps.rootClientId);
  const {
    bodyPlaceholder
  } = getSettings();
  return {
    showPrompt: isEmpty,
    isLocked: !!getTemplateLock(ownProps.rootClientId),
    placeholder: bodyPlaceholder
  };
}), with_dispatch((dispatch, ownProps) => {
  const {
    insertDefaultBlock,
    startTyping
  } = dispatch(store_store);
  return {
    onAppend() {
      const {
        rootClientId
      } = ownProps;
      insertDefaultBlock(undefined, rootClientId);
      startTyping();
    }

  };
}))(DefaultBlockAppender));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/button-block-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */



function ButtonBlockAppender(_ref, ref) {
  let {
    rootClientId,
    className,
    onFocus,
    tabIndex
  } = _ref;
  return (0,react.createElement)(inserter, {
    position: "bottom center",
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    renderToggle: _ref2 => {
      let {
        onToggle,
        disabled,
        isOpen,
        blockTitle,
        hasSingleBlockType
      } = _ref2;
      let label;

      if (hasSingleBlockType) {
        label = (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: the name of the block when there is only one
        (0,_wordpress_i18n_build_module._x)('Add %s', 'directly add the only allowed block'), blockTitle);
      } else {
        label = (0,_wordpress_i18n_build_module._x)('Add block', 'Generic label for block inserter button');
      }

      const isToggleButton = !hasSingleBlockType;
      let inserterButton = (0,react.createElement)(build_module_button, {
        ref: ref,
        onFocus: onFocus,
        tabIndex: tabIndex,
        className: classnames_default()(className, 'block-editor-button-block-appender'),
        onClick: onToggle,
        "aria-haspopup": isToggleButton ? 'true' : undefined,
        "aria-expanded": isToggleButton ? isOpen : undefined,
        disabled: disabled,
        label: label
      }, !hasSingleBlockType && (0,react.createElement)(visually_hidden_component, {
        as: "span"
      }, label), (0,react.createElement)(icon, {
        icon: library_plus
      }));

      if (isToggleButton || hasSingleBlockType) {
        inserterButton = (0,react.createElement)(tooltip, {
          text: label
        }, inserterButton);
      }

      return inserterButton;
    },
    isAppender: true
  });
}
/**
 * Use `ButtonBlockAppender` instead.
 *
 * @deprecated
 */


const ButtonBlockerAppender = (0,react.forwardRef)((props, ref) => {
  (0,deprecated_build_module/* default */.A)(`wp.blockEditor.ButtonBlockerAppender`, {
    alternative: 'wp.blockEditor.ButtonBlockAppender',
    since: '5.9'
  });
  return ButtonBlockAppender(props, ref);
});
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/button-block-appender/README.md
 */

/* harmony default export */ const button_block_appender = ((0,react.forwardRef)(ButtonBlockAppender));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





function BlockListAppender(_ref) {
  let {
    rootClientId,
    canInsertDefaultBlock,
    isLocked,
    renderAppender: CustomAppender,
    className,
    selectedBlockClientId,
    tagName: TagName = 'div'
  } = _ref;

  if (isLocked || CustomAppender === false) {
    return null;
  }

  let appender;

  if (CustomAppender) {
    // Prefer custom render prop if provided.
    appender = (0,react.createElement)(CustomAppender, null);
  } else {
    const isParentSelected = selectedBlockClientId === rootClientId || !rootClientId && !selectedBlockClientId;

    if (!isParentSelected) {
      return null;
    }

    if (canInsertDefaultBlock) {
      // Render the default block appender when renderAppender has not been
      // provided and the context supports use of the default appender.
      appender = (0,react.createElement)(default_block_appender, {
        rootClientId: rootClientId
      });
    } else {
      // Fallback in the case no renderAppender has been provided and the
      // default block can't be inserted.
      appender = (0,react.createElement)(button_block_appender, {
        rootClientId: rootClientId,
        className: "block-list-appender__toggle"
      });
    }
  }

  return (0,react.createElement)(TagName // A `tabIndex` is used on the wrapping `div` element in order to
  // force a focus event to occur when an appender `button` element
  // is clicked. In some browsers (Firefox, Safari), button clicks do
  // not emit a focus event, which could cause this event to propagate
  // unexpectedly. The `tabIndex` ensures that the interaction is
  // captured as a focus, without also adding an extra tab stop.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
  , {
    tabIndex: -1,
    className: classnames_default()('block-list-appender wp-block', className) // Needed in case the whole editor is content editable (for multi
    // selection). It fixes an edge case where ArrowDown and ArrowRight
    // should collapse the selection to the end of that selection and
    // not into the appender.
    ,
    contentEditable: false // The appender exists to let you add the first Paragraph before
    // any is inserted. To that end, this appender should visually be
    // presented as a block. That means theme CSS should style it as if
    // it were an empty paragraph block. That means a `wp-block` class to
    // ensure the width is correct, and a [data-block] attribute to ensure
    // the correct margin is applied, especially for classic themes which
    // have commonly targeted that attribute for margins.
    ,
    "data-block": true
  }, appender);
}

/* harmony default export */ const block_list_appender = (with_select((select, _ref2) => {
  let {
    rootClientId
  } = _ref2;
  const {
    canInsertBlockType,
    getTemplateLock,
    getSelectedBlockClientId
  } = select(store_store);
  return {
    isLocked: !!getTemplateLock(rootClientId),
    canInsertDefaultBlock: canInsertBlockType((0,build_module/* getDefaultBlockName */.K$)(), rootClientId),
    selectedBlockClientId: getSelectedBlockClientId()
  };
})(BlockListAppender));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-popover/inbetween.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const InsertionPointOpenRef = (0,react.createContext)();

function BlockPopoverInbetween(_ref) {
  let {
    previousClientId,
    nextClientId,
    children,
    __unstablePopoverSlot,
    __unstableContentRef,
    ...props
  } = _ref;
  const {
    orientation,
    rootClientId,
    isVisible
  } = use_select_useSelect(select => {
    var _getBlockListSettings;

    const {
      getBlockListSettings,
      getBlockRootClientId,
      isBlockVisible
    } = select(store_store);

    const _rootClientId = getBlockRootClientId(previousClientId);

    return {
      orientation: ((_getBlockListSettings = getBlockListSettings(_rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || 'vertical',
      rootClientId: _rootClientId,
      isVisible: isBlockVisible(previousClientId) && isBlockVisible(nextClientId)
    };
  }, [previousClientId]);
  const previousElement = useBlockElement(previousClientId);
  const nextElement = useBlockElement(nextClientId);
  const isVertical = orientation === 'vertical';
  const style = (0,react.useMemo)(() => {
    if (!previousElement && !nextElement || !isVisible) {
      return {};
    }

    const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
    const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;

    if (isVertical) {
      return {
        width: previousElement ? previousElement.offsetWidth : nextElement.offsetWidth,
        height: nextRect && previousRect ? nextRect.top - previousRect.bottom : 0
      };
    }

    let width = 0;

    if (previousRect && nextRect) {
      width = (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? previousRect.left - nextRect.right : nextRect.left - previousRect.right;
    }

    return {
      width,
      height: previousElement ? previousElement.offsetHeight : nextElement.offsetHeight
    };
  }, [previousElement, nextElement, isVertical]);
  const getAnchorRect = (0,react.useCallback)(() => {
    if (!previousElement && !nextElement || !isVisible) {
      return {};
    }

    const {
      ownerDocument
    } = previousElement || nextElement;
    const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
    const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;

    if (isVertical) {
      if ((0,_wordpress_i18n_build_module/* isRTL */.V8)()) {
        return {
          top: previousRect ? previousRect.bottom : nextRect.top,
          left: previousRect ? previousRect.right : nextRect.right,
          right: previousRect ? previousRect.left : nextRect.left,
          bottom: nextRect ? nextRect.top : previousRect.bottom,
          height: 0,
          width: 0,
          ownerDocument
        };
      }

      return {
        top: previousRect ? previousRect.bottom : nextRect.top,
        left: previousRect ? previousRect.left : nextRect.left,
        right: previousRect ? previousRect.right : nextRect.right,
        bottom: nextRect ? nextRect.top : previousRect.bottom,
        height: 0,
        width: 0,
        ownerDocument
      };
    }

    if ((0,_wordpress_i18n_build_module/* isRTL */.V8)()) {
      return {
        top: previousRect ? previousRect.top : nextRect.top,
        left: previousRect ? previousRect.left : nextRect.right,
        right: nextRect ? nextRect.right : previousRect.left,
        bottom: previousRect ? previousRect.bottom : nextRect.bottom,
        height: 0,
        width: 0,
        ownerDocument
      };
    }

    return {
      top: previousRect ? previousRect.top : nextRect.top,
      left: previousRect ? previousRect.right : nextRect.left,
      right: nextRect ? nextRect.left : previousRect.right,
      bottom: previousRect ? previousRect.bottom : nextRect.bottom,
      height: 0,
      width: 0,
      ownerDocument
    };
  }, [previousElement, nextElement]);
  const popoverScrollRef = use_popover_scroll(__unstableContentRef); // If there's either a previous or a next element, show the inbetween popover.
  // Note that drag and drop uses the inbetween popover to show the drop indicator
  // before the first block and after the last block.

  if (!previousElement && !nextElement || !isVisible) {
    return null;
  }
  /* eslint-disable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
  // While ideally it would be enough to capture the
  // bubbling focus event from the Inserter, due to the
  // characteristics of click focusing of `button`s in
  // Firefox and Safari, it is not reliable.
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus


  return (0,react.createElement)(popover, (0,esm_extends/* default */.A)({
    ref: popoverScrollRef,
    animate: false,
    getAnchorRect: getAnchorRect,
    focusOnMount: false // Render in the old slot if needed for backward compatibility,
    // otherwise render in place (not in the default popover slot).
    ,
    __unstableSlotName: __unstablePopoverSlot || null // Forces a remount of the popover when its position changes
    // This makes sure the popover doesn't animate from its previous position.
    ,
    key: nextClientId + '--' + rootClientId
  }, props, {
    className: classnames_default()('block-editor-block-popover', 'block-editor-block-popover__inbetween', props.className),
    __unstableForcePosition: true
  }), (0,react.createElement)("div", {
    style: style
  }, children));
  /* eslint-enable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
}

/* harmony default export */ const inbetween = (BlockPopoverInbetween);
//# sourceMappingURL=inbetween.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const insertion_point_InsertionPointOpenRef = (0,react.createContext)();

function InsertionPointPopover(_ref) {
  let {
    __unstablePopoverSlot,
    __unstableContentRef
  } = _ref;
  const {
    selectBlock,
    hideInsertionPoint
  } = use_dispatch(store_store);
  const openRef = (0,react.useContext)(insertion_point_InsertionPointOpenRef);
  const ref = (0,react.useRef)();
  const {
    orientation,
    previousClientId,
    nextClientId,
    rootClientId,
    isInserterShown
  } = use_select_useSelect(select => {
    var _getBlockListSettings;

    const {
      getBlockOrder,
      getBlockListSettings,
      getBlockInsertionPoint,
      isBlockBeingDragged,
      getPreviousBlockClientId,
      getNextBlockClientId
    } = select(store_store);
    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);

    if (!order.length) {
      return {};
    }

    let _previousClientId = order[insertionPoint.index - 1];
    let _nextClientId = order[insertionPoint.index];

    while (isBlockBeingDragged(_previousClientId)) {
      _previousClientId = getPreviousBlockClientId(_previousClientId);
    }

    while (isBlockBeingDragged(_nextClientId)) {
      _nextClientId = getNextBlockClientId(_nextClientId);
    }

    return {
      previousClientId: _previousClientId,
      nextClientId: _nextClientId,
      orientation: ((_getBlockListSettings = getBlockListSettings(insertionPoint.rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || 'vertical',
      rootClientId: insertionPoint.rootClientId,
      isInserterShown: insertionPoint === null || insertionPoint === void 0 ? void 0 : insertionPoint.__unstableWithInserter
    };
  }, []);
  const isVertical = orientation === 'vertical';
  const disableMotion = hooks_use_reduced_motion();

  function onClick(event) {
    if (event.target === ref.current && nextClientId) {
      selectBlock(nextClientId, -1);
    }
  }

  function onFocus(event) {
    // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.
    if (event.target !== ref.current) {
      openRef.current = true;
    }
  }

  function maybeHideInserterPoint(event) {
    // Only hide the inserter if it's triggered on the wrapper,
    // and the inserter is not open.
    if (event.target === ref.current && !openRef.current) {
      hideInsertionPoint();
    }
  } // Define animation variants for the line element.


  const horizontalLine = {
    start: {
      width: 0,
      top: '50%',
      bottom: '50%',
      x: 0
    },
    rest: {
      width: 4,
      top: 0,
      bottom: 0,
      x: -2
    },
    hover: {
      width: 4,
      top: 0,
      bottom: 0,
      x: -2
    }
  };
  const verticalLine = {
    start: {
      height: 0,
      left: '50%',
      right: '50%',
      y: 0
    },
    rest: {
      height: 4,
      left: 0,
      right: 0,
      y: -2
    },
    hover: {
      height: 4,
      left: 0,
      right: 0,
      y: -2
    }
  };
  const lineVariants = {
    // Initial position starts from the center and invisible.
    start: { ...(!isVertical ? horizontalLine.start : verticalLine.start),
      opacity: 0
    },
    // The line expands to fill the container. If the inserter is visible it
    // is delayed so it appears orchestrated.
    rest: { ...(!isVertical ? horizontalLine.rest : verticalLine.rest),
      opacity: 1,
      borderRadius: '2px',
      transition: {
        delay: isInserterShown ? 0.4 : 0
      }
    },
    hover: { ...(!isVertical ? horizontalLine.hover : verticalLine.hover),
      opacity: 1,
      borderRadius: '2px',
      transition: {
        delay: 0.4
      }
    }
  };
  const inserterVariants = {
    start: {
      scale: disableMotion ? 1 : 0
    },
    rest: {
      scale: 1,
      transition: {
        delay: 0.2
      }
    }
  };
  const className = classnames_default()('block-editor-block-list__insertion-point', 'is-' + orientation);
  return (0,react.createElement)(inbetween, {
    previousClientId: previousClientId,
    nextClientId: nextClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  }, (0,react.createElement)(motion/* motion */.P.div, {
    layout: !disableMotion,
    initial: disableMotion ? 'rest' : 'start',
    animate: "rest",
    whileHover: "hover",
    whileTap: "pressed",
    exit: "start",
    ref: ref,
    tabIndex: -1,
    onClick: onClick,
    onFocus: onFocus,
    className: classnames_default()(className, {
      'is-with-inserter': isInserterShown
    }),
    onHoverEnd: maybeHideInserterPoint
  }, (0,react.createElement)(motion/* motion */.P.div, {
    variants: lineVariants,
    className: "block-editor-block-list__insertion-point-indicator"
  }), isInserterShown && (0,react.createElement)(motion/* motion */.P.div, {
    variants: inserterVariants,
    className: classnames_default()('block-editor-block-list__insertion-point-inserter')
  }, (0,react.createElement)(inserter, {
    position: "bottom center",
    clientId: nextClientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true,
    onToggle: isOpen => {
      openRef.current = isOpen;
    },
    onSelectOrClose: () => {
      openRef.current = false;
    }
  }))));
}

function InsertionPoint(_ref2) {
  let {
    children,
    ...props
  } = _ref2;
  const isVisible = use_select_useSelect(select => {
    return select(store_store).isBlockInsertionPointVisible();
  }, []);
  return (0,react.createElement)(insertion_point_InsertionPointOpenRef.Provider, {
    value: (0,react.useRef)(false)
  }, isVisible && (0,react.createElement)(InsertionPointPopover, props), children);
}
//# sourceMappingURL=insertion-point.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/use-in-between-inserter.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function useInBetweenInserter() {
  const openRef = (0,react.useContext)(insertion_point_InsertionPointOpenRef);
  const hasReducedUI = use_select_useSelect(select => select(store_store).getSettings().hasReducedUI, []);
  const {
    getBlockListSettings,
    getBlockRootClientId,
    getBlockIndex,
    isBlockInsertionPointVisible,
    isMultiSelecting,
    getSelectedBlockClientIds,
    getTemplateLock
  } = use_select_useSelect(store_store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    if (hasReducedUI) {
      return;
    }

    function onMouseMove(event) {
      var _getBlockListSettings, _element$parentElemen;

      if (openRef.current) {
        return;
      }

      if (isMultiSelecting()) {
        return;
      }

      if (!event.target.classList.contains('block-editor-block-list__layout')) {
        if (isBlockInsertionPointVisible()) {
          hideInsertionPoint();
        }

        return;
      }

      let rootClientId;

      if (!event.target.classList.contains('is-root-container')) {
        const blockElement = !!event.target.getAttribute('data-block') ? event.target : event.target.closest('[data-block]');
        rootClientId = blockElement.getAttribute('data-block');
      } // Don't set the insertion point if the template is locked.


      if (getTemplateLock(rootClientId)) {
        return;
      }

      const orientation = ((_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || 'vertical';
      const rect = event.target.getBoundingClientRect();
      const offsetTop = event.clientY - rect.top;
      const offsetLeft = event.clientX - rect.left;
      const children = Array.from(event.target.children);
      let element = children.find(blockEl => {
        return blockEl.classList.contains('wp-block') && orientation === 'vertical' && blockEl.offsetTop > offsetTop || blockEl.classList.contains('wp-block') && orientation === 'horizontal' && blockEl.offsetLeft > offsetLeft;
      });

      if (!element) {
        return;
      } // The block may be in an alignment wrapper, so check the first direct
      // child if the element has no ID.


      if (!element.id) {
        element = element.firstElementChild;

        if (!element) {
          return;
        }
      } // Don't show the insertion point if a parent block has an "overlay"
      // See https://github.com/WordPress/gutenberg/pull/34012#pullrequestreview-727762337


      const parentOverlay = (_element$parentElemen = element.parentElement) === null || _element$parentElemen === void 0 ? void 0 : _element$parentElemen.closest('.block-editor-block-content-overlay');

      if (parentOverlay) {
        return;
      }

      const clientId = element.id.slice('block-'.length);

      if (!clientId) {
        return;
      } // Don't show the inserter when hovering above (conflicts with
      // block toolbar) or inside selected block(s).


      if (getSelectedBlockClientIds().includes(clientId)) {
        return;
      }

      const elementRect = element.getBoundingClientRect();

      if (orientation === 'horizontal' && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === 'vertical' && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
        if (isBlockInsertionPointVisible()) {
          hideInsertionPoint();
        }

        return;
      }

      const index = getBlockIndex(clientId); // Don't show the in-between inserter before the first block in
      // the list (preserves the original behaviour).

      if (index === 0) {
        if (isBlockInsertionPointVisible()) {
          hideInsertionPoint();
        }

        return;
      }

      showInsertionPoint(rootClientId, index, {
        __unstableWithInserter: true
      });
    }

    node.addEventListener('mousemove', onMouseMove);
    return () => {
      node.removeEventListener('mousemove', onMouseMove);
    };
  }, [openRef, getBlockListSettings, getBlockRootClientId, getBlockIndex, isBlockInsertionPointVisible, isMultiSelecting, showInsertionPoint, hideInsertionPoint, getSelectedBlockClientIds]);
}
//# sourceMappingURL=use-in-between-inserter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/pre-parse-patterns.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const requestIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return callback => {
      setTimeout(() => callback(Date.now()), 0);
    };
  }

  return window.requestIdleCallback || window.requestAnimationFrame;
})();

const cancelIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return clearTimeout;
  }

  return window.cancelIdleCallback || window.cancelAnimationFrame;
})();

function usePreParsePatterns() {
  const patterns = use_select_useSelect(_select => _select(store_store).getSettings().__experimentalBlockPatterns, []);
  (0,react.useEffect)(() => {
    if (!(patterns !== null && patterns !== void 0 && patterns.length)) {
      return;
    }

    let handle;
    let index = -1;

    const callback = () => {
      index++;

      if (index >= patterns.length) {
        return;
      }

      (0,data_build_module/* select */.Lt)(store_store).__experimentalGetParsedPattern(patterns[index].name);

      handle = requestIdleCallback(callback);
    };

    handle = requestIdleCallback(callback);
    return () => cancelIdleCallback(handle);
  }, [patterns]);
  return null;
}
//# sourceMappingURL=pre-parse-patterns.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/use-block-display-information/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/blocks').WPIcon} WPIcon */

/**
 * Contains basic block's information for display reasons.
 *
 * @typedef {Object} WPBlockDisplayInformation
 *
 * @property {string} title       Human-readable block type label.
 * @property {WPIcon} icon        Block type icon.
 * @property {string} description A detailed block type description.
 * @property {string} anchor      HTML anchor.
 */

/**
 * Hook used to try to find a matching block variation and return
 * the appropriate information for display reasons. In order to
 * to try to find a match we need to things:
 * 1. Block's client id to extract it's current attributes.
 * 2. A block variation should have set `isActive` prop to a proper function.
 *
 * If for any reason a block variaton match cannot be found,
 * the returned information come from the Block Type.
 * If no blockType is found with the provided clientId, returns null.
 *
 * @param {string} clientId Block's client id.
 * @return {?WPBlockDisplayInformation} Block's display information, or `null` when the block or its type not found.
 */

function useBlockDisplayInformation(clientId) {
  return use_select_useSelect(select => {
    if (!clientId) return null;
    const {
      getBlockName,
      getBlockAttributes
    } = select(store_store);
    const {
      getBlockType,
      getActiveBlockVariation
    } = select(build_module/* store */.M_);
    const blockName = getBlockName(clientId);
    const blockType = getBlockType(blockName);
    if (!blockType) return null;
    const attributes = getBlockAttributes(clientId);
    const match = getActiveBlockVariation(blockName, attributes);
    const blockTypeInfo = {
      title: blockType.title,
      icon: blockType.icon,
      description: blockType.description,
      anchor: attributes === null || attributes === void 0 ? void 0 : attributes.anchor
    };
    if (!match) return blockTypeInfo;
    return {
      title: match.title || blockType.title,
      icon: match.icon || blockType.icon,
      description: match.description || blockType.description,
      anchor: attributes === null || attributes === void 0 ? void 0 : attributes.anchor
    };
  }, [clientId]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-title/use-block-display-title.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Returns the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```js
 * useBlockDisplayTitle( { clientId: 'afd1cb17-2c08-4e7a-91be-007ba7ddc3a1', maximumLength: 17 } );
 * ```
 *
 * @param {Object}           props
 * @param {string}           props.clientId      Client ID of block.
 * @param {number|undefined} props.maximumLength The maximum length that the block title string may be before truncated.
 * @param {string|undefined} props.context       The context to pass to `getBlockLabel`.
 * @return {?string} Block title.
 */

function useBlockDisplayTitle(_ref) {
  let {
    clientId,
    maximumLength,
    context
  } = _ref;
  const {
    attributes,
    name,
    reusableBlockTitle
  } = use_select_useSelect(select => {
    if (!clientId) {
      return {};
    }

    const {
      getBlockName,
      getBlockAttributes,
      __experimentalGetReusableBlockTitle
    } = select(store_store);
    const blockName = getBlockName(clientId);

    if (!blockName) {
      return {};
    }

    const isReusable = (0,build_module/* isReusableBlock */.tk)((0,build_module/* getBlockType */.E7)(blockName));
    return {
      attributes: getBlockAttributes(clientId),
      name: blockName,
      reusableBlockTitle: isReusable && __experimentalGetReusableBlockTitle(getBlockAttributes(clientId).ref)
    };
  }, [clientId]);
  const blockInformation = useBlockDisplayInformation(clientId);

  if (!name || !blockInformation) {
    return null;
  }

  const blockType = (0,build_module/* getBlockType */.E7)(name);
  const blockLabel = blockType ? (0,build_module/* __experimentalGetBlockLabel */.Y0)(blockType, attributes, context) : null;
  const label = reusableBlockTitle || blockLabel; // Label will fallback to the title if no label is defined for the current
  // label context. If the label is defined we prioritize it over a
  // possible block variation title match.

  const blockTitle = label && label !== blockType.title ? label : blockInformation.title;

  if (maximumLength && maximumLength > 0 && blockTitle.length > maximumLength) {
    const omission = '...';
    return blockTitle.slice(0, maximumLength - omission.length) + omission;
  }

  return blockTitle;
}
//# sourceMappingURL=use-block-display-title.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-title/index.js
/**
 * Internal dependencies
 */

/**
 * Renders the block's configured title as a string, or empty if the title
 * cannot be determined.
 *
 * @example
 *
 * ```jsx
 * <BlockTitle clientId="afd1cb17-2c08-4e7a-91be-007ba7ddc3a1" maximumLength={ 17 }/>
 * ```
 *
 * @param {Object}           props
 * @param {string}           props.clientId      Client ID of block.
 * @param {number|undefined} props.maximumLength The maximum length that the block title string may be before truncated.
 * @param {string|undefined} props.context       The context to pass to `getBlockLabel`.
 *
 * @return {JSX.Element} Block title.
 */

function BlockTitle(_ref) {
  let {
    clientId,
    maximumLength,
    context
  } = _ref;
  return useBlockDisplayTitle({
    clientId,
    maximumLength,
    context
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js
/**
 * WordPress dependencies
 */


const SCROLL_INACTIVE_DISTANCE_PX = 50;
const SCROLL_INTERVAL_MS = 25;
const PIXELS_PER_SECOND_PER_PERCENTAGE = 1000;
const VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1000);
/**
 * React hook that scrolls the scroll container when a block is being dragged.
 *
 * @return {Function[]} `startScrolling`, `scrollOnDragOver`, `stopScrolling`
 *                      functions to be called in `onDragStart`, `onDragOver`
 *                      and `onDragEnd` events respectively.
 */

function useScrollWhenDragging() {
  const dragStartY = (0,react.useRef)(null);
  const velocityY = (0,react.useRef)(null);
  const scrollParentY = (0,react.useRef)(null);
  const scrollEditorInterval = (0,react.useRef)(null); // Clear interval when unmounting.

  (0,react.useEffect)(() => () => {
    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  }, []);
  const startScrolling = (0,react.useCallback)(event => {
    dragStartY.current = event.clientY; // Find nearest parent(s) to scroll.

    scrollParentY.current = getScrollContainer(event.target);
    scrollEditorInterval.current = setInterval(() => {
      if (scrollParentY.current && velocityY.current) {
        const newTop = scrollParentY.current.scrollTop + velocityY.current; // Setting `behavior: 'smooth'` as a scroll property seems to hurt performance.
        // Better to use a small scroll interval.

        scrollParentY.current.scroll({
          top: newTop
        });
      }
    }, SCROLL_INTERVAL_MS);
  }, []);
  const scrollOnDragOver = (0,react.useCallback)(event => {
    if (!scrollParentY.current) {
      return;
    }

    const scrollParentHeight = scrollParentY.current.offsetHeight;
    const offsetDragStartPosition = dragStartY.current - scrollParentY.current.offsetTop;
    const offsetDragPosition = event.clientY - scrollParentY.current.offsetTop;

    if (event.clientY > offsetDragStartPosition) {
      // User is dragging downwards.
      const moveableDistance = Math.max(scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = dragDistance / moveableDistance;
      velocityY.current = VELOCITY_MULTIPLIER * distancePercentage;
    } else if (event.clientY < offsetDragStartPosition) {
      // User is dragging upwards.
      const moveableDistance = Math.max(offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const dragDistance = Math.max(offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
      const distancePercentage = dragDistance / moveableDistance;
      velocityY.current = -VELOCITY_MULTIPLIER * distancePercentage;
    } else {
      velocityY.current = 0;
    }
  }, []);

  const stopScrolling = () => {
    dragStartY.current = null;
    scrollParentY.current = null;

    if (scrollEditorInterval.current) {
      clearInterval(scrollEditorInterval.current);
      scrollEditorInterval.current = null;
    }
  };

  return [startScrolling, scrollOnDragOver, stopScrolling];
}
//# sourceMappingURL=use-scroll-when-dragging.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-draggable/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const BlockDraggable = _ref => {
  let {
    children,
    clientIds,
    cloneClassname,
    onDragStart,
    onDragEnd
  } = _ref;
  const {
    srcRootClientId,
    isDraggable,
    icon
  } = use_select_useSelect(select => {
    var _getBlockType;

    const {
      canMoveBlocks,
      getBlockRootClientId,
      getBlockName
    } = select(store_store);
    const rootClientId = getBlockRootClientId(clientIds[0]);
    const blockName = getBlockName(clientIds[0]);
    return {
      srcRootClientId: rootClientId,
      isDraggable: canMoveBlocks(clientIds, rootClientId),
      icon: (_getBlockType = (0,build_module/* getBlockType */.E7)(blockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon
    };
  }, [clientIds]);
  const isDragging = (0,react.useRef)(false);
  const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
  const {
    startDraggingBlocks,
    stopDraggingBlocks
  } = use_dispatch(store_store); // Stop dragging blocks if the block draggable is unmounted.

  (0,react.useEffect)(() => {
    return () => {
      if (isDragging.current) {
        stopDraggingBlocks();
      }
    };
  }, []);

  if (!isDraggable) {
    return children({
      isDraggable: false
    });
  }

  const transferData = {
    type: 'block',
    srcClientIds: clientIds,
    srcRootClientId
  };
  return (0,react.createElement)(Draggable, {
    cloneClassname: cloneClassname,
    __experimentalTransferDataType: "wp-blocks",
    transferData: transferData,
    onDragStart: event => {
      startDraggingBlocks(clientIds);
      isDragging.current = true;
      startScrolling(event);

      if (onDragStart) {
        onDragStart();
      }
    },
    onDragOver: scrollOnDragOver,
    onDragEnd: () => {
      stopDraggingBlocks();
      isDragging.current = false;
      stopScrolling();

      if (onDragEnd) {
        onDragEnd();
      }
    },
    __experimentalDragComponent: (0,react.createElement)(BlockDraggableChip, {
      count: clientIds.length,
      icon: icon
    })
  }, _ref2 => {
    let {
      onDraggableStart,
      onDraggableEnd
    } = _ref2;
    return children({
      draggable: true,
      onDragStart: onDraggableStart,
      onDragEnd: onDraggableEnd
    });
  });
};

/* harmony default export */ const block_draggable = (BlockDraggable);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/block-selection-button.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */










/**
 * Internal dependencies
 */







/**
 * Block selection button component, displaying the label of the block. If the block
 * descends from a root block, a button is displayed enabling the user to select
 * the root block.
 *
 * @param {string} props          Component props.
 * @param {string} props.clientId Client ID of block.
 *
 * @return {WPComponent} The component to be rendered.
 */

function BlockSelectionButton(_ref) {
  let {
    clientId,
    rootClientId
  } = _ref;
  const blockInformation = useBlockDisplayInformation(clientId);
  const selected = use_select_useSelect(select => {
    var _getBlockListSettings;

    const {
      getBlock,
      getBlockIndex,
      hasBlockMovingClientId,
      getBlockListSettings
    } = select(store_store);
    const index = getBlockIndex(clientId);
    const {
      name,
      attributes
    } = getBlock(clientId);
    const blockMovingMode = hasBlockMovingClientId();
    return {
      index,
      name,
      attributes,
      blockMovingMode,
      orientation: (_getBlockListSettings = getBlockListSettings(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
    };
  }, [clientId, rootClientId]);
  const {
    index,
    name,
    attributes,
    blockMovingMode,
    orientation
  } = selected;
  const {
    setNavigationMode,
    removeBlock
  } = use_dispatch(store_store);
  const ref = (0,react.useRef)();
  const blockType = (0,build_module/* getBlockType */.E7)(name);
  const label = (0,build_module/* __experimentalGetAccessibleBlockLabel */.wZ)(blockType, attributes, index + 1, orientation); // Focus the breadcrumb in navigation mode.

  (0,react.useEffect)(() => {
    ref.current.focus();
    speak(label);
  }, [label]);
  const blockElement = useBlockElement(clientId);
  const {
    hasBlockMovingClientId,
    getBlockIndex,
    getBlockRootClientId,
    getClientIdsOfDescendants,
    getSelectedBlockClientId,
    getMultiSelectedBlocksEndClientId,
    getPreviousBlockClientId,
    getNextBlockClientId
  } = use_select_useSelect(store_store);
  const {
    selectBlock,
    clearSelectedBlock,
    setBlockMovingClientId,
    moveBlockToPosition
  } = use_dispatch(store_store);

  function onKeyDown(event) {
    const {
      keyCode
    } = event;
    const isUp = keyCode === keycodes_build_module.UP;
    const isDown = keyCode === keycodes_build_module/* DOWN */.PX;
    const isLeft = keyCode === keycodes_build_module/* LEFT */.M3;
    const isRight = keyCode === keycodes_build_module/* RIGHT */.NS;
    const isTab = keyCode === keycodes_build_module/* TAB */.wn;
    const isEscape = keyCode === keycodes_build_module/* ESCAPE */._f;
    const isEnter = keyCode === keycodes_build_module/* ENTER */.Fm;
    const isSpace = keyCode === keycodes_build_module/* SPACE */.t6;
    const isShift = event.shiftKey;

    if (keyCode === keycodes_build_module/* BACKSPACE */.G_ || keyCode === keycodes_build_module/* DELETE */.SJ) {
      removeBlock(clientId);
      event.preventDefault();
      return;
    }

    const selectedBlockClientId = getSelectedBlockClientId();
    const selectionEndClientId = getMultiSelectedBlocksEndClientId();
    const selectionBeforeEndClientId = getPreviousBlockClientId(selectionEndClientId || selectedBlockClientId);
    const selectionAfterEndClientId = getNextBlockClientId(selectionEndClientId || selectedBlockClientId);
    const navigateUp = isTab && isShift || isUp;
    const navigateDown = isTab && !isShift || isDown; // Move out of current nesting level (no effect if at root level).

    const navigateOut = isLeft; // Move into next nesting level (no effect if the current block has no innerBlocks).

    const navigateIn = isRight;
    let focusedBlockUid;

    if (navigateUp) {
      focusedBlockUid = selectionBeforeEndClientId;
    } else if (navigateDown) {
      focusedBlockUid = selectionAfterEndClientId;
    } else if (navigateOut) {
      var _getBlockRootClientId;

      focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
    } else if (navigateIn) {
      var _getClientIdsOfDescen;

      focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants([selectedBlockClientId])[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
    }

    const startingBlockClientId = hasBlockMovingClientId();

    if (isEscape && startingBlockClientId && !event.defaultPrevented) {
      setBlockMovingClientId(null);
      event.preventDefault();
    }

    if ((isEnter || isSpace) && startingBlockClientId) {
      const sourceRoot = getBlockRootClientId(startingBlockClientId);
      const destRoot = getBlockRootClientId(selectedBlockClientId);
      const sourceBlockIndex = getBlockIndex(startingBlockClientId);
      let destinationBlockIndex = getBlockIndex(selectedBlockClientId);

      if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
        destinationBlockIndex -= 1;
      }

      moveBlockToPosition(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
      selectBlock(startingBlockClientId);
      setBlockMovingClientId(null);
    }

    if (navigateDown || navigateUp || navigateOut || navigateIn) {
      if (focusedBlockUid) {
        event.preventDefault();
        selectBlock(focusedBlockUid);
      } else if (isTab && selectedBlockClientId) {
        let nextTabbable;

        if (navigateDown) {
          nextTabbable = blockElement;

          do {
            nextTabbable = dom_build_module/* focus */.XC.tabbable.findNext(nextTabbable);
          } while (nextTabbable && blockElement.contains(nextTabbable));

          if (!nextTabbable) {
            nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
            nextTabbable = dom_build_module/* focus */.XC.tabbable.findNext(nextTabbable);
          }
        } else {
          nextTabbable = dom_build_module/* focus */.XC.tabbable.findPrevious(blockElement);
        }

        if (nextTabbable) {
          event.preventDefault();
          nextTabbable.focus();
          clearSelectedBlock();
        }
      }
    }
  }

  const classNames = classnames_default()('block-editor-block-list__block-selection-button', {
    'is-block-moving-mode': !!blockMovingMode
  });

  const dragHandleLabel = (0,_wordpress_i18n_build_module.__)('Drag');

  return (0,react.createElement)("div", {
    className: classNames
  }, (0,react.createElement)(flex_component, {
    justify: "center",
    className: "block-editor-block-list__block-selection-button__content"
  }, (0,react.createElement)(flex_item_component, null, (0,react.createElement)(block_icon, {
    icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon,
    showColors: true
  })), (0,react.createElement)(flex_item_component, null, (0,react.createElement)(block_draggable, {
    clientIds: [clientId]
  }, draggableProps => (0,react.createElement)(build_module_button, (0,esm_extends/* default */.A)({
    icon: drag_handle,
    className: "block-selection-button_drag-handle",
    "aria-hidden": "true",
    label: dragHandleLabel // Should not be able to tab to drag handle as this
    // button can only be used with a pointer device.
    ,
    tabIndex: "-1"
  }, draggableProps)))), (0,react.createElement)(flex_item_component, null, (0,react.createElement)(build_module_button, {
    ref: ref,
    onClick: () => setNavigationMode(false),
    onKeyDown: onKeyDown,
    label: label,
    showTooltip: false,
    className: "block-selection-button_select-button"
  }, (0,react.createElement)(BlockTitle, {
    clientId: clientId,
    maximumLength: 35
  })))));
}

/* harmony default export */ const block_selection_button = (BlockSelectionButton);
//# sourceMappingURL=block-selection-button.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Toolbar/ToolbarState.js
var ToolbarState = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Toolbar/ToolbarState.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Toolbar/Toolbar.js
var Toolbar = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Toolbar/Toolbar.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar/toolbar-container.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function ToolbarContainer(_ref, ref) {
  let {
    label,
    ...props
  } = _ref;
  // https://reakit.io/docs/basic-concepts/#state-hooks
  // Passing baseId for server side rendering (which includes snapshots)
  // If an id prop is passed to Toolbar, toolbar items will use it as a base for their ids
  const toolbarState = (0,ToolbarState/* useToolbarState */.S)({
    loop: true,
    baseId: props.id,
    rtl: (0,i18n_build_module/* isRTL */.V8)()
  });
  return (// This will provide state for `ToolbarButton`'s
    (0,react.createElement)(toolbar_context.Provider, {
      value: toolbarState
    }, (0,react.createElement)(Toolbar/* Toolbar */.M, (0,helpers_esm_extends/* default */.A)({
      ref: ref,
      "aria-label": label
    }, toolbarState, props)))
  );
}

/* harmony default export */ const toolbar_container = ((0,react.forwardRef)(ToolbarContainer));
//# sourceMappingURL=toolbar-container.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toolbar/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Renders a toolbar.
 *
 * To add controls, simply pass `ToolbarButton` components as children.
 *
 * @param {Object} props             Component props.
 * @param {string} [props.className] Class to set on the container div.
 * @param {string} [props.label]     ARIA label for toolbar container.
 * @param {Object} ref               React Element ref.
 */

function toolbar_Toolbar(_ref, ref) {
  let {
    className,
    label,
    ...props
  } = _ref;

  if (!label) {
    (0,deprecated_build_module/* default */.A)('Using Toolbar without label prop', {
      since: '5.6',
      alternative: 'ToolbarGroup component',
      link: 'https://developer.wordpress.org/block-editor/components/toolbar/'
    });
    return (0,react.createElement)(toolbar_group, (0,helpers_esm_extends/* default */.A)({}, props, {
      className: className
    }));
  } // `ToolbarGroup` already uses components-toolbar for compatibility reasons.


  const finalClassName = classnames_default()('components-accessible-toolbar', className);
  return (0,react.createElement)(toolbar_container, (0,helpers_esm_extends/* default */.A)({
    className: finalClassName,
    label: label,
    ref: ref
  }, props));
}

/* harmony default export */ const toolbar = ((0,react.forwardRef)(toolbar_Toolbar));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/navigable-toolbar/index.js



/**
 * WordPress dependencies
 */






function hasOnlyToolbarItem(elements) {
  const dataProp = 'toolbarItem';
  return !elements.some(element => !(dataProp in element.dataset));
}

function getAllToolbarItemsIn(container) {
  return Array.from(container.querySelectorAll('[data-toolbar-item]'));
}

function hasFocusWithin(container) {
  return container.contains(container.ownerDocument.activeElement);
}

function focusFirstTabbableIn(container) {
  const [firstTabbable] = dom_build_module/* focus */.XC.tabbable.find(container);

  if (firstTabbable) {
    firstTabbable.focus({
      // When focusing newly mounted toolbars,
      // the position of the popover is often not right on the first render
      // This prevents the layout shifts when focusing the dialogs.
      preventScroll: true
    });
  }
}

function useIsAccessibleToolbar(ref) {
  /*
   * By default, we'll assume the starting accessible state of the Toolbar
   * is true, as it seems to be the most common case.
   *
   * Transitioning from an (initial) false to true state causes the
   * <Toolbar /> component to mount twice, which is causing undesired
   * side-effects. These side-effects appear to only affect certain
   * E2E tests.
   *
   * This was initial discovered in this pull-request:
   * https://github.com/WordPress/gutenberg/pull/23425
   */
  const initialAccessibleToolbarState = true; // By default, it's gonna render NavigableMenu. If all the tabbable elements
  // inside the toolbar are ToolbarItem components (or derived components like
  // ToolbarButton), then we can wrap them with the accessible Toolbar
  // component.

  const [isAccessibleToolbar, setIsAccessibleToolbar] = (0,react.useState)(initialAccessibleToolbarState);
  const determineIsAccessibleToolbar = (0,react.useCallback)(() => {
    const tabbables = dom_build_module/* focus */.XC.tabbable.find(ref.current);
    const onlyToolbarItem = hasOnlyToolbarItem(tabbables);

    if (!onlyToolbarItem) {
      (0,deprecated_build_module/* default */.A)('Using custom components as toolbar controls', {
        since: '5.6',
        alternative: 'ToolbarItem, ToolbarButton or ToolbarDropdownMenu components',
        link: 'https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols'
      });
    }

    setIsAccessibleToolbar(onlyToolbarItem);
  }, []);
  (0,react.useLayoutEffect)(() => {
    // Toolbar buttons may be rendered asynchronously, so we use
    // MutationObserver to check if the toolbar subtree has been modified.
    const observer = new window.MutationObserver(determineIsAccessibleToolbar);
    observer.observe(ref.current, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, [isAccessibleToolbar]);
  return isAccessibleToolbar;
}

function useToolbarFocus(ref, focusOnMount, isAccessibleToolbar, defaultIndex, onIndexChange) {
  // Make sure we don't use modified versions of this prop.
  const [initialFocusOnMount] = (0,react.useState)(focusOnMount);
  const [initialIndex] = (0,react.useState)(defaultIndex);
  const focusToolbar = (0,react.useCallback)(() => {
    focusFirstTabbableIn(ref.current);
  }, []); // Focus on toolbar when pressing alt+F10 when the toolbar is visible.

  useShortcut('core/block-editor/focus-toolbar', focusToolbar);
  (0,react.useEffect)(() => {
    if (initialFocusOnMount) {
      focusToolbar();
    }
  }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
  (0,react.useEffect)(() => {
    // If initialIndex is passed, we focus on that toolbar item when the
    // toolbar gets mounted and initial focus is not forced.
    // We have to wait for the next browser paint because block controls aren't
    // rendered right away when the toolbar gets mounted.
    let raf = 0;

    if (initialIndex && !initialFocusOnMount) {
      raf = window.requestAnimationFrame(() => {
        const items = getAllToolbarItemsIn(ref.current);
        const index = initialIndex || 0;

        if (items[index] && hasFocusWithin(ref.current)) {
          items[index].focus({
            // When focusing newly mounted toolbars,
            // the position of the popover is often not right on the first render
            // This prevents the layout shifts when focusing the dialogs.
            preventScroll: true
          });
        }
      });
    }

    return () => {
      window.cancelAnimationFrame(raf);
      if (!onIndexChange || !ref.current) return; // When the toolbar element is unmounted and onIndexChange is passed, we
      // pass the focused toolbar item index so it can be hydrated later.

      const items = getAllToolbarItemsIn(ref.current);
      const index = items.findIndex(item => item.tabIndex === 0);
      onIndexChange(index);
    };
  }, [initialIndex, initialFocusOnMount]);
}

function NavigableToolbar(_ref) {
  let {
    children,
    focusOnMount,
    __experimentalInitialIndex: initialIndex,
    __experimentalOnIndexChange: onIndexChange,
    ...props
  } = _ref;
  const ref = (0,react.useRef)();
  const isAccessibleToolbar = useIsAccessibleToolbar(ref);
  useToolbarFocus(ref, focusOnMount, isAccessibleToolbar, initialIndex, onIndexChange);

  if (isAccessibleToolbar) {
    return (0,react.createElement)(toolbar, (0,esm_extends/* default */.A)({
      label: props['aria-label'],
      ref: ref
    }, props), children);
  }

  return (0,react.createElement)(navigable_container_menu, (0,esm_extends/* default */.A)({
    orientation: "horizontal",
    role: "toolbar",
    ref: ref
  }, props), children);
}

/* harmony default export */ const navigable_toolbar = (NavigableToolbar);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/chevron-right.js

/**
 * WordPress dependencies
 */

const chevronRight = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z"
}));
/* harmony default export */ const chevron_right = (chevronRight);
//# sourceMappingURL=chevron-right.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/chevron-left.js

/**
 * WordPress dependencies
 */

const chevronLeft = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z"
}));
/* harmony default export */ const chevron_left = (chevronLeft);
//# sourceMappingURL=chevron-left.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-mover/mover-description.js
/**
 * WordPress dependencies
 */


const getMovementDirection = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? 'right' : 'left';
    }

    return 'up';
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? 'left' : 'right';
    }

    return 'down';
  }

  return null;
};
/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {string}  type          Block type - in the case of a single block, should
 *                                define its 'type'. I.e. 'Text', 'Heading', 'Image' etc.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 *                                horizontal.
 *
 * @return {string} Label for the block movement controls.
 */


function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;

  if (selectedCount > 1) {
    return getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation);
  }

  if (isFirst && isLast) {
    return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: Type of block (i.e. Text, Image etc)
    (0,_wordpress_i18n_build_module.__)('Block %s is the only block, and cannot be moved'), type);
  }

  if (dir > 0 && !isLast) {
    // Moving down.
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,_wordpress_i18n_build_module.__)('Move %1$s block from position %2$d down to position %3$d'), type, position, position + 1);
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,_wordpress_i18n_build_module.__)('Move %1$s block from position %2$d left to position %3$d'), type, position, position + 1);
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,_wordpress_i18n_build_module.__)('Move %1$s block from position %2$d right to position %3$d'), type, position, position + 1);
    }
  }

  if (dir > 0 && isLast) {
    // Moving down, and is the last item.
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,_wordpress_i18n_build_module.__)('Block %1$s is at the end of the content and can’t be moved down'), type);
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,_wordpress_i18n_build_module.__)('Block %1$s is at the end of the content and can’t be moved left'), type);
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,_wordpress_i18n_build_module.__)('Block %1$s is at the end of the content and can’t be moved right'), type);
    }
  }

  if (dir < 0 && !isFirst) {
    // Moving up.
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,_wordpress_i18n_build_module.__)('Move %1$s block from position %2$d up to position %3$d'), type, position, position - 1);
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,_wordpress_i18n_build_module.__)('Move %1$s block from position %2$d left to position %3$d'), type, position, position - 1);
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc), 2: Position of selected block, 3: New position
      (0,_wordpress_i18n_build_module.__)('Move %1$s block from position %2$d right to position %3$d'), type, position, position - 1);
    }
  }

  if (dir < 0 && isFirst) {
    // Moving up, and is the first item.
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,_wordpress_i18n_build_module.__)('Block %1$s is at the beginning of the content and can’t be moved up'), type);
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,_wordpress_i18n_build_module.__)('Block %1$s is at the beginning of the content and can’t be moved left'), type);
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Type of block (i.e. Text, Image etc)
      (0,_wordpress_i18n_build_module.__)('Block %1$s is at the beginning of the content and can’t be moved right'), type);
    }
  }
}
/**
 * Return a label for the block movement controls depending on block position.
 *
 * @param {number}  selectedCount Number of blocks selected.
 * @param {number}  firstIndex    The index (position - 1) of the first block selected.
 * @param {boolean} isFirst       This is the first block.
 * @param {boolean} isLast        This is the last block.
 * @param {number}  dir           Direction of movement (> 0 is considered to be going
 *                                down, < 0 is up).
 * @param {string}  orientation   The orientation of the block movers, vertical or
 *                                horizontal.
 *
 * @return {string} Label for the block movement controls.
 */

function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation) {
  const position = firstIndex + 1;

  if (isFirst && isLast) {
    // All blocks are selected
    return (0,_wordpress_i18n_build_module.__)('All blocks are selected, and cannot be moved');
  }

  if (dir > 0 && !isLast) {
    // moving down
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,_wordpress_i18n_build_module.__)('Move %1$d blocks from position %2$d down by one place'), selectedCount, position);
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,_wordpress_i18n_build_module.__)('Move %1$d blocks from position %2$d left by one place'), selectedCount, position);
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,_wordpress_i18n_build_module.__)('Move %1$d blocks from position %2$d right by one place'), selectedCount, position);
    }
  }

  if (dir > 0 && isLast) {
    // moving down, and the selected blocks are the last item
    const movementDirection = getMovementDirection('down', orientation);

    if (movementDirection === 'down') {
      return (0,_wordpress_i18n_build_module.__)('Blocks cannot be moved down as they are already at the bottom');
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module.__)('Blocks cannot be moved left as they are already are at the leftmost position');
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module.__)('Blocks cannot be moved right as they are already are at the rightmost position');
    }
  }

  if (dir < 0 && !isFirst) {
    // moving up
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,_wordpress_i18n_build_module.__)('Move %1$d blocks from position %2$d up by one place'), selectedCount, position);
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,_wordpress_i18n_build_module.__)('Move %1$d blocks from position %2$d left by one place'), selectedCount, position);
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: 1: Number of selected blocks, 2: Position of selected blocks
      (0,_wordpress_i18n_build_module.__)('Move %1$d blocks from position %2$d right by one place'), selectedCount, position);
    }
  }

  if (dir < 0 && isFirst) {
    // moving up, and the selected blocks are the first item
    const movementDirection = getMovementDirection('up', orientation);

    if (movementDirection === 'up') {
      return (0,_wordpress_i18n_build_module.__)('Blocks cannot be moved up as they are already at the top');
    }

    if (movementDirection === 'left') {
      return (0,_wordpress_i18n_build_module.__)('Blocks cannot be moved left as they are already are at the leftmost position');
    }

    if (movementDirection === 'right') {
      return (0,_wordpress_i18n_build_module.__)('Blocks cannot be moved right as they are already are at the rightmost position');
    }
  }
}
//# sourceMappingURL=mover-description.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */





const getArrowIcon = (direction, orientation) => {
  if (direction === 'up') {
    if (orientation === 'horizontal') {
      return (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? chevron_right : chevron_left;
    }

    return chevron_up;
  } else if (direction === 'down') {
    if (orientation === 'horizontal') {
      return (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? chevron_left : chevron_right;
    }

    return chevron_down;
  }

  return null;
};

const getMovementDirectionLabel = (moveDirection, orientation) => {
  if (moveDirection === 'up') {
    if (orientation === 'horizontal') {
      return (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? (0,_wordpress_i18n_build_module.__)('Move right') : (0,_wordpress_i18n_build_module.__)('Move left');
    }

    return (0,_wordpress_i18n_build_module.__)('Move up');
  } else if (moveDirection === 'down') {
    if (orientation === 'horizontal') {
      return (0,_wordpress_i18n_build_module/* isRTL */.V8)() ? (0,_wordpress_i18n_build_module.__)('Move left') : (0,_wordpress_i18n_build_module.__)('Move right');
    }

    return (0,_wordpress_i18n_build_module.__)('Move down');
  }

  return null;
};

const BlockMoverButton = (0,react.forwardRef)((_ref, ref) => {
  let {
    clientIds,
    direction,
    orientation: moverOrientation,
    ...props
  } = _ref;
  const instanceId = (0,use_instance_id/* default */.A)(BlockMoverButton);
  const blocksCount = (0,lodash.castArray)(clientIds).length;
  const {
    blockType,
    isDisabled,
    rootClientId,
    isFirst,
    isLast,
    firstIndex,
    orientation = 'vertical'
  } = use_select_useSelect(select => {
    const {
      getBlockIndex,
      getBlockRootClientId,
      getBlockOrder,
      getBlock,
      getBlockListSettings
    } = select(store_store);
    const normalizedClientIds = (0,lodash.castArray)(clientIds);
    const firstClientId = (0,lodash.first)(normalizedClientIds);
    const blockRootClientId = getBlockRootClientId(firstClientId);
    const firstBlockIndex = getBlockIndex(firstClientId);
    const lastBlockIndex = getBlockIndex((0,lodash.last)(normalizedClientIds));
    const blockOrder = getBlockOrder(blockRootClientId);
    const block = getBlock(firstClientId);
    const isFirstBlock = firstBlockIndex === 0;
    const isLastBlock = lastBlockIndex === blockOrder.length - 1;
    const {
      orientation: blockListOrientation
    } = getBlockListSettings(blockRootClientId) || {};
    return {
      blockType: block ? (0,build_module/* getBlockType */.E7)(block.name) : null,
      isDisabled: direction === 'up' ? isFirstBlock : isLastBlock,
      rootClientId: blockRootClientId,
      firstIndex: firstBlockIndex,
      isFirst: isFirstBlock,
      isLast: isLastBlock,
      orientation: moverOrientation || blockListOrientation
    };
  }, [clientIds, direction]);
  const {
    moveBlocksDown,
    moveBlocksUp
  } = use_dispatch(store_store);
  const moverFunction = direction === 'up' ? moveBlocksUp : moveBlocksDown;

  const onClick = event => {
    moverFunction(clientIds, rootClientId);

    if (props.onClick) {
      props.onClick(event);
    }
  };

  const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(build_module_button, (0,esm_extends/* default */.A)({
    ref: ref,
    className: classnames_default()('block-editor-block-mover-button', `is-${direction}-button`),
    icon: getArrowIcon(direction, orientation),
    label: getMovementDirectionLabel(direction, orientation),
    "aria-describedby": descriptionId
  }, props, {
    onClick: isDisabled ? null : onClick,
    disabled: isDisabled,
    __experimentalIsFocusable: true
  })), (0,react.createElement)(visually_hidden_component, {
    id: descriptionId
  }, getBlockMoverDescription(blocksCount, blockType && blockType.title, firstIndex, isFirst, isLast, direction === 'up' ? -1 : 1, orientation)));
});
const BlockMoverUpButton = (0,react.forwardRef)((props, ref) => {
  return (0,react.createElement)(BlockMoverButton, (0,esm_extends/* default */.A)({
    direction: "up",
    ref: ref
  }, props));
});
const BlockMoverDownButton = (0,react.forwardRef)((props, ref) => {
  return (0,react.createElement)(BlockMoverButton, (0,esm_extends/* default */.A)({
    direction: "down",
    ref: ref
  }, props));
});
//# sourceMappingURL=button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-mover/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





function BlockMover(_ref) {
  let {
    clientIds,
    hideDragHandle
  } = _ref;
  const {
    canMove,
    rootClientId,
    isFirst,
    isLast,
    orientation
  } = use_select_useSelect(select => {
    var _getBlockListSettings;

    const {
      getBlockIndex,
      getBlockListSettings,
      canMoveBlocks,
      getBlockOrder,
      getBlockRootClientId
    } = select(store_store);
    const normalizedClientIds = (0,lodash.castArray)(clientIds);
    const firstClientId = (0,lodash.first)(normalizedClientIds);

    const _rootClientId = getBlockRootClientId((0,lodash.first)(normalizedClientIds));

    const firstIndex = getBlockIndex(firstClientId);
    const lastIndex = getBlockIndex((0,lodash.last)(normalizedClientIds));
    const blockOrder = getBlockOrder(_rootClientId);
    return {
      canMove: canMoveBlocks(clientIds, _rootClientId),
      rootClientId: _rootClientId,
      isFirst: firstIndex === 0,
      isLast: lastIndex === blockOrder.length - 1,
      orientation: (_getBlockListSettings = getBlockListSettings(_rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
    };
  }, [clientIds]);

  if (!canMove || isFirst && isLast && !rootClientId) {
    return null;
  }

  const dragHandleLabel = (0,_wordpress_i18n_build_module.__)('Drag');

  return (0,react.createElement)(toolbar_group, {
    className: classnames_default()('block-editor-block-mover', {
      'is-horizontal': orientation === 'horizontal'
    })
  }, !hideDragHandle && (0,react.createElement)(block_draggable, {
    clientIds: clientIds
  }, draggableProps => (0,react.createElement)(build_module_button, (0,esm_extends/* default */.A)({
    icon: drag_handle,
    className: "block-editor-block-mover__drag-handle",
    "aria-hidden": "true",
    label: dragHandleLabel // Should not be able to tab to drag handle as this
    // button can only be used with a pointer device.
    ,
    tabIndex: "-1"
  }, draggableProps))), (0,react.createElement)("div", {
    className: "block-editor-block-mover__move-button-container"
  }, (0,react.createElement)(toolbar_item, null, itemProps => (0,react.createElement)(BlockMoverUpButton, (0,esm_extends/* default */.A)({
    clientIds: clientIds
  }, itemProps))), (0,react.createElement)(toolbar_item, null, itemProps => (0,react.createElement)(BlockMoverDownButton, (0,esm_extends/* default */.A)({
    clientIds: clientIds
  }, itemProps)))));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-mover/README.md
 */


/* harmony default export */ const block_mover = (BlockMover);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/utils.js
/**
 * WordPress dependencies
 */

const {
  clearTimeout: utils_clearTimeout,
  setTimeout: utils_setTimeout
} = window;

const block_toolbar_utils_noop = () => {};

const DEBOUNCE_TIMEOUT = 200;
/**
 * Hook that creates a showMover state, as well as debounced show/hide callbacks.
 *
 * @param {Object}   props                       Component props.
 * @param {Object}   props.ref                   Element reference.
 * @param {boolean}  props.isFocused             Whether the component has current focus.
 * @param {number}   [props.debounceTimeout=250] Debounce timeout in milliseconds.
 * @param {Function} [props.onChange=noop]       Callback function.
 */

function useDebouncedShowMovers(_ref) {
  let {
    ref,
    isFocused,
    debounceTimeout = DEBOUNCE_TIMEOUT,
    onChange = block_toolbar_utils_noop
  } = _ref;
  const [showMovers, setShowMovers] = (0,react.useState)(false);
  const timeoutRef = (0,react.useRef)();

  const handleOnChange = nextIsFocused => {
    if (ref !== null && ref !== void 0 && ref.current) {
      setShowMovers(nextIsFocused);
    }

    onChange(nextIsFocused);
  };

  const getIsHovered = () => {
    return (ref === null || ref === void 0 ? void 0 : ref.current) && ref.current.matches(':hover');
  };

  const shouldHideMovers = () => {
    const isHovered = getIsHovered();
    return !isFocused && !isHovered;
  };

  const clearTimeoutRef = () => {
    const timeout = timeoutRef.current;

    if (timeout && utils_clearTimeout) {
      utils_clearTimeout(timeout);
    }
  };

  const debouncedShowMovers = event => {
    if (event) {
      event.stopPropagation();
    }

    clearTimeoutRef();

    if (!showMovers) {
      handleOnChange(true);
    }
  };

  const debouncedHideMovers = event => {
    if (event) {
      event.stopPropagation();
    }

    clearTimeoutRef();
    timeoutRef.current = utils_setTimeout(() => {
      if (shouldHideMovers()) {
        handleOnChange(false);
      }
    }, debounceTimeout);
  };

  (0,react.useEffect)(() => () => {
    /**
     * We need to call the change handler with `isFocused`
     * set to false on unmount because we also clear the
     * timeout that would handle that.
     */
    handleOnChange(false);
    clearTimeoutRef();
  }, []);
  return {
    showMovers,
    debouncedShowMovers,
    debouncedHideMovers
  };
}
/**
 * Hook that provides a showMovers state and gesture events for DOM elements
 * that interact with the showMovers state.
 *
 * @param {Object}   props                       Component props.
 * @param {Object}   props.ref                   Element reference.
 * @param {number}   [props.debounceTimeout=250] Debounce timeout in milliseconds.
 * @param {Function} [props.onChange=noop]       Callback function.
 */

function useShowMoversGestures(_ref2) {
  let {
    ref,
    debounceTimeout = DEBOUNCE_TIMEOUT,
    onChange = block_toolbar_utils_noop
  } = _ref2;
  const [isFocused, setIsFocused] = (0,react.useState)(false);
  const {
    showMovers,
    debouncedShowMovers,
    debouncedHideMovers
  } = useDebouncedShowMovers({
    ref,
    debounceTimeout,
    isFocused,
    onChange
  });
  const registerRef = (0,react.useRef)(false);

  const isFocusedWithin = () => {
    return (ref === null || ref === void 0 ? void 0 : ref.current) && ref.current.contains(ref.current.ownerDocument.activeElement);
  };

  (0,react.useEffect)(() => {
    const node = ref.current;

    const handleOnFocus = () => {
      if (isFocusedWithin()) {
        setIsFocused(true);
        debouncedShowMovers();
      }
    };

    const handleOnBlur = () => {
      if (!isFocusedWithin()) {
        setIsFocused(false);
        debouncedHideMovers();
      }
    };
    /**
     * Events are added via DOM events (vs. React synthetic events),
     * as the child React components swallow mouse events.
     */


    if (node && !registerRef.current) {
      node.addEventListener('focus', handleOnFocus, true);
      node.addEventListener('blur', handleOnBlur, true);
      registerRef.current = true;
    }

    return () => {
      if (node) {
        node.removeEventListener('focus', handleOnFocus);
        node.removeEventListener('blur', handleOnBlur);
      }
    };
  }, [ref, registerRef, setIsFocused, debouncedShowMovers, debouncedHideMovers]);
  return {
    showMovers,
    gestures: {
      onMouseMove: debouncedShowMovers,
      onMouseLeave: debouncedHideMovers
    }
  };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-parent-selector/index.js



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */





/**
 * Block parent selector component, displaying the hierarchy of the
 * current block selection as a single icon to "go up" a level.
 *
 * @return {WPComponent} Parent block selector.
 */

function BlockParentSelector() {
  const {
    selectBlock,
    toggleBlockHighlight
  } = use_dispatch(store_store);
  const {
    firstParentClientId,
    shouldHide,
    hasReducedUI
  } = use_select_useSelect(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientId,
      getSettings
    } = select(store_store);
    const {
      hasBlockSupport
    } = select(build_module/* store */.M_);
    const selectedBlockClientId = getSelectedBlockClientId();
    const parents = getBlockParents(selectedBlockClientId);
    const _firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(_firstParentClientId);

    const _parentBlockType = (0,build_module/* getBlockType */.E7)(parentBlockName);

    const settings = getSettings();
    return {
      firstParentClientId: _firstParentClientId,
      shouldHide: !hasBlockSupport(_parentBlockType, '__experimentalParentSelector', true),
      hasReducedUI: settings.hasReducedUI
    };
  }, []);
  const blockInformation = useBlockDisplayInformation(firstParentClientId); // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.

  const nodeRef = (0,react.useRef)();
  const {
    gestures: showMoversGestures
  } = useShowMoversGestures({
    ref: nodeRef,

    onChange(isFocused) {
      if (isFocused && hasReducedUI) {
        return;
      }

      toggleBlockHighlight(firstParentClientId, isFocused);
    }

  });

  if (shouldHide || firstParentClientId === undefined) {
    return null;
  }

  return (0,react.createElement)("div", (0,esm_extends/* default */.A)({
    className: "block-editor-block-parent-selector",
    key: firstParentClientId,
    ref: nodeRef
  }, showMoversGestures), (0,react.createElement)(toolbar_button, {
    className: "block-editor-block-parent-selector__button",
    onClick: () => selectBlock(firstParentClientId),
    label: (0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %s: Name of the block's parent. */
    (0,_wordpress_i18n_build_module.__)('Select %s'), blockInformation.title),
    showTooltip: true,
    icon: (0,react.createElement)(block_icon, {
      icon: blockInformation.icon
    })
  }));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/copy.js

/**
 * WordPress dependencies
 */

const copy = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M20.2 8v11c0 .7-.6 1.2-1.2 1.2H6v1.5h13c1.5 0 2.7-1.2 2.7-2.8V8zM18 16.4V4.6c0-.9-.7-1.6-1.6-1.6H4.6C3.7 3 3 3.7 3 4.6v11.8c0 .9.7 1.6 1.6 1.6h11.8c.9 0 1.6-.7 1.6-1.6zm-13.5 0V4.6c0-.1.1-.1.1-.1h11.8c.1 0 .1.1.1.1v11.8c0 .1-.1.1-.1.1H4.6l-.1-.1z"
}));
/* harmony default export */ const library_copy = (copy);
//# sourceMappingURL=copy.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/preview-block-popover.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function PreviewBlockPopover(_ref) {
  let {
    blocks
  } = _ref;
  return (0,react.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__parent"
  }, (0,react.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__container"
  }, (0,react.createElement)(popover, {
    className: "block-editor-block-switcher__preview__popover",
    position: "bottom right",
    focusOnMount: false
  }, (0,react.createElement)("div", {
    className: "block-editor-block-switcher__preview"
  }, (0,react.createElement)("div", {
    className: "block-editor-block-switcher__preview-title"
  }, (0,_wordpress_i18n_build_module.__)('Preview')), (0,react.createElement)(block_preview, {
    viewportWidth: 500,
    blocks: blocks
  })))));
}
//# sourceMappingURL=preview-block-popover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-transformations-menu.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const BlockTransformationsMenu = _ref => {
  let {
    className,
    possibleBlockTransformations,
    onSelect,
    blocks
  } = _ref;
  const [hoveredTransformItemName, setHoveredTransformItemName] = (0,react.useState)();
  return (0,react.createElement)(menu_group, {
    label: (0,_wordpress_i18n_build_module.__)('Transform to'),
    className: className
  }, hoveredTransformItemName && (0,react.createElement)(PreviewBlockPopover, {
    blocks: (0,build_module/* switchToBlockType */.bh)(blocks, hoveredTransformItemName)
  }), possibleBlockTransformations.map(item => {
    const {
      name,
      icon,
      title,
      isDisabled
    } = item;
    return (0,react.createElement)(menu_item, {
      key: name,
      className: (0,build_module/* getBlockMenuDefaultClassName */.HK)(name),
      onClick: event => {
        event.preventDefault();
        onSelect(name);
      },
      disabled: isDisabled,
      onMouseLeave: () => setHoveredTransformItemName(null),
      onMouseEnter: () => setHoveredTransformItemName(name)
    }, (0,react.createElement)(block_icon, {
      icon: icon,
      showColors: true
    }), title);
  }));
};

/* harmony default export */ const block_transformations_menu = (BlockTransformationsMenu);
//# sourceMappingURL=block-transformations-menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+token-list@2.47.0/node_modules/@wordpress/token-list/build-module/index.js
/**
 * A set of tokens.
 *
 * @see https://dom.spec.whatwg.org/#domtokenlist
 */
class TokenList {
  /**
   * Constructs a new instance of TokenList.
   *
   * @param {string} initialValue Initial value to assign.
   */
  constructor(initialValue = '') {
    this.value = initialValue;

    // Disable reason: These are type hints on the class.
    /* eslint-disable no-unused-expressions */
    /** @type {string} */
    this._currentValue;

    /** @type {string[]} */
    this._valueAsArray;
    /* eslint-enable no-unused-expressions */
  }

  /**
   * @param {Parameters<Array<string>['entries']>} args
   */
  entries(...args) {
    return this._valueAsArray.entries(...args);
  }

  /**
   * @param {Parameters<Array<string>['forEach']>} args
   */
  forEach(...args) {
    return this._valueAsArray.forEach(...args);
  }

  /**
   * @param {Parameters<Array<string>['keys']>} args
   */
  keys(...args) {
    return this._valueAsArray.keys(...args);
  }

  /**
   * @param {Parameters<Array<string>['values']>} args
   */
  values(...args) {
    return this._valueAsArray.values(...args);
  }

  /**
   * Returns the associated set as string.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-value
   *
   * @return {string} Token set as string.
   */
  get value() {
    return this._currentValue;
  }

  /**
   * Replaces the associated set with a new string value.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-value
   *
   * @param {string} value New token set as string.
   */
  set value(value) {
    value = String(value);
    this._valueAsArray = [...new Set(value.split(/\s+/g).filter(Boolean))];
    this._currentValue = this._valueAsArray.join(' ');
  }

  /**
   * Returns the number of tokens.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-length
   *
   * @return {number} Number of tokens.
   */
  get length() {
    return this._valueAsArray.length;
  }

  /**
   * Returns the stringified form of the TokenList.
   *
   * @see https://dom.spec.whatwg.org/#DOMTokenList-stringification-behavior
   * @see https://www.ecma-international.org/ecma-262/9.0/index.html#sec-tostring
   *
   * @return {string} Token set as string.
   */
  toString() {
    return this.value;
  }

  /**
   * Returns an iterator for the TokenList, iterating items of the set.
   *
   * @see https://dom.spec.whatwg.org/#domtokenlist
   *
   * @return {IterableIterator<string>} TokenList iterator.
   */
  *[Symbol.iterator]() {
    return yield* this._valueAsArray;
  }

  /**
   * Returns the token with index `index`.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-item
   *
   * @param {number} index Index at which to return token.
   *
   * @return {string|undefined} Token at index.
   */
  item(index) {
    return this._valueAsArray[index];
  }

  /**
   * Returns true if `token` is present, and false otherwise.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-contains
   *
   * @param {string} item Token to test.
   *
   * @return {boolean} Whether token is present.
   */
  contains(item) {
    return this._valueAsArray.indexOf(item) !== -1;
  }

  /**
   * Adds all arguments passed, except those already present.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-add
   *
   * @param {...string} items Items to add.
   */
  add(...items) {
    this.value += ' ' + items.join(' ');
  }

  /**
   * Removes arguments passed, if they are present.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-remove
   *
   * @param {...string} items Items to remove.
   */
  remove(...items) {
    this.value = this._valueAsArray.filter(val => !items.includes(val)).join(' ');
  }

  /**
   * If `force` is not given, "toggles" `token`, removing it if it’s present
   * and adding it if it’s not present. If `force` is true, adds token (same
   * as add()). If force is false, removes token (same as remove()). Returns
   * true if `token` is now present, and false otherwise.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-toggle
   *
   * @param {string}  token   Token to toggle.
   * @param {boolean} [force] Presence to force.
   *
   * @return {boolean} Whether token is present after toggle.
   */
  toggle(token, force) {
    if (undefined === force) {
      force = !this.contains(token);
    }
    if (force) {
      this.add(token);
    } else {
      this.remove(token);
    }
    return force;
  }

  /**
   * Replaces `token` with `newToken`. Returns true if `token` was replaced
   * with `newToken`, and false otherwise.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-replace
   *
   * @param {string} token    Token to replace with `newToken`.
   * @param {string} newToken Token to use in place of `token`.
   *
   * @return {boolean} Whether replacement occurred.
   */
  replace(token, newToken) {
    if (!this.contains(token)) {
      return false;
    }
    this.remove(token);
    this.add(newToken);
    return true;
  }

  /**
   * Returns true if `token` is in the associated attribute’s supported
   * tokens. Returns false otherwise.
   *
   * Always returns `true` in this implementation.
   *
   * @see https://dom.spec.whatwg.org/#dom-domtokenlist-supports
   *
   * @return {boolean} Whether token is supported.
   */
  supports() {
    return true;
  }
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Returns the active style from the given className.
 *
 * @param {Array}  styles    Block style variations.
 * @param {string} className Class name
 *
 * @return {Object?} The active style.
 */

function getActiveStyle(styles, className) {
  for (const style of new TokenList(className).values()) {
    if (style.indexOf('is-style-') === -1) {
      continue;
    }

    const potentialStyleName = style.substring(9);
    const activeStyle = (0,lodash.find)(styles, {
      name: potentialStyleName
    });

    if (activeStyle) {
      return activeStyle;
    }
  }

  return (0,lodash.find)(styles, 'isDefault');
}
/**
 * Replaces the active style in the block's className.
 *
 * @param {string}  className   Class name.
 * @param {Object?} activeStyle The replaced style.
 * @param {Object}  newStyle    The replacing style.
 *
 * @return {string} The updated className.
 */

function replaceActiveStyle(className, activeStyle, newStyle) {
  const list = new TokenList(className);

  if (activeStyle) {
    list.remove('is-style-' + activeStyle.name);
  }

  list.add('is-style-' + newStyle.name);
  return list.value;
}
/**
 * Returns a collection of styles that can be represented on the frontend.
 * The function checks a style collection for a default style. If none is found, it adds one to
 * act as a fallback for when there is no active style applied to a block. The default item also serves
 * as a switch on the frontend to deactivate non-default styles.
 *
 * @param {Array} styles Block style variations.
 *
 * @return {Array<Object?>}        The style collection.
 */

function getRenderedStyles(styles) {
  if (!styles || styles.length === 0) {
    return [];
  }

  return getDefaultStyle(styles) ? styles : [{
    name: 'default',
    label: (0,_wordpress_i18n_build_module._x)('Default', 'block style'),
    isDefault: true
  }, ...styles];
}
/**
 * Returns a style object from a collection of styles where that style object is the default block style.
 *
 * @param {Array} styles Block style variations.
 *
 * @return {Object?}        The default style object, if found.
 */

function getDefaultStyle(styles) {
  return (0,lodash.find)(styles, 'isDefault');
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-styles/use-styles-for-block.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 *
 * @param {WPBlock}     block Block object.
 * @param {WPBlockType} type  Block type settings.
 * @return {WPBlock}          A generic block ready for styles preview.
 */

function useGenericPreviewBlock(block, type) {
  return (0,react.useMemo)(() => {
    const example = type === null || type === void 0 ? void 0 : type.example;
    const blockName = type === null || type === void 0 ? void 0 : type.name;

    if (example && blockName) {
      return (0,build_module/* getBlockFromExample */.KL)(blockName, {
        attributes: example.attributes,
        innerBlocks: example.innerBlocks
      });
    }

    if (block) {
      return (0,build_module/* cloneBlock */.JB)(block);
    }
  }, [type !== null && type !== void 0 && type.example ? block === null || block === void 0 ? void 0 : block.name : block, type]);
}
/**
 * @typedef useStylesForBlocksArguments
 * @property {string}     clientId Block client ID.
 * @property {() => void} onSwitch Block style switch callback function.
 */

/**
 *
 * @param {useStylesForBlocksArguments} useStylesForBlocks arguments.
 * @return {Object}                                         Results of the select methods.
 */


function useStylesForBlocks(_ref) {
  let {
    clientId,
    onSwitch
  } = _ref;

  const selector = select => {
    const {
      getBlock
    } = select(store_store);
    const block = getBlock(clientId);

    if (!block) {
      return {};
    }

    const blockType = (0,build_module/* getBlockType */.E7)(block.name);
    const {
      getBlockStyles
    } = select(build_module/* store */.M_);
    return {
      block,
      blockType,
      styles: getBlockStyles(block.name),
      className: block.attributes.className || ''
    };
  };

  const {
    styles,
    block,
    blockType,
    className
  } = use_select_useSelect(selector, [clientId]);
  const {
    updateBlockAttributes
  } = use_dispatch(store_store);
  const stylesToRender = getRenderedStyles(styles);
  const activeStyle = getActiveStyle(stylesToRender, className);
  const genericPreviewBlock = useGenericPreviewBlock(block, blockType);

  const onSelect = style => {
    const styleClassName = replaceActiveStyle(className, activeStyle, style);
    updateBlockAttributes(clientId, {
      className: styleClassName
    });
    onSwitch();
  };

  return {
    onSelect,
    stylesToRender,
    activeStyle,
    genericPreviewBlock,
    className
  };
}
//# sourceMappingURL=use-styles-for-block.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-styles/menu-items.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const menu_items_noop = () => {};

function BlockStylesMenuItems(_ref) {
  let {
    clientId,
    onSwitch = menu_items_noop
  } = _ref;
  const {
    onSelect,
    stylesToRender,
    activeStyle
  } = useStylesForBlocks({
    clientId,
    onSwitch
  });

  if (!stylesToRender || stylesToRender.length === 0) {
    return null;
  }

  return (0,react.createElement)(react.Fragment, null, stylesToRender.map(style => {
    const menuItemText = style.label || style.name;
    return (0,react.createElement)(menu_item, {
      key: style.name,
      icon: activeStyle.name === style.name ? library_check : null,
      onClick: () => onSelect(style)
    }, (0,react.createElement)(text_component, {
      as: "span",
      limit: 18,
      ellipsizeMode: "tail",
      truncate: true
    }, menuItemText));
  }));
}
//# sourceMappingURL=menu-items.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-styles-menu.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function BlockStylesMenu(_ref) {
  let {
    hoveredBlock,
    onSwitch
  } = _ref;
  const {
    clientId
  } = hoveredBlock;
  return (0,react.createElement)(menu_group, {
    label: (0,_wordpress_i18n_build_module.__)('Styles'),
    className: "block-editor-block-switcher__styles__menugroup"
  }, (0,react.createElement)(BlockStylesMenuItems, {
    clientId: clientId,
    onSwitch: onSwitch
  }));
}
//# sourceMappingURL=block-styles-menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/utils.js
/**
 * WordPress dependencies
 */

/**
 * Try to find a matching block by a block's name in a provided
 * block. We recurse through InnerBlocks and return the reference
 * of the matched block (it could be an InnerBlock).
 * If no match is found return nothing.
 *
 * @param {WPBlock} block             The block to try to find a match.
 * @param {string}  selectedBlockName The block's name to use for matching condition.
 * @param {Set}     consumedBlocks    A set holding the previously matched/consumed blocks.
 *
 * @return {WPBlock?} The matched block if found or nothing(`undefined`).
 */

const getMatchingBlockByName = function (block, selectedBlockName) {
  let consumedBlocks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
  const {
    clientId,
    name,
    innerBlocks = []
  } = block; // Check if block has been consumed already.

  if (consumedBlocks.has(clientId)) return;
  if (name === selectedBlockName) return block; // Try to find a matching block from InnerBlocks recursively.

  for (const innerBlock of innerBlocks) {
    const match = getMatchingBlockByName(innerBlock, selectedBlockName, consumedBlocks);
    if (match) return match;
  }
};
/**
 * Find and return the block attributes to retain through
 * the transformation, based on Block Type's `role:content`
 * attributes. If no `role:content` attributes exist,
 * return selected block's attributes.
 *
 * @param {string} name       Block type's namespaced name.
 * @param {Object} attributes Selected block's attributes.
 * @return {Object} The block's attributes to retain.
 */

const getRetainedBlockAttributes = (name, attributes) => {
  const contentAttributes = (0,build_module/* __experimentalGetBlockAttributesNamesByRole */.GJ)(name, 'content');
  if (!(contentAttributes !== null && contentAttributes !== void 0 && contentAttributes.length)) return attributes;
  return contentAttributes.reduce((_accumulator, attribute) => {
    if (attributes[attribute]) _accumulator[attribute] = attributes[attribute];
    return _accumulator;
  }, {});
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Mutate the matched block's attributes by getting
 * which block type's attributes to retain and prioritize
 * them in the merging of the attributes.
 *
 * @param {WPBlock} match         The matched block.
 * @param {WPBlock} selectedBlock The selected block.
 * @return {void}
 */

const transformMatchingBlock = (match, selectedBlock) => {
  // Get the block attributes to retain through the transformation.
  const retainedBlockAttributes = getRetainedBlockAttributes(selectedBlock.name, selectedBlock.attributes);
  match.attributes = { ...match.attributes,
    ...retainedBlockAttributes
  };
};
/**
 * By providing the selected blocks and pattern's blocks
 * find the matching blocks, transform them and return them.
 * If not all selected blocks are matched, return nothing.
 *
 * @param {WPBlock[]} selectedBlocks The selected blocks.
 * @param {WPBlock[]} patternBlocks  The pattern's blocks.
 * @return {WPBlock[]|void} The transformed pattern's blocks or undefined if not all selected blocks have been matched.
 */

const getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
  // Clone Pattern's blocks to produce new clientIds and be able to mutate the matches.
  const _patternBlocks = patternBlocks.map(block => (0,build_module/* cloneBlock */.JB)(block));
  /**
   * Keep track of the consumed pattern blocks.
   * This is needed because we loop the selected blocks
   * and for example we may have selected two paragraphs and
   * the pattern's blocks could have more `paragraphs`.
   */


  const consumedBlocks = new Set();

  for (const selectedBlock of selectedBlocks) {
    let isMatch = false;

    for (const patternBlock of _patternBlocks) {
      const match = getMatchingBlockByName(patternBlock, selectedBlock.name, consumedBlocks);
      if (!match) continue;
      isMatch = true;
      consumedBlocks.add(match.clientId); // We update (mutate) the matching pattern block.

      transformMatchingBlock(match, selectedBlock); // No need to loop through other pattern's blocks.

      break;
    } // Bail eary if a selected block has not been matched.


    if (!isMatch) return;
  }

  return _patternBlocks;
};
/**
 * @typedef {WPBlockPattern & {transformedBlocks: WPBlock[]}} TransformedBlockPattern
 */

/**
 * Custom hook that accepts patterns from state and the selected
 * blocks and tries to match these with the pattern's blocks.
 * If all selected blocks are matched with a Pattern's block,
 * we transform them by retaining block's attributes with `role:content`.
 * The transformed pattern's blocks are set to a new pattern
 * property `transformedBlocks`.
 *
 * @param {WPBlockPattern[]} patterns       Patterns from state.
 * @param {WPBlock[]}        selectedBlocks The currently selected blocks.
 * @return {TransformedBlockPattern[]} Returns the eligible matched patterns with all the selected blocks.
 */

const useTransformedPatterns = (patterns, selectedBlocks) => {
  return (0,react.useMemo)(() => patterns.reduce((accumulator, _pattern) => {
    const transformedBlocks = getPatternTransformedBlocks(selectedBlocks, _pattern.blocks);

    if (transformedBlocks) {
      accumulator.push({ ..._pattern,
        transformedBlocks
      });
    }

    return accumulator;
  }, []), [patterns, selectedBlocks]);
};

/* harmony default export */ const use_transformed_patterns = (useTransformedPatterns);
//# sourceMappingURL=use-transformed-patterns.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




function PatternTransformationsMenu(_ref) {
  let {
    blocks,
    patterns: statePatterns,
    onSelect
  } = _ref;
  const [showTransforms, setShowTransforms] = (0,react.useState)(false);
  const patterns = use_transformed_patterns(statePatterns, blocks);
  if (!patterns.length) return null;
  return (0,react.createElement)(menu_group, {
    className: "block-editor-block-switcher__pattern__transforms__menugroup"
  }, showTransforms && (0,react.createElement)(PreviewPatternsPopover, {
    patterns: patterns,
    onSelect: onSelect
  }), (0,react.createElement)(menu_item, {
    onClick: event => {
      event.preventDefault();
      setShowTransforms(!showTransforms);
    },
    icon: chevron_right
  }, (0,_wordpress_i18n_build_module.__)('Patterns')));
}

function PreviewPatternsPopover(_ref2) {
  let {
    patterns,
    onSelect
  } = _ref2;
  return (0,react.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__parent"
  }, (0,react.createElement)("div", {
    className: "block-editor-block-switcher__popover__preview__container"
  }, (0,react.createElement)(popover, {
    className: "block-editor-block-switcher__preview__popover",
    position: "bottom right"
  }, (0,react.createElement)("div", {
    className: "block-editor-block-switcher__preview"
  }, (0,react.createElement)("div", {
    className: "block-editor-block-switcher__preview-title"
  }, (0,_wordpress_i18n_build_module.__)('Preview')), (0,react.createElement)(BlockPatternsList, {
    patterns: patterns,
    onSelect: onSelect
  })))));
}

function BlockPatternsList(_ref3) {
  let {
    patterns,
    onSelect
  } = _ref3;
  const composite = (0,CompositeState/* useCompositeState */.A)();
  return (0,react.createElement)(Composite/* Composite */.e, (0,esm_extends/* default */.A)({}, composite, {
    role: "listbox",
    className: "block-editor-block-switcher__preview-patterns-container",
    "aria-label": (0,_wordpress_i18n_build_module.__)('Patterns list')
  }), patterns.map(pattern => (0,react.createElement)(pattern_transformations_menu_BlockPattern, {
    key: pattern.name,
    pattern: pattern,
    onSelect: onSelect,
    composite: composite
  })));
}

function pattern_transformations_menu_BlockPattern(_ref4) {
  let {
    pattern,
    onSelect,
    composite
  } = _ref4;
  // TODO check pattern/preview width...
  const baseClassName = 'block-editor-block-switcher__preview-patterns-container';
  const descriptionId = (0,use_instance_id/* default */.A)(pattern_transformations_menu_BlockPattern, `${baseClassName}-list__item-description`);
  return (0,react.createElement)("div", {
    className: `${baseClassName}-list__list-item`,
    "aria-label": pattern.title,
    "aria-describedby": pattern.description ? descriptionId : undefined
  }, (0,react.createElement)(CompositeItem/* CompositeItem */.l, (0,esm_extends/* default */.A)({
    role: "option",
    as: "div"
  }, composite, {
    className: `${baseClassName}-list__item`,
    onClick: () => onSelect(pattern.transformedBlocks)
  }), (0,react.createElement)(block_preview, {
    blocks: pattern.transformedBlocks,
    viewportWidth: pattern.viewportWidth || 500
  }), (0,react.createElement)("div", {
    className: `${baseClassName}-list__item-title`
  }, pattern.title)), !!pattern.description && (0,react.createElement)(visually_hidden_component, {
    id: descriptionId
  }, pattern.description));
}

/* harmony default export */ const pattern_transformations_menu = (PatternTransformationsMenu);
//# sourceMappingURL=pattern-transformations-menu.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-switcher/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */








const BlockSwitcherDropdownMenu = _ref => {
  let {
    clientIds,
    blocks
  } = _ref;
  const {
    replaceBlocks
  } = use_dispatch(store_store);
  const blockInformation = useBlockDisplayInformation(blocks[0].clientId);
  const {
    possibleBlockTransformations,
    canRemove,
    hasBlockStyles,
    icon,
    patterns
  } = use_select_useSelect(select => {
    const {
      getBlockRootClientId,
      getBlockTransformItems,
      __experimentalGetPatternTransformItems
    } = select(store_store);
    const {
      getBlockStyles,
      getBlockType
    } = select(build_module/* store */.M_);
    const {
      canRemoveBlocks
    } = select(store_store);
    const rootClientId = getBlockRootClientId((0,lodash.castArray)(clientIds)[0]);
    const [{
      name: firstBlockName
    }] = blocks;

    const _isSingleBlockSelected = blocks.length === 1;

    const styles = _isSingleBlockSelected && getBlockStyles(firstBlockName);

    let _icon;

    if (_isSingleBlockSelected) {
      _icon = blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon; // Take into account active block variations.
    } else {
      var _getBlockType;

      const isSelectionOfSameType = new Set(blocks.map(_ref2 => {
        let {
          name
        } = _ref2;
        return name;
      })).size === 1; // When selection consists of blocks of multiple types, display an
      // appropriate icon to communicate the non-uniformity.

      _icon = isSelectionOfSameType ? (_getBlockType = getBlockType(firstBlockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon : library_copy;
    }

    return {
      possibleBlockTransformations: getBlockTransformItems(blocks, rootClientId),
      canRemove: canRemoveBlocks(clientIds, rootClientId),
      hasBlockStyles: !!(styles !== null && styles !== void 0 && styles.length),
      icon: _icon,
      patterns: __experimentalGetPatternTransformItems(blocks, rootClientId)
    };
  }, [clientIds, blocks, blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon]);
  const blockTitle = useBlockDisplayTitle({
    clientId: Array.isArray(clientIds) ? clientIds[0] : clientIds,
    maximumLength: 35
  });
  const isReusable = blocks.length === 1 && (0,build_module/* isReusableBlock */.tk)(blocks[0]);
  const isTemplate = blocks.length === 1 && (0,build_module/* isTemplatePart */.gc)(blocks[0]); // Simple block tranformation based on the `Block Transforms` API.

  const onBlockTransform = name => replaceBlocks(clientIds, (0,build_module/* switchToBlockType */.bh)(blocks, name)); // Pattern transformation through the `Patterns` API.


  const onPatternTransform = transformedBlocks => replaceBlocks(clientIds, transformedBlocks);
  /**
   * The `isTemplate` check is a stopgap solution here.
   * Ideally, the Transforms API should handle this
   * by allowing to exclude blocks from wildcard transformations.
   */


  const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
  const hasPatternTransformation = !!(patterns !== null && patterns !== void 0 && patterns.length) && canRemove;

  if (!hasBlockStyles && !hasPossibleBlockTransformations) {
    return (0,react.createElement)(toolbar_group, null, (0,react.createElement)(toolbar_button, {
      disabled: true,
      className: "block-editor-block-switcher__no-switcher-icon",
      title: blockTitle,
      icon: (0,react.createElement)(react.Fragment, null, (0,react.createElement)(block_icon, {
        icon: icon,
        showColors: true
      }), (isReusable || isTemplate) && (0,react.createElement)("span", {
        className: "block-editor-block-switcher__toggle-text"
      }, blockTitle))
    }));
  }

  const blockSwitcherLabel = blockTitle;
  const blockSwitcherDescription = 1 === blocks.length ? (0,_wordpress_i18n_build_module/* sprintf */.nv)(
  /* translators: %s: block title. */
  (0,_wordpress_i18n_build_module.__)('%s: Change block type or style'), blockTitle) : (0,_wordpress_i18n_build_module/* sprintf */.nv)(
  /* translators: %d: number of blocks. */
  (0,_wordpress_i18n_build_module._n)('Change type of %d block', 'Change type of %d blocks', blocks.length), blocks.length);
  const showDropDown = hasBlockStyles || hasPossibleBlockTransformations || hasPatternTransformation;
  return (0,react.createElement)(toolbar_group, null, (0,react.createElement)(toolbar_item, null, toggleProps => (0,react.createElement)(dropdown_menu, {
    className: "block-editor-block-switcher",
    label: blockSwitcherLabel,
    popoverProps: {
      position: 'bottom right',
      isAlternate: true,
      className: 'block-editor-block-switcher__popover'
    },
    icon: (0,react.createElement)(react.Fragment, null, (0,react.createElement)(block_icon, {
      icon: icon,
      className: "block-editor-block-switcher__toggle",
      showColors: true
    }), (isReusable || isTemplate) && (0,react.createElement)("span", {
      className: "block-editor-block-switcher__toggle-text"
    }, blockTitle)),
    toggleProps: {
      describedBy: blockSwitcherDescription,
      ...toggleProps
    },
    menuProps: {
      orientation: 'both'
    }
  }, _ref3 => {
    let {
      onClose
    } = _ref3;
    return showDropDown && (0,react.createElement)("div", {
      className: "block-editor-block-switcher__container"
    }, hasPatternTransformation && (0,react.createElement)(pattern_transformations_menu, {
      blocks: blocks,
      patterns: patterns,
      onSelect: transformedBlocks => {
        onPatternTransform(transformedBlocks);
        onClose();
      }
    }), hasPossibleBlockTransformations && (0,react.createElement)(block_transformations_menu, {
      className: "block-editor-block-switcher__transforms__menugroup",
      possibleBlockTransformations: possibleBlockTransformations,
      blocks: blocks,
      onSelect: name => {
        onBlockTransform(name);
        onClose();
      }
    }), hasBlockStyles && (0,react.createElement)(BlockStylesMenu, {
      hoveredBlock: blocks[0],
      onSwitch: onClose
    }));
  })));
};
const BlockSwitcher = _ref4 => {
  let {
    clientIds
  } = _ref4;
  const blocks = use_select_useSelect(select => select(store_store).getBlocksByClientId(clientIds), [clientIds]);

  if (!blocks.length || blocks.some(block => !block)) {
    return null;
  }

  return (0,react.createElement)(BlockSwitcherDropdownMenu, {
    clientIds: clientIds,
    blocks: blocks
  });
};
/* harmony default export */ const block_switcher = (BlockSwitcher);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-toolbar-last-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockToolbarLastItem,
  Slot: block_toolbar_last_item_Slot
} = createSlotFill('__unstableBlockToolbarLastItem');
__unstableBlockToolbarLastItem.Slot = block_toolbar_last_item_Slot;
/* harmony default export */ const block_toolbar_last_item = (__unstableBlockToolbarLastItem);
//# sourceMappingURL=block-toolbar-last-item.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/clipboard@2.0.11/node_modules/clipboard/dist/clipboard.js
var dist_clipboard = __webpack_require__("../../node_modules/.pnpm/clipboard@2.0.11/node_modules/clipboard/dist/clipboard.js");
var clipboard_default = /*#__PURE__*/__webpack_require__.n(dist_clipboard);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-copy-to-clipboard/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * @template T
 * @param {T} value
 * @return {import('react').RefObject<T>} The updated ref
 */

function useUpdatedRef(value) {
  const ref = (0,react.useRef)(value);
  ref.current = value;
  return ref;
}
/**
 * Copies the given text to the clipboard when the element is clicked.
 *
 * @template {HTMLElement} TElementType
 * @param {string | (() => string)} text      The text to copy. Use a function if not
 *                                            already available and expensive to compute.
 * @param {Function}                onSuccess Called when to text is copied.
 *
 * @return {import('react').Ref<TElementType>} A ref to assign to the target element.
 */


function useCopyToClipboard(text, onSuccess) {
  // Store the dependencies as refs and continuously update them so they're
  // fresh when the callback is called.
  const textRef = useUpdatedRef(text);
  const onSuccessRef = useUpdatedRef(onSuccess);
  return (0,use_ref_effect/* default */.A)(node => {
    // Clipboard listens to click events.
    const clipboard = new (clipboard_default())(node, {
      text() {
        return typeof textRef.current === 'function' ? textRef.current() : textRef.current || '';
      }

    });
    clipboard.on('success', _ref => {
      let {
        clearSelection
      } = _ref;
      // Clearing selection will move focus back to the triggering
      // button, ensuring that it is not reset to the body, and
      // further that it is kept within the rendered node.
      clearSelection(); // Handle ClipboardJS focus bug, see
      // https://github.com/zenorocha/clipboard.js/issues/680

      node.focus();

      if (onSuccessRef.current) {
        onSuccessRef.current();
      }
    });
    return () => {
      clipboard.destroy();
    };
  }, []);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/copy-handler/index.js


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */



function useNotifyCopy() {
  const {
    getBlockName
  } = use_select_useSelect(store_store);
  const {
    getBlockType
  } = use_select_useSelect(build_module/* store */.M_);
  const {
    createSuccessNotice
  } = use_dispatch(notices_build_module_store_store);
  return (0,react.useCallback)((eventType, selectedBlockClientIds) => {
    let notice = '';

    if (selectedBlockClientIds.length === 1) {
      var _getBlockType;

      const clientId = selectedBlockClientIds[0];
      const title = (_getBlockType = getBlockType(getBlockName(clientId))) === null || _getBlockType === void 0 ? void 0 : _getBlockType.title;
      notice = eventType === 'copy' ? (0,_wordpress_i18n_build_module/* sprintf */.nv)( // Translators: Name of the block being copied, e.g. "Paragraph".
      (0,_wordpress_i18n_build_module.__)('Copied "%s" to clipboard.'), title) : (0,_wordpress_i18n_build_module/* sprintf */.nv)( // Translators: Name of the block being cut, e.g. "Paragraph".
      (0,_wordpress_i18n_build_module.__)('Moved "%s" to clipboard.'), title);
    } else {
      notice = eventType === 'copy' ? (0,_wordpress_i18n_build_module/* sprintf */.nv)( // Translators: %d: Number of blocks being copied.
      (0,_wordpress_i18n_build_module._n)('Copied %d block to clipboard.', 'Copied %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length) : (0,_wordpress_i18n_build_module/* sprintf */.nv)( // Translators: %d: Number of blocks being cut.
      (0,_wordpress_i18n_build_module._n)('Moved %d block to clipboard.', 'Moved %d blocks to clipboard.', selectedBlockClientIds.length), selectedBlockClientIds.length);
    }

    createSuccessNotice(notice, {
      type: 'snackbar'
    });
  }, []);
}
function useClipboardHandler() {
  const {
    getBlocksByClientId,
    getSelectedBlockClientIds,
    hasMultiSelection,
    getSettings,
    __unstableIsFullySelected,
    __unstableIsSelectionCollapsed,
    __unstableIsSelectionMergeable,
    __unstableGetSelectedBlocksWithPartialSelection
  } = useSelect(blockEditorStore);
  const {
    flashBlock,
    removeBlocks,
    replaceBlocks,
    __unstableDeleteSelection,
    __unstableExpandSelection
  } = useDispatch(blockEditorStore);
  const notifyCopy = useNotifyCopy();
  return useRefEffect(node => {
    function handler(event) {
      const selectedBlockClientIds = getSelectedBlockClientIds();

      if (selectedBlockClientIds.length === 0) {
        return;
      } // Always handle multiple selected blocks.


      if (!hasMultiSelection()) {
        const {
          target
        } = event;
        const {
          ownerDocument
        } = target; // If copying, only consider actual text selection as selection.
        // Otherwise, any focus on an input field is considered.

        const hasSelection = event.type === 'copy' || event.type === 'cut' ? documentHasUncollapsedSelection(ownerDocument) : documentHasSelection(ownerDocument); // Let native copy behaviour take over in input fields.

        if (hasSelection) {
          return;
        }
      }

      if (!node.contains(event.target.ownerDocument.activeElement)) {
        return;
      }

      const eventDefaultPrevented = event.defaultPrevented;
      event.preventDefault();

      const isSelectionMergeable = __unstableIsSelectionMergeable();

      const shouldHandleWholeBlocks = __unstableIsSelectionCollapsed() || __unstableIsFullySelected();

      const expandSelectionIsNeeded = !shouldHandleWholeBlocks && !isSelectionMergeable;

      if (event.type === 'copy' || event.type === 'cut') {
        if (selectedBlockClientIds.length === 1) {
          flashBlock(selectedBlockClientIds[0]);
        } // If we have a partial selection that is not mergeable, just
        // expand the selection to the whole blocks.


        if (expandSelectionIsNeeded) {
          __unstableExpandSelection();
        } else {
          notifyCopy(event.type, selectedBlockClientIds);
          let blocks; // Check if we have partial selection.

          if (shouldHandleWholeBlocks) {
            blocks = getBlocksByClientId(selectedBlockClientIds);
          } else {
            const [head, tail] = __unstableGetSelectedBlocksWithPartialSelection();

            const inBetweenBlocks = getBlocksByClientId(selectedBlockClientIds.slice(1, selectedBlockClientIds.length - 1));
            blocks = [head, ...inBetweenBlocks, tail];
          }

          const wrapperBlockName = event.clipboardData.getData('__unstableWrapperBlockName');

          if (wrapperBlockName) {
            blocks = createBlock(wrapperBlockName, JSON.parse(event.clipboardData.getData('__unstableWrapperBlockAttributes')), blocks);
          }

          const serialized = serialize(blocks);
          event.clipboardData.setData('text/plain', toPlainText(serialized));
          event.clipboardData.setData('text/html', serialized);
        }
      }

      if (event.type === 'cut') {
        // We need to also check if at the start we needed to
        // expand the selection, as in this point we might have
        // programmatically fully selected the blocks above.
        if (shouldHandleWholeBlocks && !expandSelectionIsNeeded) {
          removeBlocks(selectedBlockClientIds);
        } else {
          __unstableDeleteSelection();
        }
      } else if (event.type === 'paste') {
        if (eventDefaultPrevented) {
          // This was likely already handled in rich-text/use-paste-handler.js.
          return;
        }

        const {
          __experimentalCanUserUseUnfilteredHTML: canUserUseUnfilteredHTML
        } = getSettings();
        const {
          plainText,
          html
        } = getPasteEventData(event);
        const blocks = pasteHandler({
          HTML: html,
          plainText,
          mode: 'BLOCKS',
          canUserUseUnfilteredHTML
        });
        replaceBlocks(selectedBlockClientIds, blocks, blocks.length - 1, -1);
      }
    }

    node.ownerDocument.addEventListener('copy', handler);
    node.ownerDocument.addEventListener('cut', handler);
    node.ownerDocument.addEventListener('paste', handler);
    return () => {
      node.ownerDocument.removeEventListener('copy', handler);
      node.ownerDocument.removeEventListener('cut', handler);
      node.ownerDocument.removeEventListener('paste', handler);
    };
  }, []);
}

function CopyHandler(_ref) {
  let {
    children
  } = _ref;
  return createElement("div", {
    ref: useClipboardHandler()
  }, children);
}
/**
 * Given a string of HTML representing serialized blocks, returns the plain
 * text extracted after stripping the HTML of any tags and fixing line breaks.
 *
 * @param {string} html Serialized blocks.
 * @return {string} The plain-text content with any html removed.
 */


function toPlainText(html) {
  // Manually handle BR tags as line breaks prior to `stripHTML` call
  html = html.replace(/<br>/g, '\n');
  const plainText = stripHTML(html).trim(); // Merge any consecutive line breaks

  return plainText.replace(/\n\n+/g, '\n\n');
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/copy-handler/README.md
 */


/* harmony default export */ const copy_handler = ((/* unused pure expression or super */ null && (CopyHandler)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-actions/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockActions(_ref) {
  let {
    clientIds,
    children,
    __experimentalUpdateSelection: updateSelection
  } = _ref;
  const {
    canInsertBlockType,
    getBlockRootClientId,
    getBlocksByClientId,
    canMoveBlocks,
    canRemoveBlocks
  } = use_select_useSelect(store_store);
  const {
    getDefaultBlockName,
    getGroupingBlockName
  } = use_select_useSelect(build_module/* store */.M_);
  const blocks = getBlocksByClientId(clientIds);
  const rootClientId = getBlockRootClientId(clientIds[0]);
  const canDuplicate = (0,lodash.every)(blocks, block => {
    return !!block && (0,build_module/* hasBlockSupport */.pN)(block.name, 'multiple', true) && canInsertBlockType(block.name, rootClientId);
  });
  const canInsertDefaultBlock = canInsertBlockType(getDefaultBlockName(), rootClientId);
  const canMove = canMoveBlocks(clientIds, rootClientId);
  const canRemove = canRemoveBlocks(clientIds, rootClientId);
  const {
    removeBlocks,
    replaceBlocks,
    duplicateBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    flashBlock,
    setBlockMovingClientId,
    setNavigationMode,
    selectBlock
  } = use_dispatch(store_store);
  const notifyCopy = useNotifyCopy();
  return children({
    canDuplicate,
    canInsertDefaultBlock,
    canMove,
    canRemove,
    rootClientId,
    blocks,

    onDuplicate() {
      return duplicateBlocks(clientIds, updateSelection);
    },

    onRemove() {
      return removeBlocks(clientIds, updateSelection);
    },

    onInsertBefore() {
      insertBeforeBlock((0,lodash.first)((0,lodash.castArray)(clientIds)));
    },

    onInsertAfter() {
      insertAfterBlock((0,lodash.last)((0,lodash.castArray)(clientIds)));
    },

    onMoveTo() {
      setNavigationMode(true);
      selectBlock(clientIds[0]);
      setBlockMovingClientId(clientIds[0]);
    },

    onGroup() {
      if (!blocks.length) {
        return;
      }

      const groupingBlockName = getGroupingBlockName(); // Activate the `transform` on `core/group` which does the conversion.

      const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocks, groupingBlockName);

      if (!newBlocks) {
        return;
      }

      replaceBlocks(clientIds, newBlocks);
    },

    onUngroup() {
      if (!blocks.length) {
        return;
      }

      const innerBlocks = blocks[0].innerBlocks;

      if (!innerBlocks.length) {
        return;
      }

      replaceBlocks(clientIds, innerBlocks);
    },

    onCopy() {
      const selectedBlockClientIds = blocks.map(_ref2 => {
        let {
          clientId
        } = _ref2;
        return clientId;
      });

      if (blocks.length === 1) {
        flashBlock(selectedBlockClientIds[0]);
      }

      notifyCopy('copy', selectedBlockClientIds);
    }

  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const block_mode_toggle_noop = () => {};

function BlockModeToggle(_ref) {
  let {
    blockType,
    mode,
    onToggleMode,
    small = false,
    isCodeEditingEnabled = true
  } = _ref;

  if (!blockType || !(0,build_module/* hasBlockSupport */.pN)(blockType, 'html', true) || !isCodeEditingEnabled) {
    return null;
  }

  const label = mode === 'visual' ? (0,_wordpress_i18n_build_module.__)('Edit as HTML') : (0,_wordpress_i18n_build_module.__)('Edit visually');
  return (0,react.createElement)(menu_item, {
    onClick: onToggleMode
  }, !small && label);
}
/* harmony default export */ const block_mode_toggle = ((0,compose/* default */.A)([with_select((select, _ref2) => {
  let {
    clientId
  } = _ref2;
  const {
    getBlock,
    getBlockMode,
    getSettings
  } = select(store_store);
  const block = getBlock(clientId);
  const isCodeEditingEnabled = getSettings().codeEditingEnabled;
  return {
    mode: getBlockMode(clientId),
    blockType: block ? (0,build_module/* getBlockType */.E7)(block.name) : null,
    isCodeEditingEnabled
  };
}), with_dispatch((dispatch, _ref3) => {
  let {
    onToggle = block_mode_toggle_noop,
    clientId
  } = _ref3;
  return {
    onToggleMode() {
      dispatch(store_store).toggleBlockMode(clientId);
      onToggle();
    }

  };
})])(BlockModeToggle));
//# sourceMappingURL=block-mode-toggle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-convert-button.js


/**
 * WordPress dependencies
 */


function BlockConvertButton(_ref) {
  let {
    shouldRender,
    onClick,
    small
  } = _ref;

  if (!shouldRender) {
    return null;
  }

  const label = (0,_wordpress_i18n_build_module.__)('Convert to Blocks');

  return (0,react.createElement)(menu_item, {
    onClick: onClick
  }, !small && label);
}
//# sourceMappingURL=block-convert-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/* harmony default export */ const block_html_convert_button = ((0,compose/* default */.A)(with_select((select, _ref) => {
  let {
    clientId
  } = _ref;
  const block = select(store_store).getBlock(clientId);
  return {
    block,
    shouldRender: block && block.name === 'core/html'
  };
}), with_dispatch((dispatch, _ref2) => {
  let {
    block
  } = _ref2;
  return {
    onClick: () => dispatch(store_store).replaceBlocks(block.clientId, (0,build_module/* rawHandler */.lh)({
      HTML: (0,build_module/* getBlockContent */.F8)(block)
    }))
  };
}))(BlockConvertButton));
//# sourceMappingURL=block-html-convert-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js
/**
 * WordPress dependencies
 */

const {
  Fill: __unstableBlockSettingsMenuFirstItem,
  Slot: block_settings_menu_first_item_Slot
} = createSlotFill('__unstableBlockSettingsMenuFirstItem');
__unstableBlockSettingsMenuFirstItem.Slot = block_settings_menu_first_item_Slot;
/* harmony default export */ const block_settings_menu_first_item = (__unstableBlockSettingsMenuFirstItem);
//# sourceMappingURL=block-settings-menu-first-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Contains the properties `ConvertToGroupButton` component needs.
 *
 * @typedef {Object} ConvertToGroupButtonProps
 * @property {string[]}  clientIds         An array of the selected client ids.
 * @property {boolean}   isGroupable       Indicates if the selected blocks can be grouped.
 * @property {boolean}   isUngroupable     Indicates if the selected blocks can be ungrouped.
 * @property {WPBlock[]} blocksSelection   An array of the selected blocks.
 * @property {string}    groupingBlockName The name of block used for handling grouping interactions.
 */

/**
 * Returns the properties `ConvertToGroupButton` component needs to work properly.
 * It is used in `BlockSettingsMenuControls` to know if `ConvertToGroupButton`
 * should be rendered, to avoid ending up with an empty MenuGroup.
 *
 * @return {ConvertToGroupButtonProps} Returns the properties needed by `ConvertToGroupButton`.
 */

function useConvertToGroupButtonProps() {
  const {
    clientIds,
    isGroupable,
    isUngroupable,
    blocksSelection,
    groupingBlockName
  } = use_select_useSelect(select => {
    var _blocksSelection$;

    const {
      getBlockRootClientId,
      getBlocksByClientId,
      canInsertBlockType,
      getSelectedBlockClientIds
    } = select(store_store);
    const {
      getGroupingBlockName
    } = select(build_module/* store */.M_);

    const _clientIds = getSelectedBlockClientIds();

    const _groupingBlockName = getGroupingBlockName();

    const rootClientId = !!(_clientIds !== null && _clientIds !== void 0 && _clientIds.length) ? getBlockRootClientId(_clientIds[0]) : undefined;
    const groupingBlockAvailable = canInsertBlockType(_groupingBlockName, rootClientId);

    const _blocksSelection = getBlocksByClientId(_clientIds);

    const isSingleGroupingBlock = _blocksSelection.length === 1 && ((_blocksSelection$ = _blocksSelection[0]) === null || _blocksSelection$ === void 0 ? void 0 : _blocksSelection$.name) === _groupingBlockName; // Do we have
    // 1. Grouping block available to be inserted?
    // 2. One or more blocks selected

    const _isGroupable = groupingBlockAvailable && _blocksSelection.length; // Do we have a single Group Block selected and does that group have inner blocks?


    const _isUngroupable = isSingleGroupingBlock && !!_blocksSelection[0].innerBlocks.length;

    return {
      clientIds: _clientIds,
      isGroupable: _isGroupable,
      isUngroupable: _isUngroupable,
      blocksSelection: _blocksSelection,
      groupingBlockName: _groupingBlockName
    };
  }, []);
  return {
    clientIds,
    isGroupable,
    isUngroupable,
    blocksSelection,
    groupingBlockName
  };
}
//# sourceMappingURL=use-convert-to-group-button-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function ConvertToGroupButton(_ref) {
  let {
    clientIds,
    isGroupable,
    isUngroupable,
    blocksSelection,
    groupingBlockName,
    onClose = () => {}
  } = _ref;
  const {
    replaceBlocks
  } = use_dispatch(store_store);

  const onConvertToGroup = () => {
    // Activate the `transform` on the Grouping Block which does the conversion.
    const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocksSelection, groupingBlockName);

    if (newBlocks) {
      replaceBlocks(clientIds, newBlocks);
    }
  };

  const onConvertFromGroup = () => {
    const innerBlocks = blocksSelection[0].innerBlocks;

    if (!innerBlocks.length) {
      return;
    }

    replaceBlocks(clientIds, innerBlocks);
  };

  if (!isGroupable && !isUngroupable) {
    return null;
  }

  return (0,react.createElement)(react.Fragment, null, isGroupable && (0,react.createElement)(menu_item, {
    onClick: () => {
      onConvertToGroup();
      onClose();
    }
  }, (0,_wordpress_i18n_build_module._x)('Group', 'verb')), isUngroupable && (0,react.createElement)(menu_item, {
    onClick: () => {
      onConvertFromGroup();
      onClose();
    }
  }, (0,_wordpress_i18n_build_module._x)('Ungroup', 'Ungrouping blocks from within a Group block back into individual blocks within the Editor ')));
}


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-lock/use-block-lock.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Return details about the block lock status.
 *
 * @param {string} clientId The block client Id.
 *
 * @return {Object} Block lock status
 */

function useBlockLock(clientId) {
  return use_select_useSelect(select => {
    const {
      canEditBlock,
      canMoveBlock,
      canRemoveBlock,
      canLockBlockType,
      getBlockName,
      getBlockRootClientId
    } = select(store_store);
    const rootClientId = getBlockRootClientId(clientId);
    const canEdit = canEditBlock(clientId);
    const canMove = canMoveBlock(clientId, rootClientId);
    const canRemove = canRemoveBlock(clientId, rootClientId);
    return {
      canEdit,
      canMove,
      canRemove,
      canLock: canLockBlockType(getBlockName(clientId)),
      isLocked: !canEdit || !canMove || !canRemove
    };
  }, [clientId]);
}
//# sourceMappingURL=use-block-lock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/unlock.js

/**
 * WordPress dependencies
 */

const unlock_unlock = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8h1.5c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1z"
}));
/* harmony default export */ const library_unlock = (unlock_unlock);
//# sourceMappingURL=unlock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/lock.js

/**
 * WordPress dependencies
 */

const lock_lock = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zm-2.8 0H9.8V7c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3z"
}));
/* harmony default export */ const library_lock = (lock_lock);
//# sourceMappingURL=lock.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/checkbox-control/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



/**
 * Checkboxes allow the user to select one or more items from a set.
 *
 * ```jsx
 * import { CheckboxControl } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyCheckboxControl = () => {
 *   const [ isChecked, setChecked ] = useState( true );
 *   return (
 *     <CheckboxControl
 *       label="Is author"
 *       help="Is the user a author or not?"
 *       checked={ isChecked }
 *       onChange={ setChecked }
 *     />
 *   );
 * };
 * ```
 */
function CheckboxControl( // ref is omitted until we have `WordPressComponentPropsWithoutRef` or add
// ref forwarding to CheckboxControl.
props) {
  const {
    label,
    className,
    heading,
    checked,
    indeterminate,
    help,
    onChange,
    ...additionalProps
  } = props;

  if (heading) {
    (0,deprecated_build_module/* default */.A)('`heading` prop in `CheckboxControl`', {
      alternative: 'a separate element to implement a heading',
      since: '5.8'
    });
  }

  const [showCheckedIcon, setShowCheckedIcon] = (0,react.useState)(false);
  const [showIndeterminateIcon, setShowIndeterminateIcon] = (0,react.useState)(false); // Run the following callback every time the `ref` (and the additional
  // dependencies) change.

  const ref = (0,use_ref_effect/* default */.A)(node => {
    if (!node) {
      return;
    } // It cannot be set using an HTML attribute.


    node.indeterminate = !!indeterminate;
    setShowCheckedIcon(node.matches(':checked'));
    setShowIndeterminateIcon(node.matches(':indeterminate'));
  }, [checked, indeterminate]);
  const instanceId = (0,use_instance_id/* default */.A)(CheckboxControl);
  const id = `inspector-checkbox-control-${instanceId}`;

  const onChangeValue = event => onChange(event.target.checked);

  return (0,react.createElement)(base_control, {
    label: heading,
    id: id,
    help: help,
    className: classnames_default()('components-checkbox-control', className)
  }, (0,react.createElement)("span", {
    className: "components-checkbox-control__input-container"
  }, (0,react.createElement)("input", (0,helpers_esm_extends/* default */.A)({
    ref: ref,
    id: id,
    className: "components-checkbox-control__input",
    type: "checkbox",
    value: "1",
    onChange: onChangeValue,
    checked: checked,
    "aria-describedby": !!help ? id + '__help' : undefined
  }, additionalProps)), showIndeterminateIcon ? (0,react.createElement)(icon, {
    icon: library_reset,
    className: "components-checkbox-control__indeterminate",
    role: "presentation"
  }) : null, showCheckedIcon ? (0,react.createElement)(icon, {
    icon: library_check,
    className: "components-checkbox-control__checked",
    role: "presentation"
  }) : null), (0,react.createElement)("label", {
    className: "components-checkbox-control__label",
    htmlFor: id
  }, label));
}
/* harmony default export */ const checkbox_control = (CheckboxControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-lock/modal.js


/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */





function getTemplateLockValue(lock) {
  // Prevents all operations.
  if (lock.remove && lock.move) {
    return 'all';
  } // Prevents inserting or removing blocks, but allows moving existing blocks.


  if (lock.remove && !lock.move) {
    return 'insert';
  }

  return false;
}

function BlockLockModal(_ref) {
  let {
    clientId,
    onClose
  } = _ref;
  const [lock, setLock] = (0,react.useState)({
    move: false,
    remove: false
  });
  const {
    canEdit,
    canMove,
    canRemove
  } = useBlockLock(clientId);
  const {
    isReusable,
    templateLock,
    hasTemplateLock
  } = use_select_useSelect(select => {
    var _getBlockAttributes, _blockType$attributes;

    const {
      getBlockName,
      getBlockAttributes
    } = select(store_store);
    const blockName = getBlockName(clientId);
    const blockType = (0,build_module/* getBlockType */.E7)(blockName);
    return {
      isReusable: (0,build_module/* isReusableBlock */.tk)(blockType),
      templateLock: (_getBlockAttributes = getBlockAttributes(clientId)) === null || _getBlockAttributes === void 0 ? void 0 : _getBlockAttributes.templateLock,
      hasTemplateLock: !!(blockType !== null && blockType !== void 0 && (_blockType$attributes = blockType.attributes) !== null && _blockType$attributes !== void 0 && _blockType$attributes.templateLock)
    };
  }, [clientId]);
  const [applyTemplateLock, setApplyTemplateLock] = (0,react.useState)(!!templateLock);
  const {
    updateBlockAttributes
  } = use_dispatch(store_store);
  const blockInformation = useBlockDisplayInformation(clientId);
  const instanceId = (0,use_instance_id/* default */.A)(BlockLockModal, 'block-editor-block-lock-modal__options-title');
  (0,react.useEffect)(() => {
    setLock({
      move: !canMove,
      remove: !canRemove,
      ...(isReusable ? {
        edit: !canEdit
      } : {})
    });
  }, [canEdit, canMove, canRemove, isReusable]);
  const isAllChecked = Object.values(lock).every(Boolean);
  const isMixed = Object.values(lock).some(Boolean) && !isAllChecked;
  return (0,react.createElement)(modal, {
    title: (0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %s: Name of the block. */
    (0,_wordpress_i18n_build_module.__)('Lock %s'), blockInformation.title),
    overlayClassName: "block-editor-block-lock-modal",
    closeLabel: (0,_wordpress_i18n_build_module.__)('Close'),
    onRequestClose: onClose
  }, (0,react.createElement)("p", null, (0,_wordpress_i18n_build_module.__)('Choose specific attributes to restrict or lock all available options.')), (0,react.createElement)("form", {
    onSubmit: event => {
      event.preventDefault();
      updateBlockAttributes([clientId], {
        lock,
        templateLock: applyTemplateLock ? getTemplateLockValue(lock) : undefined
      });
      onClose();
    }
  }, (0,react.createElement)("div", {
    role: "group",
    "aria-labelledby": instanceId,
    className: "block-editor-block-lock-modal__options"
  }, (0,react.createElement)(checkbox_control, {
    className: "block-editor-block-lock-modal__options-title",
    label: (0,react.createElement)("span", {
      id: instanceId
    }, (0,_wordpress_i18n_build_module.__)('Lock all')),
    checked: isAllChecked,
    indeterminate: isMixed,
    onChange: newValue => setLock({
      move: newValue,
      remove: newValue,
      ...(isReusable ? {
        edit: newValue
      } : {})
    })
  }), (0,react.createElement)("ul", {
    className: "block-editor-block-lock-modal__checklist"
  }, isReusable && (0,react.createElement)("li", {
    className: "block-editor-block-lock-modal__checklist-item"
  }, (0,react.createElement)(checkbox_control, {
    label: (0,react.createElement)(react.Fragment, null, (0,_wordpress_i18n_build_module.__)('Restrict editing'), (0,react.createElement)(build_module_icon, {
      icon: lock.edit ? library_lock : library_unlock
    })),
    checked: !!lock.edit,
    onChange: edit => setLock(prevLock => ({ ...prevLock,
      edit
    }))
  })), (0,react.createElement)("li", {
    className: "block-editor-block-lock-modal__checklist-item"
  }, (0,react.createElement)(checkbox_control, {
    label: (0,react.createElement)(react.Fragment, null, (0,_wordpress_i18n_build_module.__)('Disable movement'), (0,react.createElement)(build_module_icon, {
      icon: lock.move ? library_lock : library_unlock
    })),
    checked: lock.move,
    onChange: move => setLock(prevLock => ({ ...prevLock,
      move
    }))
  })), (0,react.createElement)("li", {
    className: "block-editor-block-lock-modal__checklist-item"
  }, (0,react.createElement)(checkbox_control, {
    label: (0,react.createElement)(react.Fragment, null, (0,_wordpress_i18n_build_module.__)('Prevent removal'), (0,react.createElement)(build_module_icon, {
      icon: lock.remove ? library_lock : library_unlock
    })),
    checked: lock.remove,
    onChange: remove => setLock(prevLock => ({ ...prevLock,
      remove
    }))
  }))), hasTemplateLock && (0,react.createElement)(ToggleControl, {
    className: "block-editor-block-lock-modal__template-lock",
    label: (0,_wordpress_i18n_build_module.__)('Apply to all blocks inside'),
    checked: applyTemplateLock,
    disabled: lock.move && !lock.remove,
    onChange: () => setApplyTemplateLock(!applyTemplateLock)
  })), (0,react.createElement)(flex_component, {
    className: "block-editor-block-lock-modal__actions",
    justify: "flex-end",
    expanded: false
  }, (0,react.createElement)(flex_item_component, null, (0,react.createElement)(build_module_button, {
    variant: "tertiary",
    onClick: onClose
  }, (0,_wordpress_i18n_build_module.__)('Cancel'))), (0,react.createElement)(flex_item_component, null, (0,react.createElement)(build_module_button, {
    variant: "primary",
    type: "submit"
  }, (0,_wordpress_i18n_build_module.__)('Apply'))))));
}
//# sourceMappingURL=modal.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-lock/menu-item.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */



function BlockLockMenuItem(_ref) {
  let {
    clientId
  } = _ref;
  const {
    canLock,
    isLocked
  } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,react.useReducer)(isActive => !isActive, false);

  if (!canLock) {
    return null;
  }

  const label = isLocked ? (0,_wordpress_i18n_build_module.__)('Unlock') : (0,_wordpress_i18n_build_module.__)('Lock');
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(menu_item, {
    icon: isLocked ? library_unlock : library_lock,
    onClick: toggleModal
  }, label), isModalOpen && (0,react.createElement)(BlockLockModal, {
    clientId: clientId,
    onClose: toggleModal
  }));
}
//# sourceMappingURL=menu-item.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const {
  Fill: block_settings_menu_controls_Fill,
  Slot: block_settings_menu_controls_Slot
} = createSlotFill('BlockSettingsMenuControls');

const BlockSettingsMenuControlsSlot = _ref => {
  let {
    fillProps,
    clientIds = null
  } = _ref;
  const {
    selectedBlocks,
    selectedClientIds,
    canRemove
  } = use_select_useSelect(select => {
    const {
      getBlocksByClientId,
      getSelectedBlockClientIds,
      canRemoveBlocks
    } = select(store_store);
    const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds();
    return {
      selectedBlocks: (0,lodash.map)(getBlocksByClientId(ids).filter(Boolean), block => block.name),
      selectedClientIds: ids,
      canRemove: canRemoveBlocks(ids)
    };
  }, [clientIds]);
  const {
    canLock
  } = useBlockLock(selectedClientIds[0]);
  const showLockButton = selectedClientIds.length === 1 && canLock; // Check if current selection of blocks is Groupable or Ungroupable
  // and pass this props down to ConvertToGroupButton.

  const convertToGroupButtonProps = useConvertToGroupButtonProps();
  const {
    isGroupable,
    isUngroupable
  } = convertToGroupButtonProps;
  const showConvertToGroupButton = (isGroupable || isUngroupable) && canRemove;
  return (0,react.createElement)(block_settings_menu_controls_Slot, {
    fillProps: { ...fillProps,
      selectedBlocks,
      selectedClientIds
    }
  }, fills => {
    if (!(fills !== null && fills !== void 0 && fills.length) > 0 && !showConvertToGroupButton && !showLockButton) {
      return null;
    }

    return (0,react.createElement)(menu_group, null, showLockButton && (0,react.createElement)(BlockLockMenuItem, {
      clientId: selectedClientIds[0]
    }), fills, showConvertToGroupButton && (0,react.createElement)(ConvertToGroupButton, (0,esm_extends/* default */.A)({}, convertToGroupButtonProps, {
      onClose: fillProps === null || fillProps === void 0 ? void 0 : fillProps.onClose
    })));
  });
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-settings-menu-controls/README.md
 *
 * @param {Object} props Fill props.
 * @return {WPElement} Element.
 */


function BlockSettingsMenuControls(_ref2) {
  let { ...props
  } = _ref2;
  return (0,react.createElement)(style_provider, {
    document: document
  }, (0,react.createElement)(block_settings_menu_controls_Fill, props));
}

BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
/* harmony default export */ const block_settings_menu_controls = (BlockSettingsMenuControls);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */









/**
 * Internal dependencies
 */











const block_settings_dropdown_noop = () => {};

const block_settings_dropdown_POPOVER_PROPS = {
  className: 'block-editor-block-settings-menu__popover',
  position: 'bottom right',
  isAlternate: true
};

function CopyMenuItem(_ref) {
  let {
    blocks,
    onCopy
  } = _ref;
  const ref = useCopyToClipboard(() => (0,build_module/* serialize */.lK)(blocks), onCopy);
  const copyMenuItemLabel = blocks.length > 1 ? (0,_wordpress_i18n_build_module.__)('Copy blocks') : (0,_wordpress_i18n_build_module.__)('Copy block');
  return (0,react.createElement)(menu_item, {
    ref: ref
  }, copyMenuItemLabel);
}

function BlockSettingsDropdown(_ref2) {
  let {
    clientIds,
    __experimentalSelectBlock,
    children,
    ...props
  } = _ref2;
  const blockClientIds = (0,lodash.castArray)(clientIds);
  const count = blockClientIds.length;
  const firstBlockClientId = blockClientIds[0];
  const {
    firstParentClientId,
    hasReducedUI,
    onlyBlock,
    parentBlockType,
    previousBlockClientId,
    nextBlockClientId,
    selectedBlockClientIds
  } = use_select_useSelect(select => {
    const {
      getBlockCount,
      getBlockName,
      getBlockParents,
      getPreviousBlockClientId,
      getNextBlockClientId,
      getSelectedBlockClientIds,
      getSettings
    } = select(store_store);
    const parents = getBlockParents(firstBlockClientId);
    const _firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(_firstParentClientId);
    return {
      firstParentClientId: _firstParentClientId,
      hasReducedUI: getSettings().hasReducedUI,
      onlyBlock: 1 === getBlockCount(),
      parentBlockType: (0,build_module/* getBlockType */.E7)(parentBlockName),
      previousBlockClientId: getPreviousBlockClientId(firstBlockClientId),
      nextBlockClientId: getNextBlockClientId(firstBlockClientId),
      selectedBlockClientIds: getSelectedBlockClientIds()
    };
  }, [firstBlockClientId]);
  const shortcuts = use_select_useSelect(select => {
    const {
      getShortcutRepresentation
    } = select(build_module_store_store);
    return {
      duplicate: getShortcutRepresentation('core/block-editor/duplicate'),
      remove: getShortcutRepresentation('core/block-editor/remove'),
      insertAfter: getShortcutRepresentation('core/block-editor/insert-after'),
      insertBefore: getShortcutRepresentation('core/block-editor/insert-before')
    };
  }, []);
  const {
    selectBlock,
    toggleBlockHighlight
  } = use_dispatch(store_store);
  const updateSelectionAfterDuplicate = (0,react.useCallback)(__experimentalSelectBlock ? async clientIdsPromise => {
    const ids = await clientIdsPromise;

    if (ids && ids[0]) {
      __experimentalSelectBlock(ids[0]);
    }
  } : block_settings_dropdown_noop, [__experimentalSelectBlock]);
  const blockTitle = useBlockDisplayTitle({
    clientId: firstBlockClientId,
    maximumLength: 25
  });
  const updateSelectionAfterRemove = (0,react.useCallback)(__experimentalSelectBlock ? () => {
    const blockToSelect = previousBlockClientId || nextBlockClientId;

    if (blockToSelect && // From the block options dropdown, it's possible to remove a block that is not selected,
    // in this case, it's not necessary to update the selection since the selected block wasn't removed.
    selectedBlockClientIds.includes(firstBlockClientId) && // Don't update selection when next/prev block also is in the selection ( and gets removed ),
    // In case someone selects all blocks and removes them at once.
    !selectedBlockClientIds.includes(blockToSelect)) {
      __experimentalSelectBlock(blockToSelect);
    }
  } : block_settings_dropdown_noop, [__experimentalSelectBlock, previousBlockClientId, nextBlockClientId, selectedBlockClientIds]);
  const label = (0,_wordpress_i18n_build_module/* sprintf */.nv)(
  /* translators: %s: block name */
  (0,_wordpress_i18n_build_module.__)('Remove %s'), blockTitle);
  const removeBlockLabel = count === 1 ? label : (0,_wordpress_i18n_build_module.__)('Remove blocks'); // Allows highlighting the parent block outline when focusing or hovering
  // the parent block selector within the child.

  const selectParentButtonRef = (0,react.useRef)();
  const {
    gestures: showParentOutlineGestures
  } = useShowMoversGestures({
    ref: selectParentButtonRef,

    onChange(isFocused) {
      if (isFocused && hasReducedUI) {
        return;
      }

      toggleBlockHighlight(firstParentClientId, isFocused);
    }

  });
  return (0,react.createElement)(BlockActions, {
    clientIds: clientIds,
    __experimentalUpdateSelection: !__experimentalSelectBlock
  }, _ref3 => {
    let {
      canDuplicate,
      canInsertDefaultBlock,
      canMove,
      canRemove,
      onDuplicate,
      onInsertAfter,
      onInsertBefore,
      onRemove,
      onCopy,
      onMoveTo,
      blocks
    } = _ref3;
    return (0,react.createElement)(dropdown_menu, (0,esm_extends/* default */.A)({
      icon: more_vertical,
      label: (0,_wordpress_i18n_build_module.__)('Options'),
      className: "block-editor-block-settings-menu",
      popoverProps: block_settings_dropdown_POPOVER_PROPS,
      noIcons: true
    }, props), _ref4 => {
      let {
        onClose
      } = _ref4;
      return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(menu_group, null, (0,react.createElement)(block_settings_menu_first_item.Slot, {
        fillProps: {
          onClose
        }
      }), firstParentClientId !== undefined && (0,react.createElement)(menu_item, (0,esm_extends/* default */.A)({}, showParentOutlineGestures, {
        ref: selectParentButtonRef,
        icon: (0,react.createElement)(block_icon, {
          icon: parentBlockType.icon
        }),
        onClick: () => selectBlock(firstParentClientId)
      }), (0,_wordpress_i18n_build_module/* sprintf */.nv)(
      /* translators: %s: Name of the block's parent. */
      (0,_wordpress_i18n_build_module.__)('Select parent block (%s)'), parentBlockType.title)), count === 1 && (0,react.createElement)(block_html_convert_button, {
        clientId: firstBlockClientId
      }), (0,react.createElement)(CopyMenuItem, {
        blocks: blocks,
        onCopy: onCopy
      }), canDuplicate && (0,react.createElement)(menu_item, {
        onClick: (0,lodash.flow)(onClose, onDuplicate, updateSelectionAfterDuplicate),
        shortcut: shortcuts.duplicate
      }, (0,_wordpress_i18n_build_module.__)('Duplicate')), canInsertDefaultBlock && (0,react.createElement)(react.Fragment, null, (0,react.createElement)(menu_item, {
        onClick: (0,lodash.flow)(onClose, onInsertBefore),
        shortcut: shortcuts.insertBefore
      }, (0,_wordpress_i18n_build_module.__)('Insert before')), (0,react.createElement)(menu_item, {
        onClick: (0,lodash.flow)(onClose, onInsertAfter),
        shortcut: shortcuts.insertAfter
      }, (0,_wordpress_i18n_build_module.__)('Insert after'))), canMove && !onlyBlock && (0,react.createElement)(menu_item, {
        onClick: (0,lodash.flow)(onClose, onMoveTo)
      }, (0,_wordpress_i18n_build_module.__)('Move to')), count === 1 && (0,react.createElement)(block_mode_toggle, {
        clientId: firstBlockClientId,
        onToggle: onClose
      })), (0,react.createElement)(block_settings_menu_controls.Slot, {
        fillProps: {
          onClose
        },
        clientIds: clientIds
      }), typeof children === 'function' ? children({
        onClose
      }) : react.Children.map(child => (0,react.cloneElement)(child, {
        onClose
      })), canRemove && (0,react.createElement)(menu_group, null, (0,react.createElement)(menu_item, {
        onClick: (0,lodash.flow)(onClose, onRemove, updateSelectionAfterRemove),
        shortcut: shortcuts.remove
      }, removeBlockLabel)));
    });
  });
}
/* harmony default export */ const block_settings_dropdown = (BlockSettingsDropdown);
//# sourceMappingURL=block-settings-dropdown.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/index.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


function BlockSettingsMenu(_ref) {
  let {
    clientIds,
    ...props
  } = _ref;
  return (0,react.createElement)(toolbar_group, null, (0,react.createElement)(toolbar_item, null, toggleProps => (0,react.createElement)(block_settings_dropdown, (0,esm_extends/* default */.A)({
    clientIds: clientIds,
    toggleProps: toggleProps
  }, props))));
}
/* harmony default export */ const block_settings_menu = (BlockSettingsMenu);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-lock/toolbar.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




function BlockLockToolbar(_ref) {
  let {
    clientId
  } = _ref;
  const blockInformation = useBlockDisplayInformation(clientId);
  const {
    canEdit,
    canMove,
    canRemove,
    canLock
  } = useBlockLock(clientId);
  const [isModalOpen, toggleModal] = (0,react.useReducer)(isActive => !isActive, false);

  if (!canLock) {
    return null;
  }

  if (canEdit && canMove && canRemove) {
    return null;
  }

  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(toolbar_group, {
    className: "block-editor-block-lock-toolbar"
  }, (0,react.createElement)(toolbar_button, {
    icon: library_lock,
    label: (0,_wordpress_i18n_build_module/* sprintf */.nv)(
    /* translators: %s: block name */
    (0,_wordpress_i18n_build_module.__)('Unlock %s'), blockInformation.title),
    onClick: toggleModal
  })), isModalOpen && (0,react.createElement)(BlockLockModal, {
    clientId: clientId,
    onClose: toggleModal
  }));
}
//# sourceMappingURL=toolbar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/group.js

/**
 * WordPress dependencies
 */

const group_group = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M18 4h-7c-1.1 0-2 .9-2 2v3H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-3h3c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h3V13c0 1.1.9 2 2 2h2.5v3zm0-4.5H11c-.3 0-.5-.2-.5-.5v-2.5H13c.3 0 .5.2.5.5v2.5zm5-.5c0 .3-.2.5-.5.5h-3V11c0-1.1-.9-2-2-2h-2.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7z"
}));
/* harmony default export */ const library_group = (group_group);
//# sourceMappingURL=group.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/row.js

/**
 * WordPress dependencies
 */

const row = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M4 6.5h5a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4V16h5a.5.5 0 0 0 .5-.5v-7A.5.5 0 0 0 9 8H4V6.5Zm16 0h-5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h5V16h-5a.5.5 0 0 1-.5-.5v-7A.5.5 0 0 1 15 8h5V6.5Z"
}));
/* harmony default export */ const library_row = (row);
//# sourceMappingURL=row.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/stack.js

/**
 * WordPress dependencies
 */

const stack_stack = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M17.5 4v5a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V4H8v5a.5.5 0 0 0 .5.5h7A.5.5 0 0 0 16 9V4h1.5Zm0 16v-5a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2v5H8v-5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v5h1.5Z"
}));
/* harmony default export */ const library_stack = (stack_stack);
//# sourceMappingURL=stack.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/toolbar.js


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



const layouts = {
  group: undefined,
  row: {
    type: 'flex',
    flexWrap: 'nowrap'
  },
  stack: {
    type: 'flex',
    orientation: 'vertical'
  }
};

function BlockGroupToolbar() {
  const {
    blocksSelection,
    clientIds,
    groupingBlockName,
    isGroupable
  } = useConvertToGroupButtonProps();
  const {
    replaceBlocks
  } = use_dispatch(store_store);
  const {
    canRemove,
    variations
  } = use_select_useSelect(select => {
    const {
      canRemoveBlocks
    } = select(store_store);
    const {
      getBlockVariations
    } = select(build_module/* store */.M_);
    return {
      canRemove: canRemoveBlocks(clientIds),
      variations: getBlockVariations(groupingBlockName, 'transform')
    };
  }, [clientIds, groupingBlockName]);

  const onConvertToGroup = function () {
    let layout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'group';
    const newBlocks = (0,build_module/* switchToBlockType */.bh)(blocksSelection, groupingBlockName);

    if (newBlocks && newBlocks.length > 0) {
      // Because the block is not in the store yet we can't use
      // updateBlockAttributes so need to manually update attributes.
      newBlocks[0].attributes.layout = layouts[layout];
      replaceBlocks(clientIds, newBlocks);
    }
  };

  const onConvertToRow = () => onConvertToGroup('row');

  const onConvertToStack = () => onConvertToGroup('stack'); // Don't render the button if the current selection cannot be grouped.
  // A good example is selecting multiple button blocks within a Buttons block:
  // The group block is not a valid child of Buttons, so we should not show the button.
  // Any blocks that are locked against removal also cannot be grouped.


  if (!isGroupable || !canRemove) {
    return null;
  }

  const canInsertRow = !!variations.find(_ref => {
    let {
      name
    } = _ref;
    return name === 'group-row';
  });
  const canInsertStack = !!variations.find(_ref2 => {
    let {
      name
    } = _ref2;
    return name === 'group-stack';
  });
  return (0,react.createElement)(toolbar_group, null, (0,react.createElement)(toolbar_button, {
    icon: library_group,
    label: (0,_wordpress_i18n_build_module._x)('Group', 'verb'),
    onClick: onConvertToGroup
  }), canInsertRow && (0,react.createElement)(toolbar_button, {
    icon: library_row,
    label: (0,_wordpress_i18n_build_module._x)('Row', 'single horizontal line'),
    onClick: onConvertToRow
  }), canInsertStack && (0,react.createElement)(toolbar_button, {
    icon: library_stack,
    label: (0,_wordpress_i18n_build_module._x)('Stack', 'verb'),
    onClick: onConvertToStack
  }));
}

/* harmony default export */ const convert_to_group_buttons_toolbar = (BlockGroupToolbar);
//# sourceMappingURL=toolbar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-edit-visually-button/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function BlockEditVisuallyButton(_ref) {
  let {
    clientIds
  } = _ref;
  // Edit visually only works for single block selection.
  const clientId = clientIds.length === 1 ? clientIds[0] : undefined;
  const canEditVisually = use_select_useSelect(select => !!clientId && select(store_store).getBlockMode(clientId) === 'html', [clientId]);
  const {
    toggleBlockMode
  } = use_dispatch(store_store);

  if (!canEditVisually) {
    return null;
  }

  return (0,react.createElement)(toolbar_group, null, (0,react.createElement)(toolbar_button, {
    onClick: () => {
      toggleBlockMode(clientId);
    }
  }, (0,_wordpress_i18n_build_module.__)('Edit visually')));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-name-context.js
/**
 * WordPress dependencies
 */


const __unstableBlockNameContext = (0,react.createContext)('');

/* harmony default export */ const block_name_context = (__unstableBlockNameContext);
//# sourceMappingURL=block-name-context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */














const BlockToolbar = _ref => {
  let {
    hideDragHandle
  } = _ref;
  const {
    blockClientIds,
    blockClientId,
    blockType,
    hasFixedToolbar,
    hasReducedUI,
    isValid,
    isVisual
  } = use_select_useSelect(select => {
    const {
      getBlockName,
      getBlockMode,
      getSelectedBlockClientIds,
      isBlockValid,
      getBlockRootClientId,
      getSettings
    } = select(store_store);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const blockRootClientId = getBlockRootClientId(selectedBlockClientId);
    const settings = getSettings();
    return {
      blockClientIds: selectedBlockClientIds,
      blockClientId: selectedBlockClientId,
      blockType: selectedBlockClientId && (0,build_module/* getBlockType */.E7)(getBlockName(selectedBlockClientId)),
      hasFixedToolbar: settings.hasFixedToolbar,
      hasReducedUI: settings.hasReducedUI,
      rootClientId: blockRootClientId,
      isValid: selectedBlockClientIds.every(id => isBlockValid(id)),
      isVisual: selectedBlockClientIds.every(id => getBlockMode(id) === 'visual')
    };
  }, []); // Handles highlighting the current block outline on hover or focus of the
  // block type toolbar area.

  const {
    toggleBlockHighlight
  } = use_dispatch(store_store);
  const nodeRef = (0,react.useRef)();
  const {
    showMovers,
    gestures: showMoversGestures
  } = useShowMoversGestures({
    ref: nodeRef,

    onChange(isFocused) {
      if (isFocused && hasReducedUI) {
        return;
      }

      toggleBlockHighlight(blockClientId, isFocused);
    }

  }); // Account for the cases where the block toolbar is rendered within the
  // header area and not contextually to the block.

  const displayHeaderToolbar = (0,use_viewport_match/* default */.A)('medium', '<') || hasFixedToolbar;

  if (blockType) {
    if (!(0,build_module/* hasBlockSupport */.pN)(blockType, '__experimentalToolbar', true)) {
      return null;
    }
  }

  const shouldShowMovers = displayHeaderToolbar || showMovers;

  if (blockClientIds.length === 0) {
    return null;
  }

  const shouldShowVisualToolbar = isValid && isVisual;
  const isMultiToolbar = blockClientIds.length > 1;
  const classes = classnames_default()('block-editor-block-toolbar', shouldShowMovers && 'is-showing-movers');
  return (0,react.createElement)("div", {
    className: classes
  }, !isMultiToolbar && !displayHeaderToolbar && (0,react.createElement)(BlockParentSelector, {
    clientIds: blockClientIds
  }), (0,react.createElement)("div", (0,esm_extends/* default */.A)({
    ref: nodeRef
  }, showMoversGestures), (shouldShowVisualToolbar || isMultiToolbar) && (0,react.createElement)(toolbar_group, {
    className: "block-editor-block-toolbar__block-controls"
  }, (0,react.createElement)(block_switcher, {
    clientIds: blockClientIds
  }), !isMultiToolbar && (0,react.createElement)(BlockLockToolbar, {
    clientId: blockClientIds[0]
  }), (0,react.createElement)(block_mover, {
    clientIds: blockClientIds,
    hideDragHandle: hideDragHandle || hasReducedUI
  }))), shouldShowVisualToolbar && isMultiToolbar && (0,react.createElement)(convert_to_group_buttons_toolbar, null), shouldShowVisualToolbar && (0,react.createElement)(react.Fragment, null, (0,react.createElement)(block_controls.Slot, {
    group: "parent",
    className: "block-editor-block-toolbar__slot"
  }), (0,react.createElement)(block_controls.Slot, {
    group: "block",
    className: "block-editor-block-toolbar__slot"
  }), (0,react.createElement)(block_controls.Slot, {
    className: "block-editor-block-toolbar__slot"
  }), (0,react.createElement)(block_controls.Slot, {
    group: "inline",
    className: "block-editor-block-toolbar__slot"
  }), (0,react.createElement)(block_controls.Slot, {
    group: "other",
    className: "block-editor-block-toolbar__slot"
  }), (0,react.createElement)(block_name_context.Provider, {
    value: blockType === null || blockType === void 0 ? void 0 : blockType.name
  }, (0,react.createElement)(block_toolbar_last_item.Slot, null))), (0,react.createElement)(BlockEditVisuallyButton, {
    clientIds: blockClientIds
  }), (0,react.createElement)(block_settings_menu, {
    clientIds: blockClientIds
  }));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-toolbar/README.md
 */


/* harmony default export */ const block_toolbar = (BlockToolbar);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/block-contextual-toolbar.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





function BlockContextualToolbar(_ref) {
  let {
    focusOnMount,
    isFixed,
    ...props
  } = _ref;
  const {
    blockType,
    hasParents,
    showParentSelector
  } = use_select_useSelect(select => {
    const {
      getBlockName,
      getBlockParents,
      getSelectedBlockClientIds
    } = select(store_store);
    const {
      getBlockType
    } = select(build_module/* store */.M_);
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const selectedBlockClientId = selectedBlockClientIds[0];
    const parents = getBlockParents(selectedBlockClientId);
    const firstParentClientId = parents[parents.length - 1];
    const parentBlockName = getBlockName(firstParentClientId);
    const parentBlockType = getBlockType(parentBlockName);
    return {
      blockType: selectedBlockClientId && getBlockType(getBlockName(selectedBlockClientId)),
      hasParents: parents.length,
      showParentSelector: parentBlockType && (0,build_module/* hasBlockSupport */.pN)(parentBlockType, '__experimentalParentSelector', true) && selectedBlockClientIds.length <= 1
    };
  }, []);

  if (blockType) {
    if (!(0,build_module/* hasBlockSupport */.pN)(blockType, '__experimentalToolbar', true)) {
      return null;
    }
  } // Shifts the toolbar to make room for the parent block selector.


  const classes = classnames_default()('block-editor-block-contextual-toolbar', {
    'has-parent': hasParents && showParentSelector,
    'is-fixed': isFixed
  });
  return (0,react.createElement)(navigable_toolbar, (0,esm_extends/* default */.A)({
    focusOnMount: focusOnMount,
    className: classes
    /* translators: accessibility text for the block toolbar */
    ,
    "aria-label": (0,_wordpress_i18n_build_module.__)('Block tools')
  }, props), (0,react.createElement)(block_toolbar, {
    hideDragHandle: isFixed
  }));
}

/* harmony default export */ const block_contextual_toolbar = (BlockContextualToolbar);
//# sourceMappingURL=block-contextual-toolbar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


 // By default the toolbar sets the `shift` prop. If the user scrolls the page
// down the toolbar will stay on screen by adopting a sticky position at the
// top of the viewport.

const use_block_toolbar_popover_props_DEFAULT_PROPS = {
  __unstableForcePosition: true,
  __unstableShift: true
}; // When there isn't enough height between the top of the block and the editor
// canvas, the `shift` prop is set to `false`, as it will cause the block to be
// obscured. The `flip` behavior is enabled (by setting `forcePosition` to
// `false`), which positions the toolbar below the block.

const RESTRICTED_HEIGHT_PROPS = {
  __unstableForcePosition: false,
  __unstableShift: false
};
/**
 * Get the popover props for the block toolbar, determined by the space at the top of the canvas and the toolbar height.
 *
 * @param {Element} contentElement       The DOM element that represents the editor content or canvas.
 * @param {Element} selectedBlockElement The outer DOM element of the first selected block.
 * @param {number}  toolbarHeight        The height of the toolbar in pixels.
 *
 * @return {Object} The popover props used to determine the position of the toolbar.
 */

function getProps(contentElement, selectedBlockElement, toolbarHeight) {
  if (!contentElement || !selectedBlockElement) {
    return use_block_toolbar_popover_props_DEFAULT_PROPS;
  }

  const blockRect = selectedBlockElement.getBoundingClientRect();
  const contentRect = contentElement.getBoundingClientRect();

  if (blockRect.top - contentRect.top > toolbarHeight) {
    return use_block_toolbar_popover_props_DEFAULT_PROPS;
  }

  return RESTRICTED_HEIGHT_PROPS;
}
/**
 * Determines the desired popover positioning behavior, returning a set of appropriate props.
 *
 * @param {Object}  elements
 * @param {Element} elements.contentElement The DOM element that represents the editor content or canvas.
 * @param {string}  elements.clientId       The clientId of the first selected block.
 *
 * @return {Object} The popover props used to determine the position of the toolbar.
 */


function useBlockToolbarPopoverProps(_ref) {
  let {
    contentElement,
    clientId
  } = _ref;
  const selectedBlockElement = useBlockElement(clientId);
  const [toolbarHeight, setToolbarHeight] = (0,react.useState)(0);
  const [props, setProps] = (0,react.useState)(() => getProps(contentElement, selectedBlockElement, toolbarHeight));
  const blockIndex = use_select_useSelect(select => select(store_store).getBlockIndex(clientId), [clientId]);
  const popoverRef = (0,use_ref_effect/* default */.A)(popoverNode => {
    setToolbarHeight(popoverNode.offsetHeight);
  }, []);
  const updateProps = (0,react.useCallback)(() => setProps(getProps(contentElement, selectedBlockElement, toolbarHeight)), [contentElement, selectedBlockElement, toolbarHeight]); // Update props when the block is moved. This also ensures the props are
  // correct on initial mount, and when the selected block or content element
  // changes (since the callback ref will update).

  (0,react.useLayoutEffect)(updateProps, [blockIndex, updateProps]); // Update props when the viewport is resized or the block is resized.

  (0,react.useLayoutEffect)(() => {
    var _contentElement$owner, _contentView$addEvent, _selectedBlockElement;

    if (!contentElement || !selectedBlockElement) {
      return;
    } // Update the toolbar props on viewport resize.


    const contentView = contentElement === null || contentElement === void 0 ? void 0 : (_contentElement$owner = contentElement.ownerDocument) === null || _contentElement$owner === void 0 ? void 0 : _contentElement$owner.defaultView;
    contentView === null || contentView === void 0 ? void 0 : (_contentView$addEvent = contentView.addEventHandler) === null || _contentView$addEvent === void 0 ? void 0 : _contentView$addEvent.call(contentView, 'resize', updateProps); // Update the toolbar props on block resize.

    let resizeObserver;
    const blockView = selectedBlockElement === null || selectedBlockElement === void 0 ? void 0 : (_selectedBlockElement = selectedBlockElement.ownerDocument) === null || _selectedBlockElement === void 0 ? void 0 : _selectedBlockElement.defaultView;

    if (blockView.ResizeObserver) {
      resizeObserver = new blockView.ResizeObserver(updateProps);
      resizeObserver.observe(selectedBlockElement);
    }

    return () => {
      var _contentView$removeEv;

      contentView === null || contentView === void 0 ? void 0 : (_contentView$removeEv = contentView.removeEventHandler) === null || _contentView$removeEv === void 0 ? void 0 : _contentView$removeEv.call(contentView, 'resize', updateProps);

      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateProps, contentElement, selectedBlockElement]);
  return { ...props,
    ref: popoverRef
  };
}
//# sourceMappingURL=use-block-toolbar-popover-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/selected-block-popover.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */







function selected_block_popover_selector(select) {
  const {
    isNavigationMode,
    isMultiSelecting,
    hasMultiSelection,
    isTyping,
    getSettings,
    getLastMultiSelectedBlockClientId
  } = select(store_store);
  return {
    isNavigationMode: isNavigationMode(),
    isMultiSelecting: isMultiSelecting(),
    isTyping: isTyping(),
    hasFixedToolbar: getSettings().hasFixedToolbar,
    lastClientId: hasMultiSelection() ? getLastMultiSelectedBlockClientId() : null
  };
}

function SelectedBlockPopover(_ref) {
  let {
    clientId,
    rootClientId,
    isEmptyDefaultBlock,
    capturingClientId,
    __unstablePopoverSlot,
    __unstableContentRef
  } = _ref;
  const {
    isNavigationMode,
    isMultiSelecting,
    isTyping,
    hasFixedToolbar,
    lastClientId
  } = use_select_useSelect(selected_block_popover_selector, []);
  const isInsertionPointVisible = use_select_useSelect(select => {
    const {
      isBlockInsertionPointVisible,
      getBlockInsertionPoint,
      getBlockOrder
    } = select(store_store);

    if (!isBlockInsertionPointVisible()) {
      return false;
    }

    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    return order[insertionPoint.index] === clientId;
  }, [clientId]);
  const isLargeViewport = (0,use_viewport_match/* default */.A)('medium');
  const isToolbarForced = (0,react.useRef)(false);
  const {
    stopTyping
  } = use_dispatch(store_store);
  const showEmptyBlockSideInserter = !isTyping && !isNavigationMode && isEmptyDefaultBlock;
  const shouldShowBreadcrumb = isNavigationMode;
  const shouldShowContextualToolbar = !isNavigationMode && !hasFixedToolbar && isLargeViewport && !isMultiSelecting && !showEmptyBlockSideInserter && !isTyping;
  const canFocusHiddenToolbar = !isNavigationMode && !shouldShowContextualToolbar && !hasFixedToolbar && !isEmptyDefaultBlock;
  useShortcut('core/block-editor/focus-toolbar', () => {
    isToolbarForced.current = true;
    stopTyping(true);
  }, {
    isDisabled: !canFocusHiddenToolbar
  });
  (0,react.useEffect)(() => {
    isToolbarForced.current = false;
  }); // Stores the active toolbar item index so the block toolbar can return focus
  // to it when re-mounting.

  const initialToolbarItemIndexRef = (0,react.useRef)();
  const popoverProps = useBlockToolbarPopoverProps({
    contentElement: __unstableContentRef === null || __unstableContentRef === void 0 ? void 0 : __unstableContentRef.current,
    clientId
  });

  if (!shouldShowBreadcrumb && !shouldShowContextualToolbar) {
    return null;
  }

  return (0,react.createElement)(block_popover, (0,esm_extends/* default */.A)({
    clientId: capturingClientId || clientId,
    bottomClientId: lastClientId,
    className: classnames_default()('block-editor-block-list__block-popover', {
      'is-insertion-point-visible': isInsertionPointVisible
    }),
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  }, popoverProps), shouldShowContextualToolbar && (0,react.createElement)(block_contextual_toolbar // If the toolbar is being shown because of being forced
  // it should focus the toolbar right after the mount.
  , {
    focusOnMount: isToolbarForced.current,
    __experimentalInitialIndex: initialToolbarItemIndexRef.current,
    __experimentalOnIndexChange: index => {
      initialToolbarItemIndexRef.current = index;
    } // Resets the index whenever the active block changes so
    // this is not persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
    ,
    key: clientId
  }), shouldShowBreadcrumb && (0,react.createElement)(block_selection_button, {
    clientId: clientId,
    rootClientId: rootClientId
  }));
}

function wrapperSelector(select) {
  const {
    getSelectedBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getBlockRootClientId,
    getBlock,
    getBlockParents,
    __experimentalGetBlockListSettingsForBlocks
  } = select(store_store);
  const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();

  if (!clientId) {
    return;
  }

  const {
    name,
    attributes = {}
  } = getBlock(clientId) || {};
  const blockParentsClientIds = getBlockParents(clientId); // Get Block List Settings for all ancestors of the current Block clientId.

  const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks(blockParentsClientIds); // Get the clientId of the topmost parent with the capture toolbars setting.


  const capturingClientId = (0,lodash.find)(blockParentsClientIds, parentClientId => {
    var _parentBlockListSetti;

    return (_parentBlockListSetti = parentBlockListSettings[parentClientId]) === null || _parentBlockListSetti === void 0 ? void 0 : _parentBlockListSetti.__experimentalCaptureToolbars;
  });
  return {
    clientId,
    rootClientId: getBlockRootClientId(clientId),
    name,
    isEmptyDefaultBlock: name && (0,build_module/* isUnmodifiedDefaultBlock */.Xw)({
      name,
      attributes
    }),
    capturingClientId
  };
}

function WrappedBlockPopover(_ref2) {
  let {
    __unstablePopoverSlot,
    __unstableContentRef
  } = _ref2;
  const selected = use_select_useSelect(wrapperSelector, []);

  if (!selected) {
    return null;
  }

  const {
    clientId,
    rootClientId,
    name,
    isEmptyDefaultBlock,
    capturingClientId
  } = selected;

  if (!name) {
    return null;
  }

  return (0,react.createElement)(SelectedBlockPopover, {
    clientId: clientId,
    rootClientId: rootClientId,
    isEmptyDefaultBlock: isEmptyDefaultBlock,
    capturingClientId: capturingClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  });
}
//# sourceMappingURL=selected-block-popover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/back-compat.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



function BlockToolsBackCompat(_ref) {
  let {
    children
  } = _ref;
  const openRef = (0,react.useContext)(insertion_point_InsertionPointOpenRef);
  const isDisabled = (0,react.useContext)(disabled.Context); // If context is set, `BlockTools` is a parent component.

  if (openRef || isDisabled) {
    return children;
  }

  (0,deprecated_build_module/* default */.A)('wp.components.Popover.Slot name="block-toolbar"', {
    alternative: 'wp.blockEditor.BlockTools',
    since: '5.8'
  });
  return (0,react.createElement)(InsertionPoint, {
    __unstablePopoverSlot: "block-toolbar"
  }, (0,react.createElement)(WrappedBlockPopover, {
    __unstablePopoverSlot: "block-toolbar"
  }), children);
}
//# sourceMappingURL=back-compat.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/with-client-id.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const withClientId = (0,create_higher_order_component/* createHigherOrderComponent */.f)(WrappedComponent => props => {
  const {
    clientId
  } = context_useBlockEditContext();
  return (0,react.createElement)(WrappedComponent, (0,esm_extends/* default */.A)({}, props, {
    clientId: clientId
  }));
}, 'withClientId');
/* harmony default export */ const with_client_id = (withClientId);
//# sourceMappingURL=with-client-id.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const button_block_appender_ButtonBlockAppender = _ref => {
  let {
    clientId,
    showSeparator,
    isFloating,
    onAddBlock,
    isToggle
  } = _ref;
  return (0,react.createElement)(button_block_appender, {
    className: classnames_default()({
      'block-list-appender__toggle': isToggle
    }),
    rootClientId: clientId,
    showSeparator: showSeparator,
    isFloating: isFloating,
    onAddBlock: onAddBlock
  });
};
/* harmony default export */ const inner_blocks_button_block_appender = (with_client_id(button_block_appender_ButtonBlockAppender));
//# sourceMappingURL=button-block-appender.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/default-block-appender.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




const default_block_appender_DefaultBlockAppender = _ref => {
  let {
    clientId
  } = _ref;
  return (0,react.createElement)(default_block_appender, {
    rootClientId: clientId
  });
};
/* harmony default export */ const inner_blocks_default_block_appender = ((0,compose/* default */.A)([with_client_id, with_select((select, _ref2) => {
  let {
    clientId
  } = _ref2;
  const {
    getBlockOrder
  } = select(store_store);
  const blockClientIds = getBlockOrder(clientId);
  return {
    lastBlockClientId: (0,lodash.last)(blockClientIds)
  };
})])(default_block_appender_DefaultBlockAppender));
//# sourceMappingURL=default-block-appender.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/** @typedef {import('../../selectors').WPDirectInsertBlock } WPDirectInsertBlock */

/**
 * This hook is a side effect which updates the block-editor store when changes
 * happen to inner block settings. The given props are transformed into a
 * settings object, and if that is different from the current settings object in
 * the block-editor store, then the store is updated with the new settings which
 * came from props.
 *
 * @param {string}               clientId                   The client ID of the block to update.
 * @param {string[]}             allowedBlocks              An array of block names which are permitted
 *                                                          in inner blocks.
 * @param {?WPDirectInsertBlock} __experimentalDefaultBlock The default block to insert: [ blockName, { blockAttributes } ].
 * @param {?Function|boolean}    __experimentalDirectInsert If a default block should be inserted directly by the
 *                                                          appender.
 * @param {string}               [templateLock]             The template lock specified for the inner
 *                                                          blocks component. (e.g. "all")
 * @param {boolean}              captureToolbars            Whether or children toolbars should be shown
 *                                                          in the inner blocks component rather than on
 *                                                          the child block.
 * @param {string}               orientation                The direction in which the block
 *                                                          should face.
 * @param {Object}               layout                     The layout object for the block container.
 */

function useNestedSettingsUpdate(clientId, allowedBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout) {
  const {
    updateBlockListSettings
  } = use_dispatch(store_store);
  const {
    blockListSettings,
    parentLock
  } = use_select_useSelect(select => {
    const rootClientId = select(store_store).getBlockRootClientId(clientId);
    return {
      blockListSettings: select(store_store).getBlockListSettings(clientId),
      parentLock: select(store_store).getTemplateLock(rootClientId)
    };
  }, [clientId]); // Memoize as inner blocks implementors often pass a new array on every
  // render.

  const _allowedBlocks = (0,react.useMemo)(() => allowedBlocks, allowedBlocks);

  (0,react.useLayoutEffect)(() => {
    const newSettings = {
      allowedBlocks: _allowedBlocks,
      templateLock: templateLock === undefined ? parentLock : templateLock
    }; // These values are not defined for RN, so only include them if they
    // are defined.

    if (captureToolbars !== undefined) {
      newSettings.__experimentalCaptureToolbars = captureToolbars;
    } // Orientation depends on layout,
    // ideally the separate orientation prop should be deprecated.


    if (orientation !== undefined) {
      newSettings.orientation = orientation;
    } else {
      const layoutType = getLayoutType(layout === null || layout === void 0 ? void 0 : layout.type);
      newSettings.orientation = layoutType.getOrientation(layout);
    }

    if (__experimentalDefaultBlock !== undefined) {
      newSettings.__experimentalDefaultBlock = __experimentalDefaultBlock;
    }

    if (__experimentalDirectInsert !== undefined) {
      newSettings.__experimentalDirectInsert = __experimentalDirectInsert;
    }

    if (!(0,is_shallow_equal_build_module/* default */.Ay)(blockListSettings, newSettings)) {
      updateBlockListSettings(clientId, newSettings);
    }
  }, [clientId, blockListSettings, _allowedBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, parentLock, captureToolbars, orientation, updateBlockListSettings, layout]);
}
//# sourceMappingURL=use-nested-settings-update.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * This hook makes sure that a block's inner blocks stay in sync with the given
 * block "template". The template is a block hierarchy to which inner blocks must
 * conform. If the blocks get "out of sync" with the template and the template
 * is meant to be locked (e.g. templateLock = "all"), then we replace the inner
 * blocks with the correct value after synchronizing it with the template.
 *
 * @param {string}  clientId                       The block client ID.
 * @param {Object}  template                       The template to match.
 * @param {string}  templateLock                   The template lock state for the inner blocks. For
 *                                                 example, if the template lock is set to "all",
 *                                                 then the inner blocks will stay in sync with the
 *                                                 template. If not defined or set to false, then
 *                                                 the inner blocks will not be synchronized with
 *                                                 the given template.
 * @param {boolean} templateInsertUpdatesSelection Whether or not to update the
 *                                                 block-editor selection state when inner blocks
 *                                                 are replaced after template synchronization.
 */

function useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection) {
  const {
    getSelectedBlocksInitialCaretPosition
  } = use_select_useSelect(store_store);
  const {
    replaceInnerBlocks
  } = use_dispatch(store_store);
  const innerBlocks = use_select_useSelect(select => select(store_store).getBlocks(clientId), [clientId]); // Maintain a reference to the previous value so we can do a deep equality check.

  const existingTemplate = (0,react.useRef)(null);
  (0,react.useLayoutEffect)(() => {
    // Only synchronize innerBlocks with template if innerBlocks are empty or
    // a locking all exists directly on the block.
    if (innerBlocks.length === 0 || templateLock === 'all') {
      const hasTemplateChanged = !(0,lodash.isEqual)(template, existingTemplate.current);

      if (hasTemplateChanged) {
        existingTemplate.current = template;
        const nextBlocks = (0,build_module/* synchronizeBlocksWithTemplate */.Nk)(innerBlocks, template);

        if (!(0,lodash.isEqual)(nextBlocks, innerBlocks)) {
          replaceInnerBlocks(clientId, nextBlocks, innerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0, // This ensures the "initialPosition" doesn't change when applying the template
          // If we're supposed to focus the block, we'll focus the first inner block
          // otherwise, we won't apply any auto-focus.
          // This ensures for instance that the focus stays in the inserter when inserting the "buttons" block.
          getSelectedBlocksInitialCaretPosition());
        }
      }
    }
  }, [innerBlocks, template, templateLock, clientId]);
}
//# sourceMappingURL=use-inner-block-template-sync.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/get-block-context.js
/**
 * External dependencies
 */

/**
 * Block context cache, implemented as a WeakMap mapping block types to a
 * WeakMap mapping attributes object to context value.
 *
 * @type {WeakMap<string,WeakMap<string,*>>}
 */

const BLOCK_CONTEXT_CACHE = new WeakMap();
/**
 * Returns a cached context object value for a given set of attributes for the
 * block type.
 *
 * @param {Record<string,*>} attributes Block attributes object.
 * @param {WPBlockType}      blockType  Block type settings.
 *
 * @return {Record<string,*>} Context value.
 */

function getBlockContext(attributes, blockType) {
  if (!BLOCK_CONTEXT_CACHE.has(blockType)) {
    BLOCK_CONTEXT_CACHE.set(blockType, new WeakMap());
  }

  const blockTypeCache = BLOCK_CONTEXT_CACHE.get(blockType);

  if (!blockTypeCache.has(attributes)) {
    const context = (0,lodash.mapValues)(blockType.providesContext, attributeName => attributes[attributeName]);
    blockTypeCache.set(attributes, context);
  }

  return blockTypeCache.get(attributes);
}
//# sourceMappingURL=get-block-context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/utils/throttle/index.js
/**
 * Parts of this source were derived and modified from lodash,
 * released under the MIT license.
 *
 * https://github.com/lodash/lodash
 *
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 *
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 * DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>
 *
 * This software consists of voluntary contributions made by many
 * individuals. For exact contribution history, see the revision history
 * available at https://github.com/lodash/lodash
 *
 * The following license applies to all parts of this software except as
 * documented below:
 *
 * ====
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Internal dependencies
 */


/**
 * A simplified and properly typed version of lodash's `throttle`, that
 * always uses timers instead of sometimes using rAF.
 *
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return
 * the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * @param {Function}                   func             The function to throttle.
 * @param {number}                     wait             The number of milliseconds to throttle invocations to.
 * @param {Partial< ThrottleOptions >} options          The options object.
 * @param {boolean}                    options.leading  Specify invoking on the leading edge of the timeout.
 * @param {boolean}                    options.trailing Specify invoking on the trailing edge of the timeout.
 * @return Returns the new throttled function.
 */
const throttle = (func, wait, options) => {
  let leading = true;
  let trailing = true;

  if (options) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return (0,debounce/* debounce */.s)(func, wait, {
    leading,
    trailing,
    maxWait: wait
  });
};
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-throttle/index.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Throttles a function similar to Lodash's `throttle`. A new throttled function will
 * be returned and any scheduled calls cancelled if any of the arguments change,
 * including the function to throttle, so please wrap functions created on
 * render in components in `useCallback`.
 *
 * @see https://docs-lodash.com/v4/throttle/
 *
 * @template {(...args: any[]) => void} TFunc
 *
 * @param {TFunc}                                          fn        The function to throttle.
 * @param {number}                                         [wait]    The number of milliseconds to throttle invocations to.
 * @param {import('../../utils/throttle').ThrottleOptions} [options] The options object. See linked documentation for details.
 * @return {import('../../utils/debounce').DebouncedFunc<TFunc>} Throttled function.
 */

function useThrottle(fn, wait, options) {
  const throttled = (0,use_memo_one_esm/* useMemoOne */.MA)(() => throttle(fn, wait !== null && wait !== void 0 ? wait : 0, options), [fn, wait, options]);
  (0,react.useEffect)(() => () => throttled.cancel(), [throttled]);
  return throttled;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-drop-zone/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/* eslint-disable jsdoc/valid-types */

/**
 * @template T
 * @param {T} value
 * @return {import('react').MutableRefObject<T|null>} A ref with the value.
 */

function useFreshRef(value) {
  /* eslint-enable jsdoc/valid-types */

  /* eslint-disable jsdoc/no-undefined-types */

  /** @type {import('react').MutableRefObject<T>} */

  /* eslint-enable jsdoc/no-undefined-types */
  // Disable reason: We're doing something pretty JavaScript-y here where the
  // ref will always have a current value that is not null or undefined but it
  // needs to start as undefined. We don't want to change the return type so
  // it's easier to just ts-ignore this specific line that's complaining about
  // undefined not being part of T.
  // @ts-ignore
  const ref = (0,react.useRef)();
  ref.current = value;
  return ref;
}
/**
 * A hook to facilitate drag and drop handling.
 *
 * @param {Object}                  props               Named parameters.
 * @param {boolean}                 [props.isDisabled]  Whether or not to disable the drop zone.
 * @param {(e: DragEvent) => void}  [props.onDragStart] Called when dragging has started.
 * @param {(e: DragEvent) => void}  [props.onDragEnter] Called when the zone is entered.
 * @param {(e: DragEvent) => void}  [props.onDragOver]  Called when the zone is moved within.
 * @param {(e: DragEvent) => void}  [props.onDragLeave] Called when the zone is left.
 * @param {(e: MouseEvent) => void} [props.onDragEnd]   Called when dragging has ended.
 * @param {(e: DragEvent) => void}  [props.onDrop]      Called when dropping in the zone.
 *
 * @return {import('react').RefCallback<HTMLElement>} Ref callback to be passed to the drop zone element.
 */


function useDropZone(_ref) {
  let {
    isDisabled,
    onDrop: _onDrop,
    onDragStart: _onDragStart,
    onDragEnter: _onDragEnter,
    onDragLeave: _onDragLeave,
    onDragEnd: _onDragEnd,
    onDragOver: _onDragOver
  } = _ref;
  const onDropRef = useFreshRef(_onDrop);
  const onDragStartRef = useFreshRef(_onDragStart);
  const onDragEnterRef = useFreshRef(_onDragEnter);
  const onDragLeaveRef = useFreshRef(_onDragLeave);
  const onDragEndRef = useFreshRef(_onDragEnd);
  const onDragOverRef = useFreshRef(_onDragOver);
  return (0,use_ref_effect/* default */.A)(element => {
    if (isDisabled) {
      return;
    }

    let isDragging = false;
    const {
      ownerDocument
    } = element;
    /**
     * Checks if an element is in the drop zone.
     *
     * @param {EventTarget|null} targetToCheck
     *
     * @return {boolean} True if in drop zone, false if not.
     */

    function isElementInZone(targetToCheck) {
      const {
        defaultView
      } = ownerDocument;

      if (!targetToCheck || !defaultView || !(targetToCheck instanceof defaultView.HTMLElement) || !element.contains(targetToCheck)) {
        return false;
      }
      /** @type {HTMLElement|null} */


      let elementToCheck = targetToCheck;

      do {
        if (elementToCheck.dataset.isDropZone) {
          return elementToCheck === element;
        }
      } while (elementToCheck = elementToCheck.parentElement);

      return false;
    }

    function maybeDragStart(
    /** @type {DragEvent} */
    event) {
      if (isDragging) {
        return;
      }

      isDragging = true; // Note that `dragend` doesn't fire consistently for file and
      // HTML drag events where the drag origin is outside the browser
      // window. In Firefox it may also not fire if the originating
      // node is removed.

      ownerDocument.addEventListener('dragend', maybeDragEnd);
      ownerDocument.addEventListener('mousemove', maybeDragEnd);

      if (onDragStartRef.current) {
        onDragStartRef.current(event);
      }
    }

    function onDragEnter(
    /** @type {DragEvent} */
    event) {
      event.preventDefault(); // The `dragenter` event will also fire when entering child
      // elements, but we only want to call `onDragEnter` when
      // entering the drop zone, which means the `relatedTarget`
      // (element that has been left) should be outside the drop zone.

      if (element.contains(
      /** @type {Node} */
      event.relatedTarget)) {
        return;
      }

      if (onDragEnterRef.current) {
        onDragEnterRef.current(event);
      }
    }

    function onDragOver(
    /** @type {DragEvent} */
    event) {
      // Only call onDragOver for the innermost hovered drop zones.
      if (!event.defaultPrevented && onDragOverRef.current) {
        onDragOverRef.current(event);
      } // Prevent the browser default while also signalling to parent
      // drop zones that `onDragOver` is already handled.


      event.preventDefault();
    }

    function onDragLeave(
    /** @type {DragEvent} */
    event) {
      // The `dragleave` event will also fire when leaving child
      // elements, but we only want to call `onDragLeave` when
      // leaving the drop zone, which means the `relatedTarget`
      // (element that has been entered) should be outside the drop
      // zone.
      // Note: This is not entirely reliable in Safari due to this bug
      // https://bugs.webkit.org/show_bug.cgi?id=66547
      if (isElementInZone(event.relatedTarget)) {
        return;
      }

      if (onDragLeaveRef.current) {
        onDragLeaveRef.current(event);
      }
    }

    function onDrop(
    /** @type {DragEvent} */
    event) {
      // Don't handle drop if an inner drop zone already handled it.
      if (event.defaultPrevented) {
        return;
      } // Prevent the browser default while also signalling to parent
      // drop zones that `onDrop` is already handled.


      event.preventDefault(); // This seemingly useless line has been shown to resolve a
      // Safari issue where files dragged directly from the dock are
      // not recognized.
      // eslint-disable-next-line no-unused-expressions

      event.dataTransfer && event.dataTransfer.files.length;

      if (onDropRef.current) {
        onDropRef.current(event);
      }

      maybeDragEnd(event);
    }

    function maybeDragEnd(
    /** @type {MouseEvent} */
    event) {
      if (!isDragging) {
        return;
      }

      isDragging = false;
      ownerDocument.removeEventListener('dragend', maybeDragEnd);
      ownerDocument.removeEventListener('mousemove', maybeDragEnd);

      if (onDragEndRef.current) {
        onDragEndRef.current(event);
      }
    }

    element.dataset.isDropZone = 'true';
    element.addEventListener('drop', onDrop);
    element.addEventListener('dragenter', onDragEnter);
    element.addEventListener('dragover', onDragOver);
    element.addEventListener('dragleave', onDragLeave); // The `dragstart` event doesn't fire if the drag started outside
    // the document.

    ownerDocument.addEventListener('dragenter', maybeDragStart);
    return () => {
      delete element.dataset.isDropZone;
      element.removeEventListener('drop', onDrop);
      element.removeEventListener('dragenter', onDragEnter);
      element.removeEventListener('dragover', onDragOver);
      element.removeEventListener('dragleave', onDragLeave);
      ownerDocument.removeEventListener('dragend', maybeDragEnd);
      ownerDocument.removeEventListener('mousemove', maybeDragEnd);
      ownerDocument.removeEventListener('dragenter', maybeDragStart);
    };
  }, [isDisabled]);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/data-transfer.js
/**
 * Gets all files from a DataTransfer object.
 *
 * @param {DataTransfer} dataTransfer DataTransfer object to inspect.
 *
 * @return {File[]} An array containing all files.
 */
function getFilesFromDataTransfer(dataTransfer) {
  const files = Array.from(dataTransfer.files);
  Array.from(dataTransfer.items).forEach(item => {
    const file = item.getAsFile();

    if (file && !files.find(_ref => {
      let {
        name,
        type,
        size
      } = _ref;
      return name === file.name && type === file.type && size === file.size;
    })) {
      files.push(file);
    }
  });
  return files;
}
//# sourceMappingURL=data-transfer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/use-on-block-drop/index.js
/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').WPSyntheticEvent} WPSyntheticEvent */

/**
 * Retrieve the data for a block drop event.
 *
 * @param {WPSyntheticEvent} event The drop event.
 *
 * @return {Object} An object with block drag and drop data.
 */

function parseDropEvent(event) {
  let result = {
    srcRootClientId: null,
    srcClientIds: null,
    srcIndex: null,
    type: null,
    blocks: null
  };

  if (!event.dataTransfer) {
    return result;
  }

  try {
    result = Object.assign(result, JSON.parse(event.dataTransfer.getData('wp-blocks')));
  } catch (err) {
    return result;
  }

  return result;
}
/**
 * A function that returns an event handler function for block drop events.
 *
 * @param {string}   targetRootClientId        The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex          The index where the block(s) will be inserted.
 * @param {Function} getBlockIndex             A function that gets the index of a block.
 * @param {Function} getClientIdsOfDescendants A function that gets the client ids of descendant blocks.
 * @param {Function} moveBlocksToPosition      A function that moves blocks.
 * @param {Function} insertBlocks              A function that inserts blocks.
 * @param {Function} clearSelectedBlock        A function that clears block selection.
 * @return {Function} The event handler for a block drop event.
 */

function onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocksToPosition, insertBlocks, clearSelectedBlock) {
  return event => {
    const {
      srcRootClientId: sourceRootClientId,
      srcClientIds: sourceClientIds,
      type: dropType,
      blocks
    } = parseDropEvent(event); // If the user is inserting a block.

    if (dropType === 'inserter') {
      clearSelectedBlock();
      const blocksToInsert = blocks.map(block => (0,build_module/* cloneBlock */.JB)(block));
      insertBlocks(blocksToInsert, targetBlockIndex, targetRootClientId, true, null);
    } // If the user is moving a block.


    if (dropType === 'block') {
      const sourceBlockIndex = getBlockIndex(sourceClientIds[0]); // If the user is dropping to the same position, return early.

      if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
        return;
      } // If the user is attempting to drop a block within its own
      // nested blocks, return early as this would create infinite
      // recursion.


      if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants(sourceClientIds).some(id => id === targetRootClientId)) {
        return;
      }

      const isAtSameLevel = sourceRootClientId === targetRootClientId;
      const draggedBlockCount = sourceClientIds.length; // If the block is kept at the same level and moved downwards,
      // subtract to take into account that the blocks being dragged
      // were removed from the block list above the insertion point.

      const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
      moveBlocksToPosition(sourceClientIds, sourceRootClientId, targetRootClientId, insertIndex);
    }
  };
}
/**
 * A function that returns an event handler function for block-related file drop events.
 *
 * @param {string}   targetRootClientId    The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex      The index where the block(s) will be inserted.
 * @param {boolean}  hasUploadPermissions  Whether the user has upload permissions.
 * @param {Function} updateBlockAttributes A function that updates a block's attributes.
 * @param {Function} canInsertBlockType    A function that returns checks whether a block type can be inserted.
 * @param {Function} insertBlocks          A function that inserts blocks.
 *
 * @return {Function} The event handler for a block-related file drop event.
 */

function onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes, canInsertBlockType, insertBlocks) {
  return files => {
    if (!hasUploadPermissions) {
      return;
    }

    const transformation = (0,build_module/* findTransform */.wG)((0,build_module/* getBlockTransforms */.XD)('from'), transform => transform.type === 'files' && canInsertBlockType(transform.blockName, targetRootClientId) && transform.isMatch(files));

    if (transformation) {
      const blocks = transformation.transform(files, updateBlockAttributes);
      insertBlocks(blocks, targetBlockIndex, targetRootClientId);
    }
  };
}
/**
 * A function that returns an event handler function for block-related HTML drop events.
 *
 * @param {string}   targetRootClientId The root client id where the block(s) will be inserted.
 * @param {number}   targetBlockIndex   The index where the block(s) will be inserted.
 * @param {Function} insertBlocks       A function that inserts blocks.
 *
 * @return {Function} The event handler for a block-related HTML drop event.
 */

function onHTMLDrop(targetRootClientId, targetBlockIndex, insertBlocks) {
  return HTML => {
    const blocks = (0,build_module/* pasteHandler */.Gk)({
      HTML,
      mode: 'BLOCKS'
    });

    if (blocks.length) {
      insertBlocks(blocks, targetBlockIndex, targetRootClientId);
    }
  };
}
/**
 * A React hook for handling block drop events.
 *
 * @param {string} targetRootClientId The root client id where the block(s) will be inserted.
 * @param {number} targetBlockIndex   The index where the block(s) will be inserted.
 *
 * @return {Object} An object that contains the event handlers `onDrop`, `onFilesDrop` and `onHTMLDrop`.
 */

function useOnBlockDrop(targetRootClientId, targetBlockIndex) {
  const hasUploadPermissions = use_select_useSelect(select => select(store_store).getSettings().mediaUpload, []);
  const {
    canInsertBlockType,
    getBlockIndex,
    getClientIdsOfDescendants
  } = use_select_useSelect(store_store);
  const {
    insertBlocks,
    moveBlocksToPosition,
    updateBlockAttributes,
    clearSelectedBlock
  } = use_dispatch(store_store);

  const _onDrop = onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex, getClientIdsOfDescendants, moveBlocksToPosition, insertBlocks, clearSelectedBlock);

  const _onFilesDrop = onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes, canInsertBlockType, insertBlocks);

  const _onHTMLDrop = onHTMLDrop(targetRootClientId, targetBlockIndex, insertBlocks);

  return event => {
    const files = getFilesFromDataTransfer(event.dataTransfer);
    const html = event.dataTransfer.getData('text/html');
    /**
     * From Windows Chrome 96, the `event.dataTransfer` returns both file object and HTML.
     * The order of the checks is important to recognise the HTML drop.
     */

    if (html) {
      _onHTMLDrop(html);
    } else if (files.length) {
      _onFilesDrop(files);
    } else {
      _onDrop(event);
    }
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/utils/math.js
/**
 * A string representing the name of an edge.
 *
 * @typedef {'top'|'right'|'bottom'|'left'} WPEdgeName
 */

/**
 * @typedef  {Object} WPPoint
 * @property {number} x The horizontal position.
 * @property {number} y The vertical position.
 */

/**
 * Given a point, a DOMRect and the name of an edge, returns the distance to
 * that edge of the rect.
 *
 * This function works for edges that are horizontal or vertical (e.g. not
 * rotated), the following terms are used so that the function works in both
 * orientations:
 *
 * - Forward, meaning the axis running horizontally when an edge is vertical
 *   and vertically when an edge is horizontal.
 * - Lateral, meaning the axis running vertically when an edge is vertical
 *   and horizontally when an edge is horizontal.
 *
 * @param {WPPoint}    point The point to measure distance from.
 * @param {DOMRect}    rect  A DOM Rect containing edge positions.
 * @param {WPEdgeName} edge  The edge to measure to.
 */
function getDistanceFromPointToEdge(point, rect, edge) {
  const isHorizontal = edge === 'top' || edge === 'bottom';
  const {
    x,
    y
  } = point;
  const pointLateralPosition = isHorizontal ? x : y;
  const pointForwardPosition = isHorizontal ? y : x;
  const edgeStart = isHorizontal ? rect.left : rect.top;
  const edgeEnd = isHorizontal ? rect.right : rect.bottom;
  const edgeForwardPosition = rect[edge]; // Measure the straight line distance to the edge of the rect, when the
  // point is adjacent to the edge.
  // Else, if the point is positioned diagonally to the edge of the rect,
  // measure diagonally to the nearest corner that the edge meets.

  let edgeLateralPosition;

  if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
    edgeLateralPosition = pointLateralPosition;
  } else if (pointLateralPosition < edgeEnd) {
    edgeLateralPosition = edgeStart;
  } else {
    edgeLateralPosition = edgeEnd;
  }

  return Math.sqrt((pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2);
}
/**
 * Given a point, a DOMRect and a list of allowed edges returns the name of and
 * distance to the nearest edge.
 *
 * @param {WPPoint}      point        The point to measure distance from.
 * @param {DOMRect}      rect         A DOM Rect containing edge positions.
 * @param {WPEdgeName[]} allowedEdges A list of the edges included in the
 *                                    calculation. Defaults to all edges.
 *
 * @return {[number, string]} An array where the first value is the distance
 *                              and a second is the edge name.
 */

function getDistanceToNearestEdge(point, rect) {
  let allowedEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['top', 'bottom', 'left', 'right'];
  let candidateDistance;
  let candidateEdge;
  allowedEdges.forEach(edge => {
    const distance = getDistanceFromPointToEdge(point, rect, edge);

    if (candidateDistance === undefined || distance < candidateDistance) {
      candidateDistance = distance;
      candidateEdge = edge;
    }
  });
  return [candidateDistance, candidateEdge];
}
//# sourceMappingURL=math.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/use-block-drop-zone/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/** @typedef {import('../../utils/math').WPPoint} WPPoint */

/**
 * The orientation of a block list.
 *
 * @typedef {'horizontal'|'vertical'|undefined} WPBlockListOrientation
 */

/**
 * Given a list of block DOM elements finds the index that a block should be dropped
 * at.
 *
 * @param {Element[]}              elements    Array of DOM elements that represent each block in a block list.
 * @param {WPPoint}                position    The position of the item being dragged.
 * @param {WPBlockListOrientation} orientation The orientation of a block list.
 *
 * @return {number|undefined} The block index that's closest to the drag position.
 */

function getNearestBlockIndex(elements, position, orientation) {
  const allowedEdges = orientation === 'horizontal' ? ['left', 'right'] : ['top', 'bottom'];
  const isRightToLeft = (0,_wordpress_i18n_build_module/* isRTL */.V8)();
  let candidateIndex;
  let candidateDistance;
  elements.forEach((element, index) => {
    const rect = element.getBoundingClientRect();
    const [distance, edge] = getDistanceToNearestEdge(position, rect, allowedEdges);

    if (candidateDistance === undefined || distance < candidateDistance) {
      // If the user is dropping to the trailing edge of the block
      // add 1 to the index to represent dragging after.
      // Take RTL languages into account where the left edge is
      // the trailing edge.
      const isTrailingEdge = edge === 'bottom' || !isRightToLeft && edge === 'right' || isRightToLeft && edge === 'left';
      const offset = isTrailingEdge ? 1 : 0; // Update the currently known best candidate.

      candidateDistance = distance;
      candidateIndex = index + offset;
    }
  });
  return candidateIndex;
}
/**
 * @typedef  {Object} WPBlockDropZoneConfig
 * @property {string} rootClientId The root client id for the block list.
 */

/**
 * A React hook that can be used to make a block list handle drag and drop.
 *
 * @param {WPBlockDropZoneConfig} dropZoneConfig configuration data for the drop zone.
 */

function useBlockDropZone() {
  let {
    // An undefined value represents a top-level block. Default to an empty
    // string for this so that `targetRootClientId` can be easily compared to
    // values returned by the `getRootBlockClientId` selector, which also uses
    // an empty string to represent top-level blocks.
    rootClientId: targetRootClientId = ''
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const [targetBlockIndex, setTargetBlockIndex] = (0,react.useState)(null);
  const isLockedAll = use_select_useSelect(select => {
    const {
      getTemplateLock
    } = select(store_store);
    return getTemplateLock(targetRootClientId) === 'all';
  }, [targetRootClientId]);
  const {
    getBlockListSettings
  } = use_select_useSelect(store_store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = use_dispatch(store_store);
  const onBlockDrop = useOnBlockDrop(targetRootClientId, targetBlockIndex);
  const throttled = useThrottle((0,react.useCallback)((event, currentTarget) => {
    var _getBlockListSettings;

    const blockElements = Array.from(currentTarget.children).filter( // Ensure the element is a block. It should have the `wp-block` class.
    element => element.classList.contains('wp-block'));
    const targetIndex = getNearestBlockIndex(blockElements, {
      x: event.clientX,
      y: event.clientY
    }, (_getBlockListSettings = getBlockListSettings(targetRootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation);
    setTargetBlockIndex(targetIndex === undefined ? 0 : targetIndex);

    if (targetIndex !== null) {
      showInsertionPoint(targetRootClientId, targetIndex);
    }
  }, []), 200);
  return useDropZone({
    isDisabled: isLockedAll,
    onDrop: onBlockDrop,

    onDragOver(event) {
      // `currentTarget` is only available while the event is being
      // handled, so get it now and pass it to the thottled function.
      // https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget
      throttled(event, event.currentTarget);
    },

    onDragLeave() {
      throttled.cancel();
      hideInsertionPoint();
      setTargetBlockIndex(null);
    },

    onDragEnd() {
      throttled.cancel();
      hideInsertionPoint();
      setTargetBlockIndex(null);
    }

  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */












/**
 * InnerBlocks is a component which allows a single block to have multiple blocks
 * as children. The UncontrolledInnerBlocks component is used whenever the inner
 * blocks are not controlled by another entity. In other words, it is normally
 * used for inner blocks in the post editor
 *
 * @param {Object} props The component props.
 */

function UncontrolledInnerBlocks(props) {
  const {
    clientId,
    allowedBlocks,
    __experimentalDefaultBlock,
    __experimentalDirectInsert,
    template,
    templateLock,
    wrapperRef,
    templateInsertUpdatesSelection,
    __experimentalCaptureToolbars: captureToolbars,
    __experimentalAppenderTagName,
    renderAppender,
    orientation,
    placeholder,
    __experimentalLayout
  } = props;
  useNestedSettingsUpdate(clientId, allowedBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, __experimentalLayout);
  useInnerBlockTemplateSync(clientId, template, templateLock, templateInsertUpdatesSelection);
  const context = use_select_useSelect(select => {
    const block = select(store_store).getBlock(clientId);
    const blockType = (0,build_module/* getBlockType */.E7)(block.name);

    if (!blockType || !blockType.providesContext) {
      return;
    }

    return getBlockContext(block.attributes, blockType);
  }, [clientId]); // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.

  return (0,react.createElement)(BlockContextProvider, {
    value: context
  }, (0,react.createElement)(block_list_BlockListItems, {
    rootClientId: clientId,
    renderAppender: renderAppender,
    __experimentalAppenderTagName: __experimentalAppenderTagName,
    __experimentalLayout: __experimentalLayout,
    wrapperRef: wrapperRef,
    placeholder: placeholder
  }));
}
/**
 * The controlled inner blocks component wraps the uncontrolled inner blocks
 * component with the blockSync hook. This keeps the innerBlocks of the block in
 * the block-editor store in sync with the blocks of the controlling entity. An
 * example of an inner block controller is a template part block, which provides
 * its own blocks from the template part entity data source.
 *
 * @param {Object} props The component props.
 */


function ControlledInnerBlocks(props) {
  useBlockSync(props);
  return (0,react.createElement)(UncontrolledInnerBlocks, props);
}

const ForwardedInnerBlocks = (0,react.forwardRef)((props, ref) => {
  const innerBlocksProps = useInnerBlocksProps({
    ref
  }, props);
  return (0,react.createElement)("div", {
    className: "block-editor-inner-blocks"
  }, (0,react.createElement)("div", innerBlocksProps));
});
/**
 * This hook is used to lightly mark an element as an inner blocks wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * an inner blocks wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object} props   Optional. Props to pass to the element. Must contain
 *                         the ref if one is defined.
 * @param {Object} options Optional. Inner blocks options.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */

function useInnerBlocksProps() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    clientId
  } = context_useBlockEditContext();
  const isSmallScreen = (0,use_viewport_match/* default */.A)('medium', '<');
  const {
    __experimentalCaptureToolbars,
    hasOverlay
  } = use_select_useSelect(select => {
    if (!clientId) {
      return {};
    }

    const {
      getBlockName,
      isBlockSelected,
      hasSelectedInnerBlock,
      isNavigationMode
    } = select(store_store);
    const blockName = getBlockName(clientId);
    const enableClickThrough = isNavigationMode() || isSmallScreen;
    return {
      __experimentalCaptureToolbars: select(build_module/* store */.M_).hasBlockSupport(blockName, '__experimentalExposeControlsToChildren', false),
      hasOverlay: blockName !== 'core/template' && !isBlockSelected(clientId) && !hasSelectedInnerBlock(clientId, true) && enableClickThrough
    };
  }, [clientId, isSmallScreen]);
  const ref = (0,use_merge_refs/* default */.A)([props.ref, useBlockDropZone({
    rootClientId: clientId
  })]);
  const innerBlocksProps = {
    __experimentalCaptureToolbars,
    ...options
  };
  const InnerBlocks = innerBlocksProps.value && innerBlocksProps.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
  return { ...props,
    ref,
    className: classnames_default()(props.className, 'block-editor-block-list__layout', {
      'has-overlay': hasOverlay
    }),
    children: clientId ? (0,react.createElement)(InnerBlocks, (0,esm_extends/* default */.A)({}, innerBlocksProps, {
      clientId: clientId
    })) : (0,react.createElement)(block_list_BlockListItems, options)
  };
}
useInnerBlocksProps.save = build_module/* __unstableGetInnerBlocksProps */.v9; // Expose default appender placeholders as components.

ForwardedInnerBlocks.DefaultBlockAppender = inner_blocks_default_block_appender;
ForwardedInnerBlocks.ButtonBlockAppender = inner_blocks_button_block_appender;

ForwardedInnerBlocks.Content = () => useInnerBlocksProps.save().children;
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/inner-blocks/README.md
 */


/* harmony default export */ const inner_blocks = ((/* unused pure expression or super */ null && (ForwardedInnerBlocks)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-list/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */











const elementContext = (0,react.createContext)();
const block_list_IntersectionObserver = (0,react.createContext)();

function block_list_Root(_ref) {
  let {
    className,
    ...settings
  } = _ref;
  const [element, setElement] = (0,react.useState)();
  const isLargeViewport = (0,use_viewport_match/* default */.A)('medium');
  const {
    isOutlineMode,
    isFocusMode,
    isNavigationMode
  } = use_select_useSelect(select => {
    const {
      getSettings,
      isNavigationMode: _isNavigationMode
    } = select(store_store);
    const {
      outlineMode,
      focusMode
    } = getSettings();
    return {
      isOutlineMode: outlineMode,
      isFocusMode: focusMode,
      isNavigationMode: _isNavigationMode()
    };
  }, []);
  const {
    setBlockVisibility
  } = use_dispatch(store_store);
  const intersectionObserver = (0,react.useMemo)(() => {
    const {
      IntersectionObserver: Observer
    } = window;

    if (!Observer) {
      return;
    }

    return new Observer(entries => {
      const updates = {};

      for (const entry of entries) {
        const clientId = entry.target.getAttribute('data-block');
        updates[clientId] = entry.isIntersecting;
      }

      setBlockVisibility(updates);
    });
  }, []);
  const innerBlocksProps = useInnerBlocksProps({
    ref: (0,use_merge_refs/* default */.A)([useBlockSelectionClearer(), useInBetweenInserter(), setElement]),
    className: classnames_default()('is-root-container', className, {
      'is-outline-mode': isOutlineMode,
      'is-focus-mode': isFocusMode && isLargeViewport,
      'is-navigate-mode': isNavigationMode
    })
  }, settings);
  return (0,react.createElement)(elementContext.Provider, {
    value: element
  }, (0,react.createElement)(block_list_IntersectionObserver.Provider, {
    value: intersectionObserver
  }, (0,react.createElement)("div", innerBlocksProps)));
}

function BlockList(settings) {
  usePreParsePatterns();
  return (0,react.createElement)(BlockToolsBackCompat, null, (0,react.createElement)(block_edit_context_Provider, {
    value: DEFAULT_BLOCK_EDIT_CONTEXT
  }, (0,react.createElement)(block_list_Root, settings)));
}
BlockList.__unstableElementContext = elementContext;

function Items(_ref2) {
  let {
    placeholder,
    rootClientId,
    renderAppender,
    __experimentalAppenderTagName,
    __experimentalLayout: layout = defaultLayout
  } = _ref2;
  const {
    order,
    selectedBlocks,
    visibleBlocks
  } = use_select_useSelect(select => {
    const {
      getBlockOrder,
      getSelectedBlockClientIds,
      __unstableGetVisibleBlocks
    } = select(store_store);
    return {
      order: getBlockOrder(rootClientId),
      selectedBlocks: getSelectedBlockClientIds(),
      visibleBlocks: __unstableGetVisibleBlocks()
    };
  }, [rootClientId]);
  return (0,react.createElement)(LayoutProvider, {
    value: layout
  }, order.map(clientId => (0,react.createElement)(async_mode_provider_context, {
    key: clientId,
    value: // Only provide data asynchronously if the block is
    // not visible and not selected.
    !visibleBlocks.has(clientId) && !selectedBlocks.includes(clientId)
  }, (0,react.createElement)(block_list_block, {
    rootClientId: rootClientId,
    clientId: clientId
  }))), order.length < 1 && placeholder, (0,react.createElement)(block_list_appender, {
    tagName: __experimentalAppenderTagName,
    rootClientId: rootClientId,
    renderAppender: renderAppender
  }));
}

function block_list_BlockListItems(props) {
  // This component needs to always be synchronous as it's the one changing
  // the async mode depending on the block selection.
  return (0,react.createElement)(async_mode_provider_context, {
    value: false
  }, (0,react.createElement)(Items, props));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/utils.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */
const sides = ['top', 'right', 'bottom', 'left'];
const borderProps = ['color', 'style', 'width'];
const isEmptyBorder = border => {
  if (!border) {
    return true;
  }

  return !borderProps.some(prop => border[prop] !== undefined);
};
const isDefinedBorder = border => {
  // No border, no worries :)
  if (!border) {
    return false;
  } // If we have individual borders per side within the border object we
  // need to check whether any of those side borders have been set.


  if (hasSplitBorders(border)) {
    const allSidesEmpty = sides.every(side => isEmptyBorder(border[side]));
    return !allSidesEmpty;
  } // If we have a top-level border only, check if that is empty. e.g.
  // { color: undefined, style: undefined, width: undefined }
  // Border radius can still be set within the border object as it is
  // handled separately.


  return !isEmptyBorder(border);
};
const isCompleteBorder = border => {
  if (!border) {
    return false;
  }

  return borderProps.every(prop => border[prop] !== undefined);
};
const hasSplitBorders = function () {
  let border = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(border).some(side => sides.indexOf(side) !== -1);
};
const hasMixedBorders = borders => {
  if (!hasSplitBorders(borders)) {
    return false;
  }

  const shorthandBorders = sides.map(side => getShorthandBorderStyle(borders === null || borders === void 0 ? void 0 : borders[side]));
  return !shorthandBorders.every(border => border === shorthandBorders[0]);
};
const getSplitBorders = border => {
  if (!border || isEmptyBorder(border)) {
    return undefined;
  }

  return {
    top: border,
    right: border,
    bottom: border,
    left: border
  };
};
const getBorderDiff = (original, updated) => {
  const diff = {};

  if (original.color !== updated.color) {
    diff.color = updated.color;
  }

  if (original.style !== updated.style) {
    diff.style = updated.style;
  }

  if (original.width !== updated.width) {
    diff.width = updated.width;
  }

  return diff;
};
const getCommonBorder = borders => {
  if (!borders) {
    return undefined;
  }

  const colors = [];
  const styles = [];
  const widths = [];
  sides.forEach(side => {
    var _borders$side, _borders$side2, _borders$side3;

    colors.push((_borders$side = borders[side]) === null || _borders$side === void 0 ? void 0 : _borders$side.color);
    styles.push((_borders$side2 = borders[side]) === null || _borders$side2 === void 0 ? void 0 : _borders$side2.style);
    widths.push((_borders$side3 = borders[side]) === null || _borders$side3 === void 0 ? void 0 : _borders$side3.width);
  });
  const allColorsMatch = colors.every(value => value === colors[0]);
  const allStylesMatch = styles.every(value => value === styles[0]);
  const allWidthsMatch = widths.every(value => value === widths[0]);
  return {
    color: allColorsMatch ? colors[0] : undefined,
    style: allStylesMatch ? styles[0] : undefined,
    width: allWidthsMatch ? widths[0] : undefined
  };
};
const getShorthandBorderStyle = (border, fallbackBorder) => {
  if (isEmptyBorder(border)) {
    return fallbackBorder;
  }

  const {
    color: fallbackColor,
    style: fallbackStyle,
    width: fallbackWidth
  } = fallbackBorder || {};
  const {
    color = fallbackColor,
    style = fallbackStyle,
    width = fallbackWidth
  } = border;
  const hasVisibleBorder = !!width && width !== '0' || !!color;
  const borderStyle = hasVisibleBorder ? style || 'solid' : style;
  return [width, borderStyle, color].filter(Boolean).join(' ');
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/styles.js
function border_box_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const BorderBoxControl = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)( true ? "" : 0,  true ? "" : 0);
const LinkedBorderControl =  true ? {
  name: "82a6rk",
  styles: "flex:1"
} : 0;
const BorderBoxControlLinkedButton = __next36pxDefaultSize => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("flex:0;flex-basis:36px;margin-top:", __next36pxDefaultSize ? '6px' : '3px', ";" + ( true ? "" : 0),  true ? "" : 0);
};

const BorderBoxStyleWithFallback = border => {
  const {
    color = COLORS.gray[200],
    style = 'solid',
    width = config_values.borderWidth
  } = border || {};
  const clampedWidth = width !== config_values.borderWidth ? `clamp(1px, ${width}, 10px)` : width;
  const hasVisibleBorder = !!width && width !== '0' || !!color;
  const borderStyle = hasVisibleBorder ? style || 'solid' : style;
  return `${color} ${borderStyle} ${clampedWidth}`;
};

const borderBoxControlVisualizer = (borders, __next36pxDefaultSize) => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("position:absolute;top:", __next36pxDefaultSize ? '18px' : '15px', ";right:30px;bottom:", __next36pxDefaultSize ? '18px' : '15px', ";left:30px;border-top:", BorderBoxStyleWithFallback(borders === null || borders === void 0 ? void 0 : borders.top), ";border-bottom:", BorderBoxStyleWithFallback(borders === null || borders === void 0 ? void 0 : borders.bottom), ";", rtl({
    borderLeft: BorderBoxStyleWithFallback(borders === null || borders === void 0 ? void 0 : borders.left)
  })(), " ", rtl({
    borderRight: BorderBoxStyleWithFallback(borders === null || borders === void 0 ? void 0 : borders.right)
  })(), ";" + ( true ? "" : 0),  true ? "" : 0);
};
const borderBoxControlSplitControls = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("position:relative;flex:1;", rtl({
  marginRight: space(3)
}, {
  marginLeft: space(3)
})(), ";" + ( true ? "" : 0),  true ? "" : 0);
const CenteredBorderControl =  true ? {
  name: "1nwbfnf",
  styles: "grid-column:span 2;margin:0 auto"
} : 0;
const rightBorderControl = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(rtl({
  marginLeft: 'auto'
}, {
  marginRight: 'auto'
})(), ";" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-linked-button/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function useBorderBoxControlLinkedButton(props) {
  const {
    className,
    __next36pxDefaultSize = false,
    ...otherProps
  } = useContextSystem(props, 'BorderBoxControlLinkedButton'); // Generate class names.

  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    return cx(BorderBoxControlLinkedButton(__next36pxDefaultSize), className);
  }, [className, cx, __next36pxDefaultSize]);
  return { ...otherProps,
    className: classes
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-linked-button/component.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */







const component_BorderBoxControlLinkedButton = (props, forwardedRef) => {
  const {
    className,
    isLinked,
    ...buttonProps
  } = useBorderBoxControlLinkedButton(props);
  const label = isLinked ? (0,i18n_build_module.__)('Unlink sides') : (0,i18n_build_module.__)('Link sides');
  return (0,react.createElement)(tooltip, {
    text: label
  }, (0,react.createElement)(component, {
    className: className
  }, (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({}, buttonProps, {
    variant: isLinked ? 'primary' : 'secondary',
    isSmall: true,
    icon: isLinked ? library_link : link_off,
    iconSize: 16,
    "aria-label": label,
    ref: forwardedRef
  }))));
};

const ConnectedBorderBoxControlLinkedButton = contextConnect(component_BorderBoxControlLinkedButton, 'BorderBoxControlLinkedButton');
/* harmony default export */ const border_box_control_linked_button_component = (ConnectedBorderBoxControlLinkedButton);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-visualizer/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function useBorderBoxControlVisualizer(props) {
  const {
    className,
    value,
    __next36pxDefaultSize = false,
    ...otherProps
  } = useContextSystem(props, 'BorderBoxControlVisualizer'); // Generate class names.

  const cx = useCx();
  const rtlWatchResult = rtl.watch();
  const classes = (0,react.useMemo)(() => {
    return cx(borderBoxControlVisualizer(value, __next36pxDefaultSize), className); // rtlWatchResult is needed to refresh styles when the writing direction changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cx, className, value, __next36pxDefaultSize, rtlWatchResult]);
  return { ...otherProps,
    className: classes,
    value
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-visualizer/component.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const BorderBoxControlVisualizer = (props, forwardedRef) => {
  const {
    value,
    ...otherProps
  } = useBorderBoxControlVisualizer(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, otherProps, {
    ref: forwardedRef
  }));
};

const ConnectedBorderBoxControlVisualizer = contextConnect(BorderBoxControlVisualizer, 'BorderBoxControlVisualizer');
/* harmony default export */ const border_box_control_visualizer_component = (ConnectedBorderBoxControlVisualizer);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/line-solid.js

/**
 * WordPress dependencies
 */

const lineSolid = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M5 11.25h14v1.5H5z"
}));
/* harmony default export */ const line_solid = (lineSolid);
//# sourceMappingURL=line-solid.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/line-dashed.js

/**
 * WordPress dependencies
 */

const lineDashed = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  fillRule: "evenodd",
  d: "M5 11.25h3v1.5H5v-1.5zm5.5 0h3v1.5h-3v-1.5zm8.5 0h-3v1.5h3v-1.5z",
  clipRule: "evenodd"
}));
/* harmony default export */ const line_dashed = (lineDashed);
//# sourceMappingURL=line-dashed.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/line-dotted.js

/**
 * WordPress dependencies
 */

const lineDotted = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  fillRule: "evenodd",
  d: "M5.25 11.25h1.5v1.5h-1.5v-1.5zm3 0h1.5v1.5h-1.5v-1.5zm4.5 0h-1.5v1.5h1.5v-1.5zm1.5 0h1.5v1.5h-1.5v-1.5zm4.5 0h-1.5v1.5h1.5v-1.5z",
  clipRule: "evenodd"
}));
/* harmony default export */ const line_dotted = (lineDotted);
//# sourceMappingURL=line-dotted.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/styles.js
function border_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */





const styles_labelStyles =  true ? {
  name: "f3vz0n",
  styles: "font-weight:500"
} : 0;
const focusBoxShadow = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("box-shadow:inset 0 0 0 ", config_values.borderWidth, " ", COLORS.ui.borderFocus, ";" + ( true ? "" : 0),  true ? "" : 0);
const borderControl = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border:0;padding:0;margin:0;", boxSizingReset, ";" + ( true ? "" : 0),  true ? "" : 0);
const innerWrapper = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(unit_control_styles_Root, "{flex:1 1 40%;}&& ", UnitSelect, "{min-height:0;}" + ( true ? "" : 0),  true ? "" : 0);
/*
 * This style is only applied to the UnitControl wrapper when the border width
 * field should be a set width. Omitting this allows the UnitControl &
 * RangeControl to share the available width in a 40/60 split respectively.
 */

const styles_wrapperWidth = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(unit_control_styles_Root, "{flex:0 0 auto;}" + ( true ? "" : 0),  true ? "" : 0);
/*
 * When default control height is 36px the following should be removed.
 * See: InputControl and __next36pxDefaultSize.
 */

const wrapperHeight = __next36pxDefaultSize => {
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("height:", __next36pxDefaultSize ? '36px' : '30px', ";" + ( true ? "" : 0),  true ? "" : 0);
};
const borderControlDropdown = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background:#fff;&&>button{height:100%;padding:", space(0.75), ";", rtl({
  borderRadius: `2px 0 0 2px`
}, {
  borderRadius: `0 2px 2px 0`
})(), " border:", config_values.borderWidth, " solid ", COLORS.ui.border, ";&:focus,&:hover:not( :disabled ){", focusBoxShadow, " border-color:", COLORS.ui.borderFocus, ";z-index:1;position:relative;}}" + ( true ? "" : 0),  true ? "" : 0);
const colorIndicatorBorder = border => {
  const {
    color,
    style
  } = border || {};
  const fallbackColor = !!style && style !== 'none' ? COLORS.gray[300] : undefined;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-style:", style === 'none' ? 'solid' : style, ";border-color:", color || fallbackColor, ";" + ( true ? "" : 0),  true ? "" : 0);
};

var styles_ref =  true ? {
  name: "6g24ce",
  styles: "height:16px;width:16px"
} : 0;

const colorIndicatorWrapper = (border, __next36pxDefaultSize) => {
  const {
    style
  } = border || {};
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-radius:9999px;border:2px solid transparent;", style ? colorIndicatorBorder(border) : undefined, " width:", __next36pxDefaultSize ? '28px' : '22px', ";height:", __next36pxDefaultSize ? '28px' : '22px', ";padding:", __next36pxDefaultSize ? '2px' : '1px', ";&>span{", !__next36pxDefaultSize ? styles_ref : '', " background:linear-gradient(\n\t\t\t\t-45deg,\n\t\t\t\ttransparent 48%,\n\t\t\t\trgb( 0 0 0 / 20% ) 48%,\n\t\t\t\trgb( 0 0 0 / 20% ) 52%,\n\t\t\t\ttransparent 52%\n\t\t\t);}" + ( true ? "" : 0),  true ? "" : 0);
}; // Must equal $color-palette-circle-size from:
// @wordpress/components/src/circular-option-picker/style.scss

const swatchSize = 28;
const swatchGap = 12;
const borderControlPopoverControls = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("width:", swatchSize * 6 + swatchGap * 5, "px;>div:first-of-type>", StyledLabel, "{margin-bottom:0;", styles_labelStyles, ";}&& ", StyledLabel, "+button:not( .has-text ){min-width:24px;padding:0;}" + ( true ? "" : 0),  true ? "" : 0);
const borderControlPopoverContent = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)( true ? "" : 0,  true ? "" : 0);
const borderColorIndicator = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)( true ? "" : 0,  true ? "" : 0);
const resetButton = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("justify-content:center;width:100%;&&{border-top:", config_values.borderWidth, " solid ", COLORS.gray[200], ";border-top-left-radius:0;border-top-right-radius:0;height:46px;}" + ( true ? "" : 0),  true ? "" : 0);
const borderControlStylePicker = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)(StyledLabel, "{", styles_labelStyles, ";}" + ( true ? "" : 0),  true ? "" : 0);
const borderStyleButton =  true ? {
  name: "1486260",
  styles: "&&&&&{min-width:30px;width:30px;height:30px;padding:3px;}"
} : 0;
const borderSlider = () => /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("flex:1 1 60%;", rtl({
  marginRight: space(3)
})(), " ", StyledField, "{margin-bottom:0;font-size:0;display:flex;}" + ( true ? "" : 0),  true ? "" : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/border-control-style-picker/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function useBorderControlStylePicker(props) {
  const {
    className,
    ...otherProps
  } = useContextSystem(props, 'BorderControlStylePicker'); // Generate class names.

  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    return cx(borderControlStylePicker, className);
  }, [className, cx]);
  const buttonClassName = (0,react.useMemo)(() => {
    return cx(borderStyleButton);
  }, [cx]);
  return { ...otherProps,
    className: classes,
    buttonClassName
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/border-control-style-picker/component.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */








const BORDER_STYLES = [{
  label: (0,i18n_build_module.__)('Solid'),
  icon: line_solid,
  value: 'solid'
}, {
  label: (0,i18n_build_module.__)('Dashed'),
  icon: line_dashed,
  value: 'dashed'
}, {
  label: (0,i18n_build_module.__)('Dotted'),
  icon: line_dotted,
  value: 'dotted'
}];

const component_Label = props => {
  const {
    label,
    hideLabelFromVision
  } = props;

  if (!label) {
    return null;
  }

  return hideLabelFromVision ? (0,react.createElement)(visually_hidden_component, {
    as: "label"
  }, label) : (0,react.createElement)(StyledLabel, null, label);
};

const BorderControlStylePicker = (props, forwardedRef) => {
  const {
    buttonClassName,
    hideLabelFromVision,
    label,
    onChange,
    value,
    ...otherProps
  } = useBorderControlStylePicker(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, otherProps, {
    ref: forwardedRef
  }), (0,react.createElement)(component_Label, {
    label: label,
    hideLabelFromVision: hideLabelFromVision
  }), (0,react.createElement)(flex_component, {
    justify: "flex-start",
    gap: 1
  }, BORDER_STYLES.map(borderStyle => (0,react.createElement)(build_module_button, {
    key: borderStyle.value,
    className: buttonClassName,
    icon: borderStyle.icon,
    isSmall: true,
    isPressed: borderStyle.value === value,
    onClick: () => onChange(borderStyle.value === value ? undefined : borderStyle.value),
    "aria-label": borderStyle.label,
    label: borderStyle.label,
    showTooltip: true
  }))));
};

const ConnectedBorderControlStylePicker = contextConnect(BorderControlStylePicker, 'BorderControlStylePicker');
/* harmony default export */ const border_control_style_picker_component = (ConnectedBorderControlStylePicker);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-indicator/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function UnforwardedColorIndicator(props, forwardedRef) {
  const {
    className,
    colorValue,
    ...additionalProps
  } = props;
  return (0,react.createElement)("span", (0,helpers_esm_extends/* default */.A)({
    className: classnames_default()('component-color-indicator', className),
    style: {
      background: colorValue
    },
    ref: forwardedRef
  }, additionalProps));
}
/**
 * ColorIndicator is a React component that renders a specific color in a
 * circle. It's often used to summarize a collection of used colors in a child
 * component.
 *
 * ```jsx
 * import { ColorIndicator } from '@wordpress/components';
 *
 * const MyColorIndicator = () => <ColorIndicator colorValue="#0073aa" />;
 * ```
 */


const ColorIndicator = (0,react.forwardRef)(UnforwardedColorIndicator);
/* harmony default export */ const color_indicator = (ColorIndicator);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/styles.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */











const NumberControlWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(number_control,  true ? {
  target: "ez9hsf47"
} : 0)(Container, "{width:", space(24), ";}" + ( true ? "" : 0));
const styles_SelectControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(select_control,  true ? {
  target: "ez9hsf46"
} : 0)("margin-left:", space(-2), ";width:5em;", BackdropUI, "{display:none;}" + ( true ? "" : 0));
const styles_RangeControl = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(range_control,  true ? {
  target: "ez9hsf45"
} : 0)("flex:1;margin-right:", space(2), ";", StyledField, "{margin-bottom:0;}" + ( true ? "" : 0)); // Make the Hue circle picker not go out of the bar.

const interactiveHueStyles = `
.react-colorful__interactive {
	width: calc( 100% - ${space(2)} );
	margin-left: ${space(1)};
}`;
const AuxiliaryColorArtefactWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ez9hsf44"
} : 0)("padding-top:", space(2), ";padding-right:0;padding-left:0;padding-bottom:0;" + ( true ? "" : 0));
const AuxiliaryColorArtefactHStackHeader = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(h_stack_component,  true ? {
  target: "ez9hsf43"
} : 0)("padding-left:", space(4), ";padding-right:", space(4), ";" + ( true ? "" : 0));
const ColorInputWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "ez9hsf42"
} : 0)("padding-top:", space(4), ";padding-left:", space(4), ";padding-right:", space(3), ";padding-bottom:", space(5), ";" + ( true ? "" : 0));
const ColorfulWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "ez9hsf41"
} : 0)(boxSizingReset, ";width:216px;.react-colorful{display:flex;flex-direction:column;align-items:center;width:216px;height:auto;overflow:hidden;}.react-colorful__saturation{width:100%;border-radius:0;height:216px;margin-bottom:", space(4), ";border-bottom:none;}.react-colorful__hue,.react-colorful__alpha{width:184px;height:16px;border-radius:16px;margin-bottom:", space(2), ";}.react-colorful__pointer{height:16px;width:16px;border:none;box-shadow:0 0 2px 0 rgba( 0, 0, 0, 0.25 );outline:2px solid transparent;}.react-colorful__pointer-fill{box-shadow:inset 0 0 0 ", config_values.borderWidthFocus, " #fff;}", interactiveHueStyles, " ", StyledField, "{margin-bottom:0;}" + ( true ? "" : 0));
const CopyButton = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(build_module_button,  true ? {
  target: "ez9hsf40"
} : 0)("&&&&&{min-width:", space(6), ";padding:0;>svg{margin-right:0;}}" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-warning@0.6.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-warning/es/index.js + 1 modules
var es = __webpack_require__("../../node_modules/.pnpm/reakit-warning@0.6.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-warning/es/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useSealedState.js
var useSealedState = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useSealedState.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/shallowEqual.js
var shallowEqual = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/shallowEqual.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/dom.js
var dom = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/dom.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@popperjs+core@2.11.8/node_modules/@popperjs/core/lib/popper.js + 53 modules
var lib_popper = __webpack_require__("../../node_modules/.pnpm/@popperjs+core@2.11.8/node_modules/@popperjs/core/lib/popper.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Id/IdState.js
var IdState = __webpack_require__("../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Id/IdState.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Disclosure/DisclosureState.js








function useLastValue(value) {
  var lastValue = (0,react.useRef)(null);
  (0,useIsomorphicEffect/* useIsomorphicEffect */.o)(function () {
    lastValue.current = value;
  }, [value]);
  return lastValue;
}

function useDisclosureState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var _useSealedState = (0,useSealedState/* useSealedState */.N)(initialState),
      _useSealedState$visib = _useSealedState.visible,
      initialVisible = _useSealedState$visib === void 0 ? false : _useSealedState$visib,
      _useSealedState$anima = _useSealedState.animated,
      initialAnimated = _useSealedState$anima === void 0 ? false : _useSealedState$anima,
      sealed = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_useSealedState, ["visible", "animated"]);

  var id = (0,IdState/* unstable_useIdState */.t)(sealed);

  var _React$useState = (0,react.useState)(initialVisible),
      visible = _React$useState[0],
      setVisible = _React$useState[1];

  var _React$useState2 = (0,react.useState)(initialAnimated),
      animated = _React$useState2[0],
      setAnimated = _React$useState2[1];

  var _React$useState3 = (0,react.useState)(false),
      animating = _React$useState3[0],
      setAnimating = _React$useState3[1];

  var lastVisible = useLastValue(visible);
  var visibleHasChanged = lastVisible.current != null && lastVisible.current !== visible;

  if (animated && !animating && visibleHasChanged) {
    // Sets animating to true when when visible is updated
    setAnimating(true);
  }

  (0,react.useEffect)(function () {
    if (typeof animated === "number" && animating) {
      var timeout = setTimeout(function () {
        return setAnimating(false);
      }, animated);
      return function () {
        clearTimeout(timeout);
      };
    }

    if (animated && animating && "production" === "development") { var _timeout; }

    return function () {};
  }, [animated, animating]);
  var show = (0,react.useCallback)(function () {
    return setVisible(true);
  }, []);
  var hide = (0,react.useCallback)(function () {
    return setVisible(false);
  }, []);
  var toggle = (0,react.useCallback)(function () {
    return setVisible(function (v) {
      return !v;
    });
  }, []);
  var stopAnimation = (0,react.useCallback)(function () {
    return setAnimating(false);
  }, []);
  return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, id), {}, {
    visible: visible,
    animated: animated,
    animating: animating,
    show: show,
    hide: hide,
    toggle: toggle,
    setVisible: setVisible,
    setAnimated: setAnimated,
    stopAnimation: stopAnimation
  });
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Dialog/DialogState.js









function useDialogState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var _useSealedState = (0,useSealedState/* useSealedState */.N)(initialState),
      _useSealedState$modal = _useSealedState.modal,
      initialModal = _useSealedState$modal === void 0 ? true : _useSealedState$modal,
      sealed = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_useSealedState, ["modal"]);

  var disclosure = useDisclosureState(sealed);

  var _React$useState = (0,react.useState)(initialModal),
      modal = _React$useState[0],
      setModal = _React$useState[1];

  var disclosureRef = (0,react.useRef)(null);
  return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, disclosure), {}, {
    modal: modal,
    setModal: setModal,
    unstable_disclosureRef: disclosureRef
  });
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Popover/PopoverState.js













var isSafari = (0,dom/* isUA */.p)("Mac") && !(0,dom/* isUA */.p)("Chrome") && (0,dom/* isUA */.p)("Safari");

function applyStyles(styles) {
  return function (prevStyles) {
    if (styles && !(0,shallowEqual/* shallowEqual */.b)(prevStyles, styles)) {
      return styles;
    }

    return prevStyles;
  };
}

function usePopoverState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var _useSealedState = (0,useSealedState/* useSealedState */.N)(initialState),
      _useSealedState$gutte = _useSealedState.gutter,
      gutter = _useSealedState$gutte === void 0 ? 12 : _useSealedState$gutte,
      _useSealedState$place = _useSealedState.placement,
      sealedPlacement = _useSealedState$place === void 0 ? "bottom" : _useSealedState$place,
      _useSealedState$unsta = _useSealedState.unstable_flip,
      flip = _useSealedState$unsta === void 0 ? true : _useSealedState$unsta,
      sealedOffset = _useSealedState.unstable_offset,
      _useSealedState$unsta2 = _useSealedState.unstable_preventOverflow,
      preventOverflow = _useSealedState$unsta2 === void 0 ? true : _useSealedState$unsta2,
      _useSealedState$unsta3 = _useSealedState.unstable_fixed,
      fixed = _useSealedState$unsta3 === void 0 ? false : _useSealedState$unsta3,
      _useSealedState$modal = _useSealedState.modal,
      modal = _useSealedState$modal === void 0 ? false : _useSealedState$modal,
      sealed = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_useSealedState, ["gutter", "placement", "unstable_flip", "unstable_offset", "unstable_preventOverflow", "unstable_fixed", "modal"]);

  var popper = (0,react.useRef)(null);
  var referenceRef = (0,react.useRef)(null);
  var popoverRef = (0,react.useRef)(null);
  var arrowRef = (0,react.useRef)(null);

  var _React$useState = (0,react.useState)(sealedPlacement),
      originalPlacement = _React$useState[0],
      place = _React$useState[1];

  var _React$useState2 = (0,react.useState)(sealedPlacement),
      placement = _React$useState2[0],
      setPlacement = _React$useState2[1];

  var _React$useState3 = (0,react.useState)(sealedOffset || [0, gutter]),
      offset = _React$useState3[0];

  var _React$useState4 = (0,react.useState)({
    position: "fixed",
    left: "100%",
    top: "100%"
  }),
      popoverStyles = _React$useState4[0],
      setPopoverStyles = _React$useState4[1];

  var _React$useState5 = (0,react.useState)({}),
      arrowStyles = _React$useState5[0],
      setArrowStyles = _React$useState5[1];

  var dialog = useDialogState((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
    modal: modal
  }, sealed));
  var update = (0,react.useCallback)(function () {
    if (popper.current) {
      popper.current.forceUpdate();
      return true;
    }

    return false;
  }, []);
  var updateState = (0,react.useCallback)(function (state) {
    if (state.placement) {
      setPlacement(state.placement);
    }

    if (state.styles) {
      setPopoverStyles(applyStyles(state.styles.popper));

      if (arrowRef.current) {
        setArrowStyles(applyStyles(state.styles.arrow));
      }
    }
  }, []);
  (0,useIsomorphicEffect/* useIsomorphicEffect */.o)(function () {
    if (referenceRef.current && popoverRef.current) {
      popper.current = (0,lib_popper/* createPopper */.n4)(referenceRef.current, popoverRef.current, {
        // https://popper.js.org/docs/v2/constructors/#options
        placement: originalPlacement,
        strategy: fixed ? "fixed" : "absolute",
        // Safari needs styles to be applied in the first render, otherwise
        // hovering over the popover when it gets visible for the first time
        // will change its dimensions unexpectedly.
        onFirstUpdate: isSafari ? updateState : undefined,
        modifiers: [{
          // https://popper.js.org/docs/v2/modifiers/event-listeners/
          name: "eventListeners",
          enabled: dialog.visible
        }, {
          // https://popper.js.org/docs/v2/modifiers/apply-styles/
          name: "applyStyles",
          enabled: false
        }, {
          // https://popper.js.org/docs/v2/modifiers/flip/
          name: "flip",
          enabled: flip,
          options: {
            padding: 8
          }
        }, {
          // https://popper.js.org/docs/v2/modifiers/offset/
          name: "offset",
          options: {
            offset: offset
          }
        }, {
          // https://popper.js.org/docs/v2/modifiers/prevent-overflow/
          name: "preventOverflow",
          enabled: preventOverflow,
          options: {
            tetherOffset: function tetherOffset() {
              var _arrowRef$current;

              return ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.clientWidth) || 0;
            }
          }
        }, {
          // https://popper.js.org/docs/v2/modifiers/arrow/
          name: "arrow",
          enabled: !!arrowRef.current,
          options: {
            element: arrowRef.current
          }
        }, {
          // https://popper.js.org/docs/v2/modifiers/#custom-modifiers
          name: "updateState",
          phase: "write",
          requires: ["computeStyles"],
          enabled: dialog.visible && "production" !== "test",
          fn: function fn(_ref) {
            var state = _ref.state;
            return updateState(state);
          }
        }]
      });
    }

    return function () {
      if (popper.current) {
        popper.current.destroy();
        popper.current = null;
      }
    };
  }, [originalPlacement, fixed, dialog.visible, flip, offset, preventOverflow]); // Ensure that the popover will be correctly positioned with an additional
  // update.

  (0,react.useEffect)(function () {
    if (!dialog.visible) return undefined;
    var id = window.requestAnimationFrame(function () {
      var _popper$current;

      (_popper$current = popper.current) === null || _popper$current === void 0 ? void 0 : _popper$current.forceUpdate();
    });
    return function () {
      window.cancelAnimationFrame(id);
    };
  }, [dialog.visible]);
  return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, dialog), {}, {
    unstable_referenceRef: referenceRef,
    unstable_popoverRef: popoverRef,
    unstable_arrowRef: arrowRef,
    unstable_popoverStyles: popoverStyles,
    unstable_arrowStyles: arrowStyles,
    unstable_update: update,
    unstable_originalPlacement: originalPlacement,
    placement: placement,
    place: place
  });
}



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/__globalState-300469f0.js
var globalState = {
  currentTooltipId: null,
  listeners: new Set(),
  subscribe: function subscribe(listener) {
    var _this = this;

    this.listeners.add(listener);
    return function () {
      _this.listeners.delete(listener);
    };
  },
  show: function show(id) {
    this.currentTooltipId = id;
    this.listeners.forEach(function (listener) {
      return listener(id);
    });
  },
  hide: function hide(id) {
    if (this.currentTooltipId === id) {
      this.currentTooltipId = null;
      this.listeners.forEach(function (listener) {
        return listener(null);
      });
    }
  }
};



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Tooltip/TooltipState.js















function useTooltipState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var _useSealedState = (0,useSealedState/* useSealedState */.N)(initialState),
      _useSealedState$place = _useSealedState.placement,
      placement = _useSealedState$place === void 0 ? "top" : _useSealedState$place,
      _useSealedState$unsta = _useSealedState.unstable_timeout,
      initialTimeout = _useSealedState$unsta === void 0 ? 0 : _useSealedState$unsta,
      sealed = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_useSealedState, ["placement", "unstable_timeout"]);

  var _React$useState = (0,react.useState)(initialTimeout),
      timeout = _React$useState[0],
      setTimeout = _React$useState[1];

  var showTimeout = (0,react.useRef)(null);
  var hideTimeout = (0,react.useRef)(null);

  var _usePopoverState = usePopoverState((0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, sealed), {}, {
    placement: placement
  })),
      modal = _usePopoverState.modal,
      setModal = _usePopoverState.setModal,
      popover = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_usePopoverState, ["modal", "setModal"]);

  var clearTimeouts = (0,react.useCallback)(function () {
    if (showTimeout.current !== null) {
      window.clearTimeout(showTimeout.current);
    }

    if (hideTimeout.current !== null) {
      window.clearTimeout(hideTimeout.current);
    }
  }, []);
  var hide = (0,react.useCallback)(function () {
    clearTimeouts();
    popover.hide(); // Let's give some time so people can move from a reference to another
    // and still show tooltips immediately

    hideTimeout.current = window.setTimeout(function () {
      globalState.hide(popover.baseId);
    }, timeout);
  }, [clearTimeouts, popover.hide, timeout, popover.baseId]);
  var show = (0,react.useCallback)(function () {
    clearTimeouts();

    if (!timeout || globalState.currentTooltipId) {
      // If there's no timeout or a tooltip visible already, we can show this
      // immediately
      globalState.show(popover.baseId);
      popover.show();
    } else {
      // There may be a reference with focus whose tooltip is still not visible
      // In this case, we want to update it before it gets shown.
      globalState.show(null); // Otherwise, wait a little bit to show the tooltip

      showTimeout.current = window.setTimeout(function () {
        globalState.show(popover.baseId);
        popover.show();
      }, timeout);
    }
  }, [clearTimeouts, timeout, popover.show, popover.baseId]);
  (0,react.useEffect)(function () {
    return globalState.subscribe(function (id) {
      if (id !== popover.baseId) {
        clearTimeouts();

        if (popover.visible) {
          // Make sure there will be only one tooltip visible
          popover.hide();
        }
      }
    });
  }, [popover.baseId, clearTimeouts, popover.visible, popover.hide]);
  (0,react.useEffect)(function () {
    return function () {
      clearTimeouts();
      globalState.hide(popover.baseId);
    };
  }, [clearTimeouts, popover.baseId]);
  return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, popover), {}, {
    hide: hide,
    show: show,
    unstable_timeout: timeout,
    unstable_setTimeout: setTimeout
  });
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useLiveRef.js
var useLiveRef = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/useLiveRef.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/__keys-d101cb3b.js
// Automatically generated
var TOOLTIP_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation", "unstable_disclosureRef", "unstable_referenceRef", "unstable_popoverRef", "unstable_arrowRef", "unstable_popoverStyles", "unstable_arrowStyles", "unstable_originalPlacement", "unstable_update", "placement", "place", "unstable_timeout", "unstable_setTimeout"];
var TOOLTIP_KEYS = [].concat(TOOLTIP_STATE_KEYS, ["unstable_portal"]);
var TOOLTIP_ARROW_KEYS = TOOLTIP_STATE_KEYS;
var TOOLTIP_REFERENCE_KEYS = TOOLTIP_ARROW_KEYS;



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Tooltip/TooltipReference.js










var useTooltipReference = (0,createHook/* createHook */.a)({
  name: "TooltipReference",
  compose: Role/* useRole */.I,
  keys: TOOLTIP_REFERENCE_KEYS,
  useProps: function useProps(options, _ref) {
    var htmlRef = _ref.ref,
        htmlOnFocus = _ref.onFocus,
        htmlOnBlur = _ref.onBlur,
        htmlOnMouseEnter = _ref.onMouseEnter,
        htmlOnMouseLeave = _ref.onMouseLeave,
        htmlProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref, ["ref", "onFocus", "onBlur", "onMouseEnter", "onMouseLeave"]);

    var onFocusRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnFocus);
    var onBlurRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnBlur);
    var onMouseEnterRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnMouseEnter);
    var onMouseLeaveRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnMouseLeave);
    var onFocus = (0,react.useCallback)(function (event) {
      var _onFocusRef$current, _options$show;

      (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
      if (event.defaultPrevented) return;
      (_options$show = options.show) === null || _options$show === void 0 ? void 0 : _options$show.call(options);
    }, [options.show]);
    var onBlur = (0,react.useCallback)(function (event) {
      var _onBlurRef$current, _options$hide;

      (_onBlurRef$current = onBlurRef.current) === null || _onBlurRef$current === void 0 ? void 0 : _onBlurRef$current.call(onBlurRef, event);
      if (event.defaultPrevented) return;
      (_options$hide = options.hide) === null || _options$hide === void 0 ? void 0 : _options$hide.call(options);
    }, [options.hide]);
    var onMouseEnter = (0,react.useCallback)(function (event) {
      var _onMouseEnterRef$curr, _options$show2;

      (_onMouseEnterRef$curr = onMouseEnterRef.current) === null || _onMouseEnterRef$curr === void 0 ? void 0 : _onMouseEnterRef$curr.call(onMouseEnterRef, event);
      if (event.defaultPrevented) return;
      (_options$show2 = options.show) === null || _options$show2 === void 0 ? void 0 : _options$show2.call(options);
    }, [options.show]);
    var onMouseLeave = (0,react.useCallback)(function (event) {
      var _onMouseLeaveRef$curr, _options$hide2;

      (_onMouseLeaveRef$curr = onMouseLeaveRef.current) === null || _onMouseLeaveRef$curr === void 0 ? void 0 : _onMouseLeaveRef$curr.call(onMouseLeaveRef, event);
      if (event.defaultPrevented) return;
      (_options$hide2 = options.hide) === null || _options$hide2 === void 0 ? void 0 : _options$hide2.call(options);
    }, [options.hide]);
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      ref: (0,useForkRef/* useForkRef */.N)(options.unstable_referenceRef, htmlRef),
      tabIndex: 0,
      onFocus: onFocus,
      onBlur: onBlur,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      "aria-describedby": options.baseId
    }, htmlProps);
  }
});
var TooltipReference = (0,createComponent/* createComponent */.a)({
  as: "div",
  useHook: useTooltipReference
});



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/tooltip/context.js
/**
 * WordPress dependencies
 */

/**
 * @type {import('react').Context<{ tooltip?: import('reakit').TooltipState }>}
 */

const TooltipContext = (0,react.createContext)({});
const useTooltipContext = () => (0,react.useContext)(TooltipContext);
//# sourceMappingURL=context.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/getDocument.js
var getDocument = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/getDocument.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/isSelfTarget.js
var isSelfTarget = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/isSelfTarget.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/__keys-e6a5cfbe.js
// Automatically generated
var DISCLOSURE_STATE_KEYS = ["baseId", "unstable_idCountRef", "visible", "animated", "animating", "setBaseId", "show", "hide", "toggle", "setVisible", "setAnimated", "stopAnimation"];
var DISCLOSURE_KEYS = DISCLOSURE_STATE_KEYS;
var DISCLOSURE_CONTENT_KEYS = DISCLOSURE_KEYS;



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Disclosure/DisclosureContent.js










var useDisclosureContent = (0,createHook/* createHook */.a)({
  name: "DisclosureContent",
  compose: Role/* useRole */.I,
  keys: DISCLOSURE_CONTENT_KEYS,
  useProps: function useProps(options, _ref) {
    var htmlOnTransitionEnd = _ref.onTransitionEnd,
        htmlOnAnimationEnd = _ref.onAnimationEnd,
        htmlStyle = _ref.style,
        htmlProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref, ["onTransitionEnd", "onAnimationEnd", "style"]);

    var animating = options.animated && options.animating;

    var _React$useState = (0,react.useState)(null),
        transition = _React$useState[0],
        setTransition = _React$useState[1];

    var hidden = !options.visible && !animating;
    var style = hidden ? (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      display: "none"
    }, htmlStyle) : htmlStyle;
    var onTransitionEndRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnTransitionEnd);
    var onAnimationEndRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnAnimationEnd);
    var raf = (0,react.useRef)(0);
    (0,react.useEffect)(function () {
      if (!options.animated) return undefined; // Double RAF is needed so the browser has enough time to paint the
      // default styles before processing the `data-enter` attribute. Otherwise
      // it wouldn't be considered a transition.
      // See https://github.com/reakit/reakit/issues/643

      raf.current = window.requestAnimationFrame(function () {
        raf.current = window.requestAnimationFrame(function () {
          if (options.visible) {
            setTransition("enter");
          } else if (animating) {
            setTransition("leave");
          } else {
            setTransition(null);
          }
        });
      });
      return function () {
        return window.cancelAnimationFrame(raf.current);
      };
    }, [options.animated, options.visible, animating]);
    var onEnd = (0,react.useCallback)(function (event) {
      if (!(0,isSelfTarget/* isSelfTarget */.u)(event)) return;
      if (!animating) return; // Ignores number animated

      if (options.animated === true) {
        var _options$stopAnimatio;

        (_options$stopAnimatio = options.stopAnimation) === null || _options$stopAnimatio === void 0 ? void 0 : _options$stopAnimatio.call(options);
      }
    }, [options.animated, animating, options.stopAnimation]);
    var onTransitionEnd = (0,react.useCallback)(function (event) {
      var _onTransitionEndRef$c;

      (_onTransitionEndRef$c = onTransitionEndRef.current) === null || _onTransitionEndRef$c === void 0 ? void 0 : _onTransitionEndRef$c.call(onTransitionEndRef, event);
      onEnd(event);
    }, [onEnd]);
    var onAnimationEnd = (0,react.useCallback)(function (event) {
      var _onAnimationEndRef$cu;

      (_onAnimationEndRef$cu = onAnimationEndRef.current) === null || _onAnimationEndRef$cu === void 0 ? void 0 : _onAnimationEndRef$cu.call(onAnimationEndRef, event);
      onEnd(event);
    }, [onEnd]);
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      id: options.baseId,
      "data-enter": transition === "enter" ? "" : undefined,
      "data-leave": transition === "leave" ? "" : undefined,
      onTransitionEnd: onTransitionEnd,
      onAnimationEnd: onAnimationEnd,
      hidden: hidden,
      style: style
    }, htmlProps);
  }
});
var DisclosureContent = (0,createComponent/* createComponent */.a)({
  as: "div",
  useHook: useDisclosureContent
});



// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/canUseDOM.js
var canUseDOM = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/canUseDOM.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Portal/Portal.js





function getBodyElement() {
  return canUseDOM/* canUseDOM */.S ? document.body : null;
}

var PortalContext = /*#__PURE__*/(0,react.createContext)(getBodyElement());
function Portal(_ref) {
  var children = _ref.children;
  // if it's a nested portal, context is the parent portal
  // otherwise it's document.body
  // https://github.com/reakit/reakit/issues/513
  var context = (0,react.useContext)(PortalContext) || getBodyElement();

  var _React$useState = (0,react.useState)(function () {
    if (canUseDOM/* canUseDOM */.S) {
      var element = document.createElement("div");
      element.className = Portal.__className;
      return element;
    } // ssr


    return null;
  }),
      hostNode = _React$useState[0];

  (0,useIsomorphicEffect/* useIsomorphicEffect */.o)(function () {
    if (!hostNode || !context) return undefined;
    context.appendChild(hostNode);
    return function () {
      context.removeChild(hostNode);
    };
  }, [hostNode, context]);

  if (hostNode) {
    return /*#__PURE__*/(0,react_dom.createPortal)( /*#__PURE__*/(0,react.createElement)(PortalContext.Provider, {
      value: hostNode
    }, children), hostNode);
  } // ssr


  return null;
}
Portal.__className = "__reakit-portal";
Portal.__selector = "." + Portal.__className;



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Tooltip/Tooltip.js



















function globallyHideTooltipOnEscape(event) {
  if (event.defaultPrevented) return;

  if (event.key === "Escape") {
    globalState.show(null);
  }
}

var useTooltip = (0,createHook/* createHook */.a)({
  name: "Tooltip",
  compose: useDisclosureContent,
  keys: TOOLTIP_KEYS,
  useOptions: function useOptions(_ref) {
    var _ref$unstable_portal = _ref.unstable_portal,
        unstable_portal = _ref$unstable_portal === void 0 ? true : _ref$unstable_portal,
        options = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref, ["unstable_portal"]);

    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      unstable_portal: unstable_portal
    }, options);
  },
  useProps: function useProps(options, _ref2) {
    var htmlRef = _ref2.ref,
        htmlStyle = _ref2.style,
        htmlWrapElement = _ref2.wrapElement,
        htmlProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref2, ["ref", "style", "wrapElement"]);

    (0,react.useEffect)(function () {
      var _options$unstable_pop;

      var document = (0,getDocument/* getDocument */.Y)((_options$unstable_pop = options.unstable_popoverRef) === null || _options$unstable_pop === void 0 ? void 0 : _options$unstable_pop.current);
      document.addEventListener("keydown", globallyHideTooltipOnEscape);
    }, []);
    var wrapElement = (0,react.useCallback)(function (element) {
      if (options.unstable_portal) {
        element = /*#__PURE__*/(0,react.createElement)(Portal, null, element);
      }

      if (htmlWrapElement) {
        return htmlWrapElement(element);
      }

      return element;
    }, [options.unstable_portal, htmlWrapElement]);
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      ref: (0,useForkRef/* useForkRef */.N)(options.unstable_popoverRef, htmlRef),
      role: "tooltip",
      style: (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, options.unstable_popoverStyles), {}, {
        pointerEvents: "none"
      }, htmlStyle),
      wrapElement: wrapElement
    }, htmlProps);
  }
});
var Tooltip_Tooltip = (0,createComponent/* createComponent */.a)({
  as: "div",
  memo: true,
  useHook: useTooltip
});



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/shortcut/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function component_Shortcut(props, forwardedRef) {
  const {
    as: asProp = 'span',
    shortcut,
    className,
    ...otherProps
  } = useContextSystem(props, 'Shortcut');

  if (!shortcut) {
    return null;
  }

  let displayText;
  let ariaLabel;

  if (typeof shortcut === 'string') {
    displayText = shortcut;
  } else {
    displayText = shortcut.display;
    ariaLabel = shortcut.ariaLabel;
  }

  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({
    as: asProp,
    className: className,
    "aria-label": ariaLabel,
    ref: forwardedRef
  }, otherProps), displayText);
}

const ConnectedShortcut = contextConnect(component_Shortcut, 'Shortcut');
/* harmony default export */ const shortcut_component = (ConnectedShortcut);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/z-index.js
const Flyout = 10000;
const z_index_Tooltip = 1000002;
//# sourceMappingURL=z-index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/tooltip/styles.js


function tooltip_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */





const TooltipContent = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("z-index:", z_index_Tooltip, ";box-sizing:border-box;opacity:0;outline:none;transform-origin:top center;transition:opacity ", config_values.transitionDurationFastest, " ease;font-size:", config_values.fontSize, ";&[data-enter]{opacity:1;}" + ( true ? "" : 0),  true ? "" : 0);
const TooltipPopoverView = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e7tfjmw1"
} : 0)("background:rgba( 0, 0, 0, 0.8 );border-radius:2px;box-shadow:0 0 0 1px rgba( 255, 255, 255, 0.04 );color:", COLORS.white, ";padding:4px 8px;" + ( true ? "" : 0));
const noOutline =  true ? {
  name: "12mkfdx",
  styles: "outline:none"
} : 0;
const TooltipShortcut = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(shortcut_component,  true ? {
  target: "e7tfjmw0"
} : 0)("display:inline-block;margin-left:", space(1), ";" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/tooltip/content.js



/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports

/**
 * Internal dependencies
 */






const {
  TooltipPopoverView: content_TooltipPopoverView
} = tooltip_styles_namespaceObject;
/**
 *
 * @param {import('../context').WordPressComponentProps<import('./types').ContentProps, 'div'>} props
 * @param {import('react').ForwardedRef<any>}                                                   forwardedRef
 */

function content_TooltipContent(props, forwardedRef) {
  const {
    children,
    className,
    ...otherProps
  } = useContextSystem(props, 'TooltipContent');
  const {
    tooltip
  } = useTooltipContext();
  const cx = useCx();
  const classes = cx(TooltipContent, className);
  return (0,react.createElement)(Tooltip_Tooltip, (0,helpers_esm_extends/* default */.A)({
    as: component
  }, otherProps, tooltip, {
    className: classes,
    ref: forwardedRef
  }), (0,react.createElement)(content_TooltipPopoverView, null, children));
}

/* harmony default export */ const tooltip_content = (contextConnect(content_TooltipContent, 'TooltipContent'));
//# sourceMappingURL=content.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/ui/tooltip/component.js



/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





/**
 * @param {import('../context').WordPressComponentProps<import('./types').Props, 'div'>} props
 * @param {import('react').ForwardedRef<any>}                                            forwardedRef
 */

function component_Tooltip(props, forwardedRef) {
  const {
    animated = true,
    animationDuration = 160,
    baseId,
    children,
    content,
    focusable = true,
    gutter = 4,
    id,
    modal = true,
    placement,
    visible = false,
    shortcut,
    ...otherProps
  } = useContextSystem(props, 'Tooltip');
  const tooltip = useTooltipState({
    animated: animated ? animationDuration : undefined,
    baseId: baseId || id,
    gutter,
    placement,
    visible,
    ...otherProps
  });
  const contextProps = (0,react.useMemo)(() => ({
    tooltip
  }), [tooltip]);
  return (0,react.createElement)(TooltipContext.Provider, {
    value: contextProps
  }, content && (0,react.createElement)(tooltip_content, {
    unstable_portal: modal,
    ref: forwardedRef
  }, content, shortcut && (0,react.createElement)(TooltipShortcut, {
    shortcut: shortcut
  })), children && (0,react.createElement)(TooltipReference, (0,helpers_esm_extends/* default */.A)({}, tooltip, children.props, {
    // @ts-ignore If ref doesn't exist that's fine with us, it'll just be undefined, but it can exist on ReactElement and there's no reason to try to scope this (it'll just overcomplicate things)
    ref: children === null || children === void 0 ? void 0 : children.ref
  }), referenceProps => {
    if (!focusable) {
      referenceProps.tabIndex = undefined;
    }

    return (0,react.cloneElement)(children, referenceProps);
  }));
}
/**
 * `Tooltip` is a component that provides context for a user interface element.
 *
 * @example
 * ```jsx
 * import { Tooltip, Text } from `@wordpress/components/ui`;
 *
 * function Example() {
 * 	return (
 * 		<Tooltip content="Code is Poetry">
 * 			<Text>WordPress.org</Text>
 * 		</Tooltip>
 * 	)
 * }
 * ```
 */


const ConnectedTooltip = contextConnect(component_Tooltip, 'Tooltip');
/* harmony default export */ const tooltip_component = (ConnectedTooltip);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/color-copy-button.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




const ColorCopyButton = props => {
  const {
    color,
    colorType
  } = props;
  const [copiedColor, setCopiedColor] = (0,react.useState)(null);
  const copyTimer = (0,react.useRef)();
  const copyRef = useCopyToClipboard(() => {
    switch (colorType) {
      case 'hsl':
        {
          return color.toHslString();
        }

      case 'rgb':
        {
          return color.toRgbString();
        }

      default:
      case 'hex':
        {
          return color.toHex();
        }
    }
  }, () => {
    if (copyTimer.current) {
      clearTimeout(copyTimer.current);
    }

    setCopiedColor(color.toHex());
    copyTimer.current = setTimeout(() => {
      setCopiedColor(null);
      copyTimer.current = undefined;
    }, 3000);
  });
  (0,react.useEffect)(() => {
    // Clear copyTimer on component unmount.
    return () => {
      if (copyTimer.current) {
        clearTimeout(copyTimer.current);
      }
    };
  }, []);
  return (0,react.createElement)(tooltip_component, {
    content: (0,react.createElement)(text_component, {
      color: "white"
    }, copiedColor === color.toHex() ? (0,i18n_build_module.__)('Copied!') : (0,i18n_build_module.__)('Copy')),
    placement: "bottom"
  }, (0,react.createElement)(CopyButton, {
    isSmall: true,
    ref: copyRef,
    icon: library_copy,
    showTooltip: false
  }));
};
//# sourceMappingURL=color-copy-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/input-with-slider.js


/**
 * Internal dependencies
 */






const InputWithSlider = _ref => {
  let {
    min,
    max,
    label,
    abbreviation,
    onChange,
    value
  } = _ref;
  return (0,react.createElement)(h_stack_component, {
    spacing: 4
  }, (0,react.createElement)(NumberControlWrapper, {
    min: min,
    max: max,
    label: label,
    hideLabelFromVision: true,
    value: value,
    onChange: onChange,
    prefix: (0,react.createElement)(spacer_component, {
      as: text_component,
      paddingLeft: space(4),
      color: COLORS.ui.theme,
      lineHeight: 1
    }, abbreviation),
    hideHTMLArrows: true,
    size: "__unstable-large"
  }), (0,react.createElement)(styles_RangeControl, {
    label: label,
    hideLabelFromVision: true,
    min: min,
    max: max,
    value: value // @ts-expect-error
    // See: https://github.com/WordPress/gutenberg/pull/40535#issuecomment-1172418185
    ,
    onChange: onChange,
    withInputField: false
  }));
};
//# sourceMappingURL=input-with-slider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/rgb-input.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


const RgbInput = _ref => {
  let {
    color,
    onChange,
    enableAlpha
  } = _ref;
  const {
    r,
    g,
    b,
    a
  } = color.toRgb();
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 255,
    label: "Red",
    abbreviation: "R",
    value: r,
    onChange: nextR => onChange((0,node_modules_colord/* colord */.Mj)({
      r: nextR,
      g,
      b,
      a
    }))
  }), (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 255,
    label: "Green",
    abbreviation: "G",
    value: g,
    onChange: nextG => onChange((0,node_modules_colord/* colord */.Mj)({
      r,
      g: nextG,
      b,
      a
    }))
  }), (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 255,
    label: "Blue",
    abbreviation: "B",
    value: b,
    onChange: nextB => onChange((0,node_modules_colord/* colord */.Mj)({
      r,
      g,
      b: nextB,
      a
    }))
  }), enableAlpha && (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 100,
    label: "Alpha",
    abbreviation: "A",
    value: Math.trunc(a * 100),
    onChange: nextA => onChange((0,node_modules_colord/* colord */.Mj)({
      r,
      g,
      b,
      a: nextA / 100
    }))
  }));
};
//# sourceMappingURL=rgb-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/hsl-input.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


const HslInput = _ref => {
  let {
    color,
    onChange,
    enableAlpha
  } = _ref;
  const {
    h,
    s,
    l,
    a
  } = color.toHsl();
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 359,
    label: "Hue",
    abbreviation: "H",
    value: h,
    onChange: nextH => {
      onChange((0,node_modules_colord/* colord */.Mj)({
        h: nextH,
        s,
        l,
        a
      }));
    }
  }), (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 100,
    label: "Saturation",
    abbreviation: "S",
    value: s,
    onChange: nextS => {
      onChange((0,node_modules_colord/* colord */.Mj)({
        h,
        s: nextS,
        l,
        a
      }));
    }
  }), (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 100,
    label: "Lightness",
    abbreviation: "L",
    value: l,
    onChange: nextL => {
      onChange((0,node_modules_colord/* colord */.Mj)({
        h,
        s,
        l: nextL,
        a
      }));
    }
  }), enableAlpha && (0,react.createElement)(InputWithSlider, {
    min: 0,
    max: 100,
    label: "Alpha",
    abbreviation: "A",
    value: Math.trunc(100 * a),
    onChange: nextA => {
      onChange((0,node_modules_colord/* colord */.Mj)({
        h,
        s,
        l,
        a: nextA / 100
      }));
    }
  }));
};
//# sourceMappingURL=hsl-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/hex-input.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const HexInput = _ref => {
  let {
    color,
    onChange,
    enableAlpha
  } = _ref;

  const handleChange = nextValue => {
    if (!nextValue) return;
    const hexValue = nextValue.startsWith('#') ? nextValue : '#' + nextValue;
    onChange((0,node_modules_colord/* colord */.Mj)(hexValue));
  };

  const stateReducer = (state, action) => {
    var _action$payload, _action$payload$event, _state$value, _state$value2;

    const nativeEvent = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : (_action$payload$event = _action$payload.event) === null || _action$payload$event === void 0 ? void 0 : _action$payload$event.nativeEvent;

    if ('insertFromPaste' !== (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.inputType)) {
      return { ...state
      };
    }

    const value = (_state$value = state.value) !== null && _state$value !== void 0 && _state$value.startsWith('#') ? state.value.slice(1).toUpperCase() : (_state$value2 = state.value) === null || _state$value2 === void 0 ? void 0 : _state$value2.toUpperCase();
    return { ...state,
      value
    };
  };

  return (0,react.createElement)(InputControl, {
    prefix: (0,react.createElement)(spacer_component, {
      as: text_component,
      marginLeft: space(4),
      color: COLORS.ui.theme,
      lineHeight: 1
    }, "#"),
    value: color.toHex().slice(1).toUpperCase(),
    onChange: handleChange,
    maxLength: enableAlpha ? 9 : 7,
    label: (0,i18n_build_module.__)('Hex color'),
    hideLabelFromVision: true,
    size: "__unstable-large",
    __unstableStateReducer: stateReducer,
    __unstableInputWidth: "9em"
  });
};
//# sourceMappingURL=hex-input.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/color-input.js


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



const ColorInput = _ref => {
  let {
    colorType,
    color,
    onChange,
    enableAlpha
  } = _ref;
  const props = {
    color,
    onChange,
    enableAlpha
  };

  switch (colorType) {
    case 'hsl':
      return (0,react.createElement)(HslInput, props);

    case 'rgb':
      return (0,react.createElement)(RgbInput, props);

    default:
    case 'hex':
      return (0,react.createElement)(HexInput, props);
  }
};
//# sourceMappingURL=color-input.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-colorful/dist/index.mjs
var react_colorful_dist = __webpack_require__("../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-colorful/dist/index.mjs");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/picker.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


const Picker = _ref => {
  let {
    color,
    enableAlpha,
    onChange
  } = _ref;
  const Component = enableAlpha ? react_colorful_dist/* RgbaStringColorPicker */.p9 : react_colorful_dist/* RgbStringColorPicker */.gy;
  const rgbColor = (0,react.useMemo)(() => color.toRgbString(), [color]);
  return (0,react.createElement)(Component, {
    color: rgbColor,
    onChange: nextColor => {
      onChange((0,node_modules_colord/* colord */.Mj)(nextColor));
    }
  });
};
//# sourceMappingURL=picker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/utils/hooks/use-controlled-value.js
/**
 * WordPress dependencies
 */


/**
 * Simplified and improved implementation of useControlledState.
 *
 * @param  props
 * @param  props.defaultValue
 * @param  props.value
 * @param  props.onChange
 * @return The controlled value and the value setter.
 */
function useControlledValue(_ref) {
  let {
    defaultValue,
    onChange,
    value: valueProp
  } = _ref;
  const hasValue = typeof valueProp !== 'undefined';
  const initialValue = hasValue ? valueProp : defaultValue;
  const [state, setState] = (0,react.useState)(initialValue);
  const value = hasValue ? valueProp : state;
  let setValue;

  if (hasValue && typeof onChange === 'function') {
    setValue = onChange;
  } else if (!hasValue && typeof onChange === 'function') {
    setValue = nextValue => {
      onChange(nextValue);
      setState(nextValue);
    };
  } else {
    setValue = setState;
  }

  return [value, setValue];
}
//# sourceMappingURL=use-controlled-value.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/component.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */







(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
const options = [{
  label: 'RGB',
  value: 'rgb'
}, {
  label: 'HSL',
  value: 'hsl'
}, {
  label: 'Hex',
  value: 'hex'
}];

const ColorPicker = (props, forwardedRef) => {
  const {
    enableAlpha = false,
    color: colorProp,
    onChange,
    defaultValue = '#fff',
    copyFormat,
    ...divProps
  } = useContextSystem(props, 'ColorPicker'); // Use a safe default value for the color and remove the possibility of `undefined`.

  const [color, setColor] = useControlledValue({
    onChange,
    value: colorProp,
    defaultValue
  });
  const safeColordColor = (0,react.useMemo)(() => {
    return (0,node_modules_colord/* colord */.Mj)(color || '');
  }, [color]);
  const debouncedSetColor = (0,use_debounce/* default */.A)(setColor);
  const handleChange = (0,react.useCallback)(nextValue => {
    debouncedSetColor(nextValue.toHex());
  }, [debouncedSetColor]);
  const [colorType, setColorType] = (0,react.useState)(copyFormat || 'hex');
  return (0,react.createElement)(ColorfulWrapper, (0,helpers_esm_extends/* default */.A)({
    ref: forwardedRef
  }, divProps), (0,react.createElement)(Picker, {
    onChange: handleChange,
    color: safeColordColor,
    enableAlpha: enableAlpha
  }), (0,react.createElement)(AuxiliaryColorArtefactWrapper, null, (0,react.createElement)(AuxiliaryColorArtefactHStackHeader, {
    justify: "space-between"
  }, (0,react.createElement)(styles_SelectControl, {
    options: options,
    value: colorType,
    onChange: nextColorType => setColorType(nextColorType),
    label: (0,i18n_build_module.__)('Color format'),
    hideLabelFromVision: true
  }), (0,react.createElement)(ColorCopyButton, {
    color: safeColordColor,
    colorType: copyFormat || colorType
  })), (0,react.createElement)(ColorInputWrapper, {
    direction: "column",
    gap: 2
  }, (0,react.createElement)(ColorInput, {
    colorType: colorType,
    color: safeColordColor,
    onChange: handleChange,
    enableAlpha: enableAlpha
  }))));
};

const ConnectedColorPicker = contextConnect(ColorPicker, 'ColorPicker');
/* harmony default export */ const color_picker_component = (ConnectedColorPicker);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/use-deprecated-props.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

function isLegacyProps(props) {
  var _props$color;

  return typeof props.onChangeComplete !== 'undefined' || typeof props.disableAlpha !== 'undefined' || typeof ((_props$color = props.color) === null || _props$color === void 0 ? void 0 : _props$color.hex) === 'string';
}

function getColorFromLegacyProps(color) {
  if (color === undefined) return;
  if (typeof color === 'string') return color;
  if (color.hex) return color.hex;
  return undefined;
}

const transformColorStringToLegacyColor = memize_default()(color => {
  const colordColor = (0,node_modules_colord/* colord */.Mj)(color);
  const hex = colordColor.toHex();
  const rgb = colordColor.toRgb();
  const hsv = colordColor.toHsv();
  const hsl = colordColor.toHsl();
  return {
    hex,
    rgb,
    hsv,
    hsl,
    source: 'hex',
    oldHue: hsl.h
  };
});
function use_deprecated_props_useDeprecatedProps(props) {
  const {
    onChangeComplete
  } = props;
  const legacyChangeHandler = (0,react.useCallback)(color => {
    onChangeComplete(transformColorStringToLegacyColor(color));
  }, [onChangeComplete]);

  if (isLegacyProps(props)) {
    return {
      color: getColorFromLegacyProps(props.color),
      enableAlpha: !props.disableAlpha,
      onChange: legacyChangeHandler
    };
  }

  return { ...props,
    color: props.color,
    enableAlpha: props.enableAlpha,
    onChange: props.onChange
  };
}
//# sourceMappingURL=use-deprecated-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-picker/legacy-adapter.js


/**
 * Internal dependencies
 */


const LegacyAdapter = props => {
  return (0,react.createElement)(color_picker_component, use_deprecated_props_useDeprecatedProps(props));
};
//# sourceMappingURL=legacy-adapter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/circular-option-picker/index.js


// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function Option(_ref) {
  let {
    className,
    isSelected,
    selectedIconProps,
    tooltipText,
    ...additionalProps
  } = _ref;
  const optionButton = (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    isPressed: isSelected,
    className: "components-circular-option-picker__option"
  }, additionalProps));
  return (0,react.createElement)("div", {
    className: classnames_default()(className, 'components-circular-option-picker__option-wrapper')
  }, tooltipText ? (0,react.createElement)(tooltip, {
    text: tooltipText
  }, optionButton) : optionButton, isSelected && (0,react.createElement)(icon, (0,helpers_esm_extends/* default */.A)({
    icon: library_check
  }, selectedIconProps ? selectedIconProps : {})));
}

function DropdownLinkAction(_ref2) {
  let {
    buttonProps,
    className,
    dropdownProps,
    linkText
  } = _ref2;
  return (0,react.createElement)(Dropdown, (0,helpers_esm_extends/* default */.A)({
    className: classnames_default()('components-circular-option-picker__dropdown-link-action', className),
    renderToggle: _ref3 => {
      let {
        isOpen,
        onToggle
      } = _ref3;
      return (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
        "aria-expanded": isOpen,
        "aria-haspopup": "true",
        onClick: onToggle,
        variant: "link"
      }, buttonProps), linkText);
    }
  }, dropdownProps));
}

function ButtonAction(_ref4) {
  let {
    className,
    children,
    ...additionalProps
  } = _ref4;
  return (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    className: classnames_default()('components-circular-option-picker__clear', className),
    variant: "tertiary"
  }, additionalProps), children);
}

function CircularOptionPicker(_ref5) {
  let {
    actions,
    className,
    options,
    children
  } = _ref5;
  return (0,react.createElement)("div", {
    className: classnames_default()('components-circular-option-picker', className)
  }, (0,react.createElement)("div", {
    className: "components-circular-option-picker__swatches"
  }, options), children, actions && (0,react.createElement)("div", {
    className: "components-circular-option-picker__custom-clear-wrapper"
  }, actions));
}
CircularOptionPicker.Option = Option;
CircularOptionPicker.ButtonAction = ButtonAction;
CircularOptionPicker.DropdownLinkAction = DropdownLinkAction;
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/v-stack/hook.js
/**
 * Internal dependencies
 */


function useVStack(props) {
  const {
    expanded = false,
    ...otherProps
  } = useContextSystem(props, 'VStack');
  const hStackProps = useHStack({
    direction: 'column',
    expanded,
    ...otherProps
  });
  return hStackProps;
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/v-stack/component.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */




function UnconnectedVStack(props, forwardedRef) {
  const vStackProps = useVStack(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({}, vStackProps, {
    ref: forwardedRef
  }));
}
/**
 * `VStack` (or Vertical Stack) is a layout component that arranges child
 * elements in a vertical line.
 *
 * `VStack` can render anything inside.
 *
 * ```jsx
 * import {
 * 	__experimentalText as Text,
 * 	__experimentalVStack as VStack,
 * } from `@wordpress/components`;
 *
 * function Example() {
 * 	return (
 * 		<VStack>
 * 			<Text>Code</Text>
 * 			<Text>is</Text>
 * 			<Text>Poetry</Text>
 * 		</VStack>
 * 	);
 * }
 * ```
 */


const VStack = contextConnect(UnconnectedVStack, 'VStack');
/* harmony default export */ const v_stack_component = (VStack);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-palette/styles.js


function color_palette_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const ColorHeading = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(heading_component,  true ? {
  target: "e1uu5br00"
} : 0)( true ? {
  name: "13lxv2o",
  styles: "text-transform:uppercase;line-height:24px;font-weight:500;&&&{font-size:11px;margin-bottom:0;}"
} : 0);
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-palette/index.js


// @ts-nocheck

/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */








(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);

function SinglePalette(_ref) {
  let {
    className,
    clearColor,
    colors,
    onChange,
    value,
    actions
  } = _ref;
  const colorOptions = (0,react.useMemo)(() => {
    return colors.map((_ref2, index) => {
      let {
        color,
        name
      } = _ref2;
      const colordColor = (0,node_modules_colord/* colord */.Mj)(color);
      const isSelected = value === color;
      return (0,react.createElement)(CircularOptionPicker.Option, {
        key: `${color}-${index}`,
        isSelected: isSelected,
        selectedIconProps: isSelected ? {
          fill: colordColor.contrast() > colordColor.contrast('#000') ? '#fff' : '#000'
        } : {},
        tooltipText: name || // translators: %s: color hex code e.g: "#f00".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Color code: %s'), color),
        style: {
          backgroundColor: color,
          color
        },
        onClick: isSelected ? clearColor : () => onChange(color),
        "aria-label": name ? // translators: %s: The name of the color e.g: "vivid red".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Color: %s'), name) : // translators: %s: color hex code e.g: "#f00".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Color code: %s'), color)
      });
    });
  }, [colors, value, onChange, clearColor]);
  return (0,react.createElement)(CircularOptionPicker, {
    className: className,
    options: colorOptions,
    actions: actions
  });
}

function MultiplePalettes(_ref3) {
  let {
    className,
    clearColor,
    colors,
    onChange,
    value,
    actions
  } = _ref3;
  return (0,react.createElement)(v_stack_component, {
    spacing: 3,
    className: className
  }, colors.map((_ref4, index) => {
    let {
      name,
      colors: colorPalette
    } = _ref4;
    return (0,react.createElement)(v_stack_component, {
      spacing: 2,
      key: index
    }, (0,react.createElement)(ColorHeading, null, name), (0,react.createElement)(SinglePalette, {
      clearColor: clearColor,
      colors: colorPalette,
      onChange: onChange,
      value: value,
      actions: colors.length === index + 1 ? actions : null
    }));
  }));
}

function CustomColorPickerDropdown(_ref5) {
  let {
    isRenderedInSidebar,
    popoverProps: receivedPopoverProps,
    ...props
  } = _ref5;
  const popoverProps = (0,react.useMemo)(() => ({
    __unstableShift: true,
    ...(isRenderedInSidebar ? {
      // When in the sidebar: open to the left (stacking),
      // leaving the same gap as the parent popover.
      placement: 'left-start',
      offset: 34
    } : {
      // Default behavior: open below the anchor
      placement: 'bottom',
      offset: 8
    }),
    ...receivedPopoverProps
  }), [isRenderedInSidebar, receivedPopoverProps]);
  return (0,react.createElement)(Dropdown, (0,helpers_esm_extends/* default */.A)({
    contentClassName: "components-color-palette__custom-color-dropdown-content",
    popoverProps: popoverProps
  }, props));
}
const extractColorNameFromCurrentValue = function (currentValue) {
  let colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let showMultiplePalettes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!currentValue) {
    return '';
  }

  const currentValueIsCssVariable = /^var\(/.test(currentValue);
  const normalizedCurrentValue = currentValueIsCssVariable ? currentValue : (0,node_modules_colord/* colord */.Mj)(currentValue).toHex(); // Normalize format of `colors` to simplify the following loop

  const colorPalettes = showMultiplePalettes ? colors : [{
    colors
  }];

  for (const {
    colors: paletteColors
  } of colorPalettes) {
    for (const {
      name: colorName,
      color: colorValue
    } of paletteColors) {
      const normalizedColorValue = currentValueIsCssVariable ? colorValue : (0,node_modules_colord/* colord */.Mj)(colorValue).toHex();

      if (normalizedCurrentValue === normalizedColorValue) {
        return colorName;
      }
    }
  } // translators: shown when the user has picked a custom color (i.e not in the palette of colors).


  return (0,i18n_build_module.__)('Custom');
};
const showTransparentBackground = currentValue => {
  if (typeof currentValue === 'undefined') {
    return true;
  }

  return (0,node_modules_colord/* colord */.Mj)(currentValue).alpha() === 0;
};
function ColorPalette(_ref6) {
  let {
    clearable = true,
    className,
    colors,
    disableCustomColors = false,
    enableAlpha,
    onChange,
    value,
    __experimentalHasMultipleOrigins = false,
    __experimentalIsRenderedInSidebar = false
  } = _ref6;
  const clearColor = (0,react.useCallback)(() => onChange(undefined), [onChange]);
  const showMultiplePalettes = __experimentalHasMultipleOrigins && (colors === null || colors === void 0 ? void 0 : colors.length);
  const Component = showMultiplePalettes ? MultiplePalettes : SinglePalette;

  const renderCustomColorPicker = () => (0,react.createElement)(LegacyAdapter, {
    color: value,
    onChange: color => onChange(color),
    enableAlpha: enableAlpha
  });

  const colordColor = (0,node_modules_colord/* colord */.Mj)(value);
  const valueWithoutLeadingHash = value !== null && value !== void 0 && value.startsWith('#') ? value.substring(1) : value !== null && value !== void 0 ? value : '';
  const buttonLabelName = (0,react.useMemo)(() => extractColorNameFromCurrentValue(value, colors, showMultiplePalettes), [value, colors, showMultiplePalettes]);
  const customColorAccessibleLabel = !!valueWithoutLeadingHash ? (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The name of the color e.g: "vivid red". %2$s: The color's hex code e.g: "#f00".
  (0,i18n_build_module.__)('Custom color picker. The currently selected color is called "%1$s" and has a value of "%2$s".'), buttonLabelName, valueWithoutLeadingHash) : (0,i18n_build_module.__)('Custom color picker.');
  return (0,react.createElement)(v_stack_component, {
    spacing: 3,
    className: className
  }, !disableCustomColors && (0,react.createElement)(CustomColorPickerDropdown, {
    isRenderedInSidebar: __experimentalIsRenderedInSidebar,
    renderContent: renderCustomColorPicker,
    renderToggle: _ref7 => {
      let {
        isOpen,
        onToggle
      } = _ref7;
      return (0,react.createElement)(flex_component, {
        as: 'button',
        justify: "space-between",
        align: "flex-start",
        className: "components-color-palette__custom-color",
        "aria-expanded": isOpen,
        "aria-haspopup": "true",
        onClick: onToggle,
        "aria-label": customColorAccessibleLabel,
        style: showTransparentBackground(value) ? {
          color: '#000'
        } : {
          background: value,
          color: colordColor.contrast() > colordColor.contrast('#000') ? '#fff' : '#000'
        }
      }, (0,react.createElement)(flex_item_component, {
        isBlock: true,
        as: truncate_component,
        className: "components-color-palette__custom-color-name"
      }, buttonLabelName), (0,react.createElement)(flex_item_component, {
        as: "span",
        className: "components-color-palette__custom-color-value"
      }, valueWithoutLeadingHash));
    }
  }), (0,react.createElement)(Component, {
    clearable: clearable,
    clearColor: clearColor,
    colors: colors,
    onChange: onChange,
    value: value,
    actions: !!clearable && (0,react.createElement)(CircularOptionPicker.ButtonAction, {
      onClick: clearColor
    }, (0,i18n_build_module.__)('Clear'))
  }));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/border-control-dropdown/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





function useBorderControlDropdown(props) {
  const {
    border,
    className,
    colors,
    onChange,
    previousStyleSelection,
    __next36pxDefaultSize,
    ...otherProps
  } = useContextSystem(props, 'BorderControlDropdown');
  const [widthValue] = parseQuantityAndUnitFromRawValue(border === null || border === void 0 ? void 0 : border.width);
  const hasZeroWidth = widthValue === 0;

  const onColorChange = color => {
    const style = (border === null || border === void 0 ? void 0 : border.style) === 'none' ? previousStyleSelection : border === null || border === void 0 ? void 0 : border.style;
    const width = hasZeroWidth && !!color ? '1px' : border === null || border === void 0 ? void 0 : border.width;
    onChange({
      color,
      style,
      width
    });
  };

  const onStyleChange = style => {
    const width = hasZeroWidth && !!style ? '1px' : border === null || border === void 0 ? void 0 : border.width;
    onChange({ ...border,
      style,
      width
    });
  };

  const onReset = () => {
    onChange({ ...border,
      color: undefined,
      style: undefined
    });
  }; // Generate class names.


  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    return cx(borderControlDropdown(), className);
  }, [className, cx]);
  const indicatorClassName = (0,react.useMemo)(() => {
    return cx(borderColorIndicator);
  }, [cx]);
  const indicatorWrapperClassName = (0,react.useMemo)(() => {
    return cx(colorIndicatorWrapper(border, __next36pxDefaultSize));
  }, [border, cx, __next36pxDefaultSize]);
  const popoverControlsClassName = (0,react.useMemo)(() => {
    return cx(borderControlPopoverControls);
  }, [cx]);
  const popoverContentClassName = (0,react.useMemo)(() => {
    return cx(borderControlPopoverContent);
  }, [cx]);
  const resetButtonClassName = (0,react.useMemo)(() => {
    return cx(resetButton);
  }, [cx]);
  return { ...otherProps,
    border,
    className: classes,
    colors,
    indicatorClassName,
    indicatorWrapperClassName,
    onColorChange,
    onStyleChange,
    onReset,
    popoverContentClassName,
    popoverControlsClassName,
    resetButtonClassName
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/dropdown/styles.js


/**
 * External dependencies
 */


/**
 * Internal dependencies
 */


const styles_padding = _ref => {
  let {
    paddingSize = 'small'
  } = _ref;
  if (paddingSize === 'none') return;
  const paddingValues = {
    small: space(2),
    medium: space(4)
  };
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("padding:", paddingValues[paddingSize] || paddingValues.small, ";" + ( true ? "" : 0),  true ? "" : 0);
};

const DropdownContentWrapperDiv = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eovvns30"
} : 0)("margin-left:", space(-2), ";margin-right:", space(-2), ";&:first-of-type{margin-top:", space(-2), ";}&:last-of-type{margin-bottom:", space(-2), ";}", styles_padding, ";" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/dropdown/dropdown-content-wrapper.js



/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function UnconnectedDropdownContentWrapper(props, forwardedRef) {
  const {
    paddingSize = 'small',
    ...derivedProps
  } = useContextSystem(props, 'DropdownContentWrapper');
  return (0,react.createElement)(DropdownContentWrapperDiv, (0,helpers_esm_extends/* default */.A)({}, derivedProps, {
    paddingSize: paddingSize,
    ref: forwardedRef
  }));
}
/**
 * A convenience wrapper for the `renderContent` when you want to apply
 * different padding. (Default is `paddingSize="small"`).
 *
 * ```jsx
 * import {
 *   Dropdown,
 *   __experimentalDropdownContentWrapper as DropdownContentWrapper,
 * } from '@wordpress/components';
 *
 * <Dropdown
 *   renderContent={ () => (
 *     <DropdownContentWrapper paddingSize="medium">
 *       My dropdown content
 *     </DropdownContentWrapper>
 * ) }
 * />
 * ```
 */


const DropdownContentWrapper = contextConnect(UnconnectedDropdownContentWrapper, 'DropdownContentWrapper');
/* harmony default export */ const dropdown_content_wrapper = (DropdownContentWrapper);
//# sourceMappingURL=dropdown-content-wrapper.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/border-control-dropdown/component.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */













const component_noop = () => undefined;

const getColorObject = (colorValue, colors, hasMultipleColorOrigins) => {
  if (!colorValue || !colors) {
    return;
  }

  if (hasMultipleColorOrigins) {
    let matchedColor;
    colors.some(origin => origin.colors.some(color => {
      if (color.color === colorValue) {
        matchedColor = color;
        return true;
      }

      return false;
    }));
    return matchedColor;
  }

  return colors.find(color => color.color === colorValue);
};

const getToggleAriaLabel = (colorValue, colorObject, style, isStyleEnabled) => {
  if (isStyleEnabled) {
    if (colorObject) {
      return style ? (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The name of the color e.g. "vivid red". %2$s: The color's hex code e.g.: "#f00:". %3$s: The current border style selection e.g. "solid".
      'Border color and style picker. The currently selected color is called "%1$s" and has a value of "%2$s". The currently selected style is "%3$s".', colorObject.name, colorObject.color, style) : (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The name of the color e.g. "vivid red". %2$s: The color's hex code e.g.: "#f00:".
      'Border color and style picker. The currently selected color is called "%1$s" and has a value of "%2$s".', colorObject.name, colorObject.color);
    }

    if (colorValue) {
      return style ? (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The color's hex code e.g.: "#f00:". %2$s: The current border style selection e.g. "solid".
      'Border color and style picker. The currently selected color has a value of "%1$s". The currently selected style is "%2$s".', colorValue, style) : (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The color's hex code e.g.: "#f00:".
      'Border color and style picker. The currently selected color has a value of "%1$s".', colorValue);
    }

    return (0,i18n_build_module.__)('Border color and style picker.');
  }

  if (colorObject) {
    return (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The name of the color e.g. "vivid red". %2$s: The color's hex code e.g.: "#f00:".
    'Border color picker. The currently selected color is called "%1$s" and has a value of "%2$s".', colorObject.name, colorObject.color);
  }

  if (colorValue) {
    return (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: The color's hex code e.g.: "#f00:".
    'Border color picker. The currently selected color has a value of "%1$s".', colorValue);
  }

  return (0,i18n_build_module.__)('Border color picker.');
};

const BorderControlDropdown = (props, forwardedRef) => {
  const {
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    border,
    colors,
    disableCustomColors,
    enableAlpha,
    indicatorClassName,
    indicatorWrapperClassName,
    onReset,
    onColorChange,
    onStyleChange,
    popoverContentClassName,
    popoverControlsClassName,
    resetButtonClassName,
    showDropdownHeader,
    enableStyle = true,
    __unstablePopoverProps,
    ...otherProps
  } = useBorderControlDropdown(props);
  const {
    color,
    style
  } = border || {};
  const colorObject = getColorObject(color, colors, !!__experimentalHasMultipleOrigins);
  const toggleAriaLabel = getToggleAriaLabel(color, colorObject, style, enableStyle);
  const showResetButton = color || style && style !== 'none';
  const dropdownPosition = __experimentalIsRenderedInSidebar ? 'bottom left' : undefined;

  const renderToggle = _ref => {
    let {
      onToggle = component_noop
    } = _ref;
    return (0,react.createElement)(build_module_button, {
      onClick: onToggle,
      variant: "tertiary",
      "aria-label": toggleAriaLabel,
      position: dropdownPosition,
      label: (0,i18n_build_module.__)('Border color and style picker'),
      showTooltip: true
    }, (0,react.createElement)("span", {
      className: indicatorWrapperClassName
    }, (0,react.createElement)(color_indicator, {
      className: indicatorClassName,
      colorValue: color
    })));
  };

  const renderContent = _ref2 => {
    let {
      onClose
    } = _ref2;
    return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(dropdown_content_wrapper, {
      paddingSize: "medium"
    }, (0,react.createElement)(v_stack_component, {
      className: popoverControlsClassName,
      spacing: 6
    }, showDropdownHeader ? (0,react.createElement)(h_stack_component, null, (0,react.createElement)(StyledLabel, null, (0,i18n_build_module.__)('Border color')), (0,react.createElement)(build_module_button, {
      isSmall: true,
      label: (0,i18n_build_module.__)('Close border color'),
      icon: close_small,
      onClick: onClose
    })) : undefined, (0,react.createElement)(ColorPalette, {
      className: popoverContentClassName,
      value: color,
      onChange: onColorChange,
      colors,
      disableCustomColors,
      __experimentalHasMultipleOrigins: __experimentalHasMultipleOrigins,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: false,
      enableAlpha: enableAlpha
    }), enableStyle && (0,react.createElement)(border_control_style_picker_component, {
      label: (0,i18n_build_module.__)('Style'),
      value: style,
      onChange: onStyleChange
    }))), showResetButton && (0,react.createElement)(dropdown_content_wrapper, {
      paddingSize: "none"
    }, (0,react.createElement)(build_module_button, {
      className: resetButtonClassName,
      variant: "tertiary",
      onClick: () => {
        onReset();
        onClose();
      }
    }, (0,i18n_build_module.__)('Reset to default'))));
  };

  return (0,react.createElement)(Dropdown, (0,helpers_esm_extends/* default */.A)({
    renderToggle: renderToggle,
    renderContent: renderContent,
    popoverProps: { ...__unstablePopoverProps
    }
  }, otherProps, {
    ref: forwardedRef
  }));
};

const ConnectedBorderControlDropdown = contextConnect(BorderControlDropdown, 'BorderControlDropdown');
/* harmony default export */ const border_control_dropdown_component = (ConnectedBorderControlDropdown);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/border-control/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






const sanitizeBorder = border => {
  const hasNoWidth = (border === null || border === void 0 ? void 0 : border.width) === undefined || border.width === '';
  const hasNoColor = (border === null || border === void 0 ? void 0 : border.color) === undefined; // If width and color are undefined, unset any style selection as well.

  if (hasNoWidth && hasNoColor) {
    return undefined;
  }

  return border;
};

function useBorderControl(props) {
  const {
    className,
    isCompact,
    onChange,
    shouldSanitizeBorder = true,
    value: border,
    width,
    __next36pxDefaultSize = false,
    ...otherProps
  } = useContextSystem(props, 'BorderControl');
  const [widthValue, originalWidthUnit] = parseQuantityAndUnitFromRawValue(border === null || border === void 0 ? void 0 : border.width);
  const widthUnit = originalWidthUnit || 'px';
  const hadPreviousZeroWidth = widthValue === 0;
  const [colorSelection, setColorSelection] = (0,react.useState)();
  const [styleSelection, setStyleSelection] = (0,react.useState)();
  const onBorderChange = (0,react.useCallback)(newBorder => {
    if (shouldSanitizeBorder) {
      return onChange(sanitizeBorder(newBorder));
    }

    onChange(newBorder);
  }, [onChange, shouldSanitizeBorder]);
  const onWidthChange = (0,react.useCallback)(newWidth => {
    const newWidthValue = newWidth === '' ? undefined : newWidth;
    const [parsedValue] = parseQuantityAndUnitFromRawValue(newWidth);
    const hasZeroWidth = parsedValue === 0;
    const updatedBorder = { ...border,
      width: newWidthValue
    }; // Setting the border width explicitly to zero will also set the
    // border style to `none` and clear the border color.

    if (hasZeroWidth && !hadPreviousZeroWidth) {
      // Before clearing the color and style selections, keep track of
      // the current selections so they can be restored when the width
      // changes to a non-zero value.
      setColorSelection(border === null || border === void 0 ? void 0 : border.color);
      setStyleSelection(border === null || border === void 0 ? void 0 : border.style); // Clear the color and style border properties.

      updatedBorder.color = undefined;
      updatedBorder.style = 'none';
    } // Selection has changed from zero border width to non-zero width.


    if (!hasZeroWidth && hadPreviousZeroWidth) {
      // Restore previous border color and style selections if width
      // is now not zero.
      if (updatedBorder.color === undefined) {
        updatedBorder.color = colorSelection;
      }

      if (updatedBorder.style === 'none') {
        updatedBorder.style = styleSelection;
      }
    }

    onBorderChange(updatedBorder);
  }, [border, hadPreviousZeroWidth, colorSelection, styleSelection, onBorderChange]);
  const onSliderChange = (0,react.useCallback)(value => {
    onWidthChange(`${value}${widthUnit}`);
  }, [onWidthChange, widthUnit]); // Generate class names.

  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    return cx(borderControl, className);
  }, [className, cx]);
  const wrapperWidth = isCompact ? '90px' : width;
  const innerWrapperClassName = (0,react.useMemo)(() => {
    const widthStyle = !!wrapperWidth && styles_wrapperWidth;
    const heightStyle = wrapperHeight(__next36pxDefaultSize);
    return cx(innerWrapper(), widthStyle, heightStyle);
  }, [wrapperWidth, cx, __next36pxDefaultSize]);
  const sliderClassName = (0,react.useMemo)(() => {
    return cx(borderSlider());
  }, [cx]);
  return { ...otherProps,
    className: classes,
    innerWrapperClassName,
    inputWidth: wrapperWidth,
    onBorderChange,
    onSliderChange,
    onWidthChange,
    previousStyleSelection: styleSelection,
    sliderClassName,
    value: border,
    widthUnit,
    widthValue,
    __next36pxDefaultSize
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-control/border-control/component.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */











const BorderLabel = props => {
  const {
    label,
    hideLabelFromVision
  } = props;

  if (!label) {
    return null;
  }

  return hideLabelFromVision ? (0,react.createElement)(visually_hidden_component, {
    as: "legend"
  }, label) : (0,react.createElement)(StyledLabel, {
    as: "legend"
  }, label);
};

const UnconnectedBorderControl = (props, forwardedRef) => {
  const {
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle = true,
    hideLabelFromVision,
    innerWrapperClassName,
    inputWidth,
    label,
    onBorderChange,
    onSliderChange,
    onWidthChange,
    placeholder,
    __unstablePopoverProps,
    previousStyleSelection,
    showDropdownHeader,
    sliderClassName,
    value: border,
    widthUnit,
    widthValue,
    withSlider,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    __next36pxDefaultSize,
    ...otherProps
  } = useBorderControl(props);
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({
    as: "fieldset"
  }, otherProps, {
    ref: forwardedRef
  }), (0,react.createElement)(BorderLabel, {
    label: label,
    hideLabelFromVision: hideLabelFromVision
  }), (0,react.createElement)(h_stack_component, {
    spacing: 3,
    className: innerWrapperClassName
  }, (0,react.createElement)(unit_control, {
    prefix: (0,react.createElement)(border_control_dropdown_component, {
      border: border,
      colors: colors,
      __unstablePopoverProps: __unstablePopoverProps,
      disableCustomColors: disableCustomColors,
      enableAlpha: enableAlpha,
      enableStyle: enableStyle,
      onChange: onBorderChange,
      previousStyleSelection: previousStyleSelection,
      showDropdownHeader: showDropdownHeader,
      __experimentalHasMultipleOrigins: __experimentalHasMultipleOrigins,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      __next36pxDefaultSize: __next36pxDefaultSize
    }),
    label: (0,i18n_build_module.__)('Border width'),
    hideLabelFromVision: true,
    min: 0,
    onChange: onWidthChange,
    value: (border === null || border === void 0 ? void 0 : border.width) || '',
    placeholder: placeholder,
    __unstableInputWidth: inputWidth
  }), withSlider && (0,react.createElement)(range_control, {
    label: (0,i18n_build_module.__)('Border width'),
    hideLabelFromVision: true,
    className: sliderClassName,
    initialPosition: 0,
    max: 100,
    min: 0,
    onChange: onSliderChange,
    step: ['px', '%'].includes(widthUnit) ? 1 : 0.1,
    value: widthValue || undefined,
    withInputField: false
  })));
};
/**
 * The `BorderControl` brings together internal sub-components which allow users to
 * set the various properties of a border. The first sub-component, a
 * `BorderDropdown` contains options representing border color and style. The
 * border width is controlled via a `UnitControl` and an optional `RangeControl`.
 *
 * Border radius is not covered by this control as it may be desired separate to
 * color, style, and width. For example, the border radius may be absorbed under
 * a "shape" abstraction.
 *
 * ```jsx
 * import { __experimentalBorderControl as BorderControl } from '@wordpress/components';
 * import { __ } from '@wordpress/i18n';
 *
 * const colors = [
 * 	{ name: 'Blue 20', color: '#72aee6' },
 * 	// ...
 * ];
 *
 * const MyBorderControl = () => {
 * 	const [ border, setBorder ] = useState();
 * 	const onChange = ( newBorder ) => setBorder( newBorder );
 *
 * 	return (
 * 		<BorderControl
 * 			colors={ colors }
 * 			label={ __( 'Border' ) }
 * 			onChange={ onChange }
 * 			value={ border }
 * 		/>
 * 	);
 * };
 * ```
 */


const BorderControl = contextConnect(UnconnectedBorderControl, 'BorderControl');
/* harmony default export */ const border_control_component = (BorderControl);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-split-controls/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




function useBorderBoxControlSplitControls(props) {
  const {
    className,
    ...otherProps
  } = useContextSystem(props, 'BorderBoxControlSplitControls'); // Generate class names.

  const cx = useCx();
  const rtlWatchResult = rtl.watch();
  const classes = (0,react.useMemo)(() => {
    return cx(borderBoxControlSplitControls(), className); // rtlWatchResult is needed to refresh styles when the writing direction changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cx, className, rtlWatchResult]);
  const centeredClassName = (0,react.useMemo)(() => {
    return cx(CenteredBorderControl, className);
  }, [cx, className]);
  const rightAlignedClassName = (0,react.useMemo)(() => {
    return cx(rightBorderControl(), className); // rtlWatchResult is needed to refresh styles when the writing direction changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cx, className, rtlWatchResult]);
  return { ...otherProps,
    centeredClassName,
    className: classes,
    rightAlignedClassName
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control-split-controls/component.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







const BorderBoxControlSplitControls = (props, forwardedRef) => {
  const {
    centeredClassName,
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle,
    onChange,
    popoverPlacement,
    popoverOffset,
    rightAlignedClassName,
    value,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    __next36pxDefaultSize,
    ...otherProps
  } = useBorderBoxControlSplitControls(props);
  const containerRef = (0,react.useRef)();
  const mergedRef = (0,use_merge_refs/* default */.A)([containerRef, forwardedRef]);
  const popoverProps = popoverPlacement ? {
    placement: popoverPlacement,
    offset: popoverOffset,
    anchorRef: containerRef,
    __unstableShift: true
  } : undefined;
  const sharedBorderControlProps = {
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle,
    isCompact: true,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    __next36pxDefaultSize
  };
  return (0,react.createElement)(grid_component, (0,helpers_esm_extends/* default */.A)({}, otherProps, {
    ref: mergedRef,
    gap: 4
  }), (0,react.createElement)(border_box_control_visualizer_component, {
    value: value,
    __next36pxDefaultSize: __next36pxDefaultSize
  }), (0,react.createElement)(border_control_component, (0,helpers_esm_extends/* default */.A)({
    className: centeredClassName,
    hideLabelFromVision: true,
    label: (0,i18n_build_module.__)('Top border'),
    onChange: newBorder => onChange(newBorder, 'top'),
    __unstablePopoverProps: popoverProps,
    value: value === null || value === void 0 ? void 0 : value.top
  }, sharedBorderControlProps)), (0,react.createElement)(border_control_component, (0,helpers_esm_extends/* default */.A)({
    hideLabelFromVision: true,
    label: (0,i18n_build_module.__)('Left border'),
    onChange: newBorder => onChange(newBorder, 'left'),
    __unstablePopoverProps: popoverProps,
    value: value === null || value === void 0 ? void 0 : value.left
  }, sharedBorderControlProps)), (0,react.createElement)(border_control_component, (0,helpers_esm_extends/* default */.A)({
    className: rightAlignedClassName,
    hideLabelFromVision: true,
    label: (0,i18n_build_module.__)('Right border'),
    onChange: newBorder => onChange(newBorder, 'right'),
    __unstablePopoverProps: popoverProps,
    value: value === null || value === void 0 ? void 0 : value.right
  }, sharedBorderControlProps)), (0,react.createElement)(border_control_component, (0,helpers_esm_extends/* default */.A)({
    className: centeredClassName,
    hideLabelFromVision: true,
    label: (0,i18n_build_module.__)('Bottom border'),
    onChange: newBorder => onChange(newBorder, 'bottom'),
    __unstablePopoverProps: popoverProps,
    value: value === null || value === void 0 ? void 0 : value.bottom
  }, sharedBorderControlProps)));
};

const ConnectedBorderBoxControlSplitControls = contextConnect(BorderBoxControlSplitControls, 'BorderBoxControlSplitControls');
/* harmony default export */ const border_box_control_split_controls_component = (ConnectedBorderBoxControlSplitControls);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control/hook.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





function useBorderBoxControl(props) {
  const {
    className,
    onChange,
    value,
    ...otherProps
  } = useContextSystem(props, 'BorderBoxControl');
  const mixedBorders = hasMixedBorders(value);
  const splitBorders = hasSplitBorders(value);
  const linkedValue = splitBorders ? getCommonBorder(value) : value;
  const splitValue = splitBorders ? value : getSplitBorders(value);
  const [isLinked, setIsLinked] = (0,react.useState)(!mixedBorders);

  const toggleLinked = () => setIsLinked(!isLinked);

  const onLinkedChange = newBorder => {
    if (!newBorder) {
      return onChange(undefined);
    } // If we have all props defined on the new border apply it.


    if (!mixedBorders || isCompleteBorder(newBorder)) {
      return onChange(isEmptyBorder(newBorder) ? undefined : newBorder);
    } // If we had mixed borders we might have had some shared border props
    // that we need to maintain. For example; we could have mixed borders
    // with all the same color but different widths. Then from the linked
    // control we change the color. We should keep the separate  widths.


    const changes = getBorderDiff(linkedValue, newBorder);
    const updatedBorders = {
      top: { ...(value === null || value === void 0 ? void 0 : value.top),
        ...changes
      },
      right: { ...(value === null || value === void 0 ? void 0 : value.right),
        ...changes
      },
      bottom: { ...(value === null || value === void 0 ? void 0 : value.bottom),
        ...changes
      },
      left: { ...(value === null || value === void 0 ? void 0 : value.left),
        ...changes
      }
    };

    if (hasMixedBorders(updatedBorders)) {
      return onChange(updatedBorders);
    }

    const filteredResult = isEmptyBorder(updatedBorders.top) ? undefined : updatedBorders.top;
    onChange(filteredResult);
  };

  const onSplitChange = (newBorder, side) => {
    const updatedBorders = { ...splitValue,
      [side]: newBorder
    };

    if (hasMixedBorders(updatedBorders)) {
      onChange(updatedBorders);
    } else {
      onChange(newBorder);
    }
  };

  const cx = useCx();
  const classes = (0,react.useMemo)(() => {
    return cx(BorderBoxControl, className);
  }, [cx, className]);
  const linkedControlClassName = (0,react.useMemo)(() => {
    return cx(LinkedBorderControl);
  }, [cx]);
  return { ...otherProps,
    className: classes,
    hasMixedBorders: mixedBorders,
    isLinked,
    linkedControlClassName,
    onLinkedChange,
    onSplitChange,
    toggleLinked,
    linkedValue,
    splitValue
  };
}
//# sourceMappingURL=hook.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/border-box-control/border-box-control/component.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */











const component_BorderLabel = props => {
  const {
    label,
    hideLabelFromVision
  } = props;

  if (!label) {
    return null;
  }

  return hideLabelFromVision ? (0,react.createElement)(visually_hidden_component, {
    as: "label"
  }, label) : (0,react.createElement)(StyledLabel, null, label);
};

const component_BorderBoxControl = (props, forwardedRef) => {
  const {
    className,
    colors,
    disableCustomColors,
    enableAlpha,
    enableStyle,
    hasMixedBorders,
    hideLabelFromVision,
    isLinked,
    label,
    linkedControlClassName,
    linkedValue,
    onLinkedChange,
    onSplitChange,
    popoverPlacement,
    popoverOffset,
    splitValue,
    toggleLinked,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    __next36pxDefaultSize = false,
    ...otherProps
  } = useBorderBoxControl(props);
  const containerRef = (0,react.useRef)();
  const mergedRef = (0,use_merge_refs/* default */.A)([containerRef, forwardedRef]);
  const popoverProps = popoverPlacement ? {
    placement: popoverPlacement,
    offset: popoverOffset,
    anchorRef: containerRef,
    __unstableShift: true
  } : undefined;
  return (0,react.createElement)(component, (0,helpers_esm_extends/* default */.A)({
    className: className
  }, otherProps, {
    ref: mergedRef
  }), (0,react.createElement)(component_BorderLabel, {
    label: label,
    hideLabelFromVision: hideLabelFromVision
  }), (0,react.createElement)(h_stack_component, {
    alignment: 'start',
    expanded: true,
    spacing: 0
  }, isLinked ? (0,react.createElement)(border_control_component, {
    className: linkedControlClassName,
    colors: colors,
    disableCustomColors: disableCustomColors,
    enableAlpha: enableAlpha,
    enableStyle: enableStyle,
    onChange: onLinkedChange,
    placeholder: hasMixedBorders ? (0,i18n_build_module.__)('Mixed') : undefined,
    __unstablePopoverProps: popoverProps,
    shouldSanitizeBorder: false // This component will handle that.
    ,
    value: linkedValue,
    withSlider: true,
    width: '110px',
    __experimentalHasMultipleOrigins: __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
    __next36pxDefaultSize: __next36pxDefaultSize
  }) : (0,react.createElement)(border_box_control_split_controls_component, {
    colors: colors,
    disableCustomColors: disableCustomColors,
    enableAlpha: enableAlpha,
    enableStyle: enableStyle,
    onChange: onSplitChange,
    popoverPlacement: popoverPlacement,
    popoverOffset: popoverOffset,
    value: splitValue,
    __experimentalHasMultipleOrigins: __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
    __next36pxDefaultSize: __next36pxDefaultSize
  }), (0,react.createElement)(border_box_control_linked_button_component, {
    onClick: toggleLinked,
    isLinked: isLinked,
    __next36pxDefaultSize: __next36pxDefaultSize
  })));
};

const ConnectedBorderBoxControl = contextConnect(component_BorderBoxControl, 'BorderBoxControl');
/* harmony default export */ const border_box_control_component = (ConnectedBorderBoxControl);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/utils.js
/**
 * WordPress dependencies
 */

/**
 * Gets the (non-undefined) item with the highest occurrence within an array
 * Based in part on: https://stackoverflow.com/a/20762713
 *
 * Undefined values are always sorted to the end by `sort`, so this function
 * returns the first element, to always prioritize real values over undefined
 * values.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description
 *
 * @param {Array<any>} inputArray Array of items to check.
 * @return {any}                  The item with the most occurrences.
 */

function border_radius_control_utils_mode(inputArray) {
  const arr = [...inputArray];
  return arr.sort((a, b) => inputArray.filter(v => v === b).length - inputArray.filter(v => v === a).length).shift();
}
/**
 * Returns the most common CSS unit from the current CSS unit selections.
 *
 * - If a single flat border radius is set, its unit will be used
 * - If individual corner selections, the most common of those will be used
 * - Failing any unit selections a default of 'px' is returned.
 *
 * @param {Object} selectedUnits Unit selections for flat radius & each corner.
 * @return {string} Most common CSS unit from current selections. Default: `px`.
 */

function getAllUnit() {
  let selectedUnits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    flat,
    ...cornerUnits
  } = selectedUnits;
  return flat || border_radius_control_utils_mode(Object.values(cornerUnits).filter(Boolean)) || 'px';
}
/**
 * Gets the 'all' input value and unit from values data.
 *
 * @param {Object|string} values Radius values.
 * @return {string}              A value + unit for the 'all' input.
 */

function utils_getAllValue() {
  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  /**
   * Border radius support was originally a single pixel value.
   *
   * To maintain backwards compatibility treat this case as the all value.
   */
  if (typeof values === 'string') {
    return values;
  }

  const parsedQuantitiesAndUnits = Object.values(values).map(value => parseQuantityAndUnitFromRawValue(value));
  const allValues = parsedQuantitiesAndUnits.map(value => {
    var _value$;

    return (_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : '';
  });
  const allUnits = parsedQuantitiesAndUnits.map(value => value[1]);
  const value = allValues.every(v => v === allValues[0]) ? allValues[0] : '';
  const unit = border_radius_control_utils_mode(allUnits);
  const allValue = value === 0 || value ? `${value}${unit}` : undefined;
  return allValue;
}
/**
 * Checks to determine if values are mixed.
 *
 * @param {Object} values Radius values.
 * @return {boolean}      Whether values are mixed.
 */

function hasMixedValues() {
  let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const allValue = utils_getAllValue(values);
  const isMixed = typeof values === 'string' ? false : isNaN(parseFloat(allValue));
  return isMixed;
}
/**
 * Checks to determine if values are defined.
 *
 * @param {Object} values Radius values.
 * @return {boolean}      Whether values are mixed.
 */

function hasDefinedValues(values) {
  if (!values) {
    return false;
  } // A string value represents a shorthand value.


  if (typeof values === 'string') {
    return true;
  } // An object represents longhand border radius values, if any are set
  // flag values as being defined.


  const filteredValues = Object.values(values).filter(value => {
    return !!value || value === 0;
  });
  return !!filteredValues.length;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/all-input-control.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


function border_radius_control_all_input_control_AllInputControl(_ref) {
  let {
    onChange,
    selectedUnits,
    setSelectedUnits,
    values,
    ...props
  } = _ref;
  let allValue = utils_getAllValue(values);

  if (allValue === undefined) {
    // If we don't have any value set the unit to any current selection
    // or the most common unit from the individual radii values.
    allValue = getAllUnit(selectedUnits);
  }

  const hasValues = hasDefinedValues(values);
  const isMixed = hasValues && hasMixedValues(values);
  const allPlaceholder = isMixed ? (0,_wordpress_i18n_build_module.__)('Mixed') : null; // Filter out CSS-unit-only values to prevent invalid styles.

  const handleOnChange = next => {
    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    onChange(nextValue);
  }; // Store current unit selection for use as fallback for individual
  // radii controls.


  const handleOnUnitChange = unit => {
    setSelectedUnits({
      topLeft: unit,
      topRight: unit,
      bottomLeft: unit,
      bottomRight: unit
    });
  };

  return (0,react.createElement)(unit_control, (0,esm_extends/* default */.A)({}, props, {
    "aria-label": (0,_wordpress_i18n_build_module.__)('Border radius'),
    disableUnits: isMixed,
    isOnly: true,
    value: allValue,
    onChange: handleOnChange,
    onUnitChange: handleOnUnitChange,
    placeholder: allPlaceholder
  }));
}
//# sourceMappingURL=all-input-control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/input-controls.js



/**
 * WordPress dependencies
 */


const CORNERS = {
  topLeft: (0,_wordpress_i18n_build_module.__)('Top left'),
  topRight: (0,_wordpress_i18n_build_module.__)('Top right'),
  bottomLeft: (0,_wordpress_i18n_build_module.__)('Bottom left'),
  bottomRight: (0,_wordpress_i18n_build_module.__)('Bottom right')
};
function border_radius_control_input_controls_BoxInputControls(_ref) {
  let {
    onChange,
    selectedUnits,
    setSelectedUnits,
    values: valuesProp,
    ...props
  } = _ref;

  const createHandleOnChange = corner => next => {
    if (!onChange) {
      return;
    } // Filter out CSS-unit-only values to prevent invalid styles.


    const isNumeric = !isNaN(parseFloat(next));
    const nextValue = isNumeric ? next : undefined;
    onChange({ ...values,
      [corner]: nextValue
    });
  };

  const createHandleOnUnitChange = side => next => {
    const newUnits = { ...selectedUnits
    };
    newUnits[side] = next;
    setSelectedUnits(newUnits);
  }; // For shorthand style & backwards compatibility, handle flat string value.


  const values = typeof valuesProp !== 'string' ? valuesProp : {
    topLeft: valuesProp,
    topRight: valuesProp,
    bottomLeft: valuesProp,
    bottomRight: valuesProp
  }; // Controls are wrapped in tooltips as visible labels aren't desired here.
  // Tooltip rendering also requires the UnitControl to be wrapped. See:
  // https://github.com/WordPress/gutenberg/pull/24966#issuecomment-685875026

  return (0,react.createElement)("div", {
    className: "components-border-radius-control__input-controls-wrapper"
  }, Object.entries(CORNERS).map(_ref2 => {
    let [corner, label] = _ref2;
    const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(values[corner]);
    const computedUnit = values[corner] ? parsedUnit : selectedUnits[corner] || selectedUnits.flat;
    return (0,react.createElement)(tooltip, {
      text: label,
      position: "top",
      key: corner
    }, (0,react.createElement)("div", {
      className: "components-border-radius-control__tooltip-wrapper"
    }, (0,react.createElement)(unit_control, (0,esm_extends/* default */.A)({}, props, {
      "aria-label": label,
      value: [parsedQuantity, computedUnit].join(''),
      onChange: createHandleOnChange(corner),
      onUnitChange: createHandleOnUnitChange(corner)
    }))));
  }));
}
//# sourceMappingURL=input-controls.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/linked-button.js



/**
 * WordPress dependencies
 */



function border_radius_control_linked_button_LinkedButton(_ref) {
  let {
    isLinked,
    ...props
  } = _ref;
  const label = isLinked ? (0,_wordpress_i18n_build_module.__)('Unlink Radii') : (0,_wordpress_i18n_build_module.__)('Link Radii');
  return (0,react.createElement)(tooltip, {
    text: label
  }, (0,react.createElement)(build_module_button, (0,esm_extends/* default */.A)({}, props, {
    className: "component-border-radius-control__linked-button",
    isPrimary: isLinked,
    isSecondary: !isLinked,
    isSmall: true,
    icon: isLinked ? library_link : link_off,
    iconSize: 16,
    "aria-label": label
  })));
}
//# sourceMappingURL=linked-button.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/border-radius-control/index.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */






const border_radius_control_DEFAULT_VALUES = {
  topLeft: undefined,
  topRight: undefined,
  bottomLeft: undefined,
  bottomRight: undefined
};
const MIN_BORDER_RADIUS_VALUE = 0;
const MAX_BORDER_RADIUS_VALUES = {
  px: 100,
  em: 20,
  rem: 20
};
/**
 * Control to display border radius options.
 *
 * @param {Object}   props          Component props.
 * @param {Function} props.onChange Callback to handle onChange.
 * @param {Object}   props.values   Border radius values.
 *
 * @return {WPElement}              Custom border radius control.
 */

function BorderRadiusControl(_ref) {
  let {
    onChange,
    values
  } = _ref;
  const [isLinked, setIsLinked] = (0,react.useState)(!hasDefinedValues(values) || !hasMixedValues(values)); // Tracking selected units via internal state allows filtering of CSS unit
  // only values from being saved while maintaining preexisting unit selection
  // behaviour. Filtering CSS unit only values prevents invalid style values.

  const [selectedUnits, setSelectedUnits] = (0,react.useState)({
    flat: typeof values === 'string' ? parseQuantityAndUnitFromRawValue(values)[1] : undefined,
    topLeft: parseQuantityAndUnitFromRawValue(values === null || values === void 0 ? void 0 : values.topLeft)[1],
    topRight: parseQuantityAndUnitFromRawValue(values === null || values === void 0 ? void 0 : values.topRight)[1],
    bottomLeft: parseQuantityAndUnitFromRawValue(values === null || values === void 0 ? void 0 : values.bottomLeft)[1],
    bottomRight: parseQuantityAndUnitFromRawValue(values === null || values === void 0 ? void 0 : values.bottomRight)[1]
  });
  const units = useCustomUnits({
    availableUnits: use_setting_useSetting('spacing.units') || ['px', 'em', 'rem']
  });
  const unit = getAllUnit(selectedUnits);
  const unitConfig = units && units.find(item => item.value === unit);
  const step = (unitConfig === null || unitConfig === void 0 ? void 0 : unitConfig.step) || 1;
  const [allValue] = parseQuantityAndUnitFromRawValue(utils_getAllValue(values));

  const toggleLinked = () => setIsLinked(!isLinked);

  const handleSliderChange = next => {
    onChange(next !== undefined ? `${next}${unit}` : undefined);
  };

  return (0,react.createElement)("fieldset", {
    className: "components-border-radius-control"
  }, (0,react.createElement)(base_control.VisualLabel, {
    as: "legend"
  }, (0,_wordpress_i18n_build_module.__)('Radius')), (0,react.createElement)("div", {
    className: "components-border-radius-control__wrapper"
  }, isLinked ? (0,react.createElement)(react.Fragment, null, (0,react.createElement)(border_radius_control_all_input_control_AllInputControl, {
    className: "components-border-radius-control__unit-control",
    values: values,
    min: MIN_BORDER_RADIUS_VALUE,
    onChange: onChange,
    selectedUnits: selectedUnits,
    setSelectedUnits: setSelectedUnits,
    units: units
  }), (0,react.createElement)(range_control, {
    label: (0,_wordpress_i18n_build_module.__)('Border radius'),
    hideLabelFromVision: true,
    className: "components-border-radius-control__range-control",
    value: allValue !== null && allValue !== void 0 ? allValue : '',
    min: MIN_BORDER_RADIUS_VALUE,
    max: MAX_BORDER_RADIUS_VALUES[unit],
    initialPosition: 0,
    withInputField: false,
    onChange: handleSliderChange,
    step: step
  })) : (0,react.createElement)(border_radius_control_input_controls_BoxInputControls, {
    min: MIN_BORDER_RADIUS_VALUE,
    onChange: onChange,
    selectedUnits: selectedUnits,
    setSelectedUnits: setSelectedUnits,
    values: values || border_radius_control_DEFAULT_VALUES,
    units: units
  }), (0,react.createElement)(border_radius_control_linked_button_LinkedButton, {
    onClick: toggleLinked,
    isLinked: isLinked
  })));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/border-radius.js


/**
 * Internal dependencies
 */



/**
 * Inspector control panel containing the border radius related configuration.
 *
 * @param {Object} props Block properties.
 *
 * @return {WPElement} Border radius edit element.
 */

function BorderRadiusEdit(props) {
  var _style$border;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  const onChange = newRadius => {
    const newStyle = cleanEmptyObject({ ...style,
      border: { ...(style === null || style === void 0 ? void 0 : style.border),
        radius: newRadius
      }
    });
    setAttributes({
      style: newStyle
    });
  };

  return (0,react.createElement)(BorderRadiusControl, {
    values: style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.radius,
    onChange: onChange
  });
}
/**
 * Checks if there is a current value in the border radius block support
 * attributes.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a border radius value set.
 */

function hasBorderRadiusValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  const borderRadius = (_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : (_props$attributes$sty2 = _props$attributes$sty.border) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.radius;

  if (typeof borderRadius === 'object') {
    return Object.entries(borderRadius).some(Boolean);
  }

  return !!borderRadius;
}
/**
 * Resets the border radius block support attributes. This can be used when
 * disabling the border radius support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetBorderRadius(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: removeBorderAttribute(style, 'radius')
  });
}
//# sourceMappingURL=border-radius.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/colors/utils.js
/**
 * External dependencies
 */




(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
/**
 * Provided an array of color objects as set by the theme or by the editor defaults,
 * and the values of the defined color or custom color returns a color object describing the color.
 *
 * @param {Array}   colors       Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} definedColor A string containing the color slug.
 * @param {?string} customColor  A string containing the customColor value.
 *
 * @return {?Object} If definedColor is passed and the name is found in colors,
 *                   the color object exactly as set by the theme or editor defaults is returned.
 *                   Otherwise, an object that just sets the color is defined.
 */

const utils_getColorObjectByAttributeValues = (colors, definedColor, customColor) => {
  if (definedColor) {
    const colorObj = (0,lodash.find)(colors, {
      slug: definedColor
    });

    if (colorObj) {
      return colorObj;
    }
  }

  return {
    color: customColor
  };
};
/**
 * Provided an array of color objects as set by the theme or by the editor defaults, and a color value returns the color object matching that value or undefined.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {?Object} Color object included in the colors array whose color property equals colorValue.
 *                   Returns undefined if no color object matches this requirement.
 */

const getColorObjectByColorValue = (colors, colorValue) => {
  return (0,lodash.find)(colors, {
    color: colorValue
  });
};
/**
 * Returns a class based on the context a color is being used and its slug.
 *
 * @param {string} colorContextName Context/place where color is being used e.g: background, text etc...
 * @param {string} colorSlug        Slug of the color.
 *
 * @return {?string} String with the class corresponding to the color in the provided context.
 *                   Returns undefined if either colorContextName or colorSlug are not provided.
 */

function utils_getColorClassName(colorContextName, colorSlug) {
  if (!colorContextName || !colorSlug) {
    return undefined;
  }

  return `has-${(0,lodash.kebabCase)(colorSlug)}-${colorContextName}`;
}
/**
 * Given an array of color objects and a color value returns the color value of the most readable color in the array.
 *
 * @param {Array}   colors     Array of color objects as set by the theme or by the editor defaults.
 * @param {?string} colorValue A string containing the color value.
 *
 * @return {string} String with the color value of the most readable color.
 */

function getMostReadableColor(colors, colorValue) {
  const colordColor = colord(colorValue);

  const getColorContrast = _ref => {
    let {
      color
    } = _ref;
    return colordColor.contrast(color);
  };

  const maxContrast = Math.max(...colors.map(getColorContrast));
  return colors.find(color => getColorContrast(color) === maxContrast).color;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/colors-gradients/use-common-single-multiple-selects.js
/**
 * Internal dependencies
 */

function useCommonSingleMultipleSelects() {
  return {
    disableCustomColors: !use_setting_useSetting('color.custom'),
    disableCustomGradients: !use_setting_useSetting('color.customGradient')
  };
}
//# sourceMappingURL=use-common-single-multiple-selects.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/colors-gradients/use-multiple-origin-colors-and-gradients.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Retrieves color and gradient related settings.
 *
 * The arrays for colors and gradients are made up of color palettes from each
 * origin i.e. "Core", "Theme", and "User".
 *
 * @return {Object} Color and gradient related settings.
 */

function use_multiple_origin_colors_and_gradients_useMultipleOriginColorsAndGradients() {
  const colorGradientSettings = useCommonSingleMultipleSelects();
  const customColors = use_setting_useSetting('color.palette.custom');
  const themeColors = use_setting_useSetting('color.palette.theme');
  const defaultColors = use_setting_useSetting('color.palette.default');
  const shouldDisplayDefaultColors = use_setting_useSetting('color.defaultPalette');
  colorGradientSettings.colors = (0,react.useMemo)(() => {
    const result = [];

    if (themeColors && themeColors.length) {
      result.push({
        name: (0,_wordpress_i18n_build_module._x)('Theme', 'Indicates this palette comes from the theme.'),
        colors: themeColors
      });
    }

    if (shouldDisplayDefaultColors && defaultColors && defaultColors.length) {
      result.push({
        name: (0,_wordpress_i18n_build_module._x)('Default', 'Indicates this palette comes from WordPress.'),
        colors: defaultColors
      });
    }

    if (customColors && customColors.length) {
      result.push({
        name: (0,_wordpress_i18n_build_module._x)('Custom', 'Indicates this palette comes from the theme.'),
        colors: customColors
      });
    }

    return result;
  }, [defaultColors, themeColors, customColors]);
  const customGradients = use_setting_useSetting('color.gradients.custom');
  const themeGradients = use_setting_useSetting('color.gradients.theme');
  const defaultGradients = use_setting_useSetting('color.gradients.default');
  const shouldDisplayDefaultGradients = use_setting_useSetting('color.defaultGradients');
  colorGradientSettings.gradients = (0,react.useMemo)(() => {
    const result = [];

    if (themeGradients && themeGradients.length) {
      result.push({
        name: (0,_wordpress_i18n_build_module._x)('Theme', 'Indicates this palette comes from the theme.'),
        gradients: themeGradients
      });
    }

    if (shouldDisplayDefaultGradients && defaultGradients && defaultGradients.length) {
      result.push({
        name: (0,_wordpress_i18n_build_module._x)('Default', 'Indicates this palette comes from WordPress.'),
        gradients: defaultGradients
      });
    }

    if (customGradients && customGradients.length) {
      result.push({
        name: (0,_wordpress_i18n_build_module._x)('Custom', 'Indicates this palette is created by the user.'),
        gradients: customGradients
      });
    }

    return result;
  }, [customGradients, themeGradients, defaultGradients]);
  return colorGradientSettings;
}
//# sourceMappingURL=use-multiple-origin-colors-and-gradients.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/border.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */







const BORDER_SUPPORT_KEY = '__experimentalBorder';
const borderSides = ['top', 'right', 'bottom', 'left'];

const hasBorderValue = props => {
  const {
    borderColor,
    style
  } = props.attributes;
  return isDefinedBorder(style === null || style === void 0 ? void 0 : style.border) || !!borderColor;
}; // The border color, style, and width are omitted so they get undefined. The
// border radius is separate and must retain its selection.


const resetBorder = _ref => {
  var _style$border;

  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    borderColor: undefined,
    style: { ...style,
      border: cleanEmptyObject({
        radius: style === null || style === void 0 ? void 0 : (_style$border = style.border) === null || _style$border === void 0 ? void 0 : _style$border.radius
      })
    }
  });
};

const resetBorderFilter = newAttributes => {
  var _newAttributes$style, _newAttributes$style$;

  return { ...newAttributes,
    borderColor: undefined,
    style: { ...newAttributes.style,
      border: {
        radius: (_newAttributes$style = newAttributes.style) === null || _newAttributes$style === void 0 ? void 0 : (_newAttributes$style$ = _newAttributes$style.border) === null || _newAttributes$style$ === void 0 ? void 0 : _newAttributes$style$.radius
      }
    }
  };
};

const getColorByProperty = (colors, property, value) => {
  let matchedColor;
  colors.some(origin => origin.colors.some(color => {
    if (color[property] === value) {
      matchedColor = color;
      return true;
    }

    return false;
  }));
  return matchedColor;
};

const border_getMultiOriginColor = _ref2 => {
  let {
    colors,
    namedColor,
    customColor
  } = _ref2;

  // Search each origin (default, theme, or user) for matching color by name.
  if (namedColor) {
    const colorObject = getColorByProperty(colors, 'slug', namedColor);

    if (colorObject) {
      return colorObject;
    }
  } // Skip if no custom color or matching named color.


  if (!customColor) {
    return {
      color: undefined
    };
  } // Attempt to find color via custom color value or build new object.


  const colorObject = getColorByProperty(colors, 'color', customColor);
  return colorObject ? colorObject : {
    color: customColor
  };
};

const getBorderObject = (attributes, colors) => {
  const {
    borderColor,
    style
  } = attributes;
  const {
    border: borderStyles
  } = style || {}; // If we have a named color for a flat border. Fetch that color object and
  // apply that color's value to the color property within the style object.

  if (borderColor) {
    const {
      color
    } = border_getMultiOriginColor({
      colors,
      namedColor: borderColor
    });
    return color ? { ...borderStyles,
      color
    } : borderStyles;
  } // Individual side border color slugs are stored within the border style
  // object. If we don't have a border styles object we have nothing further
  // to hydrate.


  if (!borderStyles) {
    return borderStyles;
  } // If we have named colors for the individual side borders, retrieve their
  // related color objects and apply the real color values to the split
  // border objects.


  const hydratedBorderStyles = { ...borderStyles
  };
  borderSides.forEach(side => {
    var _hydratedBorderStyles;

    const colorSlug = getColorSlugFromVariable((_hydratedBorderStyles = hydratedBorderStyles[side]) === null || _hydratedBorderStyles === void 0 ? void 0 : _hydratedBorderStyles.color);

    if (colorSlug) {
      const {
        color
      } = border_getMultiOriginColor({
        colors,
        namedColor: colorSlug
      });
      hydratedBorderStyles[side] = { ...hydratedBorderStyles[side],
        color
      };
    }
  });
  return hydratedBorderStyles;
};

function getColorSlugFromVariable(value) {
  const namedColor = /var:preset\|color\|(.+)/.exec(value);

  if (namedColor && namedColor[1]) {
    return namedColor[1];
  }

  return null;
}

function BorderPanel(props) {
  const {
    attributes,
    clientId,
    setAttributes
  } = props;
  const {
    style
  } = attributes;
  const {
    colors
  } = use_multiple_origin_colors_and_gradients_useMultipleOriginColorsAndGradients();
  const isSupported = hasBorderSupport(props.name);
  const isColorSupported = use_setting_useSetting('border.color') && hasBorderSupport(props.name, 'color');
  const isRadiusSupported = use_setting_useSetting('border.radius') && hasBorderSupport(props.name, 'radius');
  const isStyleSupported = use_setting_useSetting('border.style') && hasBorderSupport(props.name, 'style');
  const isWidthSupported = use_setting_useSetting('border.width') && hasBorderSupport(props.name, 'width');
  const isDisabled = [!isColorSupported, !isRadiusSupported, !isStyleSupported, !isWidthSupported].every(Boolean);

  if (isDisabled || !isSupported) {
    return null;
  }

  const defaultBorderControls = (0,build_module/* getBlockSupport */.bI)(props.name, [BORDER_SUPPORT_KEY, '__experimentalDefaultControls']);
  const showBorderByDefault = (defaultBorderControls === null || defaultBorderControls === void 0 ? void 0 : defaultBorderControls.color) || (defaultBorderControls === null || defaultBorderControls === void 0 ? void 0 : defaultBorderControls.width);

  const onBorderChange = newBorder => {
    var _style$border2;

    // Filter out named colors and apply them to appropriate block
    // attributes so that CSS classes can be used to apply those colors.
    // e.g. has-primary-border-top-color.
    let newBorderStyles = { ...newBorder
    };
    let newBorderColor;

    if (hasSplitBorders(newBorder)) {
      // For each side check if the side has a color value set
      // If so, determine if it belongs to a named color, in which case
      // we update the color property.
      //
      // This deliberately overwrites `newBorderStyles` to avoid mutating
      // the passed object which causes problems otherwise.
      newBorderStyles = {
        top: { ...newBorder.top
        },
        right: { ...newBorder.right
        },
        bottom: { ...newBorder.bottom
        },
        left: { ...newBorder.left
        }
      };
      borderSides.forEach(side => {
        var _newBorder$side;

        if ((_newBorder$side = newBorder[side]) !== null && _newBorder$side !== void 0 && _newBorder$side.color) {
          var _newBorder$side2;

          const colorObject = border_getMultiOriginColor({
            colors,
            customColor: (_newBorder$side2 = newBorder[side]) === null || _newBorder$side2 === void 0 ? void 0 : _newBorder$side2.color
          });

          if (colorObject.slug) {
            newBorderStyles[side].color = `var:preset|color|${colorObject.slug}`;
          }
        }
      });
    } else if (newBorder !== null && newBorder !== void 0 && newBorder.color) {
      // We have a flat border configuration. Apply named color slug to
      // `borderColor` attribute and clear color style property if found.
      const customColor = newBorder === null || newBorder === void 0 ? void 0 : newBorder.color;
      const colorObject = border_getMultiOriginColor({
        colors,
        customColor
      });

      if (colorObject.slug) {
        newBorderColor = colorObject.slug;
        newBorderStyles.color = undefined;
      }
    } // Ensure previous border radius styles are maintained and clean
    // overall result for empty objects or properties.


    const newStyle = cleanEmptyObject({ ...style,
      border: {
        radius: style === null || style === void 0 ? void 0 : (_style$border2 = style.border) === null || _style$border2 === void 0 ? void 0 : _style$border2.radius,
        ...newBorderStyles
      }
    });
    setAttributes({
      style: newStyle,
      borderColor: newBorderColor
    });
  };

  const hydratedBorder = getBorderObject(attributes, colors);
  return (0,react.createElement)(inspector_controls, {
    __experimentalGroup: "border"
  }, (isWidthSupported || isColorSupported) && (0,react.createElement)(tools_panel_item_component, {
    hasValue: () => hasBorderValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Border'),
    onDeselect: () => resetBorder(props),
    isShownByDefault: showBorderByDefault,
    resetAllFilter: resetBorderFilter,
    panelId: clientId
  }, (0,react.createElement)(border_box_control_component, {
    colors: colors,
    enableAlpha: true,
    enableStyle: isStyleSupported,
    onChange: onBorderChange,
    popoverOffset: 40,
    popoverPlacement: "left-start",
    value: hydratedBorder,
    __experimentalHasMultipleOrigins: true,
    __experimentalIsRenderedInSidebar: true
  })), isRadiusSupported && (0,react.createElement)(tools_panel_item_component, {
    hasValue: () => hasBorderRadiusValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Radius'),
    onDeselect: () => resetBorderRadius(props),
    isShownByDefault: defaultBorderControls === null || defaultBorderControls === void 0 ? void 0 : defaultBorderControls.radius,
    resetAllFilter: newAttributes => {
      var _newAttributes$style2;

      return { ...newAttributes,
        style: { ...newAttributes.style,
          border: { ...((_newAttributes$style2 = newAttributes.style) === null || _newAttributes$style2 === void 0 ? void 0 : _newAttributes$style2.border),
            radius: undefined
          }
        }
      };
    },
    panelId: clientId
  }, (0,react.createElement)(BorderRadiusEdit, props)));
}
/**
 * Determine whether there is block support for border properties.
 *
 * @param {string} blockName Block name.
 * @param {string} feature   Border feature to check support for.
 *
 * @return {boolean} Whether there is support.
 */

function hasBorderSupport(blockName) {
  let feature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';

  if (platform.OS !== 'web') {
    return false;
  }

  const support = (0,build_module/* getBlockSupport */.bI)(blockName, BORDER_SUPPORT_KEY);

  if (support === true) {
    return true;
  }

  if (feature === 'any') {
    return !!(support !== null && support !== void 0 && support.color || support !== null && support !== void 0 && support.radius || support !== null && support !== void 0 && support.width || support !== null && support !== void 0 && support.style);
  }

  return !!(support !== null && support !== void 0 && support[feature]);
}
/**
 * Returns a new style object where the specified border attribute has been
 * removed.
 *
 * @param {Object} style     Styles from block attributes.
 * @param {string} attribute The border style attribute to clear.
 *
 * @return {Object} Style object with the specified attribute removed.
 */

function removeBorderAttribute(style, attribute) {
  return cleanEmptyObject({ ...style,
    border: { ...(style === null || style === void 0 ? void 0 : style.border),
      [attribute]: undefined
    }
  });
}
/**
 * Filters registered block settings, extending attributes to include
 * `borderColor` if needed.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Updated block settings.
 */

function addAttributes(settings) {
  if (!hasBorderSupport(settings, 'color')) {
    return settings;
  } // Allow blocks to specify default value if needed.


  if (settings.attributes.borderColor) {
    return settings;
  } // Add new borderColor attribute to block settings.


  return { ...settings,
    attributes: { ...settings.attributes,
      borderColor: {
        type: 'string'
      }
    }
  };
}
/**
 * Override props assigned to save component to inject border color.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type definition.
 * @param {Object} attributes Block's attributes.
 *
 * @return {Object} Filtered props to apply to save element.
 */


function border_addSaveProps(props, blockType, attributes) {
  if (!hasBorderSupport(blockType, 'color') || shouldSkipSerialization(blockType, BORDER_SUPPORT_KEY, 'color')) {
    return props;
  }

  const borderClasses = border_getBorderClasses(attributes);
  const newClassName = classnames_default()(props.className, borderClasses); // If we are clearing the last of the previous classes in `className`
  // set it to `undefined` to avoid rendering empty DOM attributes.

  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Generates a CSS class name consisting of all the applicable border color
 * classes given the current block attributes.
 *
 * @param {Object} attributes Block's attributes.
 *
 * @return {string} CSS class name.
 */


function border_getBorderClasses(attributes) {
  var _style$border3;

  const {
    borderColor,
    style
  } = attributes;
  const borderColorClass = utils_getColorClassName('border-color', borderColor);
  return classnames_default()({
    'has-border-color': borderColor || (style === null || style === void 0 ? void 0 : (_style$border3 = style.border) === null || _style$border3 === void 0 ? void 0 : _style$border3.color),
    [borderColorClass]: !!borderColorClass
  });
}
/**
 * Filters the registered block settings to apply border color styles and
 * classnames to the block edit wrapper.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function addEditProps(settings) {
  if (!hasBorderSupport(settings, 'color') || shouldSkipSerialization(settings, BORDER_SUPPORT_KEY, 'color')) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return border_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */


const withBorderColorPaletteStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  var _style$border4, _style$border4$top, _style$border5, _style$border5$right, _style$border6, _style$border6$bottom, _style$border7, _style$border7$left, _props$wrapperProps;

  const {
    name,
    attributes
  } = props;
  const {
    borderColor,
    style
  } = attributes;
  const {
    colors
  } = use_multiple_origin_colors_and_gradients_useMultipleOriginColorsAndGradients();

  if (!hasBorderSupport(name, 'color') || shouldSkipSerialization(name, BORDER_SUPPORT_KEY, 'color')) {
    return (0,react.createElement)(BlockListBlock, props);
  }

  const {
    color: borderColorValue
  } = border_getMultiOriginColor({
    colors,
    namedColor: borderColor
  });
  const {
    color: borderTopColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border4 = style.border) === null || _style$border4 === void 0 ? void 0 : (_style$border4$top = _style$border4.top) === null || _style$border4$top === void 0 ? void 0 : _style$border4$top.color)
  });
  const {
    color: borderRightColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border5 = style.border) === null || _style$border5 === void 0 ? void 0 : (_style$border5$right = _style$border5.right) === null || _style$border5$right === void 0 ? void 0 : _style$border5$right.color)
  });
  const {
    color: borderBottomColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border6 = style.border) === null || _style$border6 === void 0 ? void 0 : (_style$border6$bottom = _style$border6.bottom) === null || _style$border6$bottom === void 0 ? void 0 : _style$border6$bottom.color)
  });
  const {
    color: borderLeftColor
  } = border_getMultiOriginColor({
    colors,
    namedColor: getColorSlugFromVariable(style === null || style === void 0 ? void 0 : (_style$border7 = style.border) === null || _style$border7 === void 0 ? void 0 : (_style$border7$left = _style$border7.left) === null || _style$border7$left === void 0 ? void 0 : _style$border7$left.color)
  });
  const extraStyles = {
    borderTopColor: borderTopColor || borderColorValue,
    borderRightColor: borderRightColor || borderColorValue,
    borderBottomColor: borderBottomColor || borderColorValue,
    borderLeftColor: borderLeftColor || borderColorValue
  };
  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...((_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style),
      ...extraStyles
    }
  };
  return (0,react.createElement)(BlockListBlock, (0,esm_extends/* default */.A)({}, props, {
    wrapperProps: wrapperProps
  }));
});
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/border/addAttributes', addAttributes);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/border/addSaveProps', border_addSaveProps);
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/border/addEditProps', addEditProps);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/border/with-border-color-palette-styles', withBorderColorPaletteStyles);
//# sourceMappingURL=border.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/gradients/use-gradient.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */




function use_gradient_experimentalGetGradientClass(gradientSlug) {
  if (!gradientSlug) {
    return undefined;
  }

  return `has-${gradientSlug}-gradient-background`;
}
/**
 * Retrieves the gradient value per slug.
 *
 * @param {Array}  gradients Gradient Palette
 * @param {string} slug      Gradient slug
 *
 * @return {string} Gradient value.
 */

function use_gradient_getGradientValueBySlug(gradients, slug) {
  const gradient = (0,lodash.find)(gradients, ['slug', slug]);
  return gradient && gradient.gradient;
}
function __experimentalGetGradientObjectByGradientValue(gradients, value) {
  const gradient = (0,lodash.find)(gradients, ['gradient', value]);
  return gradient;
}
/**
 * Retrieves the gradient slug per slug.
 *
 * @param {Array}  gradients Gradient Palette
 * @param {string} value     Gradient value
 * @return {string} Gradient slug.
 */

function getGradientSlugByValue(gradients, value) {
  const gradient = __experimentalGetGradientObjectByGradientValue(gradients, value);

  return gradient && gradient.slug;
}
function __experimentalUseGradient() {
  let {
    gradientAttribute = 'gradient',
    customGradientAttribute = 'customGradient'
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    clientId
  } = useBlockEditContext();
  const userGradientPalette = useSetting('color.gradients.custom');
  const themeGradientPalette = useSetting('color.gradients.theme');
  const defaultGradientPalette = useSetting('color.gradients.default');
  const allGradients = useMemo(() => [...(userGradientPalette || []), ...(themeGradientPalette || []), ...(defaultGradientPalette || [])], [userGradientPalette, themeGradientPalette, defaultGradientPalette]);
  const {
    gradient,
    customGradient
  } = useSelect(select => {
    const {
      getBlockAttributes
    } = select(blockEditorStore);
    const attributes = getBlockAttributes(clientId) || {};
    return {
      customGradient: attributes[customGradientAttribute],
      gradient: attributes[gradientAttribute]
    };
  }, [clientId, gradientAttribute, customGradientAttribute]);
  const {
    updateBlockAttributes
  } = useDispatch(blockEditorStore);
  const setGradient = useCallback(newGradientValue => {
    const slug = getGradientSlugByValue(allGradients, newGradientValue);

    if (slug) {
      updateBlockAttributes(clientId, {
        [gradientAttribute]: slug,
        [customGradientAttribute]: undefined
      });
      return;
    }

    updateBlockAttributes(clientId, {
      [gradientAttribute]: undefined,
      [customGradientAttribute]: newGradientValue
    });
  }, [allGradients, clientId, updateBlockAttributes]);

  const gradientClass = use_gradient_experimentalGetGradientClass(gradient);

  let gradientValue;

  if (gradient) {
    gradientValue = use_gradient_getGradientValueBySlug(allGradients, gradient);
  } else {
    gradientValue = customGradient;
  }

  return {
    gradientClass,
    gradientValue,
    setGradient
  };
}
//# sourceMappingURL=use-gradient.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-dragging/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

 // Event handlers that are triggered from `document` listeners accept a MouseEvent,
// while those triggered from React listeners accept a React.MouseEvent.

/**
 * @param {Object}                                  props
 * @param {(e: import('react').MouseEvent) => void} props.onDragStart
 * @param {(e: MouseEvent) => void}                 props.onDragMove
 * @param {(e?: MouseEvent) => void}                props.onDragEnd
 */

function useDragging(_ref) {
  let {
    onDragStart,
    onDragMove,
    onDragEnd
  } = _ref;
  const [isDragging, setIsDragging] = (0,react.useState)(false);
  const eventsRef = (0,react.useRef)({
    onDragStart,
    onDragMove,
    onDragEnd
  });
  (0,use_isomorphic_layout_effect/* default */.A)(() => {
    eventsRef.current.onDragStart = onDragStart;
    eventsRef.current.onDragMove = onDragMove;
    eventsRef.current.onDragEnd = onDragEnd;
  }, [onDragStart, onDragMove, onDragEnd]);
  /** @type {(e: MouseEvent) => void} */

  const onMouseMove = (0,react.useCallback)(event => eventsRef.current.onDragMove && eventsRef.current.onDragMove(event), []);
  /** @type {(e?: MouseEvent) => void} */

  const endDrag = (0,react.useCallback)(event => {
    if (eventsRef.current.onDragEnd) {
      eventsRef.current.onDragEnd(event);
    }

    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', endDrag);
    setIsDragging(false);
  }, []);
  /** @type {(e: import('react').MouseEvent) => void} */

  const startDrag = (0,react.useCallback)(event => {
    if (eventsRef.current.onDragStart) {
      eventsRef.current.onDragStart(event);
    }

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', endDrag);
    setIsDragging(true);
  }, []); // Remove the global events when unmounting if needed.

  (0,react.useEffect)(() => {
    return () => {
      if (isDragging) {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', endDrag);
      }
    };
  }, [isDragging]);
  return {
    startDrag,
    endDrag,
    isDragging
  };
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/angle-picker-control/styles/angle-picker-control-styles.js


function angle_picker_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */




const CIRCLE_SIZE = 32;
const INNER_CIRCLE_SIZE = 3;

const deprecatedBottomMargin = _ref => {
  let {
    __nextHasNoMarginBottom
  } = _ref;
  return !__nextHasNoMarginBottom ? /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("margin-bottom:", space(2), ";" + ( true ? "" : 0),  true ? "" : 0) : '';
};

const angle_picker_control_styles_Root = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_component,  true ? {
  target: "e65ony43"
} : 0)(deprecatedBottomMargin, ";" + ( true ? "" : 0));
const CircleRoot = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e65ony42"
} : 0)("border-radius:50%;border:", config_values.borderWidth, " solid ", COLORS.ui.border, ";box-sizing:border-box;cursor:grab;height:", CIRCLE_SIZE, "px;overflow:hidden;width:", CIRCLE_SIZE, "px;" + ( true ? "" : 0));
const CircleIndicatorWrapper = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e65ony41"
} : 0)( true ? {
  name: "1bhd2sw",
  styles: "box-sizing:border-box;position:relative;width:100%;height:100%"
} : 0);
const CircleIndicator = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "e65ony40"
} : 0)("background:", COLORS.ui.theme, ";border-radius:50%;border:", INNER_CIRCLE_SIZE, "px solid ", COLORS.ui.theme, ";bottom:0;box-sizing:border-box;display:block;height:0px;left:0;margin:auto;position:absolute;right:0;top:-", CIRCLE_SIZE / 2, "px;width:0px;" + ( true ? "" : 0));
//# sourceMappingURL=angle-picker-control-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/angle-picker-control/angle-circle.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function AngleCircle(_ref) {
  let {
    value,
    onChange,
    ...props
  } = _ref;
  const angleCircleRef = (0,react.useRef)();
  const angleCircleCenter = (0,react.useRef)();
  const previousCursorValue = (0,react.useRef)();

  const setAngleCircleCenter = () => {
    const rect = angleCircleRef.current.getBoundingClientRect();
    angleCircleCenter.current = {
      x: rect.x + rect.width / 2,
      y: rect.y + rect.height / 2
    };
  };

  const changeAngleToPosition = event => {
    const {
      x: centerX,
      y: centerY
    } = angleCircleCenter.current; // Prevent (drag) mouse events from selecting and accidentally
    // triggering actions from other elements.

    event.preventDefault(); // Input control needs to lose focus and by preventDefault above, it doesn't.

    event.target.focus();
    onChange(getAngle(centerX, centerY, event.clientX, event.clientY));
  };

  const {
    startDrag,
    isDragging
  } = useDragging({
    onDragStart: event => {
      setAngleCircleCenter();
      changeAngleToPosition(event);
    },
    onDragMove: changeAngleToPosition,
    onDragEnd: changeAngleToPosition
  });
  (0,react.useEffect)(() => {
    if (isDragging) {
      if (previousCursorValue.current === undefined) {
        previousCursorValue.current = document.body.style.cursor;
      }

      document.body.style.cursor = 'grabbing';
    } else {
      document.body.style.cursor = previousCursorValue.current || null;
      previousCursorValue.current = undefined;
    }
  }, [isDragging]);
  return (
    /* eslint-disable jsx-a11y/no-static-element-interactions */
    (0,react.createElement)(CircleRoot, (0,helpers_esm_extends/* default */.A)({
      ref: angleCircleRef,
      onMouseDown: startDrag,
      className: "components-angle-picker-control__angle-circle",
      style: isDragging ? {
        cursor: 'grabbing'
      } : undefined
    }, props), (0,react.createElement)(CircleIndicatorWrapper, {
      style: value ? {
        transform: `rotate(${value}deg)`
      } : undefined,
      className: "components-angle-picker-control__angle-circle-indicator-wrapper",
      tabIndex: -1
    }, (0,react.createElement)(CircleIndicator, {
      className: "components-angle-picker-control__angle-circle-indicator"
    })))
    /* eslint-enable jsx-a11y/no-static-element-interactions */

  );
}

function getAngle(centerX, centerY, pointX, pointY) {
  const y = pointY - centerY;
  const x = pointX - centerX;
  const angleInRadians = Math.atan2(y, x);
  const angleInDeg = Math.round(angleInRadians * (180 / Math.PI)) + 90;

  if (angleInDeg < 0) {
    return 360 + angleInDeg;
  }

  return angleInDeg;
}

/* harmony default export */ const angle_circle = (AngleCircle);
//# sourceMappingURL=angle-circle.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/angle-picker-control/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */








function AnglePickerControl(_ref) {
  let {
    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMarginBottom = false,
    className,
    label = (0,i18n_build_module.__)('Angle'),
    onChange,
    value
  } = _ref;

  const handleOnNumberChange = unprocessedValue => {
    const inputValue = unprocessedValue !== '' ? parseInt(unprocessedValue, 10) : 0;
    onChange(inputValue);
  };

  const classes = classnames_default()('components-angle-picker-control', className);
  return (0,react.createElement)(angle_picker_control_styles_Root, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    className: classes,
    gap: 4
  }, (0,react.createElement)(flex_block_component, null, (0,react.createElement)(number_control, {
    label: label,
    className: "components-angle-picker-control__input-field",
    max: 360,
    min: 0,
    onChange: handleOnNumberChange,
    size: "__unstable-large",
    step: "1",
    value: value,
    hideHTMLArrows: true,
    suffix: (0,react.createElement)(spacer_component, {
      as: text_component,
      marginBottom: 0,
      marginRight: space(3),
      style: {
        color: 'var( --wp-admin-theme-color )'
      }
    }, "\xB0")
  })), (0,react.createElement)(flex_item_component, {
    style: {
      marginBottom: space(1),
      marginTop: 'auto'
    }
  }, (0,react.createElement)(angle_circle, {
    "aria-hidden": "true",
    value: value,
    onChange: onChange
  })));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/constants.js
const GRADIENT_MARKERS_WIDTH = 16;
const INSERT_POINT_WIDTH = 16;
const MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_POINT = 10;
const MINIMUM_DISTANCE_BETWEEN_POINTS = 0;
const MINIMUM_SIGNIFICANT_MOVE = 5;
const KEYBOARD_CONTROL_POINT_VARIATION = MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_POINT;
const MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_MARKER = (INSERT_POINT_WIDTH + GRADIENT_MARKERS_WIDTH) / 2;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/utils.js
/**
 * Internal dependencies
 */

/**
 * Control point for the gradient bar.
 *
 * @typedef {Object} ControlPoint
 * @property {string} color    Color of the control point.
 * @property {number} position Integer position of the control point as a percentage.
 */

/**
 * Color as parsed from the gradient by gradient-parser.
 *
 * @typedef {Object} Color
 * @property {string} r   Red component.
 * @property {string} g   Green component.
 * @property {string} b   Green component.
 * @property {string} [a] Optional alpha component.
 */

/**
 * Clamps a number between 0 and 100.
 *
 * @param {number} value Value to clamp.
 *
 * @return {number} Value clamped between 0 and 100.
 */

function clampPercent(value) {
  return Math.max(0, Math.min(100, value));
}
/**
 * Check if a control point is overlapping with another.
 *
 * @param {ControlPoint[]} value        Array of control points.
 * @param {number}         initialIndex Index of the position to test.
 * @param {number}         newPosition  New position of the control point.
 * @param {number}         minDistance  Distance considered to be overlapping.
 *
 * @return {boolean} True if the point is overlapping.
 */

function isOverlapping(value, initialIndex, newPosition) {
  let minDistance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MINIMUM_DISTANCE_BETWEEN_POINTS;
  const initialPosition = value[initialIndex].position;
  const minPosition = Math.min(initialPosition, newPosition);
  const maxPosition = Math.max(initialPosition, newPosition);
  return value.some((_ref, index) => {
    let {
      position
    } = _ref;
    return index !== initialIndex && (Math.abs(position - newPosition) < minDistance || minPosition < position && position < maxPosition);
  });
}
/**
 * Adds a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         position Position to insert the new point.
 * @param {Color}          color    Color to update the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */

function addControlPoint(points, position, color) {
  const nextIndex = points.findIndex(point => point.position > position);
  const newPoint = {
    color,
    position
  };
  const newPoints = points.slice();
  newPoints.splice(nextIndex - 1, 0, newPoint);
  return newPoints;
}
/**
 * Removes a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points Array of control points.
 * @param {number}         index  Index to remove.
 *
 * @return {ControlPoint[]} New array of control points.
 */

function removeControlPoint(points, index) {
  return points.filter((point, pointIndex) => {
    return pointIndex !== index;
  });
}
/**
 * Updates a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         index    Index to update.
 * @param {ControlPoint[]} newPoint New control point to replace the index.
 *
 * @return {ControlPoint[]} New array of control points.
 */

function updateControlPoint(points, index, newPoint) {
  const newValue = points.slice();
  newValue[index] = newPoint;
  return newValue;
}
/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points      Array of control points.
 * @param {number}         index       Index to update.
 * @param {number}         newPosition Position to move the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */

function updateControlPointPosition(points, index, newPosition) {
  if (isOverlapping(points, index, newPosition)) {
    return points;
  }

  const newPoint = { ...points[index],
    position: newPosition
  };
  return updateControlPoint(points, index, newPoint);
}
/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         index    Index to update.
 * @param {Color}          newColor Color to update the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */

function updateControlPointColor(points, index, newColor) {
  const newPoint = { ...points[index],
    color: newColor
  };
  return updateControlPoint(points, index, newPoint);
}
/**
 * Updates the position of a control point from an array and returns the new array.
 *
 * @param {ControlPoint[]} points   Array of control points.
 * @param {number}         position Position of the color stop.
 * @param {string}         newColor Color to update the control point at index.
 *
 * @return {ControlPoint[]} New array of control points.
 */

function updateControlPointColorByPosition(points, position, newColor) {
  const index = points.findIndex(point => point.position === position);
  return updateControlPointColor(points, index, newColor);
}
/**
 * Gets the horizontal coordinate when dragging a control point with the mouse.
 *
 * @param {number}  mouseXCoordinate Horizontal coordinate of the mouse position.
 * @param {Element} containerElement Container for the gradient picker.
 *
 * @return {number} Whole number percentage from the left.
 */

function getHorizontalRelativeGradientPosition(mouseXCoordinate, containerElement) {
  if (!containerElement) {
    return;
  }

  const {
    x,
    width
  } = containerElement.getBoundingClientRect();
  const absolutePositionValue = mouseXCoordinate - x;
  return Math.round(clampPercent(absolutePositionValue * 100 / width));
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/control-points.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */









function ControlPointButton(_ref) {
  let {
    isOpen,
    position,
    color,
    ...additionalProps
  } = _ref;
  const instanceId = (0,use_instance_id/* default */.A)(ControlPointButton);
  const descriptionId = `components-custom-gradient-picker__control-point-button-description-${instanceId}`;
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(build_module_button, (0,helpers_esm_extends/* default */.A)({
    "aria-label": (0,i18n_build_module/* sprintf */.nv)( // translators: %1$s: gradient position e.g: 70, %2$s: gradient color code e.g: rgb(52,121,151).
    (0,i18n_build_module.__)('Gradient control point at position %1$s%% with color code %2$s.'), position, color),
    "aria-describedby": descriptionId,
    "aria-haspopup": "true",
    "aria-expanded": isOpen,
    className: classnames_default()('components-custom-gradient-picker__control-point-button', {
      'is-active': isOpen
    })
  }, additionalProps)), (0,react.createElement)(visually_hidden_component, {
    id: descriptionId
  }, (0,i18n_build_module.__)('Use your left or right arrow keys or drag and drop with the mouse to change the gradient position. Press the button to change the color or remove the control point.')));
}

function GradientColorPickerDropdown(_ref2) {
  let {
    isRenderedInSidebar,
    className,
    ...props
  } = _ref2;
  // Open the popover below the gradient control/insertion point
  const popoverProps = (0,react.useMemo)(() => ({
    placement: 'bottom',
    offset: 8
  }), []);
  const mergedClassName = classnames_default()('components-custom-gradient-picker__control-point-dropdown', className);
  return (0,react.createElement)(CustomColorPickerDropdown, (0,helpers_esm_extends/* default */.A)({
    isRenderedInSidebar: isRenderedInSidebar,
    popoverProps: popoverProps,
    className: mergedClassName
  }, props));
}

function ControlPoints(_ref3) {
  let {
    disableRemove,
    disableAlpha,
    gradientPickerDomRef,
    ignoreMarkerPosition,
    value: controlPoints,
    onChange,
    onStartControlPointChange,
    onStopControlPointChange,
    __experimentalIsRenderedInSidebar
  } = _ref3;
  const controlPointMoveState = (0,react.useRef)();

  const onMouseMove = event => {
    const relativePosition = getHorizontalRelativeGradientPosition(event.clientX, gradientPickerDomRef.current);
    const {
      initialPosition,
      index,
      significantMoveHappened
    } = controlPointMoveState.current;

    if (!significantMoveHappened && Math.abs(initialPosition - relativePosition) >= MINIMUM_SIGNIFICANT_MOVE) {
      controlPointMoveState.current.significantMoveHappened = true;
    }

    onChange(updateControlPointPosition(controlPoints, index, relativePosition));
  };

  const cleanEventListeners = () => {
    if (window && window.removeEventListener && controlPointMoveState.current && controlPointMoveState.current.listenersActivated) {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', cleanEventListeners);
      onStopControlPointChange();
      controlPointMoveState.current.listenersActivated = false;
    }
  }; // Adding `cleanEventListeners` to the dependency array below requires the function itself to be wrapped in a `useCallback`
  // This memoization would prevent the event listeners from being properly cleaned.
  // Instead, we'll pass a ref to the function in our `useEffect` so `cleanEventListeners` itself is no longer a dependency.


  const cleanEventListenersRef = (0,react.useRef)();
  cleanEventListenersRef.current = cleanEventListeners;
  (0,react.useEffect)(() => {
    return () => {
      cleanEventListenersRef.current();
    };
  }, []);
  return controlPoints.map((point, index) => {
    const initialPosition = point === null || point === void 0 ? void 0 : point.position;
    return ignoreMarkerPosition !== initialPosition && (0,react.createElement)(GradientColorPickerDropdown, {
      isRenderedInSidebar: __experimentalIsRenderedInSidebar,
      key: index,
      onClose: onStopControlPointChange,
      renderToggle: _ref4 => {
        let {
          isOpen,
          onToggle
        } = _ref4;
        return (0,react.createElement)(ControlPointButton, {
          key: index,
          onClick: () => {
            if (controlPointMoveState.current && controlPointMoveState.current.significantMoveHappened) {
              return;
            }

            if (isOpen) {
              onStopControlPointChange();
            } else {
              onStartControlPointChange();
            }

            onToggle();
          },
          onMouseDown: () => {
            if (window && window.addEventListener) {
              controlPointMoveState.current = {
                initialPosition,
                index,
                significantMoveHappened: false,
                listenersActivated: true
              };
              onStartControlPointChange();
              window.addEventListener('mousemove', onMouseMove);
              window.addEventListener('mouseup', cleanEventListeners);
            }
          },
          onKeyDown: event => {
            if (event.code === 'ArrowLeft') {
              // Stop propagation of the key press event to avoid focus moving
              // to another editor area.
              event.stopPropagation();
              onChange(updateControlPointPosition(controlPoints, index, clampPercent(point.position - KEYBOARD_CONTROL_POINT_VARIATION)));
            } else if (event.code === 'ArrowRight') {
              // Stop propagation of the key press event to avoid focus moving
              // to another editor area.
              event.stopPropagation();
              onChange(updateControlPointPosition(controlPoints, index, clampPercent(point.position + KEYBOARD_CONTROL_POINT_VARIATION)));
            }
          },
          isOpen: isOpen,
          position: point.position,
          color: point.color
        });
      },
      renderContent: _ref5 => {
        let {
          onClose
        } = _ref5;
        return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(LegacyAdapter, {
          enableAlpha: !disableAlpha,
          color: point.color,
          onChange: color => {
            onChange(updateControlPointColor(controlPoints, index, (0,node_modules_colord/* colord */.Mj)(color).toRgbString()));
          }
        }), !disableRemove && controlPoints.length > 2 && (0,react.createElement)(h_stack_component, {
          className: "components-custom-gradient-picker__remove-control-point-wrapper",
          alignment: "center"
        }, (0,react.createElement)(build_module_button, {
          onClick: () => {
            onChange(removeControlPoint(controlPoints, index));
            onClose();
          },
          variant: "link"
        }, (0,i18n_build_module.__)('Remove Control Point'))));
      },
      style: {
        left: `${point.position}%`,
        transform: 'translateX( -50% )'
      }
    });
  });
}

function InsertPoint(_ref6) {
  let {
    value: controlPoints,
    onChange,
    onOpenInserter,
    onCloseInserter,
    insertPosition,
    disableAlpha,
    __experimentalIsRenderedInSidebar
  } = _ref6;
  const [alreadyInsertedPoint, setAlreadyInsertedPoint] = (0,react.useState)(false);
  return (0,react.createElement)(GradientColorPickerDropdown, {
    isRenderedInSidebar: __experimentalIsRenderedInSidebar,
    className: "components-custom-gradient-picker__inserter",
    onClose: () => {
      onCloseInserter();
    },
    renderToggle: _ref7 => {
      let {
        isOpen,
        onToggle
      } = _ref7;
      return (0,react.createElement)(build_module_button, {
        "aria-expanded": isOpen,
        "aria-haspopup": "true",
        onClick: () => {
          if (isOpen) {
            onCloseInserter();
          } else {
            setAlreadyInsertedPoint(false);
            onOpenInserter();
          }

          onToggle();
        },
        className: "components-custom-gradient-picker__insert-point-dropdown",
        icon: library_plus
      });
    },
    renderContent: () => (0,react.createElement)(LegacyAdapter, {
      enableAlpha: !disableAlpha,
      onChange: color => {
        if (!alreadyInsertedPoint) {
          onChange(addControlPoint(controlPoints, insertPosition, (0,node_modules_colord/* colord */.Mj)(color).toRgbString()));
          setAlreadyInsertedPoint(true);
        } else {
          onChange(updateControlPointColorByPosition(controlPoints, insertPosition, (0,node_modules_colord/* colord */.Mj)(color).toRgbString()));
        }
      }
    }),
    style: insertPosition !== null ? {
      left: `${insertPosition}%`,
      transform: 'translateX( -50% )'
    } : undefined
  });
}

ControlPoints.InsertPoint = InsertPoint;
/* harmony default export */ const control_points = (ControlPoints);
//# sourceMappingURL=control-points.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/gradient-bar/index.js


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */





function customGradientBarReducer(state, action) {
  switch (action.type) {
    case 'MOVE_INSERTER':
      if (state.id === 'IDLE' || state.id === 'MOVING_INSERTER') {
        return {
          id: 'MOVING_INSERTER',
          insertPosition: action.insertPosition
        };
      }

      break;

    case 'STOP_INSERTER_MOVE':
      if (state.id === 'MOVING_INSERTER') {
        return {
          id: 'IDLE'
        };
      }

      break;

    case 'OPEN_INSERTER':
      if (state.id === 'MOVING_INSERTER') {
        return {
          id: 'INSERTING_CONTROL_POINT',
          insertPosition: state.insertPosition
        };
      }

      break;

    case 'CLOSE_INSERTER':
      if (state.id === 'INSERTING_CONTROL_POINT') {
        return {
          id: 'IDLE'
        };
      }

      break;

    case 'START_CONTROL_CHANGE':
      if (state.id === 'IDLE') {
        return {
          id: 'MOVING_CONTROL_POINT'
        };
      }

      break;

    case 'STOP_CONTROL_CHANGE':
      if (state.id === 'MOVING_CONTROL_POINT') {
        return {
          id: 'IDLE'
        };
      }

      break;
  }

  return state;
}

const customGradientBarReducerInitialState = {
  id: 'IDLE'
};
function CustomGradientBar(_ref) {
  let {
    background,
    hasGradient,
    value: controlPoints,
    onChange,
    disableInserter = false,
    disableAlpha = false,
    __experimentalIsRenderedInSidebar
  } = _ref;
  const gradientMarkersContainerDomRef = (0,react.useRef)();
  const [gradientBarState, gradientBarStateDispatch] = (0,react.useReducer)(customGradientBarReducer, customGradientBarReducerInitialState);

  const onMouseEnterAndMove = event => {
    const insertPosition = getHorizontalRelativeGradientPosition(event.clientX, gradientMarkersContainerDomRef.current); // If the insert point is close to an existing control point don't show it.

    if ((0,lodash.some)(controlPoints, _ref2 => {
      let {
        position
      } = _ref2;
      return Math.abs(insertPosition - position) < MINIMUM_DISTANCE_BETWEEN_INSERTER_AND_POINT;
    })) {
      if (gradientBarState.id === 'MOVING_INSERTER') {
        gradientBarStateDispatch({
          type: 'STOP_INSERTER_MOVE'
        });
      }

      return;
    }

    gradientBarStateDispatch({
      type: 'MOVE_INSERTER',
      insertPosition
    });
  };

  const onMouseLeave = () => {
    gradientBarStateDispatch({
      type: 'STOP_INSERTER_MOVE'
    });
  };

  const isMovingInserter = gradientBarState.id === 'MOVING_INSERTER';
  const isInsertingControlPoint = gradientBarState.id === 'INSERTING_CONTROL_POINT';
  return (0,react.createElement)("div", {
    className: classnames_default()('components-custom-gradient-picker__gradient-bar', {
      'has-gradient': hasGradient
    }),
    onMouseEnter: onMouseEnterAndMove,
    onMouseMove: onMouseEnterAndMove,
    style: {
      background
    },
    onMouseLeave: onMouseLeave
  }, (0,react.createElement)("div", {
    ref: gradientMarkersContainerDomRef,
    className: "components-custom-gradient-picker__markers-container"
  }, !disableInserter && (isMovingInserter || isInsertingControlPoint) && (0,react.createElement)(control_points.InsertPoint, {
    __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
    disableAlpha: disableAlpha,
    insertPosition: gradientBarState.insertPosition,
    value: controlPoints,
    onChange: onChange,
    onOpenInserter: () => {
      gradientBarStateDispatch({
        type: 'OPEN_INSERTER'
      });
    },
    onCloseInserter: () => {
      gradientBarStateDispatch({
        type: 'CLOSE_INSERTER'
      });
    }
  }), (0,react.createElement)(control_points, {
    __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
    disableAlpha: disableAlpha,
    disableRemove: disableInserter,
    gradientPickerDomRef: gradientMarkersContainerDomRef,
    ignoreMarkerPosition: isInsertingControlPoint ? gradientBarState.insertPosition : undefined,
    value: controlPoints,
    onChange: onChange,
    onStartControlPointChange: () => {
      gradientBarStateDispatch({
        type: 'START_CONTROL_CHANGE'
      });
    },
    onStopControlPointChange: () => {
      gradientBarStateDispatch({
        type: 'STOP_CONTROL_CHANGE'
      });
    }
  })));
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/gradient-parser@0.1.5/node_modules/gradient-parser/build/node.js
var node = __webpack_require__("../../node_modules/.pnpm/gradient-parser@0.1.5/node_modules/gradient-parser/build/node.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/constants.js
/**
 * WordPress dependencies
 */

const DEFAULT_GRADIENT = 'linear-gradient(135deg, rgba(6, 147, 227, 1) 0%, rgb(155, 81, 224) 100%)';
const DEFAULT_LINEAR_GRADIENT_ANGLE = 180;
const HORIZONTAL_GRADIENT_ORIENTATION = {
  type: 'angular',
  value: 90
};
const GRADIENT_OPTIONS = [{
  value: 'linear-gradient',
  label: (0,i18n_build_module.__)('Linear')
}, {
  value: 'radial-gradient',
  label: (0,i18n_build_module.__)('Radial')
}];
const DIRECTIONAL_ORIENTATION_ANGLE_MAP = {
  top: 0,
  'top right': 45,
  'right top': 45,
  right: 90,
  'right bottom': 135,
  'bottom right': 135,
  bottom: 180,
  'bottom left': 225,
  'left bottom': 225,
  left: 270,
  'top left': 315,
  'left top': 315
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/serializer.js
function serializeGradientColor(_ref) {
  let {
    type,
    value
  } = _ref;

  if (type === 'literal') {
    return value;
  }

  if (type === 'hex') {
    return `#${value}`;
  }

  return `${type}(${value.join(',')})`;
}
function serializeGradientPosition(position) {
  if (!position) {
    return '';
  }

  const {
    value,
    type
  } = position;
  return `${value}${type}`;
}
function serializeGradientColorStop(_ref2) {
  let {
    type,
    value,
    length
  } = _ref2;
  return `${serializeGradientColor({
    type,
    value
  })} ${serializeGradientPosition(length)}`;
}
function serializeGradientOrientation(orientation) {
  if (!orientation || orientation.type !== 'angular') {
    return;
  }

  return `${orientation.value}deg`;
}
function serializeGradient(_ref3) {
  let {
    type,
    orientation,
    colorStops
  } = _ref3;
  const serializedOrientation = serializeGradientOrientation(orientation);
  const serializedColorStops = colorStops.sort((colorStop1, colorStop2) => {
    var _colorStop1$length$va, _colorStop1$length, _colorStop2$length$va, _colorStop2$length;

    return ((_colorStop1$length$va = colorStop1 === null || colorStop1 === void 0 ? void 0 : (_colorStop1$length = colorStop1.length) === null || _colorStop1$length === void 0 ? void 0 : _colorStop1$length.value) !== null && _colorStop1$length$va !== void 0 ? _colorStop1$length$va : 0) - ((_colorStop2$length$va = colorStop2 === null || colorStop2 === void 0 ? void 0 : (_colorStop2$length = colorStop2.length) === null || _colorStop2$length === void 0 ? void 0 : _colorStop2$length.value) !== null && _colorStop2$length$va !== void 0 ? _colorStop2$length$va : 0);
  }).map(serializeGradientColorStop);
  return `${type}(${[serializedOrientation, ...serializedColorStops].filter(Boolean).join(',')})`;
}
//# sourceMappingURL=serializer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/utils.js
/**
 * External dependencies
 */



/**
 * Internal dependencies
 */



(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
function getLinearGradientRepresentation(gradientAST) {
  return serializeGradient({
    type: 'linear-gradient',
    orientation: HORIZONTAL_GRADIENT_ORIENTATION,
    colorStops: gradientAST.colorStops
  });
}

function hasUnsupportedLength(item) {
  return item.length === undefined || item.length.type !== '%';
}

function getGradientAstWithDefault(value) {
  var _gradientAST$orientat;

  // gradientAST will contain the gradient AST as parsed by gradient-parser npm module.
  // More information of its structure available at https://www.npmjs.com/package/gradient-parser#ast.
  let gradientAST;

  try {
    gradientAST = node.parse(value)[0];
    gradientAST.value = value;
  } catch (error) {
    gradientAST = node.parse(DEFAULT_GRADIENT)[0];
    gradientAST.value = DEFAULT_GRADIENT;
  }

  if (((_gradientAST$orientat = gradientAST.orientation) === null || _gradientAST$orientat === void 0 ? void 0 : _gradientAST$orientat.type) === 'directional') {
    gradientAST.orientation.type = 'angular';
    gradientAST.orientation.value = DIRECTIONAL_ORIENTATION_ANGLE_MAP[gradientAST.orientation.value].toString();
  }

  if (gradientAST.colorStops.some(hasUnsupportedLength)) {
    const {
      colorStops
    } = gradientAST;
    const step = 100 / (colorStops.length - 1);
    colorStops.forEach((stop, index) => {
      stop.length = {
        value: step * index,
        type: '%'
      };
    });
    gradientAST.value = serializeGradient(gradientAST);
  }

  return gradientAST;
}
function getGradientAstWithControlPoints(gradientAST, newControlPoints) {
  return { ...gradientAST,
    colorStops: newControlPoints.map(_ref => {
      let {
        position,
        color
      } = _ref;
      const {
        r,
        g,
        b,
        a
      } = (0,node_modules_colord/* colord */.Mj)(color).toRgb();
      return {
        length: {
          type: '%',
          value: position === null || position === void 0 ? void 0 : position.toString()
        },
        type: a < 1 ? 'rgba' : 'rgb',
        value: a < 1 ? [r, g, b, a] : [r, g, b]
      };
    })
  };
}
function getStopCssColor(colorStop) {
  switch (colorStop.type) {
    case 'hex':
      return `#${colorStop.value}`;

    case 'literal':
      return colorStop.value;

    case 'rgb':
    case 'rgba':
      return `${colorStop.type}(${colorStop.value.join(',')})`;

    default:
      // Should be unreachable if passing an AST from gradient-parser.
      // See https://github.com/rafaelcaricio/gradient-parser#ast.
      return 'transparent';
  }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/styles/custom-gradient-picker-styles.js


function custom_gradient_picker_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const SelectWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_block_component,  true ? {
  target: "e99xvul1"
} : 0)( true ? {
  name: "1gvx10y",
  styles: "flex-grow:5"
} : 0);
const AccessoryWrapper = /*#__PURE__*/(0,emotion_styled_base_browser_esm/* default */.A)(flex_block_component,  true ? {
  target: "e99xvul0"
} : 0)( true ? {
  name: "1gvx10y",
  styles: "flex-grow:5"
} : 0);
//# sourceMappingURL=custom-gradient-picker-styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/custom-gradient-picker/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */











const GradientAnglePicker = _ref => {
  var _gradientAST$orientat, _gradientAST$orientat2;

  let {
    gradientAST,
    hasGradient,
    onChange
  } = _ref;
  const angle = (_gradientAST$orientat = gradientAST === null || gradientAST === void 0 ? void 0 : (_gradientAST$orientat2 = gradientAST.orientation) === null || _gradientAST$orientat2 === void 0 ? void 0 : _gradientAST$orientat2.value) !== null && _gradientAST$orientat !== void 0 ? _gradientAST$orientat : DEFAULT_LINEAR_GRADIENT_ANGLE;

  const onAngleChange = newAngle => {
    onChange(serializeGradient({ ...gradientAST,
      orientation: {
        type: 'angular',
        value: newAngle
      }
    }));
  };

  return (0,react.createElement)(AnglePickerControl, {
    __nextHasNoMarginBottom: true,
    onChange: onAngleChange,
    labelPosition: "top",
    value: hasGradient ? angle : ''
  });
};

const GradientTypePicker = _ref2 => {
  let {
    gradientAST,
    hasGradient,
    onChange
  } = _ref2;
  const {
    type
  } = gradientAST;

  const onSetLinearGradient = () => {
    onChange(serializeGradient({ ...gradientAST,
      ...(gradientAST.orientation ? {} : {
        orientation: HORIZONTAL_GRADIENT_ORIENTATION
      }),
      type: 'linear-gradient'
    }));
  };

  const onSetRadialGradient = () => {
    const {
      orientation,
      ...restGradientAST
    } = gradientAST;
    onChange(serializeGradient({ ...restGradientAST,
      type: 'radial-gradient'
    }));
  };

  const handleOnChange = next => {
    if (next === 'linear-gradient') {
      onSetLinearGradient();
    }

    if (next === 'radial-gradient') {
      onSetRadialGradient();
    }
  };

  return (0,react.createElement)(select_control, {
    __nextHasNoMarginBottom: true,
    className: "components-custom-gradient-picker__type-picker",
    label: (0,i18n_build_module.__)('Type'),
    labelPosition: "top",
    onChange: handleOnChange,
    options: GRADIENT_OPTIONS,
    size: "__unstable-large",
    value: hasGradient && type
  });
};

function CustomGradientPicker(_ref3) {
  let {
    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMargin = false,
    value,
    onChange,
    __experimentalIsRenderedInSidebar
  } = _ref3;
  const gradientAST = getGradientAstWithDefault(value); // On radial gradients the bar should display a linear gradient.
  // On radial gradients the bar represents a slice of the gradient from the center until the outside.
  // On liner gradients the bar represents the color stops from left to right independently of the angle.

  const background = getLinearGradientRepresentation(gradientAST);
  const hasGradient = gradientAST.value !== DEFAULT_GRADIENT; // Control points color option may be hex from presets, custom colors will be rgb.
  // The position should always be a percentage.

  const controlPoints = gradientAST.colorStops.map(colorStop => ({
    color: getStopCssColor(colorStop),
    position: parseInt(colorStop.length.value)
  }));
  return (0,react.createElement)(v_stack_component, {
    spacing: 5,
    className: classnames_default()('components-custom-gradient-picker', {
      'is-next-has-no-margin': __nextHasNoMargin
    })
  }, (0,react.createElement)(CustomGradientBar, {
    __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
    background: background,
    hasGradient: hasGradient,
    value: controlPoints,
    onChange: newControlPoints => {
      onChange(serializeGradient(getGradientAstWithControlPoints(gradientAST, newControlPoints)));
    }
  }), (0,react.createElement)(flex_component, {
    gap: 3,
    className: "components-custom-gradient-picker__ui-line"
  }, (0,react.createElement)(SelectWrapper, null, (0,react.createElement)(GradientTypePicker, {
    gradientAST: gradientAST,
    hasGradient: hasGradient,
    onChange: onChange
  })), (0,react.createElement)(AccessoryWrapper, null, gradientAST.type === 'linear-gradient' && (0,react.createElement)(GradientAnglePicker, {
    gradientAST: gradientAST,
    hasGradient: hasGradient,
    onChange: onChange
  }))));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/gradient-picker/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */







function SingleOrigin(_ref) {
  let {
    className,
    clearGradient,
    gradients,
    onChange,
    value,
    actions,
    content
  } = _ref;
  const gradientOptions = (0,react.useMemo)(() => {
    return (0,lodash.map)(gradients, _ref2 => {
      let {
        gradient,
        name
      } = _ref2;
      return (0,react.createElement)(CircularOptionPicker.Option, {
        key: gradient,
        value: gradient,
        isSelected: value === gradient,
        tooltipText: name || // translators: %s: gradient code e.g: "linear-gradient(90deg, rgba(98,16,153,1) 0%, rgba(172,110,22,1) 100%);".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Gradient code: %s'), gradient),
        style: {
          color: 'rgba( 0,0,0,0 )',
          background: gradient
        },
        onClick: value === gradient ? clearGradient : () => onChange(gradient),
        "aria-label": name ? // translators: %s: The name of the gradient e.g: "Angular red to blue".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Gradient: %s'), name) : // translators: %s: gradient code e.g: "linear-gradient(90deg, rgba(98,16,153,1) 0%, rgba(172,110,22,1) 100%);".
        (0,i18n_build_module/* sprintf */.nv)((0,i18n_build_module.__)('Gradient code: %s'), gradient)
      });
    });
  }, [gradients, value, onChange, clearGradient]);
  return (0,react.createElement)(CircularOptionPicker, {
    className: className,
    options: gradientOptions,
    actions: actions
  }, content);
}

function MultipleOrigin(_ref3) {
  let {
    className,
    clearGradient,
    gradients,
    onChange,
    value,
    actions,
    content
  } = _ref3;
  return (0,react.createElement)(v_stack_component, {
    spacing: 3,
    className: className
  }, gradients.map((_ref4, index) => {
    let {
      name,
      gradients: gradientSet
    } = _ref4;
    return (0,react.createElement)(v_stack_component, {
      spacing: 2,
      key: index
    }, (0,react.createElement)(ColorHeading, null, name), (0,react.createElement)(SingleOrigin, (0,helpers_esm_extends/* default */.A)({
      clearGradient: clearGradient,
      gradients: gradientSet,
      onChange: onChange,
      value: value
    }, gradients.length === index + 1 ? {
      actions,
      content
    } : {})));
  }));
}

function GradientPicker(_ref5) {
  let {
    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMargin = false,
    className,
    gradients,
    onChange,
    value,
    clearable = true,
    disableCustomGradients = false,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar
  } = _ref5;
  const clearGradient = (0,react.useCallback)(() => onChange(undefined), [onChange]);
  const Component = __experimentalHasMultipleOrigins && gradients !== null && gradients !== void 0 && gradients.length ? MultipleOrigin : SingleOrigin; // Can be removed when deprecation period is over

  const deprecatedMarginSpacerProps = !__nextHasNoMargin ? {
    marginTop: 3
  } : {};
  return (0,react.createElement)(Component, {
    className: className,
    clearable: clearable,
    clearGradient: clearGradient,
    gradients: gradients,
    onChange: onChange,
    value: value,
    actions: clearable && ((gradients === null || gradients === void 0 ? void 0 : gradients.length) || !disableCustomGradients) && (0,react.createElement)(CircularOptionPicker.ButtonAction, {
      onClick: clearGradient
    }, (0,i18n_build_module.__)('Clear')),
    content: !disableCustomGradients && (0,react.createElement)(spacer_component, (0,helpers_esm_extends/* default */.A)({
      marginTop: gradients !== null && gradients !== void 0 && gradients.length ? 3 : 0,
      marginBottom: 0
    }, deprecatedMarginSpacerProps), (0,react.createElement)(CustomGradientPicker, {
      __nextHasNoMargin: __nextHasNoMargin,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      value: value,
      onChange: onChange
    }))
  });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/colors-gradients/control.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


const colorsAndGradientKeys = ['colors', 'disableCustomColors', 'gradients', 'disableCustomGradients'];
const TAB_COLOR = {
  name: 'color',
  title: 'Solid',
  value: 'color'
};
const TAB_GRADIENT = {
  name: 'gradient',
  title: 'Gradient',
  value: 'gradient'
};
const TABS_SETTINGS = [TAB_COLOR, TAB_GRADIENT];

function ColorGradientControlInner(_ref) {
  let {
    colors,
    gradients,
    disableCustomColors,
    disableCustomGradients,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    className,
    label,
    onColorChange,
    onGradientChange,
    colorValue,
    gradientValue,
    clearable,
    showTitle = true,
    enableAlpha
  } = _ref;
  const canChooseAColor = onColorChange && (!(0,lodash.isEmpty)(colors) || !disableCustomColors);
  const canChooseAGradient = onGradientChange && (!(0,lodash.isEmpty)(gradients) || !disableCustomGradients);

  if (!canChooseAColor && !canChooseAGradient) {
    return null;
  }

  const tabPanels = {
    [TAB_COLOR.value]: (0,react.createElement)(ColorPalette, {
      value: colorValue,
      onChange: canChooseAGradient ? newColor => {
        onColorChange(newColor);
        onGradientChange();
      } : onColorChange,
      colors,
      disableCustomColors,
      __experimentalHasMultipleOrigins: __experimentalHasMultipleOrigins,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: clearable,
      enableAlpha: enableAlpha
    }),
    [TAB_GRADIENT.value]: (0,react.createElement)(GradientPicker, {
      value: gradientValue,
      onChange: canChooseAColor ? newGradient => {
        onGradientChange(newGradient);
        onColorChange();
      } : onGradientChange,
      gradients,
      disableCustomGradients,
      __experimentalHasMultipleOrigins: __experimentalHasMultipleOrigins,
      __experimentalIsRenderedInSidebar: __experimentalIsRenderedInSidebar,
      clearable: clearable
    })
  };

  const renderPanelType = type => (0,react.createElement)("div", {
    className: "block-editor-color-gradient-control__panel"
  }, tabPanels[type]);

  return (0,react.createElement)(base_control, {
    __nextHasNoMarginBottom: true,
    className: classnames_default()('block-editor-color-gradient-control', className)
  }, (0,react.createElement)("fieldset", {
    className: "block-editor-color-gradient-control__fieldset"
  }, (0,react.createElement)(v_stack_component, {
    spacing: 1
  }, showTitle && (0,react.createElement)("legend", null, (0,react.createElement)("div", {
    className: "block-editor-color-gradient-control__color-indicator"
  }, (0,react.createElement)(base_control.VisualLabel, null, label))), canChooseAColor && canChooseAGradient && (0,react.createElement)(TabPanel, {
    className: "block-editor-color-gradient-control__tabs",
    tabs: TABS_SETTINGS,
    initialTabName: gradientValue ? TAB_GRADIENT.value : !!canChooseAColor && TAB_COLOR.value
  }, tab => renderPanelType(tab.value)), !canChooseAGradient && renderPanelType(TAB_COLOR.value), !canChooseAColor && renderPanelType(TAB_GRADIENT.value))));
}

function ColorGradientControlSelect(props) {
  const colorGradientSettings = {};
  colorGradientSettings.colors = use_setting_useSetting('color.palette');
  colorGradientSettings.gradients = use_setting_useSetting('color.gradients');
  colorGradientSettings.disableCustomColors = !use_setting_useSetting('color.custom');
  colorGradientSettings.disableCustomGradients = !use_setting_useSetting('color.customGradient');
  return (0,react.createElement)(ColorGradientControlInner, (0,esm_extends/* default */.A)({}, colorGradientSettings, props));
}

function ColorGradientControl(props) {
  if ((0,lodash.every)(colorsAndGradientKeys, key => props.hasOwnProperty(key))) {
    return (0,react.createElement)(ColorGradientControlInner, props);
  }

  return (0,react.createElement)(ColorGradientControlSelect, props);
}

/* harmony default export */ const control = (ColorGradientControl);
//# sourceMappingURL=control.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/colors-gradients/dropdown.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

 // When the `ColorGradientSettingsDropdown` controls are being rendered to a
// `ToolsPanel` they must be wrapped in a `ToolsPanelItem`.

const WithToolsPanelItem = _ref => {
  let {
    setting,
    children,
    panelId,
    ...props
  } = _ref;

  const clearValue = () => {
    if (setting.colorValue) {
      setting.onColorChange();
    } else if (setting.gradientValue) {
      setting.onGradientChange();
    }
  };

  return (0,react.createElement)(tools_panel_item_component, (0,esm_extends/* default */.A)({
    hasValue: () => {
      return !!setting.colorValue || !!setting.gradientValue;
    },
    label: setting.label,
    onDeselect: clearValue,
    isShownByDefault: setting.isShownByDefault !== undefined ? setting.isShownByDefault : true
  }, props, {
    className: "block-editor-tools-panel-color-gradient-settings__item",
    panelId: panelId // Pass resetAllFilter if supplied due to rendering via SlotFill
    // into parent ToolsPanel.
    ,
    resetAllFilter: setting.resetAllFilter
  }), children);
};

const LabeledColorIndicator = _ref2 => {
  let {
    colorValue,
    label
  } = _ref2;
  return (0,react.createElement)(h_stack_component, {
    justify: "flex-start"
  }, (0,react.createElement)(color_indicator, {
    className: "block-editor-panel-color-gradient-settings__color-indicator",
    colorValue: colorValue
  }), (0,react.createElement)(flex_item_component, {
    className: "block-editor-panel-color-gradient-settings__color-name",
    title: label
  }, label));
}; // Renders a color dropdown's toggle as an `Item` if it is within an `ItemGroup`
// or as a `Button` if it isn't e.g. the controls are being rendered in
// a `ToolsPanel`.


const renderToggle = settings => _ref3 => {
  let {
    onToggle,
    isOpen
  } = _ref3;
  const {
    colorValue,
    label
  } = settings;
  const toggleProps = {
    onClick: onToggle,
    className: classnames_default()('block-editor-panel-color-gradient-settings__dropdown', {
      'is-open': isOpen
    }),
    'aria-expanded': isOpen
  };
  return (0,react.createElement)(build_module_button, toggleProps, (0,react.createElement)(LabeledColorIndicator, {
    colorValue: colorValue,
    label: label
  }));
}; // Renders a collection of color controls as dropdowns. Depending upon the
// context in which these dropdowns are being rendered, they may be wrapped
// in an `ItemGroup` with each dropdown's toggle as an `Item`, or alternatively,
// the may be individually wrapped in a `ToolsPanelItem` with the toggle as
// a regular `Button`.
//
// For more context see: https://github.com/WordPress/gutenberg/pull/40084


function ColorGradientSettingsDropdown(_ref4) {
  let {
    colors,
    disableCustomColors,
    disableCustomGradients,
    enableAlpha,
    gradients,
    settings,
    __experimentalHasMultipleOrigins,
    __experimentalIsRenderedInSidebar,
    ...props
  } = _ref4;
  let popoverProps;

  if (__experimentalIsRenderedInSidebar) {
    popoverProps = {
      placement: 'left-start',
      offset: 36,
      __unstableShift: true
    };
  }

  return (0,react.createElement)(react.Fragment, null, settings.map((setting, index) => {
    var _setting$gradientValu;

    const controlProps = {
      clearable: false,
      colorValue: setting.colorValue,
      colors,
      disableCustomColors,
      disableCustomGradients,
      enableAlpha,
      gradientValue: setting.gradientValue,
      gradients,
      label: setting.label,
      onColorChange: setting.onColorChange,
      onGradientChange: setting.onGradientChange,
      showTitle: false,
      __experimentalHasMultipleOrigins,
      __experimentalIsRenderedInSidebar,
      ...setting
    };
    const toggleSettings = {
      colorValue: (_setting$gradientValu = setting.gradientValue) !== null && _setting$gradientValu !== void 0 ? _setting$gradientValu : setting.colorValue,
      label: setting.label
    };
    return setting && // If not in an `ItemGroup` wrap the dropdown in a
    // `ToolsPanelItem`
    (0,react.createElement)(WithToolsPanelItem, (0,esm_extends/* default */.A)({
      key: index,
      setting: setting
    }, props), (0,react.createElement)(Dropdown, {
      popoverProps: popoverProps,
      className: "block-editor-tools-panel-color-gradient-settings__dropdown",
      renderToggle: renderToggle(toggleSettings),
      renderContent: () => (0,react.createElement)(dropdown_content_wrapper, {
        paddingSize: "none"
      }, (0,react.createElement)("div", {
        className: "block-editor-panel-color-gradient-settings__dropdown-content"
      }, (0,react.createElement)(control, controlProps)))
    }));
  }));
}
//# sourceMappingURL=dropdown.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/serialize.js
var build_module_serialize = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/serialize.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/notice/index.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */


/** @typedef {import('@wordpress/element').WPElement} WPElement */

const notice_noop = () => {};
/**
 * Custom hook which announces the message with the given politeness, if a
 * valid message is provided.
 *
 * @param {string|WPElement}     [message]  Message to announce.
 * @param {'polite'|'assertive'} politeness Politeness to announce.
 */


function useSpokenMessage(message, politeness) {
  const spokenMessage = typeof message === 'string' ? message : (0,build_module_serialize/* default */.Ay)(message);
  (0,react.useEffect)(() => {
    if (spokenMessage) {
      speak(spokenMessage, politeness);
    }
  }, [spokenMessage, politeness]);
}
/**
 * Given a notice status, returns an assumed default politeness for the status.
 * Defaults to 'assertive'.
 *
 * @param {string} [status] Notice status.
 *
 * @return {'polite'|'assertive'} Notice politeness.
 */


function getDefaultPoliteness(status) {
  switch (status) {
    case 'success':
    case 'warning':
    case 'info':
      return 'polite';

    case 'error':
    default:
      return 'assertive';
  }
}

function Notice(_ref) {
  let {
    className,
    status = 'info',
    children,
    spokenMessage = children,
    onRemove = notice_noop,
    isDismissible = true,
    actions = [],
    politeness = getDefaultPoliteness(status),
    __unstableHTML,
    // onDismiss is a callback executed when the notice is dismissed.
    // It is distinct from onRemove, which _looks_ like a callback but is
    // actually the function to call to remove the notice from the UI.
    onDismiss = notice_noop
  } = _ref;
  useSpokenMessage(spokenMessage, politeness);
  const classes = classnames_default()(className, 'components-notice', 'is-' + status, {
    'is-dismissible': isDismissible
  });

  if (__unstableHTML) {
    children = (0,react.createElement)(raw_html/* default */.A, null, children);
  }

  const onDismissNotice = event => {
    var _event$preventDefault;

    event === null || event === void 0 ? void 0 : (_event$preventDefault = event.preventDefault) === null || _event$preventDefault === void 0 ? void 0 : _event$preventDefault.call(event);
    onDismiss();
    onRemove();
  };

  return (0,react.createElement)("div", {
    className: classes
  }, (0,react.createElement)("div", {
    className: "components-notice__content"
  }, children, (0,react.createElement)("div", {
    className: "components-notice__actions"
  }, actions.map((_ref2, index) => {
    let {
      className: buttonCustomClasses,
      label,
      isPrimary,
      variant,
      noDefaultClasses = false,
      onClick,
      url
    } = _ref2;
    let computedVariant = variant;

    if (variant !== 'primary' && !noDefaultClasses) {
      computedVariant = !url ? 'secondary' : 'link';
    }

    if (typeof computedVariant === 'undefined' && isPrimary) {
      computedVariant = 'primary';
    }

    return (0,react.createElement)(build_module_button, {
      key: index,
      href: url,
      variant: computedVariant,
      onClick: url ? undefined : onClick,
      className: classnames_default()('components-notice__action', buttonCustomClasses)
    }, label);
  }))), isDismissible && (0,react.createElement)(build_module_button, {
    className: "components-notice__dismiss",
    icon: library_close/* default */.A,
    label: (0,i18n_build_module.__)('Dismiss this notice'),
    onClick: onDismissNotice,
    showTooltip: false
  }));
}

/* harmony default export */ const notice = (Notice);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/contrast-checker/index.js


/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */




(0,node_modules_colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);

function ContrastChecker(_ref) {
  let {
    backgroundColor,
    fallbackBackgroundColor,
    fallbackTextColor,
    fallbackLinkColor,
    fontSize,
    // Font size value in pixels.
    isLargeText,
    textColor,
    linkColor,
    enableAlphaChecker = false
  } = _ref;
  const currentBackgroundColor = backgroundColor || fallbackBackgroundColor; // Must have a background color.

  if (!currentBackgroundColor) {
    return null;
  }

  const currentTextColor = textColor || fallbackTextColor;
  const currentLinkColor = linkColor || fallbackLinkColor; // Must have at least one text color.

  if (!currentTextColor && !currentLinkColor) {
    return null;
  }

  const textColors = [{
    color: currentTextColor,
    description: (0,_wordpress_i18n_build_module.__)('text color')
  }, {
    color: currentLinkColor,
    description: (0,_wordpress_i18n_build_module.__)('link color')
  }];
  const colordBackgroundColor = (0,node_modules_colord/* colord */.Mj)(currentBackgroundColor);
  const backgroundColorHasTransparency = colordBackgroundColor.alpha() < 1;
  const backgroundColorBrightness = colordBackgroundColor.brightness();
  const isReadableOptions = {
    level: 'AA',
    size: isLargeText || isLargeText !== false && fontSize >= 24 ? 'large' : 'small'
  };
  let message = '';
  let speakMessage = '';

  for (const item of textColors) {
    // If there is no color, go no further.
    if (!item.color) {
      continue;
    }

    const colordTextColor = (0,node_modules_colord/* colord */.Mj)(item.color);
    const isColordTextReadable = colordTextColor.isReadable(colordBackgroundColor, isReadableOptions);
    const textHasTransparency = colordTextColor.alpha() < 1; // If the contrast is not readable.

    if (!isColordTextReadable) {
      // Don't show the message if the background or text is transparent.
      if (backgroundColorHasTransparency || textHasTransparency) {
        continue;
      }

      message = backgroundColorBrightness < colordTextColor.brightness() ? (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s is a type of text color, e.g., "text color" or "link color".
      (0,_wordpress_i18n_build_module.__)('This color combination may be hard for people to read. Try using a darker background color and/or a brighter %s.'), item.description) : (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s is a type of text color, e.g., "text color" or "link color".
      (0,_wordpress_i18n_build_module.__)('This color combination may be hard for people to read. Try using a brighter background color and/or a darker %s.'), item.description);
      speakMessage = (0,_wordpress_i18n_build_module.__)('This color combination may be hard for people to read.'); // Break from the loop when we have a contrast warning.
      // These messages take priority over the transparency warning.

      break;
    } // If there is no contrast warning and the text is transparent,
    // show the transparent warning if alpha check is enabled.


    if (textHasTransparency && enableAlphaChecker) {
      message = (0,_wordpress_i18n_build_module.__)('Transparent text may be hard for people to read.');
      speakMessage = (0,_wordpress_i18n_build_module.__)('Transparent text may be hard for people to read.');
    }
  }

  if (!message) {
    return null;
  } // Note: The `Notice` component can speak messages via its `spokenMessage`
  // prop, but the contrast checker requires granular control over when the
  // announcements are made. Notably, the message will be re-announced if a
  // new color combination is selected and the contrast is still insufficient.


  speak(speakMessage);
  return (0,react.createElement)("div", {
    className: "block-editor-contrast-checker"
  }, (0,react.createElement)(notice, {
    spokenMessage: null,
    status: "warning",
    isDismissible: false
  }, message));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/contrast-checker/README.md
 */


/* harmony default export */ const contrast_checker = (ContrastChecker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/color-panel.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */







function color_panel_getComputedStyle(node) {
  return node.ownerDocument.defaultView.getComputedStyle(node);
}

function ColorPanel(_ref) {
  let {
    enableAlpha = false,
    settings,
    clientId,
    enableContrastChecking = true
  } = _ref;
  const [detectedBackgroundColor, setDetectedBackgroundColor] = (0,react.useState)();
  const [detectedColor, setDetectedColor] = (0,react.useState)();
  const [detectedLinkColor, setDetectedLinkColor] = (0,react.useState)();
  const ref = useBlockRef(clientId);
  (0,react.useEffect)(() => {
    var _ref$current;

    if (!enableContrastChecking) {
      return;
    }

    if (!ref.current) {
      return;
    }

    setDetectedColor(color_panel_getComputedStyle(ref.current).color);
    const firstLinkElement = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.querySelector('a');

    if (firstLinkElement && !!firstLinkElement.innerText) {
      setDetectedLinkColor(color_panel_getComputedStyle(firstLinkElement).color);
    }

    let backgroundColorNode = ref.current;
    let backgroundColor = color_panel_getComputedStyle(backgroundColorNode).backgroundColor;

    while (backgroundColor === 'rgba(0, 0, 0, 0)' && backgroundColorNode.parentNode && backgroundColorNode.parentNode.nodeType === backgroundColorNode.parentNode.ELEMENT_NODE) {
      backgroundColorNode = backgroundColorNode.parentNode;
      backgroundColor = color_panel_getComputedStyle(backgroundColorNode).backgroundColor;
    }

    setDetectedBackgroundColor(backgroundColor);
  });
  const colorGradientSettings = use_multiple_origin_colors_and_gradients_useMultipleOriginColorsAndGradients();
  return (0,react.createElement)(inspector_controls, {
    __experimentalGroup: "color"
  }, (0,react.createElement)(ColorGradientSettingsDropdown, (0,esm_extends/* default */.A)({
    enableAlpha: enableAlpha,
    panelId: clientId,
    settings: settings,
    __experimentalIsItemGroup: false,
    __experimentalHasMultipleOrigins: true,
    __experimentalIsRenderedInSidebar: true
  }, colorGradientSettings)), enableContrastChecking && (0,react.createElement)(contrast_checker, {
    backgroundColor: detectedBackgroundColor,
    textColor: detectedColor,
    enableAlphaChecker: enableAlpha,
    linkColor: detectedLinkColor
  }));
}
//# sourceMappingURL=color-panel.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/color.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */






const COLOR_SUPPORT_KEY = 'color';

const hasColorSupport = blockType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && (colorSupport.link === true || colorSupport.gradient === true || colorSupport.background !== false || colorSupport.text !== false);
};

const hasLinkColorSupport = blockType => {
  if (platform.OS !== 'web') {
    return false;
  }

  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.link;
};

const hasGradientSupport = blockType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport !== null && typeof colorSupport === 'object' && !!colorSupport.gradients;
};

const hasBackgroundColorSupport = blockType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.background !== false;
};

const hasTextColorSupport = blockType => {
  const colorSupport = (0,build_module/* getBlockSupport */.bI)(blockType, COLOR_SUPPORT_KEY);
  return colorSupport && colorSupport.text !== false;
};
/**
 * Clears a single color property from a style object.
 *
 * @param {Array}  path  Path to color property to clear within styles object.
 * @param {Object} style Block attributes style object.
 * @return {Object} Styles with the color property omitted.
 */


const clearColorFromStyles = (path, style) => cleanEmptyObject(immutableSet(style, path, undefined));
/**
 * Clears text color related properties from supplied attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Update block attributes with text color properties omitted.
 */


const resetAllTextFilter = attributes => ({
  textColor: undefined,
  style: clearColorFromStyles(['color', 'text'], attributes.style)
});
/**
 * Clears link color related properties from supplied attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Update block attributes with link color properties omitted.
 */


const resetAllLinkFilter = attributes => ({
  style: clearColorFromStyles(['elements', 'link', 'color', 'text'], attributes.style)
});
/**
 * Clears all background color related properties including gradients from
 * supplied block attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Block attributes with background and gradient omitted.
 */


const clearBackgroundAndGradient = attributes => {
  var _attributes$style;

  return {
    backgroundColor: undefined,
    gradient: undefined,
    style: { ...attributes.style,
      color: { ...((_attributes$style = attributes.style) === null || _attributes$style === void 0 ? void 0 : _attributes$style.color),
        background: undefined,
        gradient: undefined
      }
    }
  };
};
/**
 * Filters registered block settings, extending attributes to include
 * `backgroundColor` and `textColor` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function color_addAttributes(settings) {
  if (!hasColorSupport(settings)) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default values if needed.


  if (!settings.attributes.backgroundColor) {
    Object.assign(settings.attributes, {
      backgroundColor: {
        type: 'string'
      }
    });
  }

  if (!settings.attributes.textColor) {
    Object.assign(settings.attributes, {
      textColor: {
        type: 'string'
      }
    });
  }

  if (hasGradientSupport(settings) && !settings.attributes.gradient) {
    Object.assign(settings.attributes, {
      gradient: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject colors classnames.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */


function color_addSaveProps(props, blockType, attributes) {
  var _style$color, _style$color2, _style$color3, _style$color4, _style$elements, _style$elements$link;

  if (!hasColorSupport(blockType) || shouldSkipSerialization(blockType, COLOR_SUPPORT_KEY)) {
    return props;
  }

  const hasGradient = hasGradientSupport(blockType); // I'd have preferred to avoid the "style" attribute usage here

  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes;

  const shouldSerialize = feature => !shouldSkipSerialization(blockType, COLOR_SUPPORT_KEY, feature); // Primary color classes must come before the `has-text-color`,
  // `has-background` and `has-link-color` classes to maintain backwards
  // compatibility and avoid block invalidations.


  const textClass = shouldSerialize('text') ? utils_getColorClassName('color', textColor) : undefined;
  const gradientClass = shouldSerialize('gradients') ? use_gradient_experimentalGetGradientClass(gradient) : undefined;
  const backgroundClass = shouldSerialize('background') ? utils_getColorClassName('background-color', backgroundColor) : undefined;
  const serializeHasBackground = shouldSerialize('background') || shouldSerialize('gradients');
  const hasBackground = backgroundColor || (style === null || style === void 0 ? void 0 : (_style$color = style.color) === null || _style$color === void 0 ? void 0 : _style$color.background) || hasGradient && (gradient || (style === null || style === void 0 ? void 0 : (_style$color2 = style.color) === null || _style$color2 === void 0 ? void 0 : _style$color2.gradient));
  const newClassName = classnames_default()(props.className, textClass, gradientClass, {
    // Don't apply the background class if there's a custom gradient.
    [backgroundClass]: (!hasGradient || !(style !== null && style !== void 0 && (_style$color3 = style.color) !== null && _style$color3 !== void 0 && _style$color3.gradient)) && !!backgroundClass,
    'has-text-color': shouldSerialize('text') && (textColor || (style === null || style === void 0 ? void 0 : (_style$color4 = style.color) === null || _style$color4 === void 0 ? void 0 : _style$color4.text)),
    'has-background': serializeHasBackground && hasBackground,
    'has-link-color': shouldSerialize('link') && (style === null || style === void 0 ? void 0 : (_style$elements = style.elements) === null || _style$elements === void 0 ? void 0 : (_style$elements$link = _style$elements.link) === null || _style$elements$link === void 0 ? void 0 : _style$elements$link.color)
  });
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to extend the block edit wrapper
 * to apply the desired styles and classnames properly.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function color_addEditProps(settings) {
  if (!hasColorSupport(settings) || shouldSkipSerialization(settings, COLOR_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return color_addSaveProps(props, settings, attributes);
  };

  return settings;
}

const getLinkColorFromAttributeValue = (colors, value) => {
  const attributeParsed = /var:preset\|color\|(.+)/.exec(value);

  if (attributeParsed && attributeParsed[1]) {
    return utils_getColorObjectByAttributeValues(colors, attributeParsed[1]).color;
  }

  return value;
};
/**
 * Inspector control panel containing the color related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Color edit element.
 */


function ColorEdit(props) {
  var _style$color6, _style$color7, _style$color8, _style$elements2, _style$elements2$link, _style$elements2$link2, _style$elements3, _style$elements3$link, _style$elements3$link2;

  const {
    name: blockName,
    attributes
  } = props; // Some color settings have a special handling for deprecated flags in `useSetting`,
  // so we can't unwrap them by doing const { ... } = useSetting('color')
  // until https://github.com/WordPress/gutenberg/issues/37094 is fixed.

  const userPalette = use_setting_useSetting('color.palette.custom');
  const themePalette = use_setting_useSetting('color.palette.theme');
  const defaultPalette = use_setting_useSetting('color.palette.default');
  const allSolids = (0,react.useMemo)(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);
  const userGradientPalette = use_setting_useSetting('color.gradients.custom');
  const themeGradientPalette = use_setting_useSetting('color.gradients.theme');
  const defaultGradientPalette = use_setting_useSetting('color.gradients.default');
  const allGradients = (0,react.useMemo)(() => [...(userGradientPalette || []), ...(themeGradientPalette || []), ...(defaultGradientPalette || [])], [userGradientPalette, themeGradientPalette, defaultGradientPalette]);
  const areCustomSolidsEnabled = use_setting_useSetting('color.custom');
  const areCustomGradientsEnabled = use_setting_useSetting('color.customGradient');
  const isBackgroundEnabled = use_setting_useSetting('color.background');
  const isLinkEnabled = use_setting_useSetting('color.link');
  const isTextEnabled = use_setting_useSetting('color.text');
  const solidsEnabled = areCustomSolidsEnabled || !themePalette || (themePalette === null || themePalette === void 0 ? void 0 : themePalette.length) > 0;
  const gradientsEnabled = areCustomGradientsEnabled || !themeGradientPalette || (themeGradientPalette === null || themeGradientPalette === void 0 ? void 0 : themeGradientPalette.length) > 0; // Shouldn't be needed but right now the ColorGradientsPanel
  // can trigger both onChangeColor and onChangeBackground
  // synchronously causing our two callbacks to override changes
  // from each other.

  const localAttributes = (0,react.useRef)(attributes);
  (0,react.useEffect)(() => {
    localAttributes.current = attributes;
  }, [attributes]);

  if (!hasColorSupport(blockName)) {
    return null;
  }

  const hasLinkColor = hasLinkColorSupport(blockName) && isLinkEnabled && solidsEnabled;
  const hasTextColor = hasTextColorSupport(blockName) && isTextEnabled && solidsEnabled;
  const hasBackgroundColor = hasBackgroundColorSupport(blockName) && isBackgroundEnabled && solidsEnabled;
  const hasGradientColor = hasGradientSupport(blockName) && gradientsEnabled;

  if (!hasLinkColor && !hasTextColor && !hasBackgroundColor && !hasGradientColor) {
    return null;
  }

  const {
    style,
    textColor,
    backgroundColor,
    gradient
  } = attributes;
  let gradientValue;

  if (hasGradientColor && gradient) {
    gradientValue = use_gradient_getGradientValueBySlug(allGradients, gradient);
  } else if (hasGradientColor) {
    var _style$color5;

    gradientValue = style === null || style === void 0 ? void 0 : (_style$color5 = style.color) === null || _style$color5 === void 0 ? void 0 : _style$color5.gradient;
  }

  const onChangeColor = name => value => {
    var _localAttributes$curr, _localAttributes$curr2;

    const colorObject = getColorObjectByColorValue(allSolids, value);
    const attributeName = name + 'Color';
    const newStyle = { ...localAttributes.current.style,
      color: { ...((_localAttributes$curr = localAttributes.current) === null || _localAttributes$curr === void 0 ? void 0 : (_localAttributes$curr2 = _localAttributes$curr.style) === null || _localAttributes$curr2 === void 0 ? void 0 : _localAttributes$curr2.color),
        [name]: colorObject !== null && colorObject !== void 0 && colorObject.slug ? undefined : value
      }
    };
    const newNamedColor = colorObject !== null && colorObject !== void 0 && colorObject.slug ? colorObject.slug : undefined;
    const newAttributes = {
      style: cleanEmptyObject(newStyle),
      [attributeName]: newNamedColor
    };
    props.setAttributes(newAttributes);
    localAttributes.current = { ...localAttributes.current,
      ...newAttributes
    };
  };

  const onChangeGradient = value => {
    const slug = getGradientSlugByValue(allGradients, value);
    let newAttributes;

    if (slug) {
      var _localAttributes$curr3, _localAttributes$curr4, _localAttributes$curr5;

      const newStyle = { ...((_localAttributes$curr3 = localAttributes.current) === null || _localAttributes$curr3 === void 0 ? void 0 : _localAttributes$curr3.style),
        color: { ...((_localAttributes$curr4 = localAttributes.current) === null || _localAttributes$curr4 === void 0 ? void 0 : (_localAttributes$curr5 = _localAttributes$curr4.style) === null || _localAttributes$curr5 === void 0 ? void 0 : _localAttributes$curr5.color),
          gradient: undefined
        }
      };
      newAttributes = {
        style: cleanEmptyObject(newStyle),
        gradient: slug
      };
    } else {
      var _localAttributes$curr6, _localAttributes$curr7, _localAttributes$curr8;

      const newStyle = { ...((_localAttributes$curr6 = localAttributes.current) === null || _localAttributes$curr6 === void 0 ? void 0 : _localAttributes$curr6.style),
        color: { ...((_localAttributes$curr7 = localAttributes.current) === null || _localAttributes$curr7 === void 0 ? void 0 : (_localAttributes$curr8 = _localAttributes$curr7.style) === null || _localAttributes$curr8 === void 0 ? void 0 : _localAttributes$curr8.color),
          gradient: value
        }
      };
      newAttributes = {
        style: cleanEmptyObject(newStyle),
        gradient: undefined
      };
    }

    props.setAttributes(newAttributes);
    localAttributes.current = { ...localAttributes.current,
      ...newAttributes
    };
  };

  const onChangeLinkColor = value => {
    var _localAttributes$curr9;

    const colorObject = getColorObjectByColorValue(allSolids, value);
    const newLinkColorValue = colorObject !== null && colorObject !== void 0 && colorObject.slug ? `var:preset|color|${colorObject.slug}` : value;
    const newStyle = cleanEmptyObject(immutableSet((_localAttributes$curr9 = localAttributes.current) === null || _localAttributes$curr9 === void 0 ? void 0 : _localAttributes$curr9.style, ['elements', 'link', 'color', 'text'], newLinkColorValue));
    props.setAttributes({
      style: newStyle
    });
    localAttributes.current = { ...localAttributes.current,
      ...{
        style: newStyle
      }
    };
  };

  const defaultColorControls = (0,build_module/* getBlockSupport */.bI)(props.name, [COLOR_SUPPORT_KEY, '__experimentalDefaultControls']);
  const enableContrastChecking = platform.OS === 'web' && !gradient && !(style !== null && style !== void 0 && (_style$color6 = style.color) !== null && _style$color6 !== void 0 && _style$color6.gradient) && // Contrast checking is enabled by default.
  // Deactivating it requires `enableContrastChecker` to have
  // an explicit value of `false`.
  false !== (0,build_module/* getBlockSupport */.bI)(props.name, [COLOR_SUPPORT_KEY, 'enableContrastChecker']);
  return (0,react.createElement)(ColorPanel, {
    enableContrastChecking: enableContrastChecking,
    clientId: props.clientId,
    enableAlpha: true,
    settings: [...(hasTextColor ? [{
      label: (0,_wordpress_i18n_build_module.__)('Text'),
      onColorChange: onChangeColor('text'),
      colorValue: utils_getColorObjectByAttributeValues(allSolids, textColor, style === null || style === void 0 ? void 0 : (_style$color7 = style.color) === null || _style$color7 === void 0 ? void 0 : _style$color7.text).color,
      isShownByDefault: defaultColorControls === null || defaultColorControls === void 0 ? void 0 : defaultColorControls.text,
      resetAllFilter: resetAllTextFilter
    }] : []), ...(hasBackgroundColor || hasGradientColor ? [{
      label: (0,_wordpress_i18n_build_module.__)('Background'),
      onColorChange: hasBackgroundColor ? onChangeColor('background') : undefined,
      colorValue: utils_getColorObjectByAttributeValues(allSolids, backgroundColor, style === null || style === void 0 ? void 0 : (_style$color8 = style.color) === null || _style$color8 === void 0 ? void 0 : _style$color8.background).color,
      gradientValue,
      onGradientChange: hasGradientColor ? onChangeGradient : undefined,
      isShownByDefault: defaultColorControls === null || defaultColorControls === void 0 ? void 0 : defaultColorControls.background,
      resetAllFilter: clearBackgroundAndGradient
    }] : []), ...(hasLinkColor ? [{
      label: (0,_wordpress_i18n_build_module.__)('Link'),
      onColorChange: onChangeLinkColor,
      colorValue: getLinkColorFromAttributeValue(allSolids, style === null || style === void 0 ? void 0 : (_style$elements2 = style.elements) === null || _style$elements2 === void 0 ? void 0 : (_style$elements2$link = _style$elements2.link) === null || _style$elements2$link === void 0 ? void 0 : (_style$elements2$link2 = _style$elements2$link.color) === null || _style$elements2$link2 === void 0 ? void 0 : _style$elements2$link2.text),
      clearable: !!(style !== null && style !== void 0 && (_style$elements3 = style.elements) !== null && _style$elements3 !== void 0 && (_style$elements3$link = _style$elements3.link) !== null && _style$elements3$link !== void 0 && (_style$elements3$link2 = _style$elements3$link.color) !== null && _style$elements3$link2 !== void 0 && _style$elements3$link2.text),
      isShownByDefault: defaultColorControls === null || defaultColorControls === void 0 ? void 0 : defaultColorControls.link,
      resetAllFilter: resetAllLinkFilter
    }] : [])]
  });
}
/**
 * This adds inline styles for color palette colors.
 * Ideally, this is not needed and themes should load their palettes on the editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withColorPaletteStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  var _props$wrapperProps;

  const {
    name,
    attributes
  } = props;
  const {
    backgroundColor,
    textColor
  } = attributes;
  const userPalette = use_setting_useSetting('color.palette.custom') || [];
  const themePalette = use_setting_useSetting('color.palette.theme') || [];
  const defaultPalette = use_setting_useSetting('color.palette.default') || [];
  const colors = (0,react.useMemo)(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);

  if (!hasColorSupport(name) || shouldSkipSerialization(name, COLOR_SUPPORT_KEY)) {
    return (0,react.createElement)(BlockListBlock, props);
  }

  const extraStyles = {};

  if (textColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, 'text')) {
    var _getColorObjectByAttr;

    extraStyles.color = (_getColorObjectByAttr = utils_getColorObjectByAttributeValues(colors, textColor)) === null || _getColorObjectByAttr === void 0 ? void 0 : _getColorObjectByAttr.color;
  }

  if (backgroundColor && !shouldSkipSerialization(name, COLOR_SUPPORT_KEY, 'background')) {
    var _getColorObjectByAttr2;

    extraStyles.backgroundColor = (_getColorObjectByAttr2 = utils_getColorObjectByAttributeValues(colors, backgroundColor)) === null || _getColorObjectByAttr2 === void 0 ? void 0 : _getColorObjectByAttr2.color;
  }

  let wrapperProps = props.wrapperProps;
  wrapperProps = { ...props.wrapperProps,
    style: { ...extraStyles,
      ...((_props$wrapperProps = props.wrapperProps) === null || _props$wrapperProps === void 0 ? void 0 : _props$wrapperProps.style)
    }
  };
  return (0,react.createElement)(BlockListBlock, (0,esm_extends/* default */.A)({}, props, {
    wrapperProps: wrapperProps
  }));
});
const MIGRATION_PATHS = {
  linkColor: [['style', 'elements', 'link', 'color', 'text']],
  textColor: [['textColor'], ['style', 'color', 'text']],
  backgroundColor: [['backgroundColor'], ['style', 'color', 'background']],
  gradient: [['gradient'], ['style', 'color', 'gradient']]
};
function color_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    linkColor: hasLinkColorSupport(destinationBlockType),
    textColor: hasTextColorSupport(destinationBlockType),
    backgroundColor: hasBackgroundColorSupport(destinationBlockType),
    gradient: hasGradientSupport(destinationBlockType)
  };
  return transformStyles(activeSupports, MIGRATION_PATHS, result, source, index, results);
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/color/addAttribute', color_addAttributes);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/color/addSaveProps', color_addSaveProps);
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/color/addEditProps', color_addEditProps);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/color/with-color-palette-styles', withColorPaletteStyles);
(0,hooks_build_module/* addFilter */.U2)('blocks.switchToBlockType.transformedBlock', 'core/color/addTransforms', color_addTransforms);
//# sourceMappingURL=color.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/font-appearance-control/index.js



/**
 * WordPress dependencies
 */



const FONT_STYLES = [{
  name: (0,_wordpress_i18n_build_module._x)('Regular', 'font style'),
  value: 'normal'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Italic', 'font style'),
  value: 'italic'
}];
const FONT_WEIGHTS = [{
  name: (0,_wordpress_i18n_build_module._x)('Thin', 'font weight'),
  value: '100'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Extra Light', 'font weight'),
  value: '200'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Light', 'font weight'),
  value: '300'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Regular', 'font weight'),
  value: '400'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Medium', 'font weight'),
  value: '500'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Semi Bold', 'font weight'),
  value: '600'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Bold', 'font weight'),
  value: '700'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Extra Bold', 'font weight'),
  value: '800'
}, {
  name: (0,_wordpress_i18n_build_module._x)('Black', 'font weight'),
  value: '900'
}];
/**
 * Adjusts font appearance field label in case either font styles or weights
 * are disabled.
 *
 * @param {boolean} hasFontStyles  Whether font styles are enabled and present.
 * @param {boolean} hasFontWeights Whether font weights are enabled and present.
 * @return {string} A label representing what font appearance is being edited.
 */

const getFontAppearanceLabel = (hasFontStyles, hasFontWeights) => {
  if (!hasFontStyles) {
    return (0,_wordpress_i18n_build_module.__)('Font weight');
  }

  if (!hasFontWeights) {
    return (0,_wordpress_i18n_build_module.__)('Font style');
  }

  return (0,_wordpress_i18n_build_module.__)('Appearance');
};
/**
 * Control to display unified font style and weight options.
 *
 * @param {Object} props Component props.
 *
 * @return {WPElement} Font appearance control.
 */

function FontAppearanceControl(props) {
  const {
    onChange,
    hasFontStyles = true,
    hasFontWeights = true,
    value: {
      fontStyle,
      fontWeight
    },
    ...otherProps
  } = props;
  const hasStylesOrWeights = hasFontStyles || hasFontWeights;
  const label = getFontAppearanceLabel(hasFontStyles, hasFontWeights);
  const defaultOption = {
    key: 'default',
    name: (0,_wordpress_i18n_build_module.__)('Default'),
    style: {
      fontStyle: undefined,
      fontWeight: undefined
    }
  }; // Combines both font style and weight options into a single dropdown.

  const combineOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(_ref => {
      let {
        name: styleName,
        value: styleValue
      } = _ref;
      FONT_WEIGHTS.forEach(_ref2 => {
        let {
          name: weightName,
          value: weightValue
        } = _ref2;
        const optionName = styleValue === 'normal' ? weightName : (0,_wordpress_i18n_build_module/* sprintf */.nv)(
        /* translators: 1: Font weight name. 2: Font style name. */
        (0,_wordpress_i18n_build_module.__)('%1$s %2$s'), weightName, styleName);
        combinedOptions.push({
          key: `${styleValue}-${weightValue}`,
          name: optionName,
          style: {
            fontStyle: styleValue,
            fontWeight: weightValue
          }
        });
      });
    });
    return combinedOptions;
  }; // Generates select options for font styles only.


  const styleOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_STYLES.forEach(_ref3 => {
      let {
        name,
        value
      } = _ref3;
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: value,
          fontWeight: undefined
        }
      });
    });
    return combinedOptions;
  }; // Generates select options for font weights only.


  const weightOptions = () => {
    const combinedOptions = [defaultOption];
    FONT_WEIGHTS.forEach(_ref4 => {
      let {
        name,
        value
      } = _ref4;
      combinedOptions.push({
        key: value,
        name,
        style: {
          fontStyle: undefined,
          fontWeight: value
        }
      });
    });
    return combinedOptions;
  }; // Map font styles and weights to select options.


  const selectOptions = (0,react.useMemo)(() => {
    if (hasFontStyles && hasFontWeights) {
      return combineOptions();
    }

    return hasFontStyles ? styleOptions() : weightOptions();
  }, [props.options]); // Find current selection by comparing font style & weight against options,
  // and fall back to the Default option if there is no matching option.

  const currentSelection = selectOptions.find(option => option.style.fontStyle === fontStyle && option.style.fontWeight === fontWeight) || selectOptions[0]; // Adjusts screen reader description based on styles or weights.

  const getDescribedBy = () => {
    if (!currentSelection) {
      return (0,_wordpress_i18n_build_module.__)('No selected font appearance');
    }

    if (!hasFontStyles) {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: Currently selected font weight.
      (0,_wordpress_i18n_build_module.__)('Currently selected font weight: %s'), currentSelection.name);
    }

    if (!hasFontWeights) {
      return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: Currently selected font style.
      (0,_wordpress_i18n_build_module.__)('Currently selected font style: %s'), currentSelection.name);
    }

    return (0,_wordpress_i18n_build_module/* sprintf */.nv)( // translators: %s: Currently selected font appearance.
    (0,_wordpress_i18n_build_module.__)('Currently selected font appearance: %s'), currentSelection.name);
  };

  return hasStylesOrWeights && (0,react.createElement)(CustomSelectControl, (0,esm_extends/* default */.A)({}, otherProps, {
    className: "components-font-appearance-control",
    label: label,
    describedBy: getDescribedBy(),
    options: selectOptions,
    value: currentSelection,
    onChange: _ref5 => {
      let {
        selectedItem
      } = _ref5;
      return onChange(selectedItem.style);
    },
    __nextUnconstrainedWidth: true
  }));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/line-height-control/utils.js
const BASE_DEFAULT_VALUE = 1.5;
const STEP = 0.1;
/**
 * There are varying value types within LineHeightControl:
 *
 * {undefined} Initial value. No changes from the user.
 * {string} Input value. Value consumed/outputted by the input. Empty would be ''.
 * {number} Block attribute type. Input value needs to be converted for attribute setting.
 *
 * Note: If the value is undefined, the input requires it to be an empty string ('')
 * in order to be considered "controlled" by props (rather than internal state).
 */

const RESET_VALUE = '';
/**
 * Determines if the lineHeight attribute has been properly defined.
 *
 * @param {any} lineHeight The value to check.
 *
 * @return {boolean} Whether the lineHeight attribute is valid.
 */

function isLineHeightDefined(lineHeight) {
  return lineHeight !== undefined && lineHeight !== RESET_VALUE;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/line-height-control/index.js



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



const LineHeightControl = _ref => {
  let {
    value: lineHeight,
    onChange,

    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMarginBottom = false,
    __unstableInputWidth = '60px',
    ...otherProps
  } = _ref;
  const isDefined = isLineHeightDefined(lineHeight);

  const adjustNextValue = (nextValue, wasTypedOrPasted) => {
    // Set the next value without modification if lineHeight has been defined.
    if (isDefined) return nextValue;
    /**
     * The following logic handles the initial step up/down action
     * (from an undefined value state) so that the next values are better suited for
     * line-height rendering. For example, the first step up should immediately
     * go to 1.6, rather than the normally expected 0.1.
     *
     * Step up/down actions can be triggered by keydowns of the up/down arrow keys,
     * or by clicking the spin buttons.
     */

    switch (`${nextValue}`) {
      case `${STEP}`:
        // Increment by step value.
        return BASE_DEFAULT_VALUE + STEP;

      case '0':
        {
          // This means the user explicitly input '0', rather than stepped down
          // from an undefined value state.
          if (wasTypedOrPasted) return nextValue; // Decrement by step value.

          return BASE_DEFAULT_VALUE - STEP;
        }

      case '':
        return BASE_DEFAULT_VALUE;

      default:
        return nextValue;
    }
  };

  const stateReducer = (state, action) => {
    var _action$payload$event;

    // Be careful when changing this — cross-browser behavior of the
    // `inputType` field in `input` events are inconsistent.
    // For example, Firefox emits an input event with inputType="insertReplacementText"
    // on spin button clicks, while other browsers do not even emit an input event.
    const wasTypedOrPasted = ['insertText', 'insertFromPaste'].includes((_action$payload$event = action.payload.event.nativeEvent) === null || _action$payload$event === void 0 ? void 0 : _action$payload$event.inputType);
    const value = adjustNextValue(state.value, wasTypedOrPasted);
    return { ...state,
      value
    };
  };

  const value = isDefined ? lineHeight : RESET_VALUE;

  if (!__nextHasNoMarginBottom) {
    (0,deprecated_build_module/* default */.A)('Bottom margin styles for wp.blockEditor.LineHeightControl', {
      since: '6.0',
      version: '6.4',
      hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version'
    });
  }

  const deprecatedStyles = __nextHasNoMarginBottom ? undefined : {
    marginBottom: 24
  };
  return (0,react.createElement)("div", {
    className: "block-editor-line-height-control",
    style: deprecatedStyles
  }, (0,react.createElement)(number_control, (0,esm_extends/* default */.A)({}, otherProps, {
    __unstableInputWidth: __unstableInputWidth,
    __unstableStateReducer: stateReducer,
    onChange: onChange,
    label: (0,_wordpress_i18n_build_module.__)('Line height'),
    placeholder: BASE_DEFAULT_VALUE,
    step: STEP,
    value: value,
    min: 0
  })));
};
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/line-height-control/README.md
 */


/* harmony default export */ const line_height_control = (LineHeightControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/line-height.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const LINE_HEIGHT_SUPPORT_KEY = 'typography.lineHeight';
/**
 * Inspector control panel containing the line height related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Line height edit element.
 */

function LineHeightEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  const onChange = newLineHeightValue => {
    const newStyle = { ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        lineHeight: newLineHeightValue
      }
    };
    setAttributes({
      style: cleanEmptyObject(newStyle)
    });
  };

  return (0,react.createElement)(line_height_control, {
    __unstableInputWidth: "100%",
    __nextHasNoMarginBottom: true,
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.lineHeight,
    onChange: onChange
  });
}
/**
 * Custom hook that checks if line-height settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsLineHeightDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const isDisabled = !use_setting_useSetting('typography.lineHeight');
  return !(0,build_module/* hasBlockSupport */.pN)(blockName, LINE_HEIGHT_SUPPORT_KEY) || isDisabled;
}
/**
 * Checks if there is a current value set for the line height block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a line height value set.
 */

function hasLineHeightValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return !!((_props$attributes$sty = props.attributes.style) !== null && _props$attributes$sty !== void 0 && (_props$attributes$sty2 = _props$attributes$sty.typography) !== null && _props$attributes$sty2 !== void 0 && _props$attributes$sty2.lineHeight);
}
/**
 * Resets the line height block support attribute. This can be used when
 * disabling the line height support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetLineHeight(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        lineHeight: undefined
      }
    })
  });
}
//# sourceMappingURL=line-height.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/font-appearance.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' support array indicating support for font style.
 */

const FONT_STYLE_SUPPORT_KEY = 'typography.__experimentalFontStyle';
/**
 * Key within block settings' support array indicating support for font weight.
 */

const FONT_WEIGHT_SUPPORT_KEY = 'typography.__experimentalFontWeight';
/**
 * Inspector control panel containing the font appearance options.
 *
 * @param {Object} props Block properties.
 *
 * @return {WPElement} Font appearance edit element.
 */

function FontAppearanceEdit(props) {
  var _style$typography, _style$typography2;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;
  const hasFontStyles = !useIsFontStyleDisabled(props);
  const hasFontWeights = !useIsFontWeightDisabled(props);

  const onChange = newStyles => {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          fontStyle: newStyles.fontStyle,
          fontWeight: newStyles.fontWeight
        }
      })
    });
  };

  const fontStyle = style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.fontStyle;
  const fontWeight = style === null || style === void 0 ? void 0 : (_style$typography2 = style.typography) === null || _style$typography2 === void 0 ? void 0 : _style$typography2.fontWeight;
  return (0,react.createElement)(FontAppearanceControl, {
    onChange: onChange,
    hasFontStyles: hasFontStyles,
    hasFontWeights: hasFontWeights,
    value: {
      fontStyle,
      fontWeight
    }
  });
}
/**
 * Checks if font style support has been disabled either by not opting in for
 * support or by failing to provide preset styles.
 *
 * @param {Object} props      Block properties.
 * @param {string} props.name Name for the block type.
 *
 * @return {boolean} Whether font style support has been disabled.
 */

function useIsFontStyleDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const styleSupport = (0,build_module/* hasBlockSupport */.pN)(blockName, FONT_STYLE_SUPPORT_KEY);
  const hasFontStyles = use_setting_useSetting('typography.fontStyle');
  return !styleSupport || !hasFontStyles;
}
/**
 * Checks if font weight support has been disabled either by not opting in for
 * support or by failing to provide preset weights.
 *
 * @param {Object} props      Block properties.
 * @param {string} props.name Name for the block type.
 *
 * @return {boolean} Whether font weight support has been disabled.
 */

function useIsFontWeightDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const weightSupport = (0,build_module/* hasBlockSupport */.pN)(blockName, FONT_WEIGHT_SUPPORT_KEY);
  const hasFontWeights = use_setting_useSetting('typography.fontWeight');
  return !weightSupport || !hasFontWeights;
}
/**
 * Checks if font appearance support has been disabled.
 *
 * @param {Object} props Block properties.
 *
 * @return {boolean} Whether font appearance support has been disabled.
 */

function useIsFontAppearanceDisabled(props) {
  const stylesDisabled = useIsFontStyleDisabled(props);
  const weightsDisabled = useIsFontWeightDisabled(props);
  return stylesDisabled && weightsDisabled;
}
/**
 * Checks if there is either a font style or weight value set within the
 * typography styles.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a font style or weight.
 */

function hasFontAppearanceValue(props) {
  var _props$attributes$sty;

  const {
    fontStyle,
    fontWeight
  } = ((_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : _props$attributes$sty.typography) || {};
  return !!fontStyle || !!fontWeight;
}
/**
 * Resets the font style and weight block support attributes. This can be used
 * when disabling the font appearance support controls for a block via a
 * progressive discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetFontAppearance(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        fontStyle: undefined,
        fontWeight: undefined
      }
    })
  });
}
//# sourceMappingURL=font-appearance.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/font-family/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


function FontFamilyControl(_ref) {
  let {
    value = '',
    onChange,
    fontFamilies,
    ...props
  } = _ref;
  const blockLevelFontFamilies = use_setting_useSetting('typography.fontFamilies');

  if (!fontFamilies) {
    fontFamilies = blockLevelFontFamilies;
  }

  if ((0,lodash.isEmpty)(fontFamilies)) {
    return null;
  }

  const options = [{
    value: '',
    label: (0,_wordpress_i18n_build_module.__)('Default')
  }, ...fontFamilies.map(_ref2 => {
    let {
      fontFamily,
      name
    } = _ref2;
    return {
      value: fontFamily,
      label: name || fontFamily
    };
  })];
  return (0,react.createElement)(select_control, (0,esm_extends/* default */.A)({
    label: (0,_wordpress_i18n_build_module.__)('Font'),
    options: options,
    value: value,
    onChange: onChange,
    labelPosition: "top"
  }, props));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/font-family.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const FONT_FAMILY_SUPPORT_KEY = 'typography.__experimentalFontFamily';
/**
 * Filters registered block settings, extending attributes to include
 * the `fontFamily` attribute.
 *
 * @param {Object} settings Original block settings
 * @return {Object}         Filtered block settings
 */

function font_family_addAttributes(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  } // Allow blocks to specify a default value if needed.


  if (!settings.attributes.fontFamily) {
    Object.assign(settings.attributes, {
      fontFamily: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject font family.
 *
 * @param {Object} props      Additional props applied to save element
 * @param {Object} blockType  Block type
 * @param {Object} attributes Block attributes
 * @return {Object}           Filtered props applied to save element
 */


function font_family_addSaveProps(props, blockType, attributes) {
  if (!(0,build_module/* hasBlockSupport */.pN)(blockType, FONT_FAMILY_SUPPORT_KEY)) {
    return props;
  }

  if (shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'fontFamily')) {
    return props;
  }

  if (!(attributes !== null && attributes !== void 0 && attributes.fontFamily)) {
    return props;
  } // Use TokenList to dedupe classes.


  const classes = new TokenList(props.className);
  classes.add(`has-${(0,lodash.kebabCase)(attributes === null || attributes === void 0 ? void 0 : attributes.fontFamily)}-font-family`);
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to expand the block edit wrapper
 * by applying the desired styles and classnames.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function font_family_addEditProps(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, FONT_FAMILY_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return font_family_addSaveProps(props, settings, attributes);
  };

  return settings;
}

function FontFamilyEdit(_ref) {
  var _find;

  let {
    setAttributes,
    attributes: {
      fontFamily
    }
  } = _ref;
  const fontFamilies = use_setting_useSetting('typography.fontFamilies');
  const value = (_find = (0,lodash.find)(fontFamilies, _ref2 => {
    let {
      slug
    } = _ref2;
    return fontFamily === slug;
  })) === null || _find === void 0 ? void 0 : _find.fontFamily;

  function onChange(newValue) {
    const predefinedFontFamily = (0,lodash.find)(fontFamilies, _ref3 => {
      let {
        fontFamily: f
      } = _ref3;
      return f === newValue;
    });
    setAttributes({
      fontFamily: predefinedFontFamily === null || predefinedFontFamily === void 0 ? void 0 : predefinedFontFamily.slug
    });
  }

  return (0,react.createElement)(FontFamilyControl, {
    className: "block-editor-hooks-font-family-control",
    fontFamilies: fontFamilies,
    value: value,
    onChange: onChange
  });
}
/**
 * Custom hook that checks if font-family functionality is disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsFontFamilyDisabled(_ref4) {
  let {
    name
  } = _ref4;
  const fontFamilies = use_setting_useSetting('typography.fontFamilies');
  return !fontFamilies || fontFamilies.length === 0 || !(0,build_module/* hasBlockSupport */.pN)(name, FONT_FAMILY_SUPPORT_KEY);
}
/**
 * Checks if there is a current value set for the font family block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a font family value set.
 */

function hasFontFamilyValue(props) {
  return !!props.attributes.fontFamily;
}
/**
 * Resets the font family block support attribute. This can be used when
 * disabling the font family support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetFontFamily(_ref5) {
  let {
    setAttributes
  } = _ref5;
  setAttributes({
    fontFamily: undefined
  });
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/fontFamily/addAttribute', font_family_addAttributes);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/fontFamily/addSaveProps', font_family_addSaveProps);
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/fontFamily/addEditProps', font_family_addEditProps);
//# sourceMappingURL=font-family.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/font-sizes/utils.js
/**
 * External dependencies
 */

/**
 *  Returns the font size object based on an array of named font sizes and the namedFontSize and customFontSize values.
 * 	If namedFontSize is undefined or not found in fontSizes an object with just the size value based on customFontSize is returned.
 *
 * @param {Array}   fontSizes               Array of font size objects containing at least the "name" and "size" values as properties.
 * @param {?string} fontSizeAttribute       Content of the font size attribute (slug).
 * @param {?number} customFontSizeAttribute Contents of the custom font size attribute (value).
 *
 * @return {?Object} If fontSizeAttribute is set and an equal slug is found in fontSizes it returns the font size object for that slug.
 * 					 Otherwise, an object with just the size value based on customFontSize is returned.
 */

const utils_getFontSize = (fontSizes, fontSizeAttribute, customFontSizeAttribute) => {
  if (fontSizeAttribute) {
    const fontSizeObject = (0,lodash.find)(fontSizes, {
      slug: fontSizeAttribute
    });

    if (fontSizeObject) {
      return fontSizeObject;
    }
  }

  return {
    size: customFontSizeAttribute
  };
};
/**
 * Returns the corresponding font size object for a given value.
 *
 * @param {Array}  fontSizes Array of font size objects.
 * @param {number} value     Font size value.
 *
 * @return {Object} Font size object.
 */

function getFontSizeObjectByValue(fontSizes, value) {
  const fontSizeObject = (0,lodash.find)(fontSizes, {
    size: value
  });

  if (fontSizeObject) {
    return fontSizeObject;
  }

  return {
    size: value
  };
}
/**
 * Returns a class based on fontSizeName.
 *
 * @param {string} fontSizeSlug Slug of the fontSize.
 *
 * @return {string} String with the class corresponding to the fontSize passed.
 *                  The class is generated by appending 'has-' followed by fontSizeSlug in kebabCase and ending with '-font-size'.
 */

function getFontSizeClass(fontSizeSlug) {
  if (!fontSizeSlug) {
    return;
  }

  return `has-${(0,lodash.kebabCase)(fontSizeSlug)}-font-size`;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Radio/RadioState.js













function useRadioState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var _useSealedState = (0,useSealedState/* useSealedState */.N)(initialState),
      initialValue = _useSealedState.state,
      _useSealedState$loop = _useSealedState.loop,
      loop = _useSealedState$loop === void 0 ? true : _useSealedState$loop,
      sealed = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_useSealedState, ["state", "loop"]);

  var _React$useState = (0,react.useState)(initialValue),
      state = _React$useState[0],
      setState = _React$useState[1];

  var composite = (0,CompositeState/* useCompositeState */.A)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, sealed), {}, {
    loop: loop
  }));
  return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({}, composite), {}, {
    state: state,
    setState: setState
  });
}



// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-system@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-system/es/useCreateElement.js
var useCreateElement = __webpack_require__("../../node_modules/.pnpm/reakit-system@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-system/es/useCreateElement.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/__keys-d251e56b.js
// Automatically generated
var RADIO_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "state", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget", "setState"];
var RADIO_KEYS = [].concat(RADIO_STATE_KEYS, ["value", "checked", "unstable_checkOnFocus"]);
var RADIO_GROUP_KEYS = RADIO_STATE_KEYS;



;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Radio/RadioGroup.js































var useRadioGroup = (0,createHook/* createHook */.a)({
  name: "RadioGroup",
  compose: Composite/* useComposite */.T,
  keys: RADIO_GROUP_KEYS,
  useProps: function useProps(_, htmlProps) {
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      role: "radiogroup"
    }, htmlProps);
  }
});
var RadioGroup = (0,createComponent/* createComponent */.a)({
  as: "div",
  useHook: useRadioGroup,
  useCreateElement: function useCreateElement$1(type, props, children) {
     false ? 0 : void 0;
    return (0,useCreateElement/* useCreateElement */.U)(type, props, children);
  }
});



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/styles.js


function toggle_group_control_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */

const ToggleGroupControl = _ref => {
  let {
    size
  } = _ref;
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("background:", COLORS.ui.background, ";border:1px solid transparent;border-radius:", config_values.controlBorderRadius, ";display:inline-flex;min-width:0;padding:2px;position:relative;transition:transform ", config_values.transitionDurationFastest, " linear;", reduceMotion('transition'), " ", toggleGroupControlSize(size), " &:focus-within{border-color:", COLORS.ui.borderFocus, ";box-shadow:", config_values.controlBoxShadowFocus, ";outline:none;z-index:1;}" + ( true ? "" : 0),  true ? "" : 0);
};
const styles_border = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("border-color:", COLORS.ui.border, ";&:hover{border-color:", COLORS.ui.borderHover, ";}" + ( true ? "" : 0),  true ? "" : 0);
const toggleGroupControlSize = size => {
  const heights = {
    default: '36px',
    '__unstable-large': '40px'
  };
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("min-height:", heights[size], ";" + ( true ? "" : 0),  true ? "" : 0);
};
const toggle_group_control_styles_block =  true ? {
  name: "7whenc",
  styles: "display:flex;width:100%"
} : 0;
const BackdropView = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "eakva830"
} : 0)("background:", COLORS.gray[900], ";border-radius:", config_values.controlBorderRadius, ";box-shadow:", config_values.toggleGroupControlBackdropBoxShadow, ";left:0;position:absolute;top:2px;bottom:2px;transition:transform ", config_values.transitionDurationFast, " ease;", reduceMotion('transition'), " z-index:1;" + ( true ? "" : 0));
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/toggle-group-control-backdrop.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function ToggleGroupControlBackdrop(_ref) {
  let {
    containerRef,
    containerWidth,
    isAdaptiveWidth,
    state
  } = _ref;
  const [left, setLeft] = (0,react.useState)(0);
  const [width, setWidth] = (0,react.useState)(0);
  const [canAnimate, setCanAnimate] = (0,react.useState)(false);
  const [renderBackdrop, setRenderBackdrop] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    const containerNode = containerRef === null || containerRef === void 0 ? void 0 : containerRef.current;
    if (!containerNode) return;
    /**
     * Workaround for Reakit
     */

    const targetNode = containerNode.querySelector(`[data-value="${state}"]`);
    setRenderBackdrop(!!targetNode);

    if (!targetNode) {
      return;
    }

    const computeDimensions = () => {
      const {
        width: offsetWidth,
        x
      } = targetNode.getBoundingClientRect();
      const {
        x: parentX
      } = containerNode.getBoundingClientRect();
      const borderWidth = 1;
      const offsetLeft = x - parentX - borderWidth;
      setLeft(offsetLeft);
      setWidth(offsetWidth);
    }; // Fix to make the component appear as expected inside popovers.
    // If the targetNode width is 0 it means the element was not yet rendered we should allow
    // some time for the render to happen.
    // requestAnimationFrame instead of setTimeout with a small time does not seems to work.


    const dimensionsRequestId = window.setTimeout(computeDimensions, 100);
    let animationRequestId;

    if (!canAnimate) {
      animationRequestId = window.requestAnimationFrame(() => {
        setCanAnimate(true);
      });
    }

    return () => {
      window.clearTimeout(dimensionsRequestId);
      window.cancelAnimationFrame(animationRequestId);
    };
  }, [canAnimate, containerRef, containerWidth, state, isAdaptiveWidth]);

  if (!renderBackdrop) {
    return null;
  }

  return (0,react.createElement)(BackdropView, {
    role: "presentation",
    style: {
      transform: `translateX(${left}px)`,
      transition: canAnimate ? undefined : 'none',
      width
    }
  });
}

/* harmony default export */ const toggle_group_control_backdrop = ((0,react.memo)(ToggleGroupControlBackdrop));
//# sourceMappingURL=toggle-group-control-backdrop.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/context.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const ToggleGroupControlContext = (0,react.createContext)({});
const useToggleGroupControlContext = () => (0,react.useContext)(ToggleGroupControlContext);
/* harmony default export */ const toggle_group_control_context = (ToggleGroupControlContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/component.js



/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */









const toggle_group_control_component_noop = () => {};

function UnconnectedToggleGroupControl(props, forwardedRef) {
  const {
    __nextHasNoMarginBottom = false,
    className,
    isAdaptiveWidth = false,
    isBlock = false,
    __experimentalIsIconGroup = false,
    label,
    hideLabelFromVision = false,
    help,
    onChange = toggle_group_control_component_noop,
    size = 'default',
    value,
    children,
    ...otherProps
  } = useContextSystem(props, 'ToggleGroupControl');
  const cx = useCx();
  const containerRef = (0,react.useRef)();
  const [resizeListener, sizes] = useResizeAware();
  const baseId = (0,use_instance_id/* default */.A)(component_ToggleGroupControl, 'toggle-group-control').toString();
  const radio = useRadioState({
    baseId,
    state: value
  });
  const previousValue = usePrevious(value); // Propagate radio.state change.

  use_update_effect(() => {
    // Avoid calling onChange if radio state changed
    // from incoming value.
    if (previousValue !== radio.state) {
      onChange(radio.state);
    }
  }, [radio.state]); // Sync incoming value with radio.state.

  use_update_effect(() => {
    if (value !== radio.state) {
      radio.setState(value);
    }
  }, [value]);
  const classes = (0,react.useMemo)(() => cx(ToggleGroupControl({
    size
  }), !__experimentalIsIconGroup && styles_border, isBlock && toggle_group_control_styles_block, className), [className, cx, isBlock, __experimentalIsIconGroup, size]);
  return (0,react.createElement)(base_control, {
    help: help,
    __nextHasNoMarginBottom: __nextHasNoMarginBottom
  }, (0,react.createElement)(toggle_group_control_context.Provider, {
    value: { ...radio,
      isBlock: !isAdaptiveWidth,
      size
    }
  }, !hideLabelFromVision && (0,react.createElement)("div", null, (0,react.createElement)(base_control.VisualLabel, null, label)), (0,react.createElement)(RadioGroup, (0,helpers_esm_extends/* default */.A)({}, radio, {
    "aria-label": label,
    as: component,
    className: classes
  }, otherProps, {
    ref: (0,use_merge_refs/* default */.A)([containerRef, forwardedRef])
  }), resizeListener, (0,react.createElement)(toggle_group_control_backdrop, (0,helpers_esm_extends/* default */.A)({}, radio, {
    containerRef: containerRef,
    containerWidth: sizes.width,
    isAdaptiveWidth: isAdaptiveWidth
  })), children)));
}
/**
 * `ToggleGroupControl` is a form component that lets users choose options
 * represented in horizontal segments. To render options for this control use
 * `ToggleGroupControlOption` component.
 *
 * This component is intended for selecting a single persistent value from a set of options,
 * similar to a how a radio button group would work. If you simply want a toggle to switch between views,
 * use a `TabPanel` instead.
 *
 * Only use this control when you know for sure the labels of items inside won't
 * wrap. For items with longer labels, you can consider a `SelectControl` or a
 * `CustomSelectControl` component instead.
 *
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOption as ToggleGroupControlOption,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */


const component_ToggleGroupControl = contextConnect(UnconnectedToggleGroupControl, 'ToggleGroupControl');
/* harmony default export */ const toggle_group_control_component = (component_ToggleGroupControl);
//# sourceMappingURL=component.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/createEvent.js
var createEvent = __webpack_require__("../../node_modules/.pnpm/reakit-utils@0.15.2_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit-utils/es/createEvent.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/reakit@1.3.11_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/reakit/es/Radio/Radio.js

































function getChecked(options) {
  if (typeof options.checked !== "undefined") {
    return options.checked;
  }

  return typeof options.value !== "undefined" && options.state === options.value;
}

function useInitialChecked(options) {
  var _React$useState = (0,react.useState)(function () {
    return getChecked(options);
  }),
      initialChecked = _React$useState[0];

  var _React$useState2 = (0,react.useState)(options.currentId),
      initialCurrentId = _React$useState2[0];

  var id = options.id,
      setCurrentId = options.setCurrentId;
  (0,react.useEffect)(function () {
    if (initialChecked && id && initialCurrentId !== id) {
      setCurrentId === null || setCurrentId === void 0 ? void 0 : setCurrentId(id);
    }
  }, [initialChecked, id, setCurrentId, initialCurrentId]);
}

function fireChange(element, onChange) {
  var event = (0,createEvent/* createEvent */.l)(element, "change");
  Object.defineProperties(event, {
    type: {
      value: "change"
    },
    target: {
      value: element
    },
    currentTarget: {
      value: element
    }
  });
  onChange === null || onChange === void 0 ? void 0 : onChange(event);
}

var useRadio = (0,createHook/* createHook */.a)({
  name: "Radio",
  compose: CompositeItem/* useCompositeItem */.k,
  keys: RADIO_KEYS,
  useOptions: function useOptions(_ref, _ref2) {
    var _options$value;

    var value = _ref2.value,
        checked = _ref2.checked;

    var _ref$unstable_clickOn = _ref.unstable_clickOnEnter,
        unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? false : _ref$unstable_clickOn,
        _ref$unstable_checkOn = _ref.unstable_checkOnFocus,
        unstable_checkOnFocus = _ref$unstable_checkOn === void 0 ? true : _ref$unstable_checkOn,
        options = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref, ["unstable_clickOnEnter", "unstable_checkOnFocus"]);

    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)((0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      checked: checked,
      unstable_clickOnEnter: unstable_clickOnEnter,
      unstable_checkOnFocus: unstable_checkOnFocus
    }, options), {}, {
      value: (_options$value = options.value) != null ? _options$value : value
    });
  },
  useProps: function useProps(options, _ref3) {
    var htmlRef = _ref3.ref,
        htmlOnChange = _ref3.onChange,
        htmlOnClick = _ref3.onClick,
        htmlProps = (0,_rollupPluginBabelHelpers_1f0bf8c2._)(_ref3, ["ref", "onChange", "onClick"]);

    var ref = (0,react.useRef)(null);

    var _React$useState3 = (0,react.useState)(true),
        isNativeRadio = _React$useState3[0],
        setIsNativeRadio = _React$useState3[1];

    var checked = getChecked(options);
    var isCurrentItemRef = (0,useLiveRef/* useLiveRef */.h)(options.currentId === options.id);
    var onChangeRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnChange);
    var onClickRef = (0,useLiveRef/* useLiveRef */.h)(htmlOnClick);
    useInitialChecked(options);
    (0,react.useEffect)(function () {
      var element = ref.current;

      if (!element) {
         false ? 0 : void 0;
        return;
      }

      if (element.tagName !== "INPUT" || element.type !== "radio") {
        setIsNativeRadio(false);
      }
    }, []);
    var onChange = (0,react.useCallback)(function (event) {
      var _onChangeRef$current, _options$setState;

      (_onChangeRef$current = onChangeRef.current) === null || _onChangeRef$current === void 0 ? void 0 : _onChangeRef$current.call(onChangeRef, event);
      if (event.defaultPrevented) return;
      if (options.disabled) return;
      (_options$setState = options.setState) === null || _options$setState === void 0 ? void 0 : _options$setState.call(options, options.value);
    }, [options.disabled, options.setState, options.value]);
    var onClick = (0,react.useCallback)(function (event) {
      var _onClickRef$current;

      (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
      if (event.defaultPrevented) return;
      if (isNativeRadio) return;
      fireChange(event.currentTarget, onChange);
    }, [onChange, isNativeRadio]);
    (0,react.useEffect)(function () {
      var element = ref.current;
      if (!element) return;

      if (options.unstable_moves && isCurrentItemRef.current && options.unstable_checkOnFocus) {
        fireChange(element, onChange);
      }
    }, [options.unstable_moves, options.unstable_checkOnFocus, onChange]);
    return (0,_rollupPluginBabelHelpers_1f0bf8c2.a)({
      ref: (0,useForkRef/* useForkRef */.N)(ref, htmlRef),
      role: !isNativeRadio ? "radio" : undefined,
      type: isNativeRadio ? "radio" : undefined,
      value: isNativeRadio ? options.value : undefined,
      name: isNativeRadio ? options.baseId : undefined,
      "aria-checked": checked,
      checked: checked,
      onChange: onChange,
      onClick: onClick
    }, htmlProps);
  }
});
var Radio = (0,createComponent/* createComponent */.a)({
  as: "input",
  memo: true,
  useHook: useRadio
});



;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/styles.js


function toggle_group_control_option_base_styles_EMOTION_STRINGIFIED_CSS_ERROR_() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */


/**
 * Internal dependencies
 */

const LabelView = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "et6ln9s1"
} : 0)( true ? {
  name: "sln1fl",
  styles: "display:inline-flex;max-width:100%;min-width:0;position:relative"
} : 0);
const labelBlock =  true ? {
  name: "82a6rk",
  styles: "flex:1"
} : 0;
const buttonView = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("align-items:center;appearance:none;background:transparent;border:none;border-radius:", config_values.controlBorderRadius, ";color:", COLORS.gray[700], ";fill:currentColor;cursor:pointer;display:flex;font-family:inherit;height:100%;justify-content:center;line-height:100%;outline:none;padding:0 12px;position:relative;text-align:center;transition:background ", config_values.transitionDurationFast, " linear,color ", config_values.transitionDurationFast, " linear,font-weight 60ms linear;", reduceMotion('transition'), " user-select:none;width:100%;z-index:2;&::-moz-focus-inner{border:0;}&:active{background:", config_values.toggleGroupControlBackgroundColor, ";}" + ( true ? "" : 0),  true ? "" : 0);
const buttonActive = /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("color:", COLORS.white, ";&:active{background:transparent;}" + ( true ? "" : 0),  true ? "" : 0);
const ButtonContentView = (0,emotion_styled_base_browser_esm/* default */.A)("div",  true ? {
  target: "et6ln9s0"
} : 0)("font-size:", config_values.fontSize, ";line-height:1;" + ( true ? "" : 0));
const separatorActive =  true ? {
  name: "1qsuvl4",
  styles: "background:transparent"
} : 0;
const styles_isIcon = _ref => {
  let {
    size
  } = _ref;
  const iconButtonSizes = {
    default: '30px',
    '__unstable-large': '34px'
  };
  return /*#__PURE__*/(0,emotion_react_browser_esm/* css */.AH)("width:", iconButtonSizes[size], ";padding-left:0;padding-right:0;" + ( true ? "" : 0),  true ? "" : 0);
};
//# sourceMappingURL=styles.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/component.js



/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */






const {
  ButtonContentView: component_ButtonContentView,
  LabelView: component_LabelView
} = toggle_group_control_option_base_styles_namespaceObject;

const WithToolTip = _ref => {
  let {
    showTooltip,
    text,
    children
  } = _ref;

  if (showTooltip && text) {
    return (0,react.createElement)(tooltip, {
      text: text,
      position: "top center"
    }, children);
  }

  return (0,react.createElement)(react.Fragment, null, children);
};

function ToggleGroupControlOptionBase(props, forwardedRef) {
  const toggleGroupControlContext = useToggleGroupControlContext();
  const id = (0,use_instance_id/* default */.A)(ToggleGroupControlOptionBase, toggleGroupControlContext.baseId || 'toggle-group-control-option-base');
  const buttonProps = useContextSystem({ ...props,
    id
  }, 'ToggleGroupControlOptionBase');
  const {
    className,
    isBlock = false,
    isIcon = false,
    value,
    children,
    size = 'default',
    showTooltip = false,
    ...radioProps
  } = { ...toggleGroupControlContext,
    ...buttonProps
  };
  const isActive = radioProps.state === value;
  const cx = useCx();
  const labelViewClasses = cx(isBlock && labelBlock);
  const classes = cx(buttonView, isIcon && styles_isIcon({
    size
  }), className, isActive && buttonActive);
  return (0,react.createElement)(component_LabelView, {
    className: labelViewClasses,
    "data-active": isActive
  }, (0,react.createElement)(WithToolTip, {
    showTooltip: showTooltip,
    text: radioProps['aria-label']
  }, (0,react.createElement)(Radio, (0,helpers_esm_extends/* default */.A)({}, radioProps, {
    as: "button",
    "aria-label": radioProps['aria-label'],
    className: classes,
    "data-value": value,
    ref: forwardedRef,
    value: value
  }), (0,react.createElement)(component_ButtonContentView, null, children))));
}
/**
 * `ToggleGroupControlOptionBase` is a form component and is meant to be used as an internal,
 * generic component for any children of `ToggleGroupControl`.
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOptionBase as ToggleGroupControlOptionBase,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */


const ConnectedToggleGroupControlOptionBase = contextConnect(ToggleGroupControlOptionBase, 'ToggleGroupControlOptionBase');
/* harmony default export */ const toggle_group_control_option_base_component = (ConnectedToggleGroupControlOptionBase);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option/component.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function UnforwardedToggleGroupControlOption(props, ref) {
  const {
    label,
    ...restProps
  } = props;
  const optionLabel = restProps['aria-label'] || label;
  return (0,react.createElement)(toggle_group_control_option_base_component, (0,helpers_esm_extends/* default */.A)({}, restProps, {
    "aria-label": optionLabel,
    ref: ref
  }), label);
}
/**
 * `ToggleGroupControlOption` is a form component and is meant to be used as a
 * child of `ToggleGroupControl`.
 *
 * ```jsx
 * import {
 *   __experimentalToggleGroupControl as ToggleGroupControl,
 *   __experimentalToggleGroupControlOption as ToggleGroupControlOption,
 * } from '@wordpress/components';
 *
 * function Example() {
 *   return (
 *     <ToggleGroupControl label="my label" value="vertical" isBlock>
 *       <ToggleGroupControlOption value="horizontal" label="Horizontal" />
 *       <ToggleGroupControlOption value="vertical" label="Vertical" />
 *     </ToggleGroupControl>
 *   );
 * }
 * ```
 */


const ToggleGroupControlOption = (0,react.forwardRef)(UnforwardedToggleGroupControlOption);
/* harmony default export */ const toggle_group_control_option_component = (ToggleGroupControlOption);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/font-size-picker/utils.js
/**
 * WordPress dependencies
 */

const DEFAULT_FONT_SIZE = 'default';
const DEFAULT_FONT_SIZE_OPTION = {
  slug: DEFAULT_FONT_SIZE,
  name: (0,i18n_build_module.__)('Default')
};
const CUSTOM_FONT_SIZE = 'custom';
const CUSTOM_FONT_SIZE_OPTION = {
  slug: CUSTOM_FONT_SIZE,
  name: (0,i18n_build_module.__)('Custom')
};
/**
 * In case we have at most five font sizes, show a `T-shirt size`
 * alias as a label of the font size. The label assumes that the font sizes
 * are ordered accordingly - from smallest to largest.
 */

const FONT_SIZES_ALIASES = [
/* translators: S stands for 'small' and is a size label. */
(0,i18n_build_module.__)('S'),
/* translators: M stands for 'medium' and is a size label. */
(0,i18n_build_module.__)('M'),
/* translators: L stands for 'large' and is a size label. */
(0,i18n_build_module.__)('L'),
/* translators: XL stands for 'extra large' and is a size label. */
(0,i18n_build_module.__)('XL'),
/* translators: XXL stands for 'extra extra large' and is a size label. */
(0,i18n_build_module.__)('XXL')];
/**
 * Helper util to split a font size to its numeric value
 * and its `unit`, if exists.
 *
 * @param {string|number} size Font size.
 * @return {[number, string]} An array with the numeric value and the unit if exists.
 */

function splitValueAndUnitFromSize(size) {
  const [numericValue, unit] = `${size}`.match(/[\d\.]+|\D+/g);

  if (!isNaN(parseFloat(numericValue)) && isFinite(numericValue)) {
    return [numericValue, unit];
  }

  return [];
}
/**
 * Some themes use css vars for their font sizes, so until we
 * have the way of calculating them don't display them.
 *
 * @param {string|number} value The value that is checked.
 * @return {boolean} Whether the value is a simple css value.
 */

function isSimpleCssValue(value) {
  const sizeRegex = /^[\d\.]+(px|em|rem|vw|vh|%)?$/i;
  return sizeRegex.test(value);
}
/**
 * Return font size options in the proper format depending
 * on the currently used control (select, toggle group).
 *
 * @param {boolean}  useSelectControl       Whether to use a select control.
 * @param {Object[]} optionsArray           Array of available font sizes objects.
 * @param {boolean}  disableCustomFontSizes Flag that indicates if custom font sizes are disabled.
 * @return {Object[]|null}                  Array of font sizes in proper format for the used control.
 */

function getFontSizeOptions(useSelectControl, optionsArray, disableCustomFontSizes) {
  if (disableCustomFontSizes && !optionsArray.length) {
    return null;
  }

  return useSelectControl ? getSelectOptions(optionsArray, disableCustomFontSizes) : getToggleGroupOptions(optionsArray);
}

function getSelectOptions(optionsArray, disableCustomFontSizes) {
  const options = [DEFAULT_FONT_SIZE_OPTION, ...optionsArray, ...(disableCustomFontSizes ? [] : [CUSTOM_FONT_SIZE_OPTION])];
  return options.map(_ref => {
    let {
      slug,
      name,
      size
    } = _ref;
    return {
      key: slug,
      name,
      size,
      __experimentalHint: size && isSimpleCssValue(size) && parseFloat(size)
    };
  });
}
/**
 * Build options for the toggle group options.
 *
 * @param {Array}    optionsArray An array of font size options.
 * @param {string[]} labelAliases An array of alternative labels.
 * @return {Array}   Remapped optionsArray.
 */


function getToggleGroupOptions(optionsArray) {
  let labelAliases = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FONT_SIZES_ALIASES;
  return optionsArray.map((_ref2, index) => {
    let {
      slug,
      size,
      name
    } = _ref2;
    return {
      key: slug,
      value: size,
      label: labelAliases[index],
      name
    };
  });
}
function getSelectedOption(fontSizes, value) {
  if (!value) {
    return DEFAULT_FONT_SIZE_OPTION;
  }

  return fontSizes.find(font => font.size === value) || CUSTOM_FONT_SIZE_OPTION;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/font-size-picker/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */











 // This conditional is needed to maintain the spacing before the slider in the `withSlider` case.

const MaybeVStack = _ref => {
  let {
    __nextHasNoMarginBottom,
    children
  } = _ref;
  return !__nextHasNoMarginBottom ? children : (0,react.createElement)(v_stack_component, {
    spacing: 6,
    children: children
  });
};

function FontSizePicker(_ref2, ref) {
  var _fontSizes$, _value$endsWith;

  let {
    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMarginBottom = false,
    fallbackFontSize,
    fontSizes = [],
    disableCustomFontSizes = false,
    onChange,

    /** @type {'default' | '__unstable-large'} */
    size = 'default',
    value,
    withSlider = false,
    withReset = true
  } = _ref2;
  const hasUnits = [typeof value, typeof (fontSizes === null || fontSizes === void 0 ? void 0 : (_fontSizes$ = fontSizes[0]) === null || _fontSizes$ === void 0 ? void 0 : _fontSizes$.size)].includes('string');
  const noUnitsValue = !hasUnits ? value : parseInt(value);
  const isPixelValue = typeof value === 'number' || (value === null || value === void 0 ? void 0 : (_value$endsWith = value.endsWith) === null || _value$endsWith === void 0 ? void 0 : _value$endsWith.call(value, 'px'));
  const units = useCustomUnits({
    availableUnits: ['px', 'em', 'rem']
  });
  /**
   * The main font size UI displays a toggle group when the presets are less
   * than six and a select control when they are more.
   */

  const fontSizesContainComplexValues = fontSizes.some(_ref3 => {
    let {
      size: sizeArg
    } = _ref3;
    return !isSimpleCssValue(sizeArg);
  });
  const shouldUseSelectControl = fontSizes.length > 5;
  const options = (0,react.useMemo)(() => getFontSizeOptions(shouldUseSelectControl, fontSizes, disableCustomFontSizes), [shouldUseSelectControl, fontSizes, disableCustomFontSizes]);
  const selectedOption = getSelectedOption(fontSizes, value);
  const isCustomValue = selectedOption.slug === CUSTOM_FONT_SIZE;
  const [showCustomValueControl, setShowCustomValueControl] = (0,react.useState)(!disableCustomFontSizes && isCustomValue);
  const headerHint = (0,react.useMemo)(() => {
    if (showCustomValueControl) {
      return `(${(0,i18n_build_module.__)('Custom')})`;
    } // If we have a custom value that is not available in the font sizes,
    // show it as a hint as long as it's a simple CSS value.


    if (isCustomValue) {
      return isSimpleCssValue(value) && `(${value})`;
    }

    if (shouldUseSelectControl) {
      return isSimpleCssValue(selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.size) && `(${selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.size})`;
    } // Calculate the `hint` for toggle group control.


    let hint = selectedOption.name;

    if (!fontSizesContainComplexValues && typeof selectedOption.size === 'string') {
      const [, unit] = splitValueAndUnitFromSize(selectedOption.size);
      hint += `(${unit})`;
    }

    return hint;
  }, [showCustomValueControl, selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.name, selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.size, value, isCustomValue, shouldUseSelectControl, fontSizesContainComplexValues]);

  if (!options) {
    return null;
  } // This is used for select control only. We need to add support
  // for ToggleGroupControl.


  const currentFontSizeSR = (0,i18n_build_module/* sprintf */.nv)( // translators: %s: Currently selected font size.
  (0,i18n_build_module.__)('Currently selected font size: %s'), selectedOption.name);
  const baseClassName = 'components-font-size-picker';
  return (0,react.createElement)("fieldset", (0,helpers_esm_extends/* default */.A)({
    className: baseClassName
  }, ref ? {} : {
    ref
  }), (0,react.createElement)(visually_hidden_component, {
    as: "legend"
  }, (0,i18n_build_module.__)('Font size')), (0,react.createElement)(h_stack_component, {
    className: `${baseClassName}__header`
  }, (0,react.createElement)(BaseControl.VisualLabel, null, (0,i18n_build_module.__)('Size'), headerHint && (0,react.createElement)("span", {
    className: `${baseClassName}__header__hint`
  }, headerHint)), !disableCustomFontSizes && (0,react.createElement)(build_module_button, {
    label: showCustomValueControl ? (0,i18n_build_module.__)('Use size preset') : (0,i18n_build_module.__)('Set custom size'),
    icon: library_settings,
    onClick: () => {
      setShowCustomValueControl(!showCustomValueControl);
    },
    isPressed: showCustomValueControl,
    isSmall: true
  })), (0,react.createElement)(MaybeVStack, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom
  }, (0,react.createElement)("div", {
    className: classnames_default()(`${baseClassName}__controls`, {
      'is-next-has-no-margin-bottom': __nextHasNoMarginBottom
    })
  }, !!fontSizes.length && shouldUseSelectControl && !showCustomValueControl && (0,react.createElement)(CustomSelectControl, {
    __nextUnconstrainedWidth: true,
    className: `${baseClassName}__select`,
    label: (0,i18n_build_module.__)('Font size'),
    hideLabelFromVision: true,
    describedBy: currentFontSizeSR,
    options: options,
    value: options.find(option => option.key === selectedOption.slug),
    onChange: _ref4 => {
      let {
        selectedItem
      } = _ref4;
      onChange(hasUnits ? selectedItem.size : Number(selectedItem.size));

      if (selectedItem.key === CUSTOM_FONT_SIZE) {
        setShowCustomValueControl(true);
      }
    },
    size: size
  }), !shouldUseSelectControl && !showCustomValueControl && (0,react.createElement)(toggle_group_control_component, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    label: (0,i18n_build_module.__)('Font size'),
    hideLabelFromVision: true,
    value: value,
    onChange: newValue => {
      onChange(hasUnits ? newValue : Number(newValue));
    },
    isBlock: true,
    size: size
  }, options.map(option => (0,react.createElement)(toggle_group_control_option_component, {
    key: option.key,
    value: option.value,
    label: option.label,
    "aria-label": option.name,
    showTooltip: true
  }))), !withSlider && !disableCustomFontSizes && showCustomValueControl && (0,react.createElement)(flex_component, {
    justify: "space-between",
    className: `${baseClassName}__custom-size-control`
  }, (0,react.createElement)(flex_item_component, {
    isBlock: true
  }, (0,react.createElement)(unit_control, {
    label: (0,i18n_build_module.__)('Custom'),
    labelPosition: "top",
    hideLabelFromVision: true,
    value: value,
    onChange: nextSize => {
      if (0 === parseFloat(nextSize) || !nextSize) {
        onChange(undefined);
      } else {
        onChange(hasUnits ? nextSize : parseInt(nextSize, 10));
      }
    },
    size: size,
    units: hasUnits ? units : []
  })), withReset && (0,react.createElement)(flex_item_component, {
    isBlock: true
  }, (0,react.createElement)(build_module_button, {
    className: "components-color-palette__clear",
    disabled: value === undefined,
    onClick: () => {
      onChange(undefined);
    },
    isSmall: true,
    variant: "secondary"
  }, (0,i18n_build_module.__)('Reset'))))), withSlider && (0,react.createElement)(range_control, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    className: `${baseClassName}__custom-input`,
    label: (0,i18n_build_module.__)('Custom Size'),
    value: isPixelValue && noUnitsValue || '',
    initialPosition: fallbackFontSize,
    onChange: newValue => {
      onChange(hasUnits ? newValue + 'px' : newValue);
    },
    min: 12,
    max: 100
  })));
}

/* harmony default export */ const font_size_picker = ((0,react.forwardRef)(FontSizePicker));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/font-sizes/font-size-picker.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



function font_size_picker_FontSizePicker(props) {
  const fontSizes = use_setting_useSetting('typography.fontSizes');
  const disableCustomFontSizes = !use_setting_useSetting('typography.customFontSize');
  return (0,react.createElement)(font_size_picker, (0,esm_extends/* default */.A)({}, props, {
    fontSizes: fontSizes,
    disableCustomFontSizes: disableCustomFontSizes
  }));
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/font-sizes/README.md
 */


/* harmony default export */ const font_sizes_font_size_picker = (font_size_picker_FontSizePicker);
//# sourceMappingURL=font-size-picker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/font-size.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */





const FONT_SIZE_SUPPORT_KEY = 'typography.fontSize';
/**
 * Filters registered block settings, extending attributes to include
 * `fontSize` and `fontWeight` attributes.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function font_size_addAttributes(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  } // Allow blocks to specify a default value if needed.


  if (!settings.attributes.fontSize) {
    Object.assign(settings.attributes, {
      fontSize: {
        type: 'string'
      }
    });
  }

  return settings;
}
/**
 * Override props assigned to save component to inject font size.
 *
 * @param {Object} props      Additional props applied to save element.
 * @param {Object} blockType  Block type.
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Filtered props applied to save element.
 */


function font_size_addSaveProps(props, blockType, attributes) {
  if (!(0,build_module/* hasBlockSupport */.pN)(blockType, FONT_SIZE_SUPPORT_KEY)) {
    return props;
  }

  if (shouldSkipSerialization(blockType, TYPOGRAPHY_SUPPORT_KEY, 'fontSize')) {
    return props;
  } // Use TokenList to dedupe classes.


  const classes = new TokenList(props.className);
  classes.add(getFontSizeClass(attributes.fontSize));
  const newClassName = classes.value;
  props.className = newClassName ? newClassName : undefined;
  return props;
}
/**
 * Filters registered block settings to expand the block edit wrapper
 * by applying the desired styles and classnames.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function font_size_addEditProps(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, FONT_SIZE_SUPPORT_KEY)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return font_size_addSaveProps(props, settings, attributes);
  };

  return settings;
}
/**
 * Inspector control panel containing the font size related configuration
 *
 * @param {Object} props
 *
 * @return {WPElement} Font size edit element.
 */


function FontSizeEdit(props) {
  var _style$typography, _style$typography2;

  const {
    attributes: {
      fontSize,
      style
    },
    setAttributes
  } = props;
  const fontSizes = use_setting_useSetting('typography.fontSizes');

  const onChange = value => {
    const fontSizeSlug = getFontSizeObjectByValue(fontSizes, value).slug;
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          fontSize: fontSizeSlug ? undefined : value
        }
      }),
      fontSize: fontSizeSlug
    });
  };

  const fontSizeObject = utils_getFontSize(fontSizes, fontSize, style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.fontSize);
  const fontSizeValue = (fontSizeObject === null || fontSizeObject === void 0 ? void 0 : fontSizeObject.size) || (style === null || style === void 0 ? void 0 : (_style$typography2 = style.typography) === null || _style$typography2 === void 0 ? void 0 : _style$typography2.fontSize) || fontSize;
  return (0,react.createElement)(font_sizes_font_size_picker, {
    onChange: onChange,
    value: fontSizeValue,
    withReset: false
  });
}
/**
 * Checks if there is a current value set for the font size block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a font size value set.
 */

function hasFontSizeValue(props) {
  var _style$typography3;

  const {
    fontSize,
    style
  } = props.attributes;
  return !!fontSize || !!(style !== null && style !== void 0 && (_style$typography3 = style.typography) !== null && _style$typography3 !== void 0 && _style$typography3.fontSize);
}
/**
 * Resets the font size block support attribute. This can be used when
 * disabling the font size support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetFontSize(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    fontSize: undefined,
    style: cleanEmptyObject({ ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        fontSize: undefined
      }
    })
  });
}
/**
 * Custom hook that checks if font-size settings have been disabled.
 *
 * @param {string} name The name of the block.
 * @return {boolean} Whether setting is disabled.
 */

function useIsFontSizeDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const fontSizes = use_setting_useSetting('typography.fontSizes');
  const hasFontSizes = !!(fontSizes !== null && fontSizes !== void 0 && fontSizes.length);
  return !(0,build_module/* hasBlockSupport */.pN)(blockName, FONT_SIZE_SUPPORT_KEY) || !hasFontSizes;
}
/**
 * Add inline styles for font sizes.
 * Ideally, this is not needed and themes load the font-size classes on the
 * editor.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withFontSizeInlineStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  var _style$typography4, _style$typography5;

  const fontSizes = use_setting_useSetting('typography.fontSizes');
  const {
    name: blockName,
    attributes: {
      fontSize,
      style
    },
    wrapperProps
  } = props; // Only add inline styles if the block supports font sizes,
  // doesn't skip serialization of font sizes,
  // doesn't already have an inline font size,
  // and does have a class to extract the font size from.

  if (!(0,build_module/* hasBlockSupport */.pN)(blockName, FONT_SIZE_SUPPORT_KEY) || shouldSkipSerialization(blockName, TYPOGRAPHY_SUPPORT_KEY, 'fontSize') || !fontSize || style !== null && style !== void 0 && (_style$typography4 = style.typography) !== null && _style$typography4 !== void 0 && _style$typography4.fontSize) {
    return (0,react.createElement)(BlockListBlock, props);
  }

  const fontSizeValue = utils_getFontSize(fontSizes, fontSize, style === null || style === void 0 ? void 0 : (_style$typography5 = style.typography) === null || _style$typography5 === void 0 ? void 0 : _style$typography5.fontSize).size;
  const newProps = { ...props,
    wrapperProps: { ...wrapperProps,
      style: {
        fontSize: fontSizeValue,
        ...(wrapperProps === null || wrapperProps === void 0 ? void 0 : wrapperProps.style)
      }
    }
  };
  return (0,react.createElement)(BlockListBlock, newProps);
}, 'withFontSizeInlineStyles');
const font_size_MIGRATION_PATHS = {
  fontSize: [['fontSize'], ['style', 'typography', 'fontSize']]
};
function font_size_addTransforms(result, source, index, results) {
  const destinationBlockType = result.name;
  const activeSupports = {
    fontSize: (0,build_module/* hasBlockSupport */.pN)(destinationBlockType, FONT_SIZE_SUPPORT_KEY)
  };
  return transformStyles(activeSupports, font_size_MIGRATION_PATHS, result, source, index, results);
}
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/font/addAttribute', font_size_addAttributes);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/font/addSaveProps', font_size_addSaveProps);
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/font/addEditProps', font_size_addEditProps);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/font-size/with-font-size-inline-styles', withFontSizeInlineStyles);
(0,hooks_build_module/* addFilter */.U2)('blocks.switchToBlockType.transformedBlock', 'core/font-size/addTransforms', font_size_addTransforms);
//# sourceMappingURL=font-size.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/format-underline.js

/**
 * WordPress dependencies
 */

const formatUnderline = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M7 18v1h10v-1H7zm5-2c1.5 0 2.6-.4 3.4-1.2.8-.8 1.1-2 1.1-3.5V5H15v5.8c0 1.2-.2 2.1-.6 2.8-.4.7-1.2 1-2.4 1s-2-.3-2.4-1c-.4-.7-.6-1.6-.6-2.8V5H7.5v6.2c0 1.5.4 2.7 1.1 3.5.8.9 1.9 1.3 3.4 1.3z"
}));
/* harmony default export */ const format_underline = (formatUnderline);
//# sourceMappingURL=format-underline.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/format-strikethrough.js

/**
 * WordPress dependencies
 */

const formatStrikethrough = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M9.1 9v-.5c0-.6.2-1.1.7-1.4.5-.3 1.2-.5 2-.5.7 0 1.4.1 2.1.3.7.2 1.4.5 2.1.9l.2-1.9c-.6-.3-1.2-.5-1.9-.7-.8-.1-1.6-.2-2.4-.2-1.5 0-2.7.3-3.6 1-.8.7-1.2 1.5-1.2 2.6V9h2zM20 12H4v1h8.3c.3.1.6.2.8.3.5.2.9.5 1.1.8.3.3.4.7.4 1.2 0 .7-.2 1.1-.8 1.5-.5.3-1.2.5-2.1.5-.8 0-1.6-.1-2.4-.3-.8-.2-1.5-.5-2.2-.8L7 18.1c.5.2 1.2.4 2 .6.8.2 1.6.3 2.4.3 1.7 0 3-.3 3.9-1 .9-.7 1.3-1.6 1.3-2.8 0-.9-.2-1.7-.7-2.2H20v-1z"
}));
/* harmony default export */ const format_strikethrough = (formatStrikethrough);
//# sourceMappingURL=format-strikethrough.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/text-decoration-control/index.js


/**
 * WordPress dependencies
 */



const TEXT_DECORATIONS = [{
  name: (0,_wordpress_i18n_build_module.__)('Underline'),
  value: 'underline',
  icon: format_underline
}, {
  name: (0,_wordpress_i18n_build_module.__)('Strikethrough'),
  value: 'line-through',
  icon: format_strikethrough
}];
/**
 * Control to facilitate text decoration selections.
 *
 * @param {Object}   props          Component props.
 * @param {string}   props.value    Currently selected text decoration.
 * @param {Function} props.onChange Handles change in text decoration selection.
 *
 * @return {WPElement} Text decoration control.
 */

function TextDecorationControl(_ref) {
  let {
    value,
    onChange
  } = _ref;
  return (0,react.createElement)("fieldset", {
    className: "block-editor-text-decoration-control"
  }, (0,react.createElement)(base_control.VisualLabel, {
    as: "legend"
  }, (0,_wordpress_i18n_build_module.__)('Decoration')), (0,react.createElement)("div", {
    className: "block-editor-text-decoration-control__buttons"
  }, TEXT_DECORATIONS.map(textDecoration => {
    return (0,react.createElement)(build_module_button, {
      key: textDecoration.value,
      icon: textDecoration.icon,
      isSmall: true,
      isPressed: textDecoration.value === value,
      onClick: () => onChange(textDecoration.value === value ? undefined : textDecoration.value),
      "aria-label": textDecoration.name
    });
  })));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/text-decoration.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' supports array indicating support for text
 * decorations e.g. settings found in `block.json`.
 */

const TEXT_DECORATION_SUPPORT_KEY = 'typography.__experimentalTextDecoration';
/**
 * Inspector control panel containing the text decoration options.
 *
 * @param {Object} props Block properties.
 *
 * @return {WPElement} Text decoration edit element.
 */

function TextDecorationEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  function onChange(newDecoration) {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          textDecoration: newDecoration
        }
      })
    });
  }

  return (0,react.createElement)(TextDecorationControl, {
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.textDecoration,
    onChange: onChange
  });
}
/**
 * Checks if text-decoration settings have been disabled.
 *
 * @param {string} name Name of the block.
 *
 * @return {boolean} Whether or not the setting is disabled.
 */

function useIsTextDecorationDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const notSupported = !(0,build_module/* hasBlockSupport */.pN)(blockName, TEXT_DECORATION_SUPPORT_KEY);
  const hasTextDecoration = use_setting_useSetting('typography.textDecoration');
  return notSupported || !hasTextDecoration;
}
/**
 * Checks if there is a current value set for the text decoration block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a text decoration set.
 */

function hasTextDecorationValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return !!((_props$attributes$sty = props.attributes.style) !== null && _props$attributes$sty !== void 0 && (_props$attributes$sty2 = _props$attributes$sty.typography) !== null && _props$attributes$sty2 !== void 0 && _props$attributes$sty2.textDecoration);
}
/**
 * Resets the text decoration block support attribute. This can be used when
 * disabling the text decoration support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetTextDecoration(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        textDecoration: undefined
      }
    })
  });
}
//# sourceMappingURL=text-decoration.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/format-uppercase.js

/**
 * WordPress dependencies
 */

const formatUppercase = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M6.1 6.8L2.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H6.1zm-.8 6.8L7 8.9l1.7 4.7H5.3zm15.1-.7c-.4-.5-.9-.8-1.6-1 .4-.2.7-.5.8-.9.2-.4.3-.9.3-1.4 0-.9-.3-1.6-.8-2-.6-.5-1.3-.7-2.4-.7h-3.5V18h4.2c1.1 0 2-.3 2.6-.8.6-.6 1-1.4 1-2.4-.1-.8-.3-1.4-.6-1.9zm-5.7-4.7h1.8c.6 0 1.1.1 1.4.4.3.2.5.7.5 1.3 0 .6-.2 1.1-.5 1.3-.3.2-.8.4-1.4.4h-1.8V8.2zm4 8c-.4.3-.9.5-1.5.5h-2.6v-3.8h2.6c1.4 0 2 .6 2 1.9.1.6-.1 1-.5 1.4z"
}));
/* harmony default export */ const format_uppercase = (formatUppercase);
//# sourceMappingURL=format-uppercase.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/format-lowercase.js

/**
 * WordPress dependencies
 */

const formatLowercase = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M11 16.8c-.1-.1-.2-.3-.3-.5v-2.6c0-.9-.1-1.7-.3-2.2-.2-.5-.5-.9-.9-1.2-.4-.2-.9-.3-1.6-.3-.5 0-1 .1-1.5.2s-.9.3-1.2.6l.2 1.2c.4-.3.7-.4 1.1-.5.3-.1.7-.2 1-.2.6 0 1 .1 1.3.4.3.2.4.7.4 1.4-1.2 0-2.3.2-3.3.7s-1.4 1.1-1.4 2.1c0 .7.2 1.2.7 1.6.4.4 1 .6 1.8.6.9 0 1.7-.4 2.4-1.2.1.3.2.5.4.7.1.2.3.3.6.4.3.1.6.1 1.1.1h.1l.2-1.2h-.1c-.4.1-.6 0-.7-.1zM9.2 16c-.2.3-.5.6-.9.8-.3.1-.7.2-1.1.2-.4 0-.7-.1-.9-.3-.2-.2-.3-.5-.3-.9 0-.6.2-1 .7-1.3.5-.3 1.3-.4 2.5-.5v2zm10.6-3.9c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2s-.2 1.4-.6 2z"
}));
/* harmony default export */ const format_lowercase = (formatLowercase);
//# sourceMappingURL=format-lowercase.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/format-capitalize.js

/**
 * WordPress dependencies
 */

const formatCapitalize = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M7.1 6.8L3.1 18h1.6l1.1-3h4.3l1.1 3h1.6l-4-11.2H7.1zm-.8 6.8L8 8.9l1.7 4.7H6.3zm14.5-1.5c-.3-.6-.7-1.1-1.2-1.5-.6-.4-1.2-.6-1.9-.6-.5 0-.9.1-1.4.3-.4.2-.8.5-1.1.8V6h-1.4v12h1.3l.2-1c.2.4.6.6 1 .8.4.2.9.3 1.4.3.7 0 1.2-.2 1.8-.5.5-.4 1-.9 1.3-1.5.3-.6.5-1.3.5-2.1-.1-.6-.2-1.3-.5-1.9zm-1.7 4c-.4.5-.9.8-1.6.8s-1.2-.2-1.7-.7c-.4-.5-.7-1.2-.7-2.1 0-.9.2-1.6.7-2.1.4-.5 1-.7 1.7-.7s1.2.3 1.6.8c.4.5.6 1.2.6 2 .1.8-.2 1.4-.6 2z"
}));
/* harmony default export */ const format_capitalize = (formatCapitalize);
//# sourceMappingURL=format-capitalize.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/text-transform-control/index.js


/**
 * WordPress dependencies
 */



const TEXT_TRANSFORMS = [{
  name: (0,_wordpress_i18n_build_module.__)('Uppercase'),
  value: 'uppercase',
  icon: format_uppercase
}, {
  name: (0,_wordpress_i18n_build_module.__)('Lowercase'),
  value: 'lowercase',
  icon: format_lowercase
}, {
  name: (0,_wordpress_i18n_build_module.__)('Capitalize'),
  value: 'capitalize',
  icon: format_capitalize
}];
/**
 * Control to facilitate text transform selections.
 *
 * @param {Object}   props          Component props.
 * @param {string}   props.value    Currently selected text transform.
 * @param {Function} props.onChange Handles change in text transform selection.
 *
 * @return {WPElement} Text transform control.
 */

function TextTransformControl(_ref) {
  let {
    value,
    onChange
  } = _ref;
  return (0,react.createElement)("fieldset", {
    className: "block-editor-text-transform-control"
  }, (0,react.createElement)(base_control.VisualLabel, {
    as: "legend"
  }, (0,_wordpress_i18n_build_module.__)('Letter case')), (0,react.createElement)("div", {
    className: "block-editor-text-transform-control__buttons"
  }, TEXT_TRANSFORMS.map(textTransform => {
    return (0,react.createElement)(build_module_button, {
      key: textTransform.value,
      icon: textTransform.icon,
      isSmall: true,
      isPressed: value === textTransform.value,
      "aria-label": textTransform.name,
      onClick: () => onChange(value === textTransform.value ? undefined : textTransform.value)
    });
  })));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/text-transform.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' supports array indicating support for text
 * transforms e.g. settings found in `block.json`.
 */

const TEXT_TRANSFORM_SUPPORT_KEY = 'typography.__experimentalTextTransform';
/**
 * Inspector control panel containing the text transform options.
 *
 * @param {Object} props Block properties.
 *
 * @return {WPElement} Text transform edit element.
 */

function TextTransformEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  function onChange(newTransform) {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          textTransform: newTransform
        }
      })
    });
  }

  return (0,react.createElement)(TextTransformControl, {
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.textTransform,
    onChange: onChange
  });
}
/**
 * Checks if text-transform settings have been disabled.
 *
 * @param {string} name Name of the block.
 *
 * @return {boolean} Whether or not the setting is disabled.
 */

function useIsTextTransformDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const notSupported = !(0,build_module/* hasBlockSupport */.pN)(blockName, TEXT_TRANSFORM_SUPPORT_KEY);
  const hasTextTransforms = use_setting_useSetting('typography.textTransform');
  return notSupported || !hasTextTransforms;
}
/**
 * Checks if there is a current value set for the text transform block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a text transform set.
 */

function hasTextTransformValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return !!((_props$attributes$sty = props.attributes.style) !== null && _props$attributes$sty !== void 0 && (_props$attributes$sty2 = _props$attributes$sty.typography) !== null && _props$attributes$sty2 !== void 0 && _props$attributes$sty2.textTransform);
}
/**
 * Resets the text transform block support attribute. This can be used when
 * disabling the text transform support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetTextTransform(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        textTransform: undefined
      }
    })
  });
}
//# sourceMappingURL=text-transform.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/letter-spacing-control/index.js



/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Control for letter-spacing.
 *
 * @param {Object}                  props                      Component props.
 * @param {string}                  props.value                Currently selected letter-spacing.
 * @param {Function}                props.onChange             Handles change in letter-spacing selection.
 * @param {string|number|undefined} props.__unstableInputWidth Input width to pass through to inner UnitControl. Should be a valid CSS value.
 *
 * @return {WPElement} Letter-spacing control.
 */

function LetterSpacingControl(_ref) {
  let {
    value,
    onChange,
    __unstableInputWidth = '60px',
    ...otherProps
  } = _ref;
  const units = useCustomUnits({
    availableUnits: use_setting_useSetting('spacing.units') || ['px', 'em', 'rem'],
    defaultValues: {
      px: 2,
      em: 0.2,
      rem: 0.2
    }
  });
  return (0,react.createElement)(unit_control, (0,esm_extends/* default */.A)({}, otherProps, {
    label: (0,_wordpress_i18n_build_module.__)('Letter spacing'),
    value: value,
    __unstableInputWidth: __unstableInputWidth,
    units: units,
    onChange: onChange
  }));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/letter-spacing.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Key within block settings' supports array indicating support for letter-spacing
 * e.g. settings found in `block.json`.
 */

const LETTER_SPACING_SUPPORT_KEY = 'typography.__experimentalLetterSpacing';
/**
 * Inspector control panel containing the letter-spacing options.
 *
 * @param {Object} props Block properties.
 * @return {WPElement}    Letter-spacing edit element.
 */

function LetterSpacingEdit(props) {
  var _style$typography;

  const {
    attributes: {
      style
    },
    setAttributes
  } = props;

  function onChange(newSpacing) {
    setAttributes({
      style: cleanEmptyObject({ ...style,
        typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
          letterSpacing: newSpacing
        }
      })
    });
  }

  return (0,react.createElement)(LetterSpacingControl, {
    value: style === null || style === void 0 ? void 0 : (_style$typography = style.typography) === null || _style$typography === void 0 ? void 0 : _style$typography.letterSpacing,
    onChange: onChange,
    __unstableInputWidth: '100%'
  });
}
/**
 * Checks if letter-spacing settings have been disabled.
 *
 * @param {string} name Name of the block.
 * @return {boolean}     Whether or not the setting is disabled.
 */

function useIsLetterSpacingDisabled() {
  let {
    name: blockName
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const notSupported = !(0,build_module/* hasBlockSupport */.pN)(blockName, LETTER_SPACING_SUPPORT_KEY);
  const hasLetterSpacing = use_setting_useSetting('typography.letterSpacing');
  return notSupported || !hasLetterSpacing;
}
/**
 * Checks if there is a current value set for the letter spacing block support.
 *
 * @param {Object} props Block props.
 * @return {boolean}     Whether or not the block has a letter spacing set.
 */

function hasLetterSpacingValue(props) {
  var _props$attributes$sty, _props$attributes$sty2;

  return !!((_props$attributes$sty = props.attributes.style) !== null && _props$attributes$sty !== void 0 && (_props$attributes$sty2 = _props$attributes$sty.typography) !== null && _props$attributes$sty2 !== void 0 && _props$attributes$sty2.letterSpacing);
}
/**
 * Resets the letter spacing block support attribute. This can be used when
 * disabling the letter spacing support controls for a block via a progressive
 * discovery panel.
 *
 * @param {Object} props               Block props.
 * @param {Object} props.attributes    Block's attributes.
 * @param {Object} props.setAttributes Function to set block's attributes.
 */

function resetLetterSpacing(_ref) {
  let {
    attributes = {},
    setAttributes
  } = _ref;
  const {
    style
  } = attributes;
  setAttributes({
    style: cleanEmptyObject({ ...style,
      typography: { ...(style === null || style === void 0 ? void 0 : style.typography),
        letterSpacing: undefined
      }
    })
  });
}
//# sourceMappingURL=letter-spacing.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/typography.js


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */










const TYPOGRAPHY_SUPPORT_KEY = 'typography';
const TYPOGRAPHY_SUPPORT_KEYS = [LINE_HEIGHT_SUPPORT_KEY, FONT_SIZE_SUPPORT_KEY, FONT_STYLE_SUPPORT_KEY, FONT_WEIGHT_SUPPORT_KEY, FONT_FAMILY_SUPPORT_KEY, TEXT_DECORATION_SUPPORT_KEY, TEXT_TRANSFORM_SUPPORT_KEY, LETTER_SPACING_SUPPORT_KEY];
function TypographyPanel(props) {
  const {
    clientId
  } = props;
  const isFontFamilyDisabled = useIsFontFamilyDisabled(props);
  const isFontSizeDisabled = useIsFontSizeDisabled(props);
  const isFontAppearanceDisabled = useIsFontAppearanceDisabled(props);
  const isLineHeightDisabled = useIsLineHeightDisabled(props);
  const isTextDecorationDisabled = useIsTextDecorationDisabled(props);
  const isTextTransformDisabled = useIsTextTransformDisabled(props);
  const isLetterSpacingDisabled = useIsLetterSpacingDisabled(props);
  const hasFontStyles = !useIsFontStyleDisabled(props);
  const hasFontWeights = !useIsFontWeightDisabled(props);
  const isDisabled = useIsTypographyDisabled(props);
  const isSupported = hasTypographySupport(props.name);
  if (isDisabled || !isSupported) return null;
  const defaultControls = (0,build_module/* getBlockSupport */.bI)(props.name, [TYPOGRAPHY_SUPPORT_KEY, '__experimentalDefaultControls']);

  const createResetAllFilter = attribute => newAttributes => {
    var _newAttributes$style;

    return { ...newAttributes,
      style: { ...newAttributes.style,
        typography: { ...((_newAttributes$style = newAttributes.style) === null || _newAttributes$style === void 0 ? void 0 : _newAttributes$style.typography),
          [attribute]: undefined
        }
      }
    };
  };

  return (0,react.createElement)(inspector_controls, {
    __experimentalGroup: "typography"
  }, !isFontFamilyDisabled && (0,react.createElement)(tools_panel_item_component, {
    hasValue: () => hasFontFamilyValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Font family'),
    onDeselect: () => resetFontFamily(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.fontFamily,
    resetAllFilter: newAttributes => ({ ...newAttributes,
      fontFamily: undefined
    }),
    panelId: clientId
  }, (0,react.createElement)(FontFamilyEdit, props)), !isFontSizeDisabled && (0,react.createElement)(tools_panel_item_component, {
    hasValue: () => hasFontSizeValue(props)
    /* translators: Ensure translation is distinct from "Letter case" */
    ,
    label: (0,_wordpress_i18n_build_module.__)('Font size'),
    onDeselect: () => resetFontSize(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.fontSize,
    resetAllFilter: newAttributes => {
      var _newAttributes$style2;

      return { ...newAttributes,
        fontSize: undefined,
        style: { ...newAttributes.style,
          typography: { ...((_newAttributes$style2 = newAttributes.style) === null || _newAttributes$style2 === void 0 ? void 0 : _newAttributes$style2.typography),
            fontSize: undefined
          }
        }
      };
    },
    panelId: clientId
  }, (0,react.createElement)(FontSizeEdit, props)), !isFontAppearanceDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: "single-column",
    hasValue: () => hasFontAppearanceValue(props),
    label: getFontAppearanceLabel(hasFontStyles, hasFontWeights),
    onDeselect: () => resetFontAppearance(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.fontAppearance,
    resetAllFilter: newAttributes => {
      var _newAttributes$style3;

      return { ...newAttributes,
        style: { ...newAttributes.style,
          typography: { ...((_newAttributes$style3 = newAttributes.style) === null || _newAttributes$style3 === void 0 ? void 0 : _newAttributes$style3.typography),
            fontStyle: undefined,
            fontWeight: undefined
          }
        }
      };
    },
    panelId: clientId
  }, (0,react.createElement)(FontAppearanceEdit, props)), !isLineHeightDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: "single-column",
    hasValue: () => hasLineHeightValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Line height'),
    onDeselect: () => resetLineHeight(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.lineHeight,
    resetAllFilter: createResetAllFilter('lineHeight'),
    panelId: clientId
  }, (0,react.createElement)(LineHeightEdit, props)), !isTextDecorationDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: "single-column",
    hasValue: () => hasTextDecorationValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Decoration'),
    onDeselect: () => resetTextDecoration(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.textDecoration,
    resetAllFilter: createResetAllFilter('textDecoration'),
    panelId: clientId
  }, (0,react.createElement)(TextDecorationEdit, props)), !isTextTransformDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: "single-column",
    hasValue: () => hasTextTransformValue(props)
    /* translators: Ensure translation is distinct from "Font size" */
    ,
    label: (0,_wordpress_i18n_build_module.__)('Letter case'),
    onDeselect: () => resetTextTransform(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.textTransform,
    resetAllFilter: createResetAllFilter('textTransform'),
    panelId: clientId
  }, (0,react.createElement)(TextTransformEdit, props)), !isLetterSpacingDisabled && (0,react.createElement)(tools_panel_item_component, {
    className: "single-column",
    hasValue: () => hasLetterSpacingValue(props),
    label: (0,_wordpress_i18n_build_module.__)('Letter spacing'),
    onDeselect: () => resetLetterSpacing(props),
    isShownByDefault: defaultControls === null || defaultControls === void 0 ? void 0 : defaultControls.letterSpacing,
    resetAllFilter: createResetAllFilter('letterSpacing'),
    panelId: clientId
  }, (0,react.createElement)(LetterSpacingEdit, props)));
}
const hasTypographySupport = blockName => {
  return TYPOGRAPHY_SUPPORT_KEYS.some(key => (0,build_module/* hasBlockSupport */.pN)(blockName, key));
};

function useIsTypographyDisabled() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const configs = [useIsFontAppearanceDisabled(props), useIsFontSizeDisabled(props), useIsLineHeightDisabled(props), useIsFontFamilyDisabled(props), useIsTextDecorationDisabled(props), useIsTextTransformDisabled(props), useIsLetterSpacingDisabled(props)];
  return configs.filter(Boolean).length === configs.length;
}
//# sourceMappingURL=typography.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/style.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */






/**
 * Internal dependencies
 */








const styleSupportKeys = [...TYPOGRAPHY_SUPPORT_KEYS, BORDER_SUPPORT_KEY, COLOR_SUPPORT_KEY, SPACING_SUPPORT_KEY];

const hasStyleSupport = blockType => styleSupportKeys.some(key => (0,build_module/* hasBlockSupport */.pN)(blockType, key));
/**
 * Returns the inline styles to add depending on the style object
 *
 * @param {Object} styles Styles configuration.
 *
 * @return {Object} Flattened CSS variables declaration.
 */


function style_getInlineStyles() {
  let styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const output = {}; // The goal is to move everything to server side generated engine styles
  // This is temporary as we absorb more and more styles into the engine.

  getCSSRules(styles).forEach(rule => {
    output[rule.key] = rule.value;
  });
  return output;
}
/**
 * Filters registered block settings, extending attributes to include `style` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */

function style_addAttribute(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default values if needed.


  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }

  return settings;
}
/**
 * A dictionary of paths to flag skipping block support serialization as the key,
 * with values providing the style paths to be omitted from serialization.
 *
 * @constant
 * @type {Record<string, string[]>}
 */


const skipSerializationPathsEdit = {
  [`${BORDER_SUPPORT_KEY}.__experimentalSkipSerialization`]: ['border'],
  [`${COLOR_SUPPORT_KEY}.__experimentalSkipSerialization`]: [COLOR_SUPPORT_KEY],
  [`${TYPOGRAPHY_SUPPORT_KEY}.__experimentalSkipSerialization`]: [TYPOGRAPHY_SUPPORT_KEY],
  [`${SPACING_SUPPORT_KEY}.__experimentalSkipSerialization`]: ['spacing']
};
/**
 * A dictionary of paths to flag skipping block support serialization as the key,
 * with values providing the style paths to be omitted from serialization.
 *
 * Extends the Edit skip paths to enable skipping additional paths in just
 * the Save component. This allows a block support to be serialized within the
 * editor, while using an alternate approach, such as server-side rendering, when
 * the support is saved.
 *
 * @constant
 * @type {Record<string, string[]>}
 */

const skipSerializationPathsSave = { ...skipSerializationPathsEdit,
  [`${SPACING_SUPPORT_KEY}`]: ['spacing.blockGap']
};
/**
 * A dictionary used to normalize feature names between support flags, style
 * object properties and __experimentSkipSerialization configuration arrays.
 *
 * This allows not having to provide a migration for a support flag and possible
 * backwards compatibility bridges, while still achieving consistency between
 * the support flag and the skip serialization array.
 *
 * @constant
 * @type {Record<string, string>}
 */

const renamedFeatures = {
  gradients: 'gradient'
};
/**
 * Override props assigned to save component to inject the CSS variables definition.
 *
 * @param {Object}                    props      Additional props applied to save element.
 * @param {Object}                    blockType  Block type.
 * @param {Object}                    attributes Block attributes.
 * @param {?Record<string, string[]>} skipPaths  An object of keys and paths to skip serialization.
 *
 * @return {Object} Filtered props applied to save element.
 */

function style_addSaveProps(props, blockType, attributes) {
  let skipPaths = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : skipSerializationPathsSave;

  if (!hasStyleSupport(blockType)) {
    return props;
  }

  let {
    style
  } = attributes;
  Object.entries(skipPaths).forEach(_ref => {
    let [indicator, path] = _ref;
    const skipSerialization = (0,build_module/* getBlockSupport */.bI)(blockType, indicator);

    if (skipSerialization === true) {
      style = (0,lodash.omit)(style, path);
    }

    if (Array.isArray(skipSerialization)) {
      skipSerialization.forEach(featureName => {
        const feature = renamedFeatures[featureName] || featureName;
        style = (0,lodash.omit)(style, [[...path, feature]]);
      });
    }
  });
  props.style = { ...style_getInlineStyles(style),
    ...props.style
  };
  return props;
}
/**
 * Filters registered block settings to extend the block edit wrapper
 * to apply the desired styles and classnames properly.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object}.Filtered block settings.
 */

function style_addEditProps(settings) {
  if (!hasStyleSupport(settings)) {
    return settings;
  }

  const existingGetEditWrapperProps = settings.getEditWrapperProps;

  settings.getEditWrapperProps = attributes => {
    let props = {};

    if (existingGetEditWrapperProps) {
      props = existingGetEditWrapperProps(attributes);
    }

    return style_addSaveProps(props, settings, attributes, skipSerializationPathsEdit);
  };

  return settings;
}
/**
 * Override the default edit UI to include new inspector controls for
 * all the custom styles configs.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const withBlockControls = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => props => {
  const shouldDisplayControls = useDisplayBlockControls();
  return (0,react.createElement)(react.Fragment, null, shouldDisplayControls && (0,react.createElement)(react.Fragment, null, (0,react.createElement)(ColorEdit, props), (0,react.createElement)(TypographyPanel, props), (0,react.createElement)(BorderPanel, props), (0,react.createElement)(DimensionsPanel, props)), (0,react.createElement)(BlockEdit, props));
}, 'withToolbarControls');
/**
 * Override the default block element to include elements styles.
 *
 * @param {Function} BlockListBlock Original component
 * @return {Function}                Wrapped component
 */

const withElementsStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  var _props$attributes$sty2, _props$attributes$sty3;

  const blockElementsContainerIdentifier = `wp-elements-${(0,use_instance_id/* default */.A)(BlockListBlock)}`;
  const skipLinkColorSerialization = shouldSkipSerialization(props.name, COLOR_SUPPORT_KEY, 'link');
  const styles = (0,react.useMemo)(() => {
    var _props$attributes$sty;

    const rawElementsStyles = (_props$attributes$sty = props.attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : _props$attributes$sty.elements;
    const elementCssRules = [];

    if (rawElementsStyles && Object.keys(rawElementsStyles).length > 0) {
      var _rawElementsStyles$li;

      // Remove values based on whether serialization has been skipped for a specific style.
      const filteredElementsStyles = { ...rawElementsStyles,
        link: { ...rawElementsStyles.link,
          color: !skipLinkColorSerialization ? (_rawElementsStyles$li = rawElementsStyles.link) === null || _rawElementsStyles$li === void 0 ? void 0 : _rawElementsStyles$li.color : undefined
        }
      };

      for (const [elementName, elementStyles] of Object.entries(filteredElementsStyles)) {
        const cssRule = compileCSS(elementStyles, {
          // The .editor-styles-wrapper selector is required on elements styles. As it is
          // added to all other editor styles, not providing it causes reset and global
          // styles to override element styles because of higher specificity.
          selector: `.editor-styles-wrapper .${blockElementsContainerIdentifier} ${build_module/* __EXPERIMENTAL_ELEMENTS */.dB[elementName]}`
        });

        if (!!cssRule) {
          elementCssRules.push(cssRule);
        }
      }
    }

    return elementCssRules.length > 0 ? elementCssRules : undefined;
  }, [(_props$attributes$sty2 = props.attributes.style) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.elements]);
  const element = (0,react.useContext)(BlockList.__unstableElementContext);
  return (0,react.createElement)(react.Fragment, null, styles && element && (0,react_dom.createPortal)((0,react.createElement)("style", {
    dangerouslySetInnerHTML: {
      __html: styles
    }
  }), element), (0,react.createElement)(BlockListBlock, (0,esm_extends/* default */.A)({}, props, {
    className: (_props$attributes$sty3 = props.attributes.style) !== null && _props$attributes$sty3 !== void 0 && _props$attributes$sty3.elements ? classnames_default()(props.className, blockElementsContainerIdentifier) : props.className
  })));
});
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/style/addAttribute', style_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('blocks.getSaveContent.extraProps', 'core/style/addSaveProps', style_addSaveProps);
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/style/addEditProps', style_addEditProps);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/style/with-block-controls', withBlockControls);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/editor/with-elements-styles', withElementsStyles);
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/settings.js
/**
 * WordPress dependencies
 */



const hasSettingsSupport = blockType => (0,build_module/* hasBlockSupport */.pN)(blockType, '__experimentalSettings', false);

function settings_addAttribute(settings) {
  var _settings$attributes;

  if (!hasSettingsSupport(settings)) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default values if needed.


  if (!(settings !== null && settings !== void 0 && (_settings$attributes = settings.attributes) !== null && _settings$attributes !== void 0 && _settings$attributes.settings)) {
    settings.attributes = { ...settings.attributes,
      settings: {
        type: 'object'
      }
    };
  }

  return settings;
}

(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/settings/addAttribute', settings_addAttribute);
//# sourceMappingURL=settings.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/swatch.js

/**
 * WordPress dependencies
 */

const swatch = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M5 17.7c.4.5.8.9 1.2 1.2l1.1-1.4c-.4-.3-.7-.6-1-1L5 17.7zM5 6.3l1.4 1.1c.3-.4.6-.7 1-1L6.3 5c-.5.4-.9.8-1.3 1.3zm.1 7.8l-1.7.5c.2.6.4 1.1.7 1.6l1.5-.8c-.2-.4-.4-.8-.5-1.3zM4.8 12v-.7L3 11.1v1.8l1.7-.2c.1-.2.1-.5.1-.7zm3 7.9c.5.3 1.1.5 1.6.7l.5-1.7c-.5-.1-.9-.3-1.3-.5l-.8 1.5zM19 6.3c-.4-.5-.8-.9-1.2-1.2l-1.1 1.4c.4.3.7.6 1 1L19 6.3zm-.1 3.6l1.7-.5c-.2-.6-.4-1.1-.7-1.6l-1.5.8c.2.4.4.8.5 1.3zM5.6 8.6l-1.5-.8c-.3.5-.5 1-.7 1.6l1.7.5c.1-.5.3-.9.5-1.3zm2.2-4.5l.8 1.5c.4-.2.8-.4 1.3-.5l-.5-1.7c-.6.2-1.1.4-1.6.7zm8.8 13.5l1.1 1.4c.5-.4.9-.8 1.2-1.2l-1.4-1.1c-.2.3-.5.6-.9.9zm1.8-2.2l1.5.8c.3-.5.5-1.1.7-1.6l-1.7-.5c-.1.5-.3.9-.5 1.3zm2.6-4.3l-1.7.2v1.4l1.7.2V12v-.9zM11.1 3l.2 1.7h1.4l.2-1.7h-1.8zm3 2.1c.5.1.9.3 1.3.5l.8-1.5c-.5-.3-1.1-.5-1.6-.7l-.5 1.7zM12 19.2h-.7l-.2 1.8h1.8l-.2-1.7c-.2-.1-.5-.1-.7-.1zm2.1-.3l.5 1.7c.6-.2 1.1-.4 1.6-.7l-.8-1.5c-.4.2-.8.4-1.3.5z"
}));
/* harmony default export */ const library_swatch = (swatch);
//# sourceMappingURL=swatch.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/duotone-picker/utils.js
/**
 * External dependencies
 */


(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
/**
 * Object representation for a color.
 *
 * @typedef {Object} RGBColor
 * @property {number} r Red component of the color in the range [0,1].
 * @property {number} g Green component of the color in the range [0,1].
 * @property {number} b Blue component of the color in the range [0,1].
 */

/**
 * Calculate the brightest and darkest values from a color palette.
 *
 * @param {Object[]} palette Color palette for the theme.
 *
 * @return {string[]} Tuple of the darkest color and brightest color.
 */

function getDefaultColors(palette) {
  // A default dark and light color are required.
  if (!palette || palette.length < 2) return ['#000', '#fff'];
  return palette.map(_ref => {
    let {
      color
    } = _ref;
    return {
      color,
      brightness: (0,node_modules_colord/* colord */.Mj)(color).brightness()
    };
  }).reduce((_ref2, current) => {
    let [min, max] = _ref2;
    return [current.brightness <= min.brightness ? current : min, current.brightness >= max.brightness ? current : max];
  }, [{
    brightness: 1
  }, {
    brightness: 0
  }]).map(_ref3 => {
    let {
      color
    } = _ref3;
    return color;
  });
}
/**
 * Generate a duotone gradient from a list of colors.
 *
 * @param {string[]} colors CSS color strings.
 * @param {string}   angle  CSS gradient angle.
 *
 * @return {string} CSS gradient string for the duotone swatch.
 */

function getGradientFromCSSColors() {
  let colors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '90deg';
  const l = 100 / colors.length;
  const stops = colors.map((c, i) => `${c} ${i * l}%, ${c} ${(i + 1) * l}%`).join(', ');
  return `linear-gradient( ${angle}, ${stops} )`;
}
/**
 * Convert a color array to an array of color stops.
 *
 * @param {string[]} colors CSS colors array
 *
 * @return {Object[]} Color stop information.
 */

function getColorStopsFromColors(colors) {
  return colors.map((color, i) => ({
    position: i * 100 / (colors.length - 1),
    color
  }));
}
/**
 * Convert a color stop array to an array colors.
 *
 * @param {Object[]} colorStops Color stop information.
 *
 * @return {string[]} CSS colors array.
 */

function getColorsFromColorStops() {
  let colorStops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return colorStops.map(_ref4 => {
    let {
      color
    } = _ref4;
    return color;
  });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/duotone-picker/duotone-swatch.js


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





function DuotoneSwatch(_ref) {
  let {
    values
  } = _ref;
  return values ? (0,react.createElement)(color_indicator, {
    colorValue: getGradientFromCSSColors(values, '135deg')
  }) : (0,react.createElement)(build_module_icon, {
    icon: library_swatch
  });
}

/* harmony default export */ const duotone_swatch = (DuotoneSwatch);
//# sourceMappingURL=duotone-swatch.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/color-list-picker/index.js


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */







function ColorOption(_ref) {
  let {
    label,
    value,
    colors,
    disableCustomColors,
    enableAlpha,
    onChange
  } = _ref;
  const [isOpen, setIsOpen] = (0,react.useState)(false);
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(build_module_button, {
    className: "components-color-list-picker__swatch-button",
    onClick: () => setIsOpen(prev => !prev)
  }, (0,react.createElement)(h_stack_component, {
    justify: "flex-start",
    spacing: 2
  }, value ? (0,react.createElement)(color_indicator, {
    colorValue: value,
    className: "components-color-list-picker__swatch-color"
  }) : (0,react.createElement)(build_module_icon, {
    icon: library_swatch
  }), (0,react.createElement)("span", null, label))), isOpen && (0,react.createElement)(ColorPalette, {
    className: "components-color-list-picker__color-picker",
    colors: colors,
    value: value,
    clearable: false,
    onChange: onChange,
    disableCustomColors: disableCustomColors,
    enableAlpha: enableAlpha
  }));
}

function ColorListPicker(_ref2) {
  let {
    colors,
    labels,
    value = [],
    disableCustomColors,
    enableAlpha,
    onChange
  } = _ref2;
  return (0,react.createElement)("div", {
    className: "components-color-list-picker"
  }, labels.map((label, index) => (0,react.createElement)(ColorOption, {
    key: index,
    label: label,
    value: value[index],
    colors: colors,
    disableCustomColors: disableCustomColors,
    enableAlpha: enableAlpha,
    onChange: newColor => {
      const newColors = value.slice();
      newColors[index] = newColor;
      onChange(newColors);
    }
  })));
}

/* harmony default export */ const color_list_picker = (ColorListPicker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/duotone-picker/custom-duotone-bar.js


/**
 * Internal dependencies
 */


const PLACEHOLDER_VALUES = ['#333', '#CCC'];
function CustomDuotoneBar(_ref) {
  let {
    value,
    onChange
  } = _ref;
  const hasGradient = !!value;
  const values = hasGradient ? value : PLACEHOLDER_VALUES;
  const background = getGradientFromCSSColors(values);
  const controlPoints = getColorStopsFromColors(values);
  return (0,react.createElement)(CustomGradientBar, {
    disableInserter: true,
    background: background,
    hasGradient: hasGradient,
    value: controlPoints,
    onChange: newColorStops => {
      const newValue = getColorsFromColorStops(newColorStops);
      onChange(newValue);
    }
  });
}
//# sourceMappingURL=custom-duotone-bar.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/duotone-picker/duotone-picker.js


/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */








function DuotonePicker(_ref) {
  let {
    clearable = true,
    unsetable = true,
    colorPalette,
    duotonePalette,
    disableCustomColors,
    disableCustomDuotone,
    value,
    onChange
  } = _ref;
  const [defaultDark, defaultLight] = (0,react.useMemo)(() => getDefaultColors(colorPalette), [colorPalette]);
  const isUnset = value === 'unset';
  const unsetOption = (0,react.createElement)(CircularOptionPicker.Option, {
    key: "unset",
    value: "unset",
    isSelected: isUnset,
    tooltipText: (0,i18n_build_module.__)('Unset'),
    className: "components-duotone-picker__color-indicator",
    onClick: () => {
      onChange(isUnset ? undefined : 'unset');
    }
  });
  const options = duotonePalette.map(_ref2 => {
    let {
      colors,
      slug,
      name
    } = _ref2;
    const style = {
      background: getGradientFromCSSColors(colors, '135deg'),
      color: 'transparent'
    };
    const tooltipText = name !== null && name !== void 0 ? name : (0,i18n_build_module/* sprintf */.nv)( // translators: %s: duotone code e.g: "dark-grayscale" or "7f7f7f-ffffff".
    (0,i18n_build_module.__)('Duotone code: %s'), slug);
    const label = name ? (0,i18n_build_module/* sprintf */.nv)( // translators: %s: The name of the option e.g: "Dark grayscale".
    (0,i18n_build_module.__)('Duotone: %s'), name) : tooltipText;
    const isSelected = (0,lodash.isEqual)(colors, value);
    return (0,react.createElement)(CircularOptionPicker.Option, {
      key: slug,
      value: colors,
      isSelected: isSelected,
      "aria-label": label,
      tooltipText: tooltipText,
      style: style,
      onClick: () => {
        onChange(isSelected ? undefined : colors);
      }
    });
  });
  return (0,react.createElement)(CircularOptionPicker, {
    options: unsetable ? [unsetOption, ...options] : options,
    actions: !!clearable && (0,react.createElement)(CircularOptionPicker.ButtonAction, {
      onClick: () => onChange(undefined)
    }, (0,i18n_build_module.__)('Clear'))
  }, (0,react.createElement)(spacer_component, {
    paddingTop: 4
  }, (0,react.createElement)(v_stack_component, {
    spacing: 3
  }, !disableCustomColors && !disableCustomDuotone && (0,react.createElement)(CustomDuotoneBar, {
    value: isUnset ? undefined : value,
    onChange: onChange
  }), !disableCustomDuotone && (0,react.createElement)(color_list_picker, {
    labels: [(0,i18n_build_module.__)('Shadows'), (0,i18n_build_module.__)('Highlights')],
    colors: colorPalette,
    value: isUnset ? undefined : value,
    disableCustomColors: disableCustomColors,
    enableAlpha: true,
    onChange: newColors => {
      if (!newColors[0]) {
        newColors[0] = defaultDark;
      }

      if (!newColors[1]) {
        newColors[1] = defaultLight;
      }

      const newValue = newColors.length >= 2 ? newColors : undefined;
      onChange(newValue);
    }
  }))));
}

/* harmony default export */ const duotone_picker = (DuotonePicker);
//# sourceMappingURL=duotone-picker.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/filter.js

/**
 * WordPress dependencies
 */

const filter = (0,react.createElement)(build_module_svg/* SVG */.t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react.createElement)(build_module_svg/* Path */.wA, {
  d: "M12 4 4 19h16L12 4zm0 3.2 5.5 10.3H12V7.2z"
}));
/* harmony default export */ const library_filter = (filter);
//# sourceMappingURL=filter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/duotone-control/index.js


/**
 * WordPress dependencies
 */





function DuotoneControl(_ref) {
  let {
    colorPalette,
    duotonePalette,
    disableCustomColors,
    disableCustomDuotone,
    value,
    onChange
  } = _ref;
  let toolbarIcon;

  if (value === 'unset') {
    toolbarIcon = (0,react.createElement)(color_indicator, {
      className: "block-editor-duotone-control__unset-indicator"
    });
  } else if (value) {
    toolbarIcon = (0,react.createElement)(duotone_swatch, {
      values: value
    });
  } else {
    toolbarIcon = (0,react.createElement)(icon, {
      icon: library_filter
    });
  }

  return (0,react.createElement)(Dropdown, {
    popoverProps: {
      className: 'block-editor-duotone-control__popover',
      headerTitle: (0,_wordpress_i18n_build_module.__)('Duotone'),
      isAlternate: true
    },
    renderToggle: _ref2 => {
      let {
        isOpen,
        onToggle
      } = _ref2;

      const openOnArrowDown = event => {
        if (!isOpen && event.keyCode === keycodes_build_module/* DOWN */.PX) {
          event.preventDefault();
          onToggle();
        }
      };

      return (0,react.createElement)(toolbar_button, {
        showTooltip: true,
        onClick: onToggle,
        "aria-haspopup": "true",
        "aria-expanded": isOpen,
        onKeyDown: openOnArrowDown,
        label: (0,_wordpress_i18n_build_module.__)('Apply duotone filter'),
        icon: toolbarIcon
      });
    },
    renderContent: () => (0,react.createElement)(menu_group, {
      label: (0,_wordpress_i18n_build_module.__)('Duotone')
    }, (0,react.createElement)("div", {
      className: "block-editor-duotone-control__description"
    }, (0,_wordpress_i18n_build_module.__)('Create a two-tone color effect without losing your original image.')), (0,react.createElement)(duotone_picker, {
      colorPalette: colorPalette,
      duotonePalette: duotonePalette,
      disableCustomColors: disableCustomColors,
      disableCustomDuotone: disableCustomDuotone,
      value: value,
      onChange: onChange
    }))
  });
}

/* harmony default export */ const duotone_control = (DuotoneControl);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/duotone.js



/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */




const duotone_EMPTY_ARRAY = [];
(0,node_modules_colord/* extend */.X$)([names/* default */.A]);
/**
 * SVG and stylesheet needed for rendering the duotone filter.
 *
 * @param {Object}           props          Duotone props.
 * @param {string}           props.selector Selector to apply the filter to.
 * @param {string}           props.id       Unique id for this duotone filter.
 * @param {string[]|"unset"} props.colors   Array of RGB color strings ordered from dark to light.
 *
 * @return {WPElement} Duotone element.
 */

function InlineDuotone(_ref) {
  let {
    selector,
    id,
    colors
  } = _ref;

  if (colors === 'unset') {
    return (0,react.createElement)(DuotoneUnsetStylesheet, {
      selector: selector
    });
  }

  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(DuotoneFilter, {
    id: id,
    colors: colors
  }), (0,react.createElement)(DuotoneStylesheet, {
    id: id,
    selector: selector
  }));
}

function useMultiOriginPresets(_ref2) {
  let {
    presetSetting,
    defaultSetting
  } = _ref2;
  const disableDefault = !use_setting_useSetting(defaultSetting);
  const userPresets = use_setting_useSetting(`${presetSetting}.custom`) || duotone_EMPTY_ARRAY;
  const themePresets = use_setting_useSetting(`${presetSetting}.theme`) || duotone_EMPTY_ARRAY;
  const defaultPresets = use_setting_useSetting(`${presetSetting}.default`) || duotone_EMPTY_ARRAY;
  return (0,react.useMemo)(() => [...userPresets, ...themePresets, ...(disableDefault ? duotone_EMPTY_ARRAY : defaultPresets)], [disableDefault, userPresets, themePresets, defaultPresets]);
}

function DuotonePanel(_ref3) {
  var _style$color;

  let {
    attributes,
    setAttributes
  } = _ref3;
  const style = attributes === null || attributes === void 0 ? void 0 : attributes.style;
  const duotone = style === null || style === void 0 ? void 0 : (_style$color = style.color) === null || _style$color === void 0 ? void 0 : _style$color.duotone;
  const duotonePalette = useMultiOriginPresets({
    presetSetting: 'color.duotone',
    defaultSetting: 'color.defaultDuotone'
  });
  const colorPalette = useMultiOriginPresets({
    presetSetting: 'color.palette',
    defaultSetting: 'color.defaultPalette'
  });
  const disableCustomColors = !use_setting_useSetting('color.custom');
  const disableCustomDuotone = !use_setting_useSetting('color.customDuotone') || (colorPalette === null || colorPalette === void 0 ? void 0 : colorPalette.length) === 0 && disableCustomColors;

  if ((duotonePalette === null || duotonePalette === void 0 ? void 0 : duotonePalette.length) === 0 && disableCustomDuotone) {
    return null;
  }

  return (0,react.createElement)(block_controls, {
    group: "block",
    __experimentalShareWithChildBlocks: true
  }, (0,react.createElement)(duotone_control, {
    duotonePalette: duotonePalette,
    colorPalette: colorPalette,
    disableCustomDuotone: disableCustomDuotone,
    disableCustomColors: disableCustomColors,
    value: duotone,
    onChange: newDuotone => {
      const newStyle = { ...style,
        color: { ...(style === null || style === void 0 ? void 0 : style.color),
          duotone: newDuotone
        }
      };
      setAttributes({
        style: newStyle
      });
    }
  }));
}
/**
 * Filters registered block settings, extending attributes to include
 * the `duotone` attribute.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function addDuotoneAttributes(settings) {
  if (!(0,build_module/* hasBlockSupport */.pN)(settings, 'color.__experimentalDuotone')) {
    return settings;
  } // Allow blocks to specify their own attribute definition with default
  // values if needed.


  if (!settings.attributes.style) {
    Object.assign(settings.attributes, {
      style: {
        type: 'object'
      }
    });
  }

  return settings;
}
/**
 * Override the default edit UI to include toolbar controls for duotone if the
 * block supports duotone.
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */


const withDuotoneControls = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => props => {
  const hasDuotoneSupport = (0,build_module/* hasBlockSupport */.pN)(props.name, 'color.__experimentalDuotone');
  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(BlockEdit, props), hasDuotoneSupport && (0,react.createElement)(DuotonePanel, props));
}, 'withDuotoneControls');
/**
 * Function that scopes a selector with another one. This works a bit like
 * SCSS nesting except the `&` operator isn't supported.
 *
 * @example
 * ```js
 * const scope = '.a, .b .c';
 * const selector = '> .x, .y';
 * const merged = scopeSelector( scope, selector );
 * // merged is '.a > .x, .a .y, .b .c > .x, .b .c .y'
 * ```
 *
 * @param {string} scope    Selector to scope to.
 * @param {string} selector Original selector.
 *
 * @return {string} Scoped selector.
 */

function scopeSelector(scope, selector) {
  const scopes = scope.split(',');
  const selectors = selector.split(',');
  const selectorsScoped = [];
  scopes.forEach(outer => {
    selectors.forEach(inner => {
      selectorsScoped.push(`${outer.trim()} ${inner.trim()}`);
    });
  });
  return selectorsScoped.join(', ');
}
/**
 * Override the default block element to include duotone styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */


const withDuotoneStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  var _props$attributes, _props$attributes$sty, _props$attributes$sty2;

  const duotoneSupport = (0,build_module/* getBlockSupport */.bI)(props.name, 'color.__experimentalDuotone');
  const colors = props === null || props === void 0 ? void 0 : (_props$attributes = props.attributes) === null || _props$attributes === void 0 ? void 0 : (_props$attributes$sty = _props$attributes.style) === null || _props$attributes$sty === void 0 ? void 0 : (_props$attributes$sty2 = _props$attributes$sty.color) === null || _props$attributes$sty2 === void 0 ? void 0 : _props$attributes$sty2.duotone;

  if (!duotoneSupport || !colors) {
    return (0,react.createElement)(BlockListBlock, props);
  }

  const id = `wp-duotone-${(0,use_instance_id/* default */.A)(BlockListBlock)}`; // Extra .editor-styles-wrapper specificity is needed in the editor
  // since we're not using inline styles to apply the filter. We need to
  // override duotone applied by global styles and theme.json.

  const selectorsGroup = scopeSelector(`.editor-styles-wrapper .${id}`, duotoneSupport);
  const className = classnames_default()(props === null || props === void 0 ? void 0 : props.className, id);
  const element = (0,react.useContext)(BlockList.__unstableElementContext);
  return (0,react.createElement)(react.Fragment, null, element && (0,react_dom.createPortal)((0,react.createElement)(InlineDuotone, {
    selector: selectorsGroup,
    id: id,
    colors: colors
  }), element), (0,react.createElement)(BlockListBlock, (0,esm_extends/* default */.A)({}, props, {
    className: className
  })));
}, 'withDuotoneStyles');
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/editor/duotone/add-attributes', addDuotoneAttributes);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/editor/duotone/with-editor-controls', withDuotoneControls);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/editor/duotone/with-styles', withDuotoneStyles);
//# sourceMappingURL=duotone.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+components@20.0.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/components/build-module/button-group/index.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function UnforwardedButtonGroup(props, ref) {
  const {
    className,
    ...restProps
  } = props;
  const classes = classnames_default()('components-button-group', className);
  return (0,react.createElement)("div", (0,helpers_esm_extends/* default */.A)({
    ref: ref,
    role: "group",
    className: classes
  }, restProps));
}
/**
 * ButtonGroup can be used to group any related buttons together. To emphasize
 * related buttons, a group should share a common container.
 *
 * ```jsx
 * import { Button, ButtonGroup } from '@wordpress/components';
 *
 * const MyButtonGroup = () => (
 *   <ButtonGroup>
 *     <Button variant="primary">Button 1</Button>
 *     <Button variant="primary">Button 2</Button>
 *   </ButtonGroup>
 * );
 * ```
 */


const ButtonGroup = (0,react.forwardRef)(UnforwardedButtonGroup);
/* harmony default export */ const button_group = (ButtonGroup);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/layout.js



/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */








/**
 * Internal dependencies
 */







const layoutBlockSupportKey = '__experimentalLayout';
/**
 * Generates the utility classnames for the given blocks layout attributes.
 * This method was primarily added to reintroduce classnames that were removed
 * in the 5.9 release (https://github.com/WordPress/gutenberg/issues/38719), rather
 * than providing an extensive list of all possible layout classes. The plan is to
 * have the style engine generate a more extensive list of utility classnames which
 * will then replace this method.
 *
 * @param { Object } layout            Layout object.
 * @param { Object } layoutDefinitions An object containing layout definitions, stored in theme.json.
 *
 * @return { Array } Array of CSS classname strings.
 */

function useLayoutClasses(layout, layoutDefinitions) {
  var _layoutDefinitions;

  const rootPaddingAlignment = use_select_useSelect(select => {
    var _getSettings$__experi;

    const {
      getSettings
    } = select(store_store);
    return (_getSettings$__experi = getSettings().__experimentalFeatures) === null || _getSettings$__experi === void 0 ? void 0 : _getSettings$__experi.useRootPaddingAwareAlignments;
  }, []);
  const layoutClassnames = [];

  if (layoutDefinitions !== null && layoutDefinitions !== void 0 && (_layoutDefinitions = layoutDefinitions[(layout === null || layout === void 0 ? void 0 : layout.type) || 'default']) !== null && _layoutDefinitions !== void 0 && _layoutDefinitions.className) {
    var _layoutDefinitions2;

    layoutClassnames.push(layoutDefinitions === null || layoutDefinitions === void 0 ? void 0 : (_layoutDefinitions2 = layoutDefinitions[(layout === null || layout === void 0 ? void 0 : layout.type) || 'default']) === null || _layoutDefinitions2 === void 0 ? void 0 : _layoutDefinitions2.className);
  }

  if ((layout !== null && layout !== void 0 && layout.inherit || layout !== null && layout !== void 0 && layout.contentSize) && rootPaddingAlignment) {
    layoutClassnames.push('has-global-padding');
  }

  if (layout !== null && layout !== void 0 && layout.orientation) {
    layoutClassnames.push(`is-${(0,lodash.kebabCase)(layout.orientation)}`);
  }

  if (layout !== null && layout !== void 0 && layout.justifyContent) {
    layoutClassnames.push(`is-content-justification-${(0,lodash.kebabCase)(layout.justifyContent)}`);
  }

  if (layout !== null && layout !== void 0 && layout.flexWrap && layout.flexWrap === 'nowrap') {
    layoutClassnames.push('is-nowrap');
  }

  return layoutClassnames;
}

function LayoutPanel(_ref) {
  let {
    setAttributes,
    attributes,
    name: blockName
  } = _ref;
  const {
    layout
  } = attributes;
  const defaultThemeLayout = use_setting_useSetting('layout');
  const themeSupportsLayout = use_select_useSelect(select => {
    const {
      getSettings
    } = select(store_store);
    return getSettings().supportsLayout;
  }, []);
  const layoutBlockSupport = (0,build_module/* getBlockSupport */.bI)(blockName, layoutBlockSupportKey, {});
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = layoutBlockSupport;

  if (!allowEditing) {
    return null;
  } // Only show the inherit toggle if it's supported,
  // a default theme layout is set (e.g. one that provides `contentSize` and/or `wideSize` values),
  // and either the default / flow or the constrained layout type is in use, as the toggle switches from one to the other.


  const showInheritToggle = !!(allowInheriting && !!defaultThemeLayout && (!(layout !== null && layout !== void 0 && layout.type) || (layout === null || layout === void 0 ? void 0 : layout.type) === 'default' || (layout === null || layout === void 0 ? void 0 : layout.type) === 'constrained' || layout !== null && layout !== void 0 && layout.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const {
    inherit = false,
    type = 'default',
    contentSize = null
  } = usedLayout;
  /**
   * `themeSupportsLayout` is only relevant to the `default/flow` or
   * `constrained` layouts and it should not be taken into account when other
   * `layout` types are used.
   */

  if ((type === 'default' || type === 'constrained') && !themeSupportsLayout) {
    return null;
  }

  const layoutType = getLayoutType(type);
  const constrainedType = getLayoutType('constrained');

  const onChangeType = newType => setAttributes({
    layout: {
      type: newType
    }
  });

  const onChangeLayout = newLayout => setAttributes({
    layout: newLayout
  });

  return (0,react.createElement)(react.Fragment, null, (0,react.createElement)(inspector_controls, null, (0,react.createElement)(body, {
    title: (0,_wordpress_i18n_build_module.__)('Layout')
  }, showInheritToggle && (0,react.createElement)(react.Fragment, null, (0,react.createElement)(ToggleControl, {
    label: (0,_wordpress_i18n_build_module.__)('Inner blocks respect content width'),
    checked: (layoutType === null || layoutType === void 0 ? void 0 : layoutType.name) === 'constrained' || !!inherit || !!contentSize,
    onChange: () => setAttributes({
      layout: {
        type: (layoutType === null || layoutType === void 0 ? void 0 : layoutType.name) === 'constrained' ? 'default' : 'constrained'
      }
    })
  }), (0,react.createElement)("p", {
    className: "block-editor-hooks__layout-controls-helptext"
  }, !!inherit || (layoutType === null || layoutType === void 0 ? void 0 : layoutType.name) === 'constrained' ? (0,_wordpress_i18n_build_module.__)('Nested blocks use theme content width with options for full and wide widths.') : (0,_wordpress_i18n_build_module.__)('Nested blocks will fill the width of this container.'))), !inherit && allowSwitching && (0,react.createElement)(LayoutTypeSwitcher, {
    type: type,
    onChange: onChangeType
  }), layoutType && layoutType.name !== 'default' && (0,react.createElement)(layoutType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }), constrainedType && !!contentSize && (0,react.createElement)(constrainedType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }))), !inherit && layoutType && (0,react.createElement)(layoutType.toolBarControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport
  }));
}

function LayoutTypeSwitcher(_ref2) {
  let {
    type,
    onChange
  } = _ref2;
  return (0,react.createElement)(button_group, null, getLayoutTypes().map(_ref3 => {
    let {
      name,
      label
    } = _ref3;
    return (0,react.createElement)(build_module_button, {
      key: name,
      isPressed: type === name,
      onClick: () => onChange(name)
    }, label);
  }));
}
/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */


function layout_addAttribute(settings) {
  if ((0,lodash.has)(settings.attributes, ['layout', 'type'])) {
    return settings;
  }

  if ((0,build_module/* hasBlockSupport */.pN)(settings, layoutBlockSupportKey)) {
    settings.attributes = { ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }

  return settings;
}
/**
 * Override the default edit UI to include layout controls
 *
 * @param {Function} BlockEdit Original component.
 *
 * @return {Function} Wrapped component.
 */

const withInspectorControls = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockEdit => props => {
  const {
    name: blockName
  } = props;
  const supportLayout = (0,build_module/* hasBlockSupport */.pN)(blockName, layoutBlockSupportKey);
  return [supportLayout && (0,react.createElement)(LayoutPanel, (0,esm_extends/* default */.A)({
    key: "layout"
  }, props)), (0,react.createElement)(BlockEdit, (0,esm_extends/* default */.A)({
    key: "edit"
  }, props))];
}, 'withInspectorControls');
/**
 * Override the default block element to add the layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */

const withLayoutStyles = (0,create_higher_order_component/* createHigherOrderComponent */.f)(BlockListBlock => props => {
  const {
    name,
    attributes
  } = props;
  const hasLayoutBlockSupport = (0,build_module/* hasBlockSupport */.pN)(name, layoutBlockSupportKey);
  const disableLayoutStyles = use_select_useSelect(select => {
    const {
      getSettings
    } = select(store_store);
    return !!getSettings().disableLayoutStyles;
  });
  const shouldRenderLayoutStyles = hasLayoutBlockSupport && !disableLayoutStyles;
  const id = (0,use_instance_id/* default */.A)(BlockListBlock);
  const defaultThemeLayout = use_setting_useSetting('layout') || {};
  const element = (0,react.useContext)(BlockList.__unstableElementContext);
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = (0,build_module/* getBlockSupport */.bI)(name, layoutBlockSupportKey) || {};
  const usedLayout = layout !== null && layout !== void 0 && layout.inherit || layout !== null && layout !== void 0 && layout.contentSize || layout !== null && layout !== void 0 && layout.wideSize ? { ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClasses = hasLayoutBlockSupport ? useLayoutClasses(usedLayout, defaultThemeLayout === null || defaultThemeLayout === void 0 ? void 0 : defaultThemeLayout.definitions) : null;
  const selector = `.${(0,build_module/* getBlockDefaultClassName */.KW)(name)}.wp-container-${id}`;
  const blockGapSupport = use_setting_useSetting('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null; // Get CSS string for the current layout type.
  // The CSS and `style` element is only output if it is not empty.

  let css;

  if (shouldRenderLayoutStyles) {
    var _fullLayoutType$getLa;

    const fullLayoutType = getLayoutType((usedLayout === null || usedLayout === void 0 ? void 0 : usedLayout.type) || 'default');
    css = fullLayoutType === null || fullLayoutType === void 0 ? void 0 : (_fullLayoutType$getLa = fullLayoutType.getLayoutStyle) === null || _fullLayoutType$getLa === void 0 ? void 0 : _fullLayoutType$getLa.call(fullLayoutType, {
      blockName: name,
      selector,
      layout: usedLayout,
      layoutDefinitions: defaultThemeLayout === null || defaultThemeLayout === void 0 ? void 0 : defaultThemeLayout.definitions,
      style: attributes === null || attributes === void 0 ? void 0 : attributes.style,
      hasBlockGapSupport
    });
  } // Attach a `wp-container-` id-based class name as well as a layout class name such as `is-layout-flex`.


  const className = classnames_default()(props === null || props === void 0 ? void 0 : props.className, {
    [`wp-container-${id}`]: shouldRenderLayoutStyles && !!css // Only attach a container class if there is generated CSS to be attached.

  }, layoutClasses);
  return (0,react.createElement)(react.Fragment, null, shouldRenderLayoutStyles && element && !!css && (0,react_dom.createPortal)((0,react.createElement)(LayoutStyle, {
    blockName: name,
    selector: selector,
    css: css,
    layout: usedLayout,
    style: attributes === null || attributes === void 0 ? void 0 : attributes.style
  }), element), (0,react.createElement)(BlockListBlock, (0,esm_extends/* default */.A)({}, props, {
    className: className
  })));
});
(0,hooks_build_module/* addFilter */.U2)('blocks.registerBlockType', 'core/layout/addAttribute', layout_addAttribute);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
(0,hooks_build_module/* addFilter */.U2)('editor.BlockEdit', 'core/editor/layout/with-inspector-controls', withInspectorControls);
//# sourceMappingURL=layout.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/use-border-props.js
/**
 * Internal dependencies
 */


 // This utility is intended to assist where the serialization of the border
// block support is being skipped for a block but the border related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's border support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 * @return {Object} Border block support derived CSS classes & styles.
 */

function getBorderClassesAndStyles(attributes) {
  var _attributes$style;

  const border = ((_attributes$style = attributes.style) === null || _attributes$style === void 0 ? void 0 : _attributes$style.border) || {};
  const className = getBorderClasses(attributes);
  return {
    className: className || undefined,
    style: getInlineStyles({
      border
    })
  };
}
/**
 * Derives the border related props for a block from its border block support
 * attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} ClassName & style props from border block support.
 */

function useBorderProps(attributes) {
  const {
    colors
  } = useMultipleOriginColorsAndGradients();
  const borderProps = getBorderClassesAndStyles(attributes);
  const {
    borderColor
  } = attributes; // Force inline styles to apply named border colors when themes do not load
  // their color stylesheets in the editor.

  if (borderColor) {
    const borderColorObject = getMultiOriginColor({
      colors,
      namedColor: borderColor
    });
    borderProps.style.borderColor = borderColorObject.color;
  }

  return borderProps;
}
//# sourceMappingURL=use-border-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/use-color-props.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




 // The code in this file has largely been lifted from the color block support
// hook.
//
// This utility is intended to assist where the serialization of the colors
// block support is being skipped for a block but the color related CSS classes
// & styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's color support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Color block support derived CSS classes & styles.
 */

function getColorClassesAndStyles(attributes) {
  var _style$color, _style$color2, _style$color3, _style$color4, _style$elements, _style$elements$link;

  const {
    backgroundColor,
    textColor,
    gradient,
    style
  } = attributes; // Collect color CSS classes.

  const backgroundClass = getColorClassName('background-color', backgroundColor);
  const textClass = getColorClassName('color', textColor);

  const gradientClass = __experimentalGetGradientClass(gradient);

  const hasGradient = gradientClass || (style === null || style === void 0 ? void 0 : (_style$color = style.color) === null || _style$color === void 0 ? void 0 : _style$color.gradient); // Determine color CSS class name list.

  const className = classnames(textClass, gradientClass, {
    // Don't apply the background class if there's a gradient.
    [backgroundClass]: !hasGradient && !!backgroundClass,
    'has-text-color': textColor || (style === null || style === void 0 ? void 0 : (_style$color2 = style.color) === null || _style$color2 === void 0 ? void 0 : _style$color2.text),
    'has-background': backgroundColor || (style === null || style === void 0 ? void 0 : (_style$color3 = style.color) === null || _style$color3 === void 0 ? void 0 : _style$color3.background) || gradient || (style === null || style === void 0 ? void 0 : (_style$color4 = style.color) === null || _style$color4 === void 0 ? void 0 : _style$color4.gradient),
    'has-link-color': style === null || style === void 0 ? void 0 : (_style$elements = style.elements) === null || _style$elements === void 0 ? void 0 : (_style$elements$link = _style$elements.link) === null || _style$elements$link === void 0 ? void 0 : _style$elements$link.color
  }); // Collect inline styles for colors.

  const colorStyles = (style === null || style === void 0 ? void 0 : style.color) || {};
  const styleProp = getInlineStyles({
    color: colorStyles
  });
  return {
    className: className || undefined,
    style: styleProp
  };
}
const EMPTY_OBJECT = {};
/**
 * Determines the color related props for a block derived from its color block
 * support attributes.
 *
 * Inline styles are forced for named colors to ensure these selections are
 * reflected when themes do not load their color stylesheets in the editor.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} ClassName & style props from colors block support.
 */

function useColorProps(attributes) {
  const {
    backgroundColor,
    textColor,
    gradient
  } = attributes; // Some color settings have a special handling for deprecated flags in `useSetting`,
  // so we can't unwrap them by doing const { ... } = useSetting('color')
  // until https://github.com/WordPress/gutenberg/issues/37094 is fixed.

  const userPalette = useSetting('color.palette.custom') || [];
  const themePalette = useSetting('color.palette.theme') || [];
  const defaultPalette = useSetting('color.palette.default') || [];
  const gradientsPerOrigin = useSetting('color.gradients') || EMPTY_OBJECT;
  const colors = useMemo(() => [...(userPalette || []), ...(themePalette || []), ...(defaultPalette || [])], [userPalette, themePalette, defaultPalette]);
  const gradients = useMemo(() => [...((gradientsPerOrigin === null || gradientsPerOrigin === void 0 ? void 0 : gradientsPerOrigin.custom) || []), ...((gradientsPerOrigin === null || gradientsPerOrigin === void 0 ? void 0 : gradientsPerOrigin.theme) || []), ...((gradientsPerOrigin === null || gradientsPerOrigin === void 0 ? void 0 : gradientsPerOrigin.default) || [])], [gradientsPerOrigin]);
  const colorProps = getColorClassesAndStyles(attributes); // Force inline styles to apply colors when themes do not load their color
  // stylesheets in the editor.

  if (backgroundColor) {
    const backgroundColorObject = getColorObjectByAttributeValues(colors, backgroundColor);
    colorProps.style.backgroundColor = backgroundColorObject.color;
  }

  if (gradient) {
    colorProps.style.background = getGradientValueBySlug(gradients, gradient);
  }

  if (textColor) {
    const textColorObject = getColorObjectByAttributeValues(colors, textColor);
    colorProps.style.color = textColorObject.color;
  }

  return colorProps;
}
//# sourceMappingURL=use-color-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/use-spacing-props.js
/**
 * Internal dependencies
 */
 // This utility is intended to assist where the serialization of the spacing
// block support is being skipped for a block but the spacing related CSS
// styles still need to be generated so they can be applied to inner elements.

/**
 * Provides the CSS class names and inline styles for a block's spacing support
 * attributes.
 *
 * @param {Object} attributes Block attributes.
 *
 * @return {Object} Spacing block support derived CSS classes & styles.
 */

function getSpacingClassesAndStyles(attributes) {
  const {
    style
  } = attributes; // Collect inline styles for spacing.

  const spacingStyles = (style === null || style === void 0 ? void 0 : style.spacing) || {};
  const styleProp = getInlineStyles({
    spacing: spacingStyles
  });
  return {
    style: styleProp
  };
}
//# sourceMappingURL=use-spacing-props.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/use-cached-truthy.js
/**
 * WordPress dependencies
 */

/**
 * Keeps an up-to-date copy of the passed value and returns it. If value becomes falsy, it will return the last truthy copy.
 *
 * @param {any} value
 * @return {any} value
 */

function useCachedTruthy(value) {
  const [cachedValue, setCachedValue] = useState(value);
  useEffect(() => {
    if (value) {
      setCachedValue(value);
    }
  }, [value]);
  return cachedValue;
}
//# sourceMappingURL=use-cached-truthy.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/hooks/index.js
/**
 * Internal dependencies
 */




















//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/block-tools/index.js



/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */






/**
 * Renders block tools (the block toolbar, select/navigation mode toolbar, the
 * insertion point and a slot for the inline rich text toolbar). Must be wrapped
 * around the block content and editor styles wrapper or iframe.
 *
 * @param {Object} $0                      Props.
 * @param {Object} $0.children             The block content and style container.
 * @param {Object} $0.__unstableContentRef Ref holding the content scroll container.
 */

function BlockTools(_ref) {
  let {
    children,
    __unstableContentRef,
    ...props
  } = _ref;
  const isLargeViewport = (0,use_viewport_match/* default */.A)('medium');
  const hasFixedToolbar = use_select_useSelect(select => select(store_store).getSettings().hasFixedToolbar, []);
  const isMatch = useShortcutEventMatch();
  const {
    getSelectedBlockClientIds,
    getBlockRootClientId
  } = use_select_useSelect(store_store);
  const {
    duplicateBlocks,
    removeBlocks,
    insertAfterBlock,
    insertBeforeBlock,
    clearSelectedBlock,
    moveBlocksUp,
    moveBlocksDown
  } = use_dispatch(store_store);

  function onKeyDown(event) {
    if (event.defaultPrevented) return;

    if (isMatch('core/block-editor/move-up', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId((0,lodash.first)(clientIds));
        moveBlocksUp(clientIds, rootClientId);
      }
    } else if (isMatch('core/block-editor/move-down', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        const rootClientId = getBlockRootClientId((0,lodash.first)(clientIds));
        moveBlocksDown(clientIds, rootClientId);
      }
    } else if (isMatch('core/block-editor/duplicate', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        duplicateBlocks(clientIds);
      }
    } else if (isMatch('core/block-editor/remove', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        removeBlocks(clientIds);
      }
    } else if (isMatch('core/block-editor/insert-after', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        insertAfterBlock((0,lodash.last)(clientIds));
      }
    } else if (isMatch('core/block-editor/insert-before', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        insertBeforeBlock((0,lodash.first)(clientIds));
      }
    } else if (isMatch('core/block-editor/unselect', event)) {
      const clientIds = getSelectedBlockClientIds();

      if (clientIds.length) {
        event.preventDefault();
        clearSelectedBlock();
        event.target.ownerDocument.defaultView.getSelection().removeAllRanges();
        __unstableContentRef === null || __unstableContentRef === void 0 ? void 0 : __unstableContentRef.current.focus();
      }
    }
  }

  return (// eslint-disable-next-line jsx-a11y/no-static-element-interactions
    (0,react.createElement)("div", (0,esm_extends/* default */.A)({}, props, {
      onKeyDown: onKeyDown
    }), (0,react.createElement)(InsertionPoint, {
      __unstableContentRef: __unstableContentRef
    }, (hasFixedToolbar || !isLargeViewport) && (0,react.createElement)(block_contextual_toolbar, {
      isFixed: true
    }), (0,react.createElement)(WrappedBlockPopover, {
      __unstableContentRef: __unstableContentRef
    }), (0,react.createElement)(popover.Slot, {
      name: "block-toolbar",
      ref: use_popover_scroll(__unstableContentRef)
    }), children, (0,react.createElement)(popover.Slot, {
      name: "__unstable-block-tools-after",
      ref: use_popover_scroll(__unstableContentRef)
    })))
  );
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/observe-typing/index.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


/**
 * Set of key codes upon which typing is to be initiated on a keydown event.
 *
 * @type {Set<number>}
 */

const KEY_DOWN_ELIGIBLE_KEY_CODES = new Set([keycodes_build_module.UP, keycodes_build_module/* RIGHT */.NS, keycodes_build_module/* DOWN */.PX, keycodes_build_module/* LEFT */.M3, keycodes_build_module/* ENTER */.Fm, keycodes_build_module/* BACKSPACE */.G_]);
/**
 * Returns true if a given keydown event can be inferred as intent to start
 * typing, or false otherwise. A keydown is considered eligible if it is a
 * text navigation without shift active.
 *
 * @param {KeyboardEvent} event Keydown event to test.
 *
 * @return {boolean} Whether event is eligible to start typing.
 */

function isKeyDownEligibleForStartTyping(event) {
  const {
    keyCode,
    shiftKey
  } = event;
  return !shiftKey && KEY_DOWN_ELIGIBLE_KEY_CODES.has(keyCode);
}
/**
 * Removes the `isTyping` flag when the mouse moves in the document of the given
 * element.
 */


function useMouseMoveTypingReset() {
  const isTyping = use_select_useSelect(select => select(store_store).isTyping(), []);
  const {
    stopTyping
  } = use_dispatch(store_store);
  return (0,use_ref_effect/* default */.A)(node => {
    if (!isTyping) {
      return;
    }

    const {
      ownerDocument
    } = node;
    let lastClientX;
    let lastClientY;
    /**
     * On mouse move, unset typing flag if user has moved cursor.
     *
     * @param {MouseEvent} event Mousemove event.
     */

    function stopTypingOnMouseMove(event) {
      const {
        clientX,
        clientY
      } = event; // We need to check that the mouse really moved because Safari
      // triggers mousemove events when shift or ctrl are pressed.

      if (lastClientX && lastClientY && (lastClientX !== clientX || lastClientY !== clientY)) {
        stopTyping();
      }

      lastClientX = clientX;
      lastClientY = clientY;
    }

    ownerDocument.addEventListener('mousemove', stopTypingOnMouseMove);
    return () => {
      ownerDocument.removeEventListener('mousemove', stopTypingOnMouseMove);
    };
  }, [isTyping, stopTyping]);
}
/**
 * Sets and removes the `isTyping` flag based on user actions:
 *
 * - Sets the flag if the user types within the given element.
 * - Removes the flag when the user selects some text, focusses a non-text
 *   field, presses ESC or TAB, or moves the mouse in the document.
 */

function useTypingObserver() {
  const {
    isTyping,
    hasInlineToolbar
  } = use_select_useSelect(select => {
    const {
      isTyping: _isTyping,
      getSettings
    } = select(store_store);
    return {
      isTyping: _isTyping(),
      hasInlineToolbar: getSettings().hasInlineToolbar
    };
  }, []);
  const {
    startTyping,
    stopTyping
  } = use_dispatch(store_store);
  const ref1 = useMouseMoveTypingReset();
  const ref2 = (0,use_ref_effect/* default */.A)(node => {
    const {
      ownerDocument
    } = node;
    const {
      defaultView
    } = ownerDocument;
    const selection = defaultView.getSelection(); // Listeners to stop typing should only be added when typing.
    // Listeners to start typing should only be added when not typing.

    if (isTyping) {
      let timerId;
      /**
       * Stops typing when focus transitions to a non-text field element.
       *
       * @param {FocusEvent} event Focus event.
       */

      function stopTypingOnNonTextField(event) {
        const {
          target
        } = event; // Since focus to a non-text field via arrow key will trigger
        // before the keydown event, wait until after current stack
        // before evaluating whether typing is to be stopped. Otherwise,
        // typing will re-start.

        timerId = defaultView.setTimeout(() => {
          if (!isTextField(target)) {
            stopTyping();
          }
        });
      }
      /**
       * Unsets typing flag if user presses Escape while typing flag is
       * active.
       *
       * @param {KeyboardEvent} event Keypress or keydown event to
       *                              interpret.
       */


      function stopTypingOnEscapeKey(event) {
        const {
          keyCode
        } = event;

        if (keyCode === keycodes_build_module/* ESCAPE */._f || keyCode === keycodes_build_module/* TAB */.wn) {
          stopTyping();
        }
      }
      /**
       * On selection change, unset typing flag if user has made an
       * uncollapsed (shift) selection.
       */


      function stopTypingOnSelectionUncollapse() {
        if (!selection.isCollapsed) {
          stopTyping();
        }
      }

      node.addEventListener('focus', stopTypingOnNonTextField);
      node.addEventListener('keydown', stopTypingOnEscapeKey);

      if (!hasInlineToolbar) {
        ownerDocument.addEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      }

      return () => {
        defaultView.clearTimeout(timerId);
        node.removeEventListener('focus', stopTypingOnNonTextField);
        node.removeEventListener('keydown', stopTypingOnEscapeKey);
        ownerDocument.removeEventListener('selectionchange', stopTypingOnSelectionUncollapse);
      };
    }
    /**
     * Handles a keypress or keydown event to infer intention to start
     * typing.
     *
     * @param {KeyboardEvent} event Keypress or keydown event to interpret.
     */


    function startTypingInTextField(event) {
      const {
        type,
        target
      } = event; // Abort early if already typing, or key press is incurred outside a
      // text field (e.g. arrow-ing through toolbar buttons).
      // Ignore typing if outside the current DOM container

      if (!isTextField(target) || !node.contains(target)) {
        return;
      } // Special-case keydown because certain keys do not emit a keypress
      // event. Conversely avoid keydown as the canonical event since
      // there are many keydown which are explicitly not targeted for
      // typing.


      if (type === 'keydown' && !isKeyDownEligibleForStartTyping(event)) {
        return;
      }

      startTyping();
    }

    node.addEventListener('keypress', startTypingInTextField);
    node.addEventListener('keydown', startTypingInTextField);
    return () => {
      node.removeEventListener('keypress', startTypingInTextField);
      node.removeEventListener('keydown', startTypingInTextField);
    };
  }, [isTyping, hasInlineToolbar, startTyping, stopTyping]);
  return (0,use_merge_refs/* default */.A)([ref1, ref2]);
}

function ObserveTyping(_ref) {
  let {
    children
  } = _ref;
  return (0,react.createElement)("div", {
    ref: useTypingObserver()
  }, children);
}
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/observe-typing/README.md
 */


/* harmony default export */ const observe_typing = (ObserveTyping);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/components/index.js
/*
 * Block Creation Components
 */

































































/*
 * Content Related Components
 */






































/*
 * State Related Components
 */



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-editor@9.8.0_@types+react@17.0.71_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/@wordpress/block-editor/build-module/index.js
/**
 * Internal dependencies
 */







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  dB: () => (/* reexport */ __EXPERIMENTAL_ELEMENTS),
  UT: () => (/* reexport */ __EXPERIMENTAL_PATHS_WITH_MERGE),
  Eb: () => (/* reexport */ __experimentalCloneSanitizedBlock),
  wZ: () => (/* reexport */ getAccessibleBlockLabel),
  GJ: () => (/* reexport */ __experimentalGetBlockAttributesNamesByRole),
  Y0: () => (/* reexport */ getBlockLabel),
  cV: () => (/* reexport */ getBlockProps),
  v9: () => (/* reexport */ getInnerBlocksProps),
  JB: () => (/* reexport */ cloneBlock),
  Wv: () => (/* reexport */ createBlock),
  to: () => (/* reexport */ createBlocksFromInnerBlocksTemplate),
  V6: () => (/* reexport */ doBlocksMatchTemplate),
  wG: () => (/* reexport */ findTransform),
  Ph: () => (/* reexport */ getBlockAttributes),
  F8: () => (/* reexport */ getBlockInnerHTML),
  KW: () => (/* reexport */ getBlockDefaultClassName),
  KL: () => (/* reexport */ getBlockFromExample),
  HK: () => (/* reexport */ getBlockMenuDefaultClassName),
  bI: () => (/* reexport */ getBlockSupport),
  XD: () => (/* reexport */ getBlockTransforms),
  E7: () => (/* reexport */ getBlockType),
  li: () => (/* reexport */ getBlockTypes),
  oO: () => (/* reexport */ getBlockVariations),
  K$: () => (/* reexport */ getDefaultBlockName),
  Fk: () => (/* reexport */ getPossibleBlockTransformations),
  Z9: () => (/* reexport */ getSaveContent),
  pN: () => (/* reexport */ hasBlockSupport),
  tk: () => (/* reexport */ isReusableBlock),
  gc: () => (/* reexport */ isTemplatePart),
  Xw: () => (/* reexport */ utils_isUnmodifiedDefaultBlock),
  qg: () => (/* reexport */ parser_parse),
  Gk: () => (/* reexport */ pasteHandler),
  lh: () => (/* reexport */ rawHandler),
  lK: () => (/* reexport */ serializer_serialize),
  Kx: () => (/* reexport */ serializeRawBlock),
  M_: () => (/* reexport */ store),
  bh: () => (/* reexport */ switchToBlockType),
  Nk: () => (/* reexport */ synchronizeBlocksWithTemplate),
  YV: () => (/* reexport */ validateBlock)
});

// UNUSED EXPORTS: __EXPERIMENTAL_STYLE_PROPERTY, __experimentalSanitizeBlockAttributes, __unstableSerializeAndClean, children, getCategories, getChildBlockNames, getFreeformContentHandlerName, getGroupingBlockName, getPhrasingContentSchema, getSaveElement, getUnregisteredTypeHandlerName, hasChildBlocks, hasChildBlocksWithInserterSupport, isValidBlockContent, isValidIcon, node, normalizeIconObject, parseWithAttributeSchema, registerBlockCollection, registerBlockStyle, registerBlockType, registerBlockVariation, setCategories, setDefaultBlockName, setFreeformContentHandlerName, setGroupingBlockName, setUnregisteredTypeHandlerName, unregisterBlockStyle, unregisterBlockType, unregisterBlockVariation, unstable__bootstrapServerSideBlockDefinitions, updateCategory, withBlockContentContext

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  __experimentalGetUnprocessedBlockTypes: () => (__experimentalGetUnprocessedBlockTypes),
  __experimentalHasContentRoleAttribute: () => (__experimentalHasContentRoleAttribute),
  getActiveBlockVariation: () => (getActiveBlockVariation),
  getBlockStyles: () => (getBlockStyles),
  getBlockSupport: () => (selectors_getBlockSupport),
  getBlockType: () => (selectors_getBlockType),
  getBlockTypes: () => (selectors_getBlockTypes),
  getBlockVariations: () => (selectors_getBlockVariations),
  getCategories: () => (getCategories),
  getChildBlockNames: () => (selectors_getChildBlockNames),
  getCollections: () => (getCollections),
  getDefaultBlockName: () => (selectors_getDefaultBlockName),
  getDefaultBlockVariation: () => (getDefaultBlockVariation),
  getFreeformFallbackBlockName: () => (getFreeformFallbackBlockName),
  getGroupingBlockName: () => (selectors_getGroupingBlockName),
  getUnregisteredFallbackBlockName: () => (getUnregisteredFallbackBlockName),
  hasBlockSupport: () => (selectors_hasBlockSupport),
  hasChildBlocks: () => (selectors_hasChildBlocks),
  hasChildBlocksWithInserterSupport: () => (selectors_hasChildBlocksWithInserterSupport),
  isMatchingSearchTerm: () => (isMatchingSearchTerm)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  __experimentalReapplyBlockTypeFilters: () => (__experimentalReapplyBlockTypeFilters),
  __experimentalRegisterBlockType: () => (__experimentalRegisterBlockType),
  addBlockCollection: () => (addBlockCollection),
  addBlockStyles: () => (addBlockStyles),
  addBlockTypes: () => (addBlockTypes),
  addBlockVariations: () => (addBlockVariations),
  removeBlockCollection: () => (removeBlockCollection),
  removeBlockStyles: () => (removeBlockStyles),
  removeBlockTypes: () => (removeBlockTypes),
  removeBlockVariations: () => (removeBlockVariations),
  setCategories: () => (setCategories),
  setDefaultBlockName: () => (actions_setDefaultBlockName),
  setFreeformFallbackBlockName: () => (setFreeformFallbackBlockName),
  setGroupingBlockName: () => (actions_setGroupingBlockName),
  setUnregisteredFallbackBlockName: () => (setUnregisteredFallbackBlockName),
  updateCategory: () => (updateCategory)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js + 9 modules
var redux_store = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/index.js
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@7.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var lodash = __webpack_require__("../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/index.js + 3 modules
var i18n_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs
var colord = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/index.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs
var names = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/names.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs
var a11y = __webpack_require__("../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/safe-html.js
var safe_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/safe-html.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/strip-html.js
/**
 * Internal dependencies
 */

/**
 * Removes any HTML tags from the provided string.
 *
 * @param {string} html The string containing html.
 *
 * @return {string} The text content with any html removed.
 */

function stripHTML(html) {
  // Remove any script tags or on* attributes otherwise their *contents* will be left
  // in place following removal of HTML tags.
  html = (0,safe_html/* default */.A)(html);
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = html;
  return doc.body.textContent || '';
}
//# sourceMappingURL=strip-html.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/constants.js
const constants_BLOCK_ICON_DEFAULT = 'block-default';
/**
 * Array of valid keys in a block type settings deprecation object.
 *
 * @type {string[]}
 */

const DEPRECATED_ENTRY_KEYS = ['attributes', 'supports', 'save', 'migrate', 'isEligible', 'apiVersion'];
const __EXPERIMENTAL_STYLE_PROPERTY = {
  // Kept for back-compatibility purposes.
  '--wp--style--color--link': {
    value: ['color', 'link'],
    support: ['color', 'link']
  },
  background: {
    value: ['color', 'gradient'],
    support: ['color', 'gradients'],
    useEngine: true
  },
  backgroundColor: {
    value: ['color', 'background'],
    support: ['color', 'background'],
    requiresOptOut: true,
    useEngine: true
  },
  borderColor: {
    value: ['border', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderRadius: {
    value: ['border', 'radius'],
    support: ['__experimentalBorder', 'radius'],
    properties: {
      borderTopLeftRadius: 'topLeft',
      borderTopRightRadius: 'topRight',
      borderBottomLeftRadius: 'bottomLeft',
      borderBottomRightRadius: 'bottomRight'
    },
    useEngine: true
  },
  borderStyle: {
    value: ['border', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderWidth: {
    value: ['border', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderTopColor: {
    value: ['border', 'top', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderTopStyle: {
    value: ['border', 'top', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderTopWidth: {
    value: ['border', 'top', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderRightColor: {
    value: ['border', 'right', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderRightStyle: {
    value: ['border', 'right', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderRightWidth: {
    value: ['border', 'right', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderBottomColor: {
    value: ['border', 'bottom', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderBottomStyle: {
    value: ['border', 'bottom', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderBottomWidth: {
    value: ['border', 'bottom', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  borderLeftColor: {
    value: ['border', 'left', 'color'],
    support: ['__experimentalBorder', 'color'],
    useEngine: true
  },
  borderLeftStyle: {
    value: ['border', 'left', 'style'],
    support: ['__experimentalBorder', 'style'],
    useEngine: true
  },
  borderLeftWidth: {
    value: ['border', 'left', 'width'],
    support: ['__experimentalBorder', 'width'],
    useEngine: true
  },
  color: {
    value: ['color', 'text'],
    support: ['color', 'text'],
    requiresOptOut: true,
    useEngine: true
  },
  filter: {
    value: ['filter', 'duotone'],
    support: ['color', '__experimentalDuotone']
  },
  linkColor: {
    value: ['elements', 'link', 'color', 'text'],
    support: ['color', 'link']
  },
  buttonColor: {
    value: ['elements', 'button', 'color', 'text'],
    support: ['color', 'button']
  },
  buttonBackgroundColor: {
    value: ['elements', 'button', 'color', 'background'],
    support: ['color', 'button']
  },
  fontFamily: {
    value: ['typography', 'fontFamily'],
    support: ['typography', '__experimentalFontFamily'],
    useEngine: true
  },
  fontSize: {
    value: ['typography', 'fontSize'],
    support: ['typography', 'fontSize'],
    useEngine: true
  },
  fontStyle: {
    value: ['typography', 'fontStyle'],
    support: ['typography', '__experimentalFontStyle'],
    useEngine: true
  },
  fontWeight: {
    value: ['typography', 'fontWeight'],
    support: ['typography', '__experimentalFontWeight'],
    useEngine: true
  },
  lineHeight: {
    value: ['typography', 'lineHeight'],
    support: ['typography', 'lineHeight'],
    useEngine: true
  },
  margin: {
    value: ['spacing', 'margin'],
    support: ['spacing', 'margin'],
    properties: {
      marginTop: 'top',
      marginRight: 'right',
      marginBottom: 'bottom',
      marginLeft: 'left'
    },
    useEngine: true
  },
  minHeight: {
    value: ['dimensions', 'minHeight'],
    support: ['dimensions', 'minHeight'],
    useEngine: true
  },
  padding: {
    value: ['spacing', 'padding'],
    support: ['spacing', 'padding'],
    properties: {
      paddingTop: 'top',
      paddingRight: 'right',
      paddingBottom: 'bottom',
      paddingLeft: 'left'
    },
    useEngine: true
  },
  textDecoration: {
    value: ['typography', 'textDecoration'],
    support: ['typography', '__experimentalTextDecoration'],
    useEngine: true
  },
  textTransform: {
    value: ['typography', 'textTransform'],
    support: ['typography', '__experimentalTextTransform'],
    useEngine: true
  },
  letterSpacing: {
    value: ['typography', 'letterSpacing'],
    support: ['typography', '__experimentalLetterSpacing'],
    useEngine: true
  },
  '--wp--style--root--padding': {
    value: ['spacing', 'padding'],
    support: ['spacing', 'padding'],
    properties: {
      '--wp--style--root--padding-top': 'top',
      '--wp--style--root--padding-right': 'right',
      '--wp--style--root--padding-bottom': 'bottom',
      '--wp--style--root--padding-left': 'left'
    },
    rootOnly: true
  }
};
const __EXPERIMENTAL_ELEMENTS = {
  link: 'a',
  heading: 'h1, h2, h3, h4, h5, h6',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  button: '.wp-element-button, .wp-block-button__link',
  caption: '.wp-element-caption, .wp-block-audio figcaption, .wp-block-embed figcaption, .wp-block-gallery figcaption, .wp-block-image figcaption, .wp-block-table figcaption, .wp-block-video figcaption',
  cite: 'cite'
};
const __EXPERIMENTAL_PATHS_WITH_MERGE = {
  'color.duotone': true,
  'color.gradients': true,
  'color.palette': true,
  'typography.fontFamilies': true,
  'typography.fontSizes': true,
  'spacing.spacingSizes': true
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/registration.js
/* eslint no-console: [ 'error', { allow: [ 'error', 'warn' ] } ] */

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */

const i18nBlockSchema = {
  title: "block title",
  description: "block description",
  keywords: ["block keyword"],
  styles: [{
    label: "block style label"
  }],
  variations: [{
    title: "block variation title",
    description: "block variation description",
    keywords: ["block variation keyword"]
  }]
};


/**
 * An icon type definition. One of a Dashicon slug, an element,
 * or a component.
 *
 * @typedef {(string|WPElement|WPComponent)} WPIcon
 *
 * @see https://developer.wordpress.org/resource/dashicons/
 */

/**
 * Render behavior of a block type icon; one of a Dashicon slug, an element,
 * or a component.
 *
 * @typedef {WPIcon} WPBlockTypeIconRender
 */

/**
 * An object describing a normalized block type icon.
 *
 * @typedef {Object} WPBlockTypeIconDescriptor
 *
 * @property {WPBlockTypeIconRender} src         Render behavior of the icon,
 *                                               one of a Dashicon slug, an
 *                                               element, or a component.
 * @property {string}                background  Optimal background hex string
 *                                               color when displaying icon.
 * @property {string}                foreground  Optimal foreground hex string
 *                                               color when displaying icon.
 * @property {string}                shadowColor Optimal shadow hex string
 *                                               color when displaying icon.
 */

/**
 * Value to use to render the icon for a block type in an editor interface,
 * either a Dashicon slug, an element, a component, or an object describing
 * the icon.
 *
 * @typedef {(WPBlockTypeIconDescriptor|WPBlockTypeIconRender)} WPBlockTypeIcon
 */

/**
 * Named block variation scopes.
 *
 * @typedef {'block'|'inserter'|'transform'} WPBlockVariationScope
 */

/**
 * An object describing a variation defined for the block type.
 *
 * @typedef {Object} WPBlockVariation
 *
 * @property {string}                  name          The unique and machine-readable name.
 * @property {string}                  title         A human-readable variation title.
 * @property {string}                  [description] A detailed variation description.
 * @property {string}                  [category]    Block type category classification,
 *                                                   used in search interfaces to arrange
 *                                                   block types by category.
 * @property {WPIcon}                  [icon]        An icon helping to visualize the variation.
 * @property {boolean}                 [isDefault]   Indicates whether the current variation is
 *                                                   the default one. Defaults to `false`.
 * @property {Object}                  [attributes]  Values which override block attributes.
 * @property {Array[]}                 [innerBlocks] Initial configuration of nested blocks.
 * @property {Object}                  [example]     Example provides structured data for
 *                                                   the block preview. You can set to
 *                                                   `undefined` to disable the preview shown
 *                                                   for the block type.
 * @property {WPBlockVariationScope[]} [scope]       The list of scopes where the variation
 *                                                   is applicable. When not provided, it
 *                                                   assumes all available scopes.
 * @property {string[]}                [keywords]    An array of terms (which can be translated)
 *                                                   that help users discover the variation
 *                                                   while searching.
 * @property {Function|string[]}       [isActive]    This can be a function or an array of block attributes.
 *                                                   Function that accepts a block's attributes and the
 *                                                   variation's attributes and determines if a variation is active.
 *                                                   This function doesn't try to find a match dynamically based
 *                                                   on all block's attributes, as in many cases some attributes are irrelevant.
 *                                                   An example would be for `embed` block where we only care
 *                                                   about `providerNameSlug` attribute's value.
 *                                                   We can also use a `string[]` to tell which attributes
 *                                                   should be compared as a shorthand. Each attributes will
 *                                                   be matched and the variation will be active if all of them are matching.
 */

/**
 * Defined behavior of a block type.
 *
 * @typedef {Object} WPBlockType
 *
 * @property {string}             name          Block type's namespaced name.
 * @property {string}             title         Human-readable block type label.
 * @property {string}             [description] A detailed block type description.
 * @property {string}             [category]    Block type category classification,
 *                                              used in search interfaces to arrange
 *                                              block types by category.
 * @property {WPBlockTypeIcon}    [icon]        Block type icon.
 * @property {string[]}           [keywords]    Additional keywords to produce block
 *                                              type as result in search interfaces.
 * @property {Object}             [attributes]  Block type attributes.
 * @property {WPComponent}        [save]        Optional component describing
 *                                              serialized markup structure of a
 *                                              block type.
 * @property {WPComponent}        edit          Component rendering an element to
 *                                              manipulate the attributes of a block
 *                                              in the context of an editor.
 * @property {WPBlockVariation[]} [variations]  The list of block variations.
 * @property {Object}             [example]     Example provides structured data for
 *                                              the block preview. When not defined
 *                                              then no preview is shown.
 */

const serverSideBlockDefinitions = {};

function isObject(object) {
  return object !== null && typeof object === 'object';
}
/**
 * Sets the server side block definition of blocks.
 *
 * @param {Object} definitions Server-side block definitions
 */
// eslint-disable-next-line camelcase


function unstable__bootstrapServerSideBlockDefinitions(definitions) {
  for (const blockName of Object.keys(definitions)) {
    // Don't overwrite if already set. It covers the case when metadata
    // was initialized from the server.
    if (serverSideBlockDefinitions[blockName]) {
      // We still need to polyfill `apiVersion` for WordPress version
      // lower than 5.7. If it isn't present in the definition shared
      // from the server, we try to fallback to the definition passed.
      // @see https://github.com/WordPress/gutenberg/pull/29279
      if (serverSideBlockDefinitions[blockName].apiVersion === undefined && definitions[blockName].apiVersion) {
        serverSideBlockDefinitions[blockName].apiVersion = definitions[blockName].apiVersion;
      } // The `ancestor` prop is not included in the definitions shared
      // from the server yet, so it needs to be polyfilled as well.
      // @see https://github.com/WordPress/gutenberg/pull/39894


      if (serverSideBlockDefinitions[blockName].ancestor === undefined && definitions[blockName].ancestor) {
        serverSideBlockDefinitions[blockName].ancestor = definitions[blockName].ancestor;
      }

      continue;
    }

    serverSideBlockDefinitions[blockName] = Object.fromEntries(Object.entries(definitions[blockName]).filter(_ref => {
      let [, value] = _ref;
      return value !== null && value !== undefined;
    }).map(_ref2 => {
      let [key, value] = _ref2;
      return [camelCase(key), value];
    }));
  }
}
/**
 * Gets block settings from metadata loaded from `block.json` file.
 *
 * @param {Object} metadata            Block metadata loaded from `block.json`.
 * @param {string} metadata.textdomain Textdomain to use with translations.
 *
 * @return {Object} Block settings.
 */

function getBlockSettingsFromMetadata(_ref3) {
  let {
    textdomain,
    ...metadata
  } = _ref3;
  const allowedFields = ['apiVersion', 'title', 'category', 'parent', 'ancestor', 'icon', 'description', 'keywords', 'attributes', 'providesContext', 'usesContext', 'supports', 'styles', 'example', 'variations'];
  const settings = Object.fromEntries(Object.entries(metadata).filter(_ref4 => {
    let [key] = _ref4;
    return allowedFields.includes(key);
  }));

  if (textdomain) {
    Object.keys(i18nBlockSchema).forEach(key => {
      if (!settings[key]) {
        return;
      }

      settings[key] = translateBlockSettingUsingI18nSchema(i18nBlockSchema[key], settings[key], textdomain);
    });
  }

  return settings;
}
/**
 * Registers a new block provided a unique name and an object defining its
 * behavior. Once registered, the block is made available as an option to any
 * editor interface where blocks are implemented.
 *
 * For more in-depth information on registering a custom block see the [Create a block tutorial](docs/how-to-guides/block-tutorial/README.md)
 *
 * @param {string|Object} blockNameOrMetadata Block type name or its metadata.
 * @param {Object}        settings            Block settings.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockType } from '@wordpress/blocks'
 *
 * registerBlockType( 'namespace/block-name', {
 *     title: __( 'My First Block' ),
 *     edit: () => <div>{ __( 'Hello from the editor!' ) }</div>,
 *     save: () => <div>Hello from the saved content!</div>,
 * } );
 * ```
 *
 * @return {?WPBlockType} The block, if it has been successfully registered;
 *                    otherwise `undefined`.
 */


function registerBlockType(blockNameOrMetadata, settings) {
  const name = isObject(blockNameOrMetadata) ? blockNameOrMetadata.name : blockNameOrMetadata;

  if (typeof name !== 'string') {
    console.error('Block names must be strings.');
    return;
  }

  if (!/^[a-z][a-z0-9-]*\/[a-z][a-z0-9-]*$/.test(name)) {
    console.error('Block names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-block');
    return;
  }

  if (select(blocksStore).getBlockType(name)) {
    console.error('Block "' + name + '" is already registered.');
    return;
  }

  if (isObject(blockNameOrMetadata)) {
    unstable__bootstrapServerSideBlockDefinitions({
      [name]: getBlockSettingsFromMetadata(blockNameOrMetadata)
    });
  }

  const blockType = {
    name,
    icon: BLOCK_ICON_DEFAULT,
    keywords: [],
    attributes: {},
    providesContext: {},
    usesContext: [],
    supports: {},
    styles: [],
    variations: [],
    save: () => null,
    ...(serverSideBlockDefinitions === null || serverSideBlockDefinitions === void 0 ? void 0 : serverSideBlockDefinitions[name]),
    ...settings
  };

  dispatch(blocksStore).__experimentalRegisterBlockType(blockType);

  return select(blocksStore).getBlockType(name);
}
/**
 * Translates block settings provided with metadata using the i18n schema.
 *
 * @param {string|string[]|Object[]} i18nSchema   I18n schema for the block setting.
 * @param {string|string[]|Object[]} settingValue Value for the block setting.
 * @param {string}                   textdomain   Textdomain to use with translations.
 *
 * @return {string|string[]|Object[]} Translated setting.
 */

function translateBlockSettingUsingI18nSchema(i18nSchema, settingValue, textdomain) {
  if (typeof i18nSchema === 'string' && typeof settingValue === 'string') {
    // eslint-disable-next-line @wordpress/i18n-no-variables, @wordpress/i18n-text-domain
    return _x(settingValue, i18nSchema, textdomain);
  }

  if (Array.isArray(i18nSchema) && i18nSchema.length && Array.isArray(settingValue)) {
    return settingValue.map(value => translateBlockSettingUsingI18nSchema(i18nSchema[0], value, textdomain));
  }

  if (isObject(i18nSchema) && Object.entries(i18nSchema).length && isObject(settingValue)) {
    return Object.keys(settingValue).reduce((accumulator, key) => {
      if (!i18nSchema[key]) {
        accumulator[key] = settingValue[key];
        return accumulator;
      }

      accumulator[key] = translateBlockSettingUsingI18nSchema(i18nSchema[key], settingValue[key], textdomain);
      return accumulator;
    }, {});
  }

  return settingValue;
}
/**
 * Registers a new block collection to group blocks in the same namespace in the inserter.
 *
 * @param {string} namespace       The namespace to group blocks by in the inserter; corresponds to the block namespace.
 * @param {Object} settings        The block collection settings.
 * @param {string} settings.title  The title to display in the block inserter.
 * @param {Object} [settings.icon] The icon to display in the block inserter.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockCollection, registerBlockType } from '@wordpress/blocks';
 *
 * // Register the collection.
 * registerBlockCollection( 'my-collection', {
 *     title: __( 'Custom Collection' ),
 * } );
 *
 * // Register a block in the same namespace to add it to the collection.
 * registerBlockType( 'my-collection/block-name', {
 *     title: __( 'My First Block' ),
 *     edit: () => <div>{ __( 'Hello from the editor!' ) }</div>,
 *     save: () => <div>'Hello from the saved content!</div>,
 * } );
 * ```
 */


function registerBlockCollection(namespace, _ref5) {
  let {
    title,
    icon
  } = _ref5;
  dispatch(blocksStore).addBlockCollection(namespace, title, icon);
}
/**
 * Unregisters a block collection
 *
 * @param {string} namespace The namespace to group blocks by in the inserter; corresponds to the block namespace
 *
 * @example
 * ```js
 * import { unregisterBlockCollection } from '@wordpress/blocks';
 *
 * unregisterBlockCollection( 'my-collection' );
 * ```
 */

function unregisterBlockCollection(namespace) {
  dispatch(blocksStore).removeBlockCollection(namespace);
}
/**
 * Unregisters a block.
 *
 * @param {string} name Block name.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { unregisterBlockType } from '@wordpress/blocks';
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () =>
 *                 unregisterBlockType( 'my-collection/block-name' )
 *             }
 *         >
 *             { __( 'Unregister my custom block.' ) }
 *         </Button>
 *     );
 * };
 * ```
 *
 * @return {?WPBlockType} The previous block value, if it has been successfully
 *                    unregistered; otherwise `undefined`.
 */

function unregisterBlockType(name) {
  const oldBlock = select(blocksStore).getBlockType(name);

  if (!oldBlock) {
    console.error('Block "' + name + '" is not registered.');
    return;
  }

  dispatch(blocksStore).removeBlockTypes(name);
  return oldBlock;
}
/**
 * Assigns name of block for handling non-block content.
 *
 * @param {string} blockName Block name.
 */

function setFreeformContentHandlerName(blockName) {
  dispatch(blocksStore).setFreeformFallbackBlockName(blockName);
}
/**
 * Retrieves name of block handling non-block content, or undefined if no
 * handler has been defined.
 *
 * @return {?string} Block name.
 */

function registration_getFreeformContentHandlerName() {
  return (0,build_module/* select */.Lt)(store).getFreeformFallbackBlockName();
}
/**
 * Retrieves name of block used for handling grouping interactions.
 *
 * @return {?string} Block name.
 */

function getGroupingBlockName() {
  return (0,build_module/* select */.Lt)(store).getGroupingBlockName();
}
/**
 * Assigns name of block handling unregistered block types.
 *
 * @param {string} blockName Block name.
 */

function setUnregisteredTypeHandlerName(blockName) {
  dispatch(blocksStore).setUnregisteredFallbackBlockName(blockName);
}
/**
 * Retrieves name of block handling unregistered block types, or undefined if no
 * handler has been defined.
 *
 * @return {?string} Block name.
 */

function getUnregisteredTypeHandlerName() {
  return (0,build_module/* select */.Lt)(store).getUnregisteredFallbackBlockName();
}
/**
 * Assigns the default block name.
 *
 * @param {string} name Block name.
 *
 * @example
 * ```js
 * import { setDefaultBlockName } from '@wordpress/blocks';
 *
 * const ExampleComponent = () => {
 *
 *     return (
 *         <Button onClick={ () => setDefaultBlockName( 'core/heading' ) }>
 *             { __( 'Set the default block to Heading' ) }
 *         </Button>
 *     );
 * };
 * ```
 */

function setDefaultBlockName(name) {
  dispatch(blocksStore).setDefaultBlockName(name);
}
/**
 * Assigns name of block for handling block grouping interactions.
 *
 * @param {string} name Block name.
 *
 * @example
 * ```js
 * import { setGroupingBlockName } from '@wordpress/blocks';
 *
 * const ExampleComponent = () => {
 *
 *     return (
 *         <Button onClick={ () => setGroupingBlockName( 'core/columns' ) }>
 *             { __( 'Set the default block to Heading' ) }
 *         </Button>
 *     );
 * };
 * ```
 */

function setGroupingBlockName(name) {
  dispatch(blocksStore).setGroupingBlockName(name);
}
/**
 * Retrieves the default block name.
 *
 * @return {?string} Block name.
 */

function getDefaultBlockName() {
  return (0,build_module/* select */.Lt)(store).getDefaultBlockName();
}
/**
 * Returns a registered block type.
 *
 * @param {string} name Block name.
 *
 * @return {?Object} Block type.
 */

function getBlockType(name) {
  var _select;

  return (_select = (0,build_module/* select */.Lt)(store)) === null || _select === void 0 ? void 0 : _select.getBlockType(name);
}
/**
 * Returns all registered blocks.
 *
 * @return {Array} Block settings.
 */

function getBlockTypes() {
  return (0,build_module/* select */.Lt)(store).getBlockTypes();
}
/**
 * Returns the block support value for a feature, if defined.
 *
 * @param {(string|Object)} nameOrType      Block name or type object
 * @param {string}          feature         Feature to retrieve
 * @param {*}               defaultSupports Default value to return if not
 *                                          explicitly defined
 *
 * @return {?*} Block support value
 */

function getBlockSupport(nameOrType, feature, defaultSupports) {
  return (0,build_module/* select */.Lt)(store).getBlockSupport(nameOrType, feature, defaultSupports);
}
/**
 * Returns true if the block defines support for a feature, or false otherwise.
 *
 * @param {(string|Object)} nameOrType      Block name or type object.
 * @param {string}          feature         Feature to test.
 * @param {boolean}         defaultSupports Whether feature is supported by
 *                                          default if not explicitly defined.
 *
 * @return {boolean} Whether block supports feature.
 */

function hasBlockSupport(nameOrType, feature, defaultSupports) {
  return (0,build_module/* select */.Lt)(store).hasBlockSupport(nameOrType, feature, defaultSupports);
}
/**
 * Determines whether or not the given block is a reusable block. This is a
 * special block type that is used to point to a global block stored via the
 * API.
 *
 * @param {Object} blockOrType Block or Block Type to test.
 *
 * @return {boolean} Whether the given block is a reusable block.
 */

function isReusableBlock(blockOrType) {
  return (blockOrType === null || blockOrType === void 0 ? void 0 : blockOrType.name) === 'core/block';
}
/**
 * Determines whether or not the given block is a template part. This is a
 * special block type that allows composing a page template out of reusable
 * design elements.
 *
 * @param {Object} blockOrType Block or Block Type to test.
 *
 * @return {boolean} Whether the given block is a template part.
 */

function isTemplatePart(blockOrType) {
  return blockOrType.name === 'core/template-part';
}
/**
 * Returns an array with the child blocks of a given block.
 *
 * @param {string} blockName Name of block (example: “latest-posts”).
 *
 * @return {Array} Array of child block names.
 */

const getChildBlockNames = blockName => {
  return select(blocksStore).getChildBlockNames(blockName);
};
/**
 * Returns a boolean indicating if a block has child blocks or not.
 *
 * @param {string} blockName Name of block (example: “latest-posts”).
 *
 * @return {boolean} True if a block contains child blocks and false otherwise.
 */

const hasChildBlocks = blockName => {
  return select(blocksStore).hasChildBlocks(blockName);
};
/**
 * Returns a boolean indicating if a block has at least one child block with inserter support.
 *
 * @param {string} blockName Block type name.
 *
 * @return {boolean} True if a block contains at least one child blocks with inserter support
 *                   and false otherwise.
 */

const hasChildBlocksWithInserterSupport = blockName => {
  return select(blocksStore).hasChildBlocksWithInserterSupport(blockName);
};
/**
 * Registers a new block style for the given block.
 *
 * For more information on connecting the styles with CSS [the official documentation](/docs/reference-guides/block-api/block-styles.md#styles)
 *
 * @param {string} blockName      Name of block (example: “core/latest-posts”).
 * @param {Object} styleVariation Object containing `name` which is the class name applied to the block and `label` which identifies the variation to the user.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockStyle } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () => {
 *                 registerBlockStyle( 'core/quote', {
 *                     name: 'fancy-quote',
 *                     label: __( 'Fancy Quote' ),
 *                 } );
 *             } }
 *         >
 *             { __( 'Add a new block style for core/quote' ) }
 *         </Button>
 *     );
 * };
 * ```
 */

const registerBlockStyle = (blockName, styleVariation) => {
  dispatch(blocksStore).addBlockStyles(blockName, styleVariation);
};
/**
 * Unregisters a block style for the given block.
 *
 * @param {string} blockName          Name of block (example: “core/latest-posts”).
 * @param {string} styleVariationName Name of class applied to the block.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { unregisterBlockStyle } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     return (
 *     <Button
 *         onClick={ () => {
 *             unregisterBlockStyle( 'core/quote', 'plain' );
 *         } }
 *     >
 *         { __( 'Remove the "Plain" block style for core/quote' ) }
 *     </Button>
 *     );
 * };
 * ```
 */

const unregisterBlockStyle = (blockName, styleVariationName) => {
  dispatch(blocksStore).removeBlockStyles(blockName, styleVariationName);
};
/**
 * Returns an array with the variations of a given block type.
 * Ignored from documentation as the recommended usage is via useSelect from @wordpress/data.
 *
 * @ignore
 *
 * @param {string}                blockName Name of block (example: “core/columns”).
 * @param {WPBlockVariationScope} [scope]   Block variation scope name.
 *
 * @return {(WPBlockVariation[]|void)} Block variations.
 */

const getBlockVariations = (blockName, scope) => {
  return (0,build_module/* select */.Lt)(store).getBlockVariations(blockName, scope);
};
/**
 * Registers a new block variation for the given block type.
 *
 * For more information on block variations see [the official documentation ](/docs/reference-guides/block-api/block-variations.md)
 *
 * @param {string}           blockName Name of the block (example: “core/columns”).
 * @param {WPBlockVariation} variation Object describing a block variation.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { registerBlockVariation } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () => {
 *                 registerBlockVariation( 'core/embed', {
 *                     name: 'custom',
 *                     title: __( 'My Custom Embed' ),
 *                     attributes: { providerNameSlug: 'custom' },
 *                 } );
 *             } }
 *          >
 *              __( 'Add a custom variation for core/embed' ) }
 *         </Button>
 *     );
 * };
 * ```
 */

const registerBlockVariation = (blockName, variation) => {
  dispatch(blocksStore).addBlockVariations(blockName, variation);
};
/**
 * Unregisters a block variation defined for the given block type.
 *
 * @param {string} blockName     Name of the block (example: “core/columns”).
 * @param {string} variationName Name of the variation defined for the block.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { unregisterBlockVariation } from '@wordpress/blocks';
 * import { Button } from '@wordpress/components';
 *
 * const ExampleComponent = () => {
 *     return (
 *         <Button
 *             onClick={ () => {
 *                 unregisterBlockVariation( 'core/embed', 'youtube' );
 *             } }
 *         >
 *             { __( 'Remove the YouTube variation from core/embed' ) }
 *         </Button>
 *     );
 * };
 * ```
 */

const unregisterBlockVariation = (blockName, variationName) => {
  dispatch(blocksStore).removeBlockVariations(blockName, variationName);
};
//# sourceMappingURL=registration.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js + 4 modules
var v4 = __webpack_require__("../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+hooks@3.57.0/node_modules/@wordpress/hooks/build-module/index.js + 10 modules
var hooks_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+hooks@3.57.0/node_modules/@wordpress/hooks/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/factory.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Returns a block object given its type and attributes.
 *
 * @param {string} name        Block name.
 * @param {Object} attributes  Block attributes.
 * @param {?Array} innerBlocks Nested blocks.
 *
 * @return {Object} Block object.
 */

function createBlock(name) {
  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let innerBlocks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  const sanitizedAttributes = __experimentalSanitizeBlockAttributes(name, attributes);

  const clientId = (0,v4/* default */.A)(); // Blocks are stored with a unique ID, the assigned type name, the block
  // attributes, and their inner blocks.

  return {
    clientId,
    name,
    isValid: true,
    attributes: sanitizedAttributes,
    innerBlocks
  };
}
/**
 * Given an array of InnerBlocks templates or Block Objects,
 * returns an array of created Blocks from them.
 * It handles the case of having InnerBlocks as Blocks by
 * converting them to the proper format to continue recursively.
 *
 * @param {Array} innerBlocksOrTemplate Nested blocks or InnerBlocks templates.
 *
 * @return {Object[]} Array of Block objects.
 */

function createBlocksFromInnerBlocksTemplate() {
  let innerBlocksOrTemplate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return innerBlocksOrTemplate.map(innerBlock => {
    const innerBlockTemplate = Array.isArray(innerBlock) ? innerBlock : [innerBlock.name, innerBlock.attributes, innerBlock.innerBlocks];
    const [name, attributes, innerBlocks = []] = innerBlockTemplate;
    return createBlock(name, attributes, createBlocksFromInnerBlocksTemplate(innerBlocks));
  });
}
/**
 * Given a block object, returns a copy of the block object while sanitizing its attributes,
 * optionally merging new attributes and/or replacing its inner blocks.
 *
 * @param {Object} block           Block instance.
 * @param {Object} mergeAttributes Block attributes.
 * @param {?Array} newInnerBlocks  Nested blocks.
 *
 * @return {Object} A cloned block.
 */

function __experimentalCloneSanitizedBlock(block) {
  let mergeAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let newInnerBlocks = arguments.length > 2 ? arguments[2] : undefined;
  const clientId = (0,v4/* default */.A)();

  const sanitizedAttributes = __experimentalSanitizeBlockAttributes(block.name, { ...block.attributes,
    ...mergeAttributes
  });

  return { ...block,
    clientId,
    attributes: sanitizedAttributes,
    innerBlocks: newInnerBlocks || block.innerBlocks.map(innerBlock => __experimentalCloneSanitizedBlock(innerBlock))
  };
}
/**
 * Given a block object, returns a copy of the block object,
 * optionally merging new attributes and/or replacing its inner blocks.
 *
 * @param {Object} block           Block instance.
 * @param {Object} mergeAttributes Block attributes.
 * @param {?Array} newInnerBlocks  Nested blocks.
 *
 * @return {Object} A cloned block.
 */

function cloneBlock(block) {
  let mergeAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let newInnerBlocks = arguments.length > 2 ? arguments[2] : undefined;
  const clientId = (0,v4/* default */.A)();
  return { ...block,
    clientId,
    attributes: { ...block.attributes,
      ...mergeAttributes
    },
    innerBlocks: newInnerBlocks || block.innerBlocks.map(innerBlock => cloneBlock(innerBlock))
  };
}
/**
 * Returns a boolean indicating whether a transform is possible based on
 * various bits of context.
 *
 * @param {Object} transform The transform object to validate.
 * @param {string} direction Is this a 'from' or 'to' transform.
 * @param {Array}  blocks    The blocks to transform from.
 *
 * @return {boolean} Is the transform possible?
 */

const isPossibleTransformForSource = (transform, direction, blocks) => {
  if (!blocks.length) {
    return false;
  } // If multiple blocks are selected, only multi block transforms
  // or wildcard transforms are allowed.


  const isMultiBlock = blocks.length > 1;
  const firstBlockName = blocks[0].name;
  const isValidForMultiBlocks = isWildcardBlockTransform(transform) || !isMultiBlock || transform.isMultiBlock;

  if (!isValidForMultiBlocks) {
    return false;
  } // Check non-wildcard transforms to ensure that transform is valid
  // for a block selection of multiple blocks of different types.


  if (!isWildcardBlockTransform(transform) && !blocks.every(block => block.name === firstBlockName)) {
    return false;
  } // Only consider 'block' type transforms as valid.


  const isBlockType = transform.type === 'block';

  if (!isBlockType) {
    return false;
  } // Check if the transform's block name matches the source block (or is a wildcard)
  // only if this is a transform 'from'.


  const sourceBlock = blocks[0];
  const hasMatchingName = direction !== 'from' || transform.blocks.indexOf(sourceBlock.name) !== -1 || isWildcardBlockTransform(transform);

  if (!hasMatchingName) {
    return false;
  } // Don't allow single Grouping blocks to be transformed into
  // a Grouping block.


  if (!isMultiBlock && direction === 'from' && isContainerGroupBlock(sourceBlock.name) && isContainerGroupBlock(transform.blockName)) {
    return false;
  } // If the transform has a `isMatch` function specified, check that it returns true.


  if (!maybeCheckTransformIsMatch(transform, blocks)) {
    return false;
  }

  if (transform.usingMobileTransformations && isWildcardBlockTransform(transform) && !isContainerGroupBlock(sourceBlock.name)) {
    return false;
  }

  return true;
};
/**
 * Returns block types that the 'blocks' can be transformed into, based on
 * 'from' transforms on other blocks.
 *
 * @param {Array} blocks The blocks to transform from.
 *
 * @return {Array} Block types that the blocks can be transformed into.
 */


const getBlockTypesForPossibleFromTransforms = blocks => {
  if (!blocks.length) {
    return [];
  }

  const allBlockTypes = getBlockTypes(); // filter all blocks to find those with a 'from' transform.

  const blockTypesWithPossibleFromTransforms = allBlockTypes.filter(blockType => {
    const fromTransforms = getBlockTransforms('from', blockType.name);
    return !!findTransform(fromTransforms, transform => {
      return isPossibleTransformForSource(transform, 'from', blocks);
    });
  });
  return blockTypesWithPossibleFromTransforms;
};
/**
 * Returns block types that the 'blocks' can be transformed into, based on
 * the source block's own 'to' transforms.
 *
 * @param {Array} blocks The blocks to transform from.
 *
 * @return {Array} Block types that the source can be transformed into.
 */


const getBlockTypesForPossibleToTransforms = blocks => {
  if (!blocks.length) {
    return [];
  }

  const sourceBlock = blocks[0];
  const blockType = getBlockType(sourceBlock.name);
  const transformsTo = blockType ? getBlockTransforms('to', blockType.name) : []; // filter all 'to' transforms to find those that are possible.

  const possibleTransforms = transformsTo.filter(transform => {
    return transform && isPossibleTransformForSource(transform, 'to', blocks);
  }); // Build a list of block names using the possible 'to' transforms.

  const blockNames = possibleTransforms.map(transformation => transformation.blocks).flat(); // Map block names to block types.

  return blockNames.map(name => name === '*' ? name : getBlockType(name));
};
/**
 * Determines whether transform is a "block" type
 * and if so whether it is a "wildcard" transform
 * ie: targets "any" block type
 *
 * @param {Object} t the Block transform object
 *
 * @return {boolean} whether transform is a wildcard transform
 */


const isWildcardBlockTransform = t => t && t.type === 'block' && Array.isArray(t.blocks) && t.blocks.includes('*');
/**
 * Determines whether the given Block is the core Block which
 * acts as a container Block for other Blocks as part of the
 * Grouping mechanics
 *
 * @param {string} name the name of the Block to test against
 *
 * @return {boolean} whether or not the Block is the container Block type
 */

const isContainerGroupBlock = name => name === getGroupingBlockName();
/**
 * Returns an array of block types that the set of blocks received as argument
 * can be transformed into.
 *
 * @param {Array} blocks Blocks array.
 *
 * @return {Array} Block types that the blocks argument can be transformed to.
 */

function getPossibleBlockTransformations(blocks) {
  if (!blocks.length) {
    return [];
  }

  const blockTypesForFromTransforms = getBlockTypesForPossibleFromTransforms(blocks);
  const blockTypesForToTransforms = getBlockTypesForPossibleToTransforms(blocks);
  return [...new Set([...blockTypesForFromTransforms, ...blockTypesForToTransforms])];
}
/**
 * Given an array of transforms, returns the highest-priority transform where
 * the predicate function returns a truthy value. A higher-priority transform
 * is one with a lower priority value (i.e. first in priority order). Returns
 * null if the transforms set is empty or the predicate function returns a
 * falsey value for all entries.
 *
 * @param {Object[]} transforms Transforms to search.
 * @param {Function} predicate  Function returning true on matching transform.
 *
 * @return {?Object} Highest-priority transform candidate.
 */

function findTransform(transforms, predicate) {
  // The hooks library already has built-in mechanisms for managing priority
  // queue, so leverage via locally-defined instance.
  const hooks = (0,hooks_build_module/* createHooks */.FF)();

  for (let i = 0; i < transforms.length; i++) {
    const candidate = transforms[i];

    if (predicate(candidate)) {
      hooks.addFilter('transform', 'transform/' + i.toString(), result => result ? result : candidate, candidate.priority);
    }
  } // Filter name is arbitrarily chosen but consistent with above aggregation.


  return hooks.applyFilters('transform', null);
}
/**
 * Returns normal block transforms for a given transform direction, optionally
 * for a specific block by name, or an empty array if there are no transforms.
 * If no block name is provided, returns transforms for all blocks. A normal
 * transform object includes `blockName` as a property.
 *
 * @param {string}        direction       Transform direction ("to", "from").
 * @param {string|Object} blockTypeOrName Block type or name.
 *
 * @return {Array} Block transforms for direction.
 */

function getBlockTransforms(direction, blockTypeOrName) {
  // When retrieving transforms for all block types, recurse into self.
  if (blockTypeOrName === undefined) {
    return getBlockTypes().map(_ref => {
      let {
        name
      } = _ref;
      return getBlockTransforms(direction, name);
    }).flat();
  } // Validate that block type exists and has array of direction.


  const blockType = utils_normalizeBlockType(blockTypeOrName);
  const {
    name: blockName,
    transforms
  } = blockType || {};

  if (!transforms || !Array.isArray(transforms[direction])) {
    return [];
  }

  const usingMobileTransformations = transforms.supportedMobileTransforms && Array.isArray(transforms.supportedMobileTransforms);
  const filteredTransforms = usingMobileTransformations ? transforms[direction].filter(t => {
    if (t.type === 'raw') {
      return true;
    }

    if (!t.blocks || !t.blocks.length) {
      return false;
    }

    if (isWildcardBlockTransform(t)) {
      return true;
    }

    return t.blocks.every(transformBlockName => transforms.supportedMobileTransforms.includes(transformBlockName));
  }) : transforms[direction]; // Map transforms to normal form.

  return filteredTransforms.map(transform => ({ ...transform,
    blockName,
    usingMobileTransformations
  }));
}
/**
 * Checks that a given transforms isMatch method passes for given source blocks.
 *
 * @param {Object} transform A transform object.
 * @param {Array}  blocks    Blocks array.
 *
 * @return {boolean} True if given blocks are a match for the transform.
 */

function maybeCheckTransformIsMatch(transform, blocks) {
  if (typeof transform.isMatch !== 'function') {
    return true;
  }

  const sourceBlock = blocks[0];
  const attributes = transform.isMultiBlock ? blocks.map(block => block.attributes) : sourceBlock.attributes;
  const block = transform.isMultiBlock ? blocks : sourceBlock;
  return transform.isMatch(attributes, block);
}
/**
 * Switch one or more blocks into one or more blocks of the new block type.
 *
 * @param {Array|Object} blocks Blocks array or block object.
 * @param {string}       name   Block name.
 *
 * @return {?Array} Array of blocks or null.
 */


function switchToBlockType(blocks, name) {
  const blocksArray = Array.isArray(blocks) ? blocks : [blocks];
  const isMultiBlock = blocksArray.length > 1;
  const firstBlock = blocksArray[0];
  const sourceName = firstBlock.name; // Find the right transformation by giving priority to the "to"
  // transformation.

  const transformationsFrom = getBlockTransforms('from', name);
  const transformationsTo = getBlockTransforms('to', sourceName);
  const transformation = findTransform(transformationsTo, t => t.type === 'block' && t.blocks.indexOf(name) !== -1 && (!isMultiBlock || t.isMultiBlock) && maybeCheckTransformIsMatch(t, blocksArray)) || findTransform(transformationsFrom, t => t.type === 'block' && (isWildcardBlockTransform(t) || t.blocks.indexOf(sourceName) !== -1) && (!isMultiBlock || t.isMultiBlock) && maybeCheckTransformIsMatch(t, blocksArray)); // Stop if there is no valid transformation.

  if (!transformation) {
    return null;
  }

  let transformationResults;

  if (transformation.isMultiBlock) {
    if ('__experimentalConvert' in transformation) {
      transformationResults = transformation.__experimentalConvert(blocksArray);
    } else {
      transformationResults = transformation.transform(blocksArray.map(currentBlock => currentBlock.attributes), blocksArray.map(currentBlock => currentBlock.innerBlocks));
    }
  } else if ('__experimentalConvert' in transformation) {
    transformationResults = transformation.__experimentalConvert(firstBlock);
  } else {
    transformationResults = transformation.transform(firstBlock.attributes, firstBlock.innerBlocks);
  } // Ensure that the transformation function returned an object or an array
  // of objects.


  if (transformationResults === null || typeof transformationResults !== 'object') {
    return null;
  } // If the transformation function returned a single object, we want to work
  // with an array instead.


  transformationResults = Array.isArray(transformationResults) ? transformationResults : [transformationResults]; // Ensure that every block object returned by the transformation has a
  // valid block type.

  if (transformationResults.some(result => !getBlockType(result.name))) {
    return null;
  } // When unwrapping blocks (`switchToBlockType( wrapperblocks, '*' )`), do
  // not run filters on the unwrapped blocks. They shoud remain as they are.


  if (name === '*') {
    return transformationResults;
  }

  const hasSwitchedBlock = transformationResults.some(result => result.name === name); // Ensure that at least one block object returned by the transformation has
  // the expected "destination" block type.

  if (!hasSwitchedBlock) {
    return null;
  }

  const ret = transformationResults.map((result, index, results) => {
    /**
     * Filters an individual transform result from block transformation.
     * All of the original blocks are passed, since transformations are
     * many-to-many, not one-to-one.
     *
     * @param {Object}   transformedBlock The transformed block.
     * @param {Object[]} blocks           Original blocks transformed.
     * @param {Object[]} index            Index of the transformed block on the array of results.
     * @param {Object[]} results          An array all the blocks that resulted from the transformation.
     */
    return (0,hooks_build_module/* applyFilters */.W5)('blocks.switchToBlockType.transformedBlock', result, blocks, index, results);
  });
  return ret;
}
/**
 * Create a block object from the example API.
 *
 * @param {string} name
 * @param {Object} example
 *
 * @return {Object} block.
 */

const getBlockFromExample = (name, example) => {
  var _example$innerBlocks;

  return createBlock(name, example.attributes, ((_example$innerBlocks = example.innerBlocks) !== null && _example$innerBlocks !== void 0 ? _example$innerBlocks : []).map(innerBlock => getBlockFromExample(innerBlock.name, innerBlock)));
};
//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/utils.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




(0,colord/* extend */.X$)([names/* default */.A, a11y/* default */.A]);
/**
 * Array of icon colors containing a color to be used if the icon color
 * was not explicitly set but the icon background color was.
 *
 * @type {Object}
 */

const ICON_COLORS = ['#191e23', '#f8f9f9'];
/**
 * Determines whether the block is a default block
 * and its attributes are equal to the default attributes
 * which means the block is unmodified.
 *
 * @param {WPBlock} block Block Object
 *
 * @return {boolean} Whether the block is an unmodified default block
 */

function utils_isUnmodifiedDefaultBlock(block) {
  var _blockType$attributes;

  const defaultBlockName = getDefaultBlockName();

  if (block.name !== defaultBlockName) {
    return false;
  } // Cache a created default block if no cache exists or the default block
  // name changed.


  if (!utils_isUnmodifiedDefaultBlock.block || utils_isUnmodifiedDefaultBlock.block.name !== defaultBlockName) {
    utils_isUnmodifiedDefaultBlock.block = createBlock(defaultBlockName);
  }

  const newDefaultBlock = utils_isUnmodifiedDefaultBlock.block;
  const blockType = getBlockType(defaultBlockName);
  return Object.keys((_blockType$attributes = blockType === null || blockType === void 0 ? void 0 : blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}).every(key => newDefaultBlock.attributes[key] === block.attributes[key]);
}
/**
 * Function that checks if the parameter is a valid icon.
 *
 * @param {*} icon Parameter to be checked.
 *
 * @return {boolean} True if the parameter is a valid icon and false otherwise.
 */

function isValidIcon(icon) {
  return !!icon && (typeof icon === 'string' || (0,react.isValidElement)(icon) || typeof icon === 'function' || icon instanceof react.Component);
}
/**
 * Function that receives an icon as set by the blocks during the registration
 * and returns a new icon object that is normalized so we can rely on just on possible icon structure
 * in the codebase.
 *
 * @param {WPBlockTypeIconRender} icon Render behavior of a block type icon;
 *                                     one of a Dashicon slug, an element, or a
 *                                     component.
 *
 * @return {WPBlockTypeIconDescriptor} Object describing the icon.
 */

function normalizeIconObject(icon) {
  icon = icon || constants_BLOCK_ICON_DEFAULT;

  if (isValidIcon(icon)) {
    return {
      src: icon
    };
  }

  if ('background' in icon) {
    const colordBgColor = (0,colord/* colord */.Mj)(icon.background);

    const getColorContrast = iconColor => colordBgColor.contrast(iconColor);

    const maxContrast = Math.max(...ICON_COLORS.map(getColorContrast));
    return { ...icon,
      foreground: icon.foreground ? icon.foreground : ICON_COLORS.find(iconColor => getColorContrast(iconColor) === maxContrast),
      shadowColor: colordBgColor.alpha(0.3).toRgbString()
    };
  }

  return icon;
}
/**
 * Normalizes block type passed as param. When string is passed then
 * it converts it to the matching block type object.
 * It passes the original object otherwise.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 *
 * @return {?Object} Block type.
 */

function utils_normalizeBlockType(blockTypeOrName) {
  if (typeof blockTypeOrName === 'string') {
    return getBlockType(blockTypeOrName);
  }

  return blockTypeOrName;
}
/**
 * Get the label for the block, usually this is either the block title,
 * or the value of the block's `label` function when that's specified.
 *
 * @param {Object} blockType  The block type.
 * @param {Object} attributes The values of the block's attributes.
 * @param {Object} context    The intended use for the label.
 *
 * @return {string} The block label.
 */

function getBlockLabel(blockType, attributes) {
  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'visual';
  const {
    __experimentalLabel: getLabel,
    title
  } = blockType;
  const label = getLabel && getLabel(attributes, {
    context
  });

  if (!label) {
    return title;
  } // Strip any HTML (i.e. RichText formatting) before returning.


  return stripHTML(label);
}
/**
 * Get a label for the block for use by screenreaders, this is more descriptive
 * than the visual label and includes the block title and the value of the
 * `getLabel` function if it's specified.
 *
 * @param {?Object} blockType              The block type.
 * @param {Object}  attributes             The values of the block's attributes.
 * @param {?number} position               The position of the block in the block list.
 * @param {string}  [direction='vertical'] The direction of the block layout.
 *
 * @return {string} The block label.
 */

function getAccessibleBlockLabel(blockType, attributes, position) {
  let direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vertical';
  // `title` is already localized, `label` is a user-supplied value.
  const title = blockType === null || blockType === void 0 ? void 0 : blockType.title;
  const label = blockType ? getBlockLabel(blockType, attributes, 'accessibility') : '';
  const hasPosition = position !== undefined; // getBlockLabel returns the block title as a fallback when there's no label,
  // if it did return the title, this function needs to avoid adding the
  // title twice within the accessible label. Use this `hasLabel` boolean to
  // handle that.

  const hasLabel = label && label !== title;

  if (hasPosition && direction === 'vertical') {
    if (hasLabel) {
      return (0,i18n_build_module/* sprintf */.nv)(
      /* translators: accessibility text. 1: The block title. 2: The block row number. 3: The block label.. */
      (0,i18n_build_module.__)('%1$s Block. Row %2$d. %3$s'), title, position, label);
    }

    return (0,i18n_build_module/* sprintf */.nv)(
    /* translators: accessibility text. 1: The block title. 2: The block row number. */
    (0,i18n_build_module.__)('%1$s Block. Row %2$d'), title, position);
  } else if (hasPosition && direction === 'horizontal') {
    if (hasLabel) {
      return (0,i18n_build_module/* sprintf */.nv)(
      /* translators: accessibility text. 1: The block title. 2: The block column number. 3: The block label.. */
      (0,i18n_build_module.__)('%1$s Block. Column %2$d. %3$s'), title, position, label);
    }

    return (0,i18n_build_module/* sprintf */.nv)(
    /* translators: accessibility text. 1: The block title. 2: The block column number. */
    (0,i18n_build_module.__)('%1$s Block. Column %2$d'), title, position);
  }

  if (hasLabel) {
    return (0,i18n_build_module/* sprintf */.nv)(
    /* translators: accessibility text. %1: The block title. %2: The block label. */
    (0,i18n_build_module.__)('%1$s Block. %2$s'), title, label);
  }

  return (0,i18n_build_module/* sprintf */.nv)(
  /* translators: accessibility text. %s: The block title. */
  (0,i18n_build_module.__)('%s Block'), title);
}
/**
 * Ensure attributes contains only values defined by block type, and merge
 * default values for missing attributes.
 *
 * @param {string} name       The block's name.
 * @param {Object} attributes The block's attributes.
 * @return {Object} The sanitized attributes.
 */

function __experimentalSanitizeBlockAttributes(name, attributes) {
  // Get the type definition associated with a registered block.
  const blockType = getBlockType(name);

  if (undefined === blockType) {
    throw new Error(`Block type '${name}' is not registered.`);
  }

  return Object.entries(blockType.attributes).reduce((accumulator, _ref) => {
    let [key, schema] = _ref;
    const value = attributes[key];

    if (undefined !== value) {
      accumulator[key] = value;
    } else if (schema.hasOwnProperty('default')) {
      accumulator[key] = schema.default;
    }

    if (['node', 'children'].indexOf(schema.source) !== -1) {
      // Ensure value passed is always an array, which we're expecting in
      // the RichText component to handle the deprecated value.
      if (typeof accumulator[key] === 'string') {
        accumulator[key] = [accumulator[key]];
      } else if (!Array.isArray(accumulator[key])) {
        accumulator[key] = [];
      }
    }

    return accumulator;
  }, {});
}
/**
 * Filter block attributes by `role` and return their names.
 *
 * @param {string} name Block attribute's name.
 * @param {string} role The role of a block attribute.
 *
 * @return {string[]} The attribute names that have the provided role.
 */

function __experimentalGetBlockAttributesNamesByRole(name, role) {
  var _getBlockType;

  const attributes = (_getBlockType = getBlockType(name)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.attributes;
  if (!attributes) return [];
  const attributesNames = Object.keys(attributes);
  if (!role) return attributesNames;
  return attributesNames.filter(attributeName => {
    var _attributes$attribute;

    return ((_attributes$attribute = attributes[attributeName]) === null || _attributes$attribute === void 0 ? void 0 : _attributes$attribute.__experimentalRole) === role;
  });
}
/**
 * Return a new object with the specified keys omitted.
 *
 * @param {Object} object Original object.
 * @param {Array}  keys   Keys to be omitted.
 *
 * @return {Object} Object with omitted keys.
 */

function omit(object, keys) {
  return Object.fromEntries(Object.entries(object).filter(_ref2 => {
    let [key] = _ref2;
    return !keys.includes(key);
  }));
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/reducer.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */


/**
 * @typedef {Object} WPBlockCategory
 *
 * @property {string} slug  Unique category slug.
 * @property {string} title Category label, for display in user interface.
 */

/**
 * Default set of categories.
 *
 * @type {WPBlockCategory[]}
 */

const DEFAULT_CATEGORIES = [{
  slug: 'text',
  title: (0,i18n_build_module.__)('Text')
}, {
  slug: 'media',
  title: (0,i18n_build_module.__)('Media')
}, {
  slug: 'design',
  title: (0,i18n_build_module.__)('Design')
}, {
  slug: 'widgets',
  title: (0,i18n_build_module.__)('Widgets')
}, {
  slug: 'theme',
  title: (0,i18n_build_module.__)('Theme')
}, {
  slug: 'embed',
  title: (0,i18n_build_module.__)('Embeds')
}, {
  slug: 'reusable',
  title: (0,i18n_build_module.__)('Reusable blocks')
}]; // Key block types by their name.

function keyBlockTypesByName(types) {
  return types.reduce((newBlockTypes, block) => ({ ...newBlockTypes,
    [block.name]: block
  }), {});
} // Filter items to ensure they're unique by their name.


function getUniqueItemsByName(items) {
  return items.reduce((acc, currentItem) => {
    if (!acc.some(item => item.name === currentItem.name)) {
      acc.push(currentItem);
    }

    return acc;
  }, []);
}
/**
 * Reducer managing the unprocessed block types in a form passed when registering the by block.
 * It's for internal use only. It allows recomputing the processed block types on-demand after block type filters
 * get added or removed.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */


function unprocessedBlockTypes() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ADD_UNPROCESSED_BLOCK_TYPE':
      return { ...state,
        [action.blockType.name]: action.blockType
      };

    case 'REMOVE_BLOCK_TYPES':
      return omit(state, action.names);
  }

  return state;
}
/**
 * Reducer managing the processed block types with all filters applied.
 * The state is derived from the `unprocessedBlockTypes` reducer.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function blockTypes() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ADD_BLOCK_TYPES':
      return { ...state,
        ...keyBlockTypesByName(action.blockTypes)
      };

    case 'REMOVE_BLOCK_TYPES':
      return omit(state, action.names);
  }

  return state;
}
/**
 * Reducer managing the block styles.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function blockStyles() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ADD_BLOCK_TYPES':
      return { ...state,
        ...(0,lodash.mapValues)(keyBlockTypesByName(action.blockTypes), blockType => getUniqueItemsByName([...(0,lodash.get)(blockType, ['styles'], []).map(style => ({ ...style,
          source: 'block'
        })), ...(0,lodash.get)(state, [blockType.name], []).filter(_ref => {
          let {
            source
          } = _ref;
          return 'block' !== source;
        })]))
      };

    case 'ADD_BLOCK_STYLES':
      return { ...state,
        [action.blockName]: getUniqueItemsByName([...(0,lodash.get)(state, [action.blockName], []), ...action.styles])
      };

    case 'REMOVE_BLOCK_STYLES':
      return { ...state,
        [action.blockName]: (0,lodash.filter)((0,lodash.get)(state, [action.blockName], []), style => action.styleNames.indexOf(style.name) === -1)
      };
  }

  return state;
}
/**
 * Reducer managing the block variations.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function blockVariations() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ADD_BLOCK_TYPES':
      return { ...state,
        ...(0,lodash.mapValues)(keyBlockTypesByName(action.blockTypes), blockType => {
          return getUniqueItemsByName([...(0,lodash.get)(blockType, ['variations'], []).map(variation => ({ ...variation,
            source: 'block'
          })), ...(0,lodash.get)(state, [blockType.name], []).filter(_ref2 => {
            let {
              source
            } = _ref2;
            return 'block' !== source;
          })]);
        })
      };

    case 'ADD_BLOCK_VARIATIONS':
      return { ...state,
        [action.blockName]: getUniqueItemsByName([...(0,lodash.get)(state, [action.blockName], []), ...action.variations])
      };

    case 'REMOVE_BLOCK_VARIATIONS':
      return { ...state,
        [action.blockName]: (0,lodash.filter)((0,lodash.get)(state, [action.blockName], []), variation => action.variationNames.indexOf(variation.name) === -1)
      };
  }

  return state;
}
/**
 * Higher-order Reducer creating a reducer keeping track of given block name.
 *
 * @param {string} setActionType Action type.
 *
 * @return {Function} Reducer.
 */

function createBlockNameSetterReducer(setActionType) {
  return function () {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case 'REMOVE_BLOCK_TYPES':
        if (action.names.indexOf(state) !== -1) {
          return null;
        }

        return state;

      case setActionType:
        return action.name || null;
    }

    return state;
  };
}
const defaultBlockName = createBlockNameSetterReducer('SET_DEFAULT_BLOCK_NAME');
const freeformFallbackBlockName = createBlockNameSetterReducer('SET_FREEFORM_FALLBACK_BLOCK_NAME');
const unregisteredFallbackBlockName = createBlockNameSetterReducer('SET_UNREGISTERED_FALLBACK_BLOCK_NAME');
const groupingBlockName = createBlockNameSetterReducer('SET_GROUPING_BLOCK_NAME');
/**
 * Reducer managing the categories
 *
 * @param {WPBlockCategory[]} state  Current state.
 * @param {Object}            action Dispatched action.
 *
 * @return {WPBlockCategory[]} Updated state.
 */

function categories() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CATEGORIES;
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'SET_CATEGORIES':
      return action.categories || [];

    case 'UPDATE_CATEGORY':
      {
        if (!action.category || (0,lodash.isEmpty)(action.category)) {
          return state;
        }

        const categoryToChange = (0,lodash.find)(state, ['slug', action.slug]);

        if (categoryToChange) {
          return (0,lodash.map)(state, category => {
            if (category.slug === action.slug) {
              return { ...category,
                ...action.category
              };
            }

            return category;
          });
        }
      }
  }

  return state;
}
function collections() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'ADD_BLOCK_COLLECTION':
      return { ...state,
        [action.namespace]: {
          title: action.title,
          icon: action.icon
        }
      };

    case 'REMOVE_BLOCK_COLLECTION':
      return omit(state, action.namespace);
  }

  return state;
}
/* harmony default export */ const reducer = ((0,build_module/* combineReducers */.HY)({
  unprocessedBlockTypes,
  blockTypes,
  blockStyles,
  blockVariations,
  defaultBlockName,
  freeformFallbackBlockName,
  unregisteredFallbackBlockName,
  groupingBlockName,
  categories,
  collections
}));
//# sourceMappingURL=reducer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js
var rememo = __webpack_require__("../../node_modules/.pnpm/rememo@4.0.2/node_modules/rememo/rememo.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/remove-accents@0.4.4/node_modules/remove-accents/index.js
var remove_accents = __webpack_require__("../../node_modules/.pnpm/remove-accents@0.4.4/node_modules/remove-accents/index.js");
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/pipe.js
var pipe = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/higher-order/pipe.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/selectors.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */


/** @typedef {import('../api/registration').WPBlockVariation} WPBlockVariation */

/** @typedef {import('../api/registration').WPBlockVariationScope} WPBlockVariationScope */

/** @typedef {import('./reducer').WPBlockCategory} WPBlockCategory */

/**
 * Given a block name or block type object, returns the corresponding
 * normalized block type object.
 *
 * @param {Object}          state      Blocks state.
 * @param {(string|Object)} nameOrType Block name or type object
 *
 * @return {Object} Block type object.
 */

const getNormalizedBlockType = (state, nameOrType) => 'string' === typeof nameOrType ? selectors_getBlockType(state, nameOrType) : nameOrType;
/**
 * Returns all the unprocessed block types as passed during the registration.
 *
 * @param {Object} state Data state.
 *
 * @return {Array} Unprocessed block types.
 */


function __experimentalGetUnprocessedBlockTypes(state) {
  return state.unprocessedBlockTypes;
}
/**
 * Returns all the available block types.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const blockTypes = useSelect(
 *         ( select ) => select( blocksStore ).getBlockTypes(),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { blockTypes.map( ( block ) => (
 *                 <li key={ block.name }>{ block.title }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Array} Block Types.
 */

const selectors_getBlockTypes = (0,rememo/* default */.A)(state => Object.values(state.blockTypes), state => [state.blockTypes]);
/**
 * Returns a block type by name.
 *
 * @param {Object} state Data state.
 * @param {string} name  Block type name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const paragraphBlock = useSelect( ( select ) =>
 *         ( select ) => select( blocksStore ).getBlockType( 'core/paragraph' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { paragraphBlock &&
 *                 Object.entries( paragraphBlock.supports ).map(
 *                     ( blockSupportsEntry ) => {
 *                         const [ propertyName, value ] = blockSupportsEntry;
 *                         return (
 *                             <li
 *                                 key={ propertyName }
 *                             >{ `${ propertyName } : ${ value }` }</li>
 *                         );
 *                     }
 *                 ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Object?} Block Type.
 */

function selectors_getBlockType(state, name) {
  return state.blockTypes[name];
}
/**
 * Returns block styles by block name.
 *
 * @param {Object} state Data state.
 * @param {string} name  Block type name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const buttonBlockStyles = useSelect( ( select ) =>
 *         select( blocksStore ).getBlockStyles( 'core/button' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { buttonBlockStyles &&
 *                 buttonBlockStyles.map( ( style ) => (
 *                     <li key={ style.name }>{ style.label }</li>
 *                 ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Array?} Block Styles.
 */

function getBlockStyles(state, name) {
  return state.blockStyles[name];
}
/**
 * Returns block variations by block name.
 *
 * @param {Object}                state     Data state.
 * @param {string}                blockName Block type name.
 * @param {WPBlockVariationScope} [scope]   Block variation scope name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const socialLinkVariations = useSelect( ( select ) =>
 *         select( blocksStore ).getBlockVariations( 'core/social-link' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { socialLinkVariations &&
 *                 socialLinkVariations.map( ( variation ) => (
 *                     <li key={ variation.name }>{ variation.title }</li>
 *             ) ) }
 *     </ul>
 *     );
 * };
 * ```
 *
 * @return {(WPBlockVariation[]|void)} Block variations.
 */

const selectors_getBlockVariations = (0,rememo/* default */.A)((state, blockName, scope) => {
  const variations = state.blockVariations[blockName];

  if (!variations || !scope) {
    return variations;
  }

  return variations.filter(variation => {
    // For backward compatibility reasons, variation's scope defaults to
    // `block` and `inserter` when not set.
    return (variation.scope || ['block', 'inserter']).includes(scope);
  });
}, (state, blockName) => [state.blockVariations[blockName]]);
/**
 * Returns the active block variation for a given block based on its attributes.
 * Variations are determined by their `isActive` property.
 * Which is either an array of block attribute keys or a function.
 *
 * In case of an array of block attribute keys, the `attributes` are compared
 * to the variation's attributes using strict equality check.
 *
 * In case of function type, the function should accept a block's attributes
 * and the variation's attributes and determines if a variation is active.
 * A function that accepts a block's attributes and the variation's attributes and determines if a variation is active.
 *
 * @param {Object}                state      Data state.
 * @param {string}                blockName  Name of block (example: “core/columns”).
 * @param {Object}                attributes Block attributes used to determine active variation.
 * @param {WPBlockVariationScope} [scope]    Block variation scope name.
 *
 * @example
 * ```js
 * import { __ } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { store as blockEditorStore } from '@wordpress/block-editor';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     // This example assumes that a core/embed block is the first block in the Block Editor.
 *     const activeBlockVariation = useSelect( ( select ) => {
 *         // Retrieve the list of blocks.
 *         const [ firstBlock ] = select( blockEditorStore ).getBlocks()
 *
 *         // Return the active block variation for the first block.
 *         return select( blocksStore ).getActiveBlockVariation(
 *             firstBlock.name,
 *             firstBlock.attributes
 *         );
 *     }, [] );
 *
 *     return activeBlockVariation && activeBlockVariation.name === 'spotify' ? (
 *         <p>{ __( 'Spotify variation' ) }</p>
 *         ) : (
 *         <p>{ __( 'Other variation' ) }</p>
 *     );
 * };
 * ```
 *
 * @return {(WPBlockVariation|undefined)} Active block variation.
 */

function getActiveBlockVariation(state, blockName, attributes, scope) {
  const variations = selectors_getBlockVariations(state, blockName, scope);
  const match = variations === null || variations === void 0 ? void 0 : variations.find(variation => {
    var _variation$isActive;

    if (Array.isArray(variation.isActive)) {
      const blockType = selectors_getBlockType(state, blockName);
      const attributeKeys = Object.keys((blockType === null || blockType === void 0 ? void 0 : blockType.attributes) || {});
      const definedAttributes = variation.isActive.filter(attribute => attributeKeys.includes(attribute));

      if (definedAttributes.length === 0) {
        return false;
      }

      return definedAttributes.every(attribute => attributes[attribute] === variation.attributes[attribute]);
    }

    return (_variation$isActive = variation.isActive) === null || _variation$isActive === void 0 ? void 0 : _variation$isActive.call(variation, attributes, variation.attributes);
  });
  return match;
}
/**
 * Returns the default block variation for the given block type.
 * When there are multiple variations annotated as the default one,
 * the last added item is picked. This simplifies registering overrides.
 * When there is no default variation set, it returns the first item.
 *
 * @param {Object}                state     Data state.
 * @param {string}                blockName Block type name.
 * @param {WPBlockVariationScope} [scope]   Block variation scope name.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const defaultEmbedBlockVariation = useSelect( ( select ) =>
 *         select( blocksStore ).getDefaultBlockVariation( 'core/embed' ),
 *         []
 *     );
 *
 *     return (
 *         defaultEmbedBlockVariation && (
 *             <p>
 *                 { sprintf(
 *                     __( 'core/embed default variation: %s' ),
 *                     defaultEmbedBlockVariation.title
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {?WPBlockVariation} The default block variation.
 */

function getDefaultBlockVariation(state, blockName, scope) {
  const variations = selectors_getBlockVariations(state, blockName, scope);
  const defaultVariation = [...variations].reverse().find(_ref => {
    let {
      isDefault
    } = _ref;
    return !!isDefault;
  });
  return defaultVariation || variations[0];
}
/**
 * Returns all the available block categories.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect, } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const blockCategories = useSelect( ( select ) =>
 *         select( blocksStore ).getCategories(),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { blockCategories.map( ( category ) => (
 *                 <li key={ category.slug }>{ category.title }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {WPBlockCategory[]} Categories list.
 */

function getCategories(state) {
  return state.categories;
}
/**
 * Returns all the available collections.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const blockCollections = useSelect( ( select ) =>
 *         select( blocksStore ).getCollections(),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { Object.values( blockCollections ).length > 0 &&
 *                 Object.values( blockCollections ).map( ( collection ) => (
 *                     <li key={ collection.title }>{ collection.title }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Object} Collections list.
 */

function getCollections(state) {
  return state.collections;
}
/**
 * Returns the name of the default block name.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const defaultBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getDefaultBlockName(),
 *         []
 *     );
 *
 *     return (
 *         defaultBlockName && (
 *             <p>
 *                 { sprintf( __( 'Default block name: %s' ), defaultBlockName ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Default block name.
 */

function selectors_getDefaultBlockName(state) {
  return state.defaultBlockName;
}
/**
 * Returns the name of the block for handling non-block content.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const freeformFallbackBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getFreeformFallbackBlockName(),
 *         []
 *     );
 *
 *     return (
 *         freeformFallbackBlockName && (
 *             <p>
 *                 { sprintf( __(
 *                     'Freeform fallback block name: %s' ),
 *                     freeformFallbackBlockName
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Name of the block for handling non-block content.
 */

function getFreeformFallbackBlockName(state) {
  return state.freeformFallbackBlockName;
}
/**
 * Returns the name of the block for handling unregistered blocks.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const unregisteredFallbackBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getUnregisteredFallbackBlockName(),
 *         []
 *     );
 *
 *     return (
 *         unregisteredFallbackBlockName && (
 *             <p>
 *                 { sprintf( __(
 *                     'Unregistered fallback block name: %s' ),
 *                     unregisteredFallbackBlockName
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Name of the block for handling unregistered blocks.
 */

function getUnregisteredFallbackBlockName(state) {
  return state.unregisteredFallbackBlockName;
}
/**
 * Returns the name of the block for handling the grouping of blocks.
 *
 * @param {Object} state Data state.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const groupingBlockName = useSelect( ( select ) =>
 *         select( blocksStore ).getGroupingBlockName(),
 *         []
 *     );
 *
 *     return (
 *         groupingBlockName && (
 *             <p>
 *                 { sprintf(
 *                     __( 'Default grouping block name: %s' ),
 *                     groupingBlockName
 *                 ) }
 *             </p>
 *         )
 *     );
 * };
 * ```
 *
 * @return {string?} Name of the block for handling the grouping of blocks.
 */

function selectors_getGroupingBlockName(state) {
  return state.groupingBlockName;
}
/**
 * Returns an array with the child blocks of a given block.
 *
 * @param {Object} state     Data state.
 * @param {string} blockName Block type name.
 *
 * @example
 * ```js
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const childBlockNames = useSelect( ( select ) =>
 *         select( blocksStore ).getChildBlockNames( 'core/navigation' ),
 *         []
 *     );
 *
 *     return (
 *         <ul>
 *             { childBlockNames &&
 *                 childBlockNames.map( ( child ) => (
 *                     <li key={ child }>{ child }</li>
 *             ) ) }
 *         </ul>
 *     );
 * };
 * ```
 *
 * @return {Array} Array of child block names.
 */

const selectors_getChildBlockNames = (0,rememo/* default */.A)((state, blockName) => {
  return (0,lodash.map)((0,lodash.filter)(state.blockTypes, blockType => {
    var _blockType$parent;

    return (_blockType$parent = blockType.parent) === null || _blockType$parent === void 0 ? void 0 : _blockType$parent.includes(blockName);
  }), _ref2 => {
    let {
      name
    } = _ref2;
    return name;
  });
}, state => [state.blockTypes]);
/**
 * Returns the block support value for a feature, if defined.
 *
 * @param {Object}          state           Data state.
 * @param {(string|Object)} nameOrType      Block name or type object
 * @param {Array|string}    feature         Feature to retrieve
 * @param {*}               defaultSupports Default value to return if not
 *                                          explicitly defined
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const paragraphBlockSupportValue = useSelect( ( select ) =>
 *         select( blocksStore ).getBlockSupport( 'core/paragraph', 'anchor' ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/paragraph supports.anchor value: %s' ),
 *                 paragraphBlockSupportValue
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {?*} Block support value
 */

const selectors_getBlockSupport = (state, nameOrType, feature, defaultSupports) => {
  const blockType = getNormalizedBlockType(state, nameOrType);

  if (!(blockType !== null && blockType !== void 0 && blockType.supports)) {
    return defaultSupports;
  }

  return (0,lodash.get)(blockType.supports, feature, defaultSupports);
};
/**
 * Returns true if the block defines support for a feature, or false otherwise.
 *
 * @param {Object}          state           Data state.
 * @param {(string|Object)} nameOrType      Block name or type object.
 * @param {string}          feature         Feature to test.
 * @param {boolean}         defaultSupports Whether feature is supported by
 *                                          default if not explicitly defined.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const paragraphBlockSupportClassName = useSelect( ( select ) =>
 *         select( blocksStore ).hasBlockSupport( 'core/paragraph', 'className' ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/paragraph supports custom class name?: %s' ),
 *                 paragraphBlockSupportClassName
 *             ) }
 *         /p>
 *     );
 * };
 * ```
 *
 * @return {boolean} Whether block supports feature.
 */

function selectors_hasBlockSupport(state, nameOrType, feature, defaultSupports) {
  return !!selectors_getBlockSupport(state, nameOrType, feature, defaultSupports);
}
/**
 * Returns true if the block type by the given name or object value matches a
 * search term, or false otherwise.
 *
 * @param {Object}          state      Blocks state.
 * @param {(string|Object)} nameOrType Block name or type object.
 * @param {string}          searchTerm Search term by which to filter.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const termFound = useSelect(
 *         ( select ) =>
 *             select( blocksStore ).isMatchingSearchTerm(
 *                 'core/navigation',
 *                 'theme'
 *             ),
 *             []
 *         );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __(
 *                     'Search term was found in the title, keywords, category or description in block.json: %s'
 *                 ),
 *                 termFound
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {Object[]} Whether block type matches search term.
 */

function isMatchingSearchTerm(state, nameOrType, searchTerm) {
  var _blockType$keywords;

  const blockType = getNormalizedBlockType(state, nameOrType);
  const getNormalizedSearchTerm = (0,pipe/* default */.h)([// Disregard diacritics.
  //  Input: "média"
  term => remove_accents_default()(term !== null && term !== void 0 ? term : ''), // Lowercase.
  //  Input: "MEDIA"
  term => term.toLowerCase(), // Strip leading and trailing whitespace.
  //  Input: " media "
  term => term.trim()]);
  const normalizedSearchTerm = getNormalizedSearchTerm(searchTerm);
  const isSearchMatch = (0,pipe/* default */.h)([getNormalizedSearchTerm, normalizedCandidate => normalizedCandidate.includes(normalizedSearchTerm)]);
  return isSearchMatch(blockType.title) || ((_blockType$keywords = blockType.keywords) === null || _blockType$keywords === void 0 ? void 0 : _blockType$keywords.some(isSearchMatch)) || isSearchMatch(blockType.category) || typeof blockType.description === 'string' && isSearchMatch(blockType.description);
}
/**
 * Returns a boolean indicating if a block has child blocks or not.
 *
 * @param {Object} state     Data state.
 * @param {string} blockName Block type name.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const navigationBlockHasChildBlocks = useSelect( ( select ) =>
 *         select( blocksStore ).hasChildBlocks( 'core/navigation' ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/navigation has child blocks: %s' ),
 *                 navigationBlockHasChildBlocks
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {boolean} True if a block contains child blocks and false otherwise.
 */

const selectors_hasChildBlocks = (state, blockName) => {
  return selectors_getChildBlockNames(state, blockName).length > 0;
};
/**
 * Returns a boolean indicating if a block has at least one child block with inserter support.
 *
 * @param {Object} state     Data state.
 * @param {string} blockName Block type name.
 *
 * @example
 * ```js
 * import { __, sprintf } from '@wordpress/i18n';
 * import { store as blocksStore } from '@wordpress/blocks';
 * import { useSelect } from '@wordpress/data';
 *
 * const ExampleComponent = () => {
 *     const navigationBlockHasChildBlocksWithInserterSupport = useSelect( ( select ) =>
 *         select( blocksStore ).hasChildBlocksWithInserterSupport(
 *             'core/navigation'
 *         ),
 *         []
 *     );
 *
 *     return (
 *         <p>
 *             { sprintf(
 *                 __( 'core/navigation has child blocks with inserter support: %s' ),
 *                 navigationBlockHasChildBlocksWithInserterSupport
 *             ) }
 *         </p>
 *     );
 * };
 * ```
 *
 * @return {boolean} True if a block contains at least one child blocks with inserter support
 *                   and false otherwise.
 */

const selectors_hasChildBlocksWithInserterSupport = (state, blockName) => {
  return selectors_getChildBlockNames(state, blockName).some(childBlockName => {
    return selectors_hasBlockSupport(state, childBlockName, 'inserter', true);
  });
};
/**
 * DO-NOT-USE in production.
 * This selector is created for internal/experimental only usage and may be
 * removed anytime without any warning, causing breakage on any plugin or theme invoking it.
 */

const __experimentalHasContentRoleAttribute = (0,rememo/* default */.A)((state, blockTypeName) => {
  const blockType = selectors_getBlockType(state, blockTypeName);

  if (!blockType) {
    return false;
  }

  return Object.entries(blockType.attributes).some(_ref3 => {
    let [, {
      __experimentalRole
    }] = _ref3;
    return __experimentalRole === 'content';
  });
}, (state, blockTypeName) => {
  var _state$blockTypes$blo;

  return [(_state$blockTypes$blo = state.blockTypes[blockTypeName]) === null || _state$blockTypes$blo === void 0 ? void 0 : _state$blockTypes$blo.attributes];
});
//# sourceMappingURL=selectors.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs
var is_plain_object = __webpack_require__("../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+deprecated@3.41.0/node_modules/@wordpress/deprecated/build-module/index.js
var deprecated_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+deprecated@3.41.0/node_modules/@wordpress/deprecated/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/actions.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/** @typedef {import('../api/registration').WPBlockVariation} WPBlockVariation */

/** @typedef {import('../api/registration').WPBlockType} WPBlockType */

/** @typedef {import('./reducer').WPBlockCategory} WPBlockCategory */

const {
  error,
  warn
} = window.console;
/**
 * Mapping of legacy category slugs to their latest normal values, used to
 * accommodate updates of the default set of block categories.
 *
 * @type {Record<string,string>}
 */

const LEGACY_CATEGORY_MAPPING = {
  common: 'text',
  formatting: 'text',
  layout: 'design'
};
/**
 * Whether the argument is a function.
 *
 * @param {*} maybeFunc The argument to check.
 * @return {boolean} True if the argument is a function, false otherwise.
 */

function isFunction(maybeFunc) {
  return typeof maybeFunc === 'function';
}
/**
 * Takes the unprocessed block type data and applies all the existing filters for the registered block type.
 * Next, it validates all the settings and performs additional processing to the block type definition.
 *
 * @param {WPBlockType} blockType        Unprocessed block type settings.
 * @param {Object}      thunkArgs        Argument object for the thunk middleware.
 * @param {Function}    thunkArgs.select Function to select from the store.
 *
 * @return {?WPBlockType} The block, if it has been successfully registered; otherwise `undefined`.
 */


const processBlockType = (blockType, _ref) => {
  let {
    select
  } = _ref;
  const {
    name
  } = blockType;
  const settings = (0,hooks_build_module/* applyFilters */.W5)('blocks.registerBlockType', { ...blockType
  }, name, null);

  if (settings.description && typeof settings.description !== 'string') {
    (0,deprecated_build_module/* default */.A)('Declaring non-string block descriptions', {
      since: '6.2'
    });
  }

  if (settings.deprecated) {
    settings.deprecated = settings.deprecated.map(deprecation => (0,lodash.pick)( // Only keep valid deprecation keys.
    (0,hooks_build_module/* applyFilters */.W5)('blocks.registerBlockType', // Merge deprecation keys with pre-filter settings
    // so that filters that depend on specific keys being
    // present don't fail.
    { // Omit deprecation keys here so that deprecations
      // can opt out of specific keys like "supports".
      ...omit(blockType, DEPRECATED_ENTRY_KEYS),
      ...deprecation
    }, name, deprecation), DEPRECATED_ENTRY_KEYS));
  }

  if (!(0,is_plain_object/* isPlainObject */.Q)(settings)) {
    error('Block settings must be a valid object.');
    return;
  }

  if (!isFunction(settings.save)) {
    error('The "save" property must be a valid function.');
    return;
  }

  if ('edit' in settings && !isFunction(settings.edit)) {
    error('The "edit" property must be a valid function.');
    return;
  } // Canonicalize legacy categories to equivalent fallback.


  if (LEGACY_CATEGORY_MAPPING.hasOwnProperty(settings.category)) {
    settings.category = LEGACY_CATEGORY_MAPPING[settings.category];
  }

  if ('category' in settings && !select.getCategories().some(_ref2 => {
    let {
      slug
    } = _ref2;
    return slug === settings.category;
  })) {
    warn('The block "' + name + '" is registered with an invalid category "' + settings.category + '".');
    delete settings.category;
  }

  if (!('title' in settings) || settings.title === '') {
    error('The block "' + name + '" must have a title.');
    return;
  }

  if (typeof settings.title !== 'string') {
    error('Block titles must be strings.');
    return;
  }

  settings.icon = normalizeIconObject(settings.icon);

  if (!isValidIcon(settings.icon.src)) {
    error('The icon passed is invalid. ' + 'The icon should be a string, an element, a function, or an object following the specifications documented in https://developer.wordpress.org/block-editor/developers/block-api/block-registration/#icon-optional');
    return;
  }

  return settings;
};
/**
 * Returns an action object used in signalling that block types have been added.
 * Ignored from documentation as the recommended usage for this action through registerBlockType from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {WPBlockType|WPBlockType[]} blockTypes Object or array of objects representing blocks to added.
 *
 *
 * @return {Object} Action object.
 */


function addBlockTypes(blockTypes) {
  return {
    type: 'ADD_BLOCK_TYPES',
    blockTypes: Array.isArray(blockTypes) ? blockTypes : [blockTypes]
  };
}
/**
 * Signals that the passed block type's settings should be stored in the state.
 *
 * @param {WPBlockType} blockType Unprocessed block type settings.
 */

const __experimentalRegisterBlockType = blockType => _ref3 => {
  let {
    dispatch,
    select
  } = _ref3;
  dispatch({
    type: 'ADD_UNPROCESSED_BLOCK_TYPE',
    blockType
  });
  const processedBlockType = processBlockType(blockType, {
    select
  });

  if (!processedBlockType) {
    return;
  }

  dispatch.addBlockTypes(processedBlockType);
};
/**
 * Signals that all block types should be computed again.
 * It uses stored unprocessed block types and all the most recent list of registered filters.
 *
 * It addresses the issue where third party block filters get registered after third party blocks. A sample sequence:
 *   1. Filter A.
 *   2. Block B.
 *   3. Block C.
 *   4. Filter D.
 *   5. Filter E.
 *   6. Block F.
 *   7. Filter G.
 * In this scenario some filters would not get applied for all blocks because they are registered too late.
 */

const __experimentalReapplyBlockTypeFilters = () => _ref4 => {
  let {
    dispatch,
    select
  } = _ref4;

  const unprocessedBlockTypes = select.__experimentalGetUnprocessedBlockTypes();

  const processedBlockTypes = Object.keys(unprocessedBlockTypes).reduce((accumulator, blockName) => {
    const result = processBlockType(unprocessedBlockTypes[blockName], {
      select
    });

    if (result) {
      accumulator.push(result);
    }

    return accumulator;
  }, []);

  if (!processedBlockTypes.length) {
    return;
  }

  dispatch.addBlockTypes(processedBlockTypes);
};
/**
 * Returns an action object used to remove a registered block type.
 * Ignored from documentation as the recommended usage for this action through unregisterBlockType from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string|string[]} names Block name or array of block names to be removed.
 *
 *
 * @return {Object} Action object.
 */

function removeBlockTypes(names) {
  return {
    type: 'REMOVE_BLOCK_TYPES',
    names: Array.isArray(names) ? names : [names]
  };
}
/**
 * Returns an action object used in signalling that new block styles have been added.
 * Ignored from documentation as the recommended usage for this action through registerBlockStyle from @wordpress/blocks.
 *
 * @param {string}       blockName Block name.
 * @param {Array|Object} styles    Block style object or array of block style objects.
 *
 * @ignore
 *
 * @return {Object} Action object.
 */

function addBlockStyles(blockName, styles) {
  return {
    type: 'ADD_BLOCK_STYLES',
    styles: Array.isArray(styles) ? styles : [styles],
    blockName
  };
}
/**
 * Returns an action object used in signalling that block styles have been removed.
 * Ignored from documentation as the recommended usage for this action through unregisterBlockStyle from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string}       blockName  Block name.
 * @param {Array|string} styleNames Block style names or array of block style names.
 *
 * @return {Object} Action object.
 */

function removeBlockStyles(blockName, styleNames) {
  return {
    type: 'REMOVE_BLOCK_STYLES',
    styleNames: Array.isArray(styleNames) ? styleNames : [styleNames],
    blockName
  };
}
/**
 * Returns an action object used in signalling that new block variations have been added.
 * Ignored from documentation as the recommended usage for this action through registerBlockVariation from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string}                              blockName  Block name.
 * @param {WPBlockVariation|WPBlockVariation[]} variations Block variations.
 *
 * @return {Object} Action object.
 */

function addBlockVariations(blockName, variations) {
  return {
    type: 'ADD_BLOCK_VARIATIONS',
    variations: Array.isArray(variations) ? variations : [variations],
    blockName
  };
}
/**
 * Returns an action object used in signalling that block variations have been removed.
 * Ignored from documentation as the recommended usage for this action through unregisterBlockVariation from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string}          blockName      Block name.
 * @param {string|string[]} variationNames Block variation names.
 *
 * @return {Object} Action object.
 */

function removeBlockVariations(blockName, variationNames) {
  return {
    type: 'REMOVE_BLOCK_VARIATIONS',
    variationNames: Array.isArray(variationNames) ? variationNames : [variationNames],
    blockName
  };
}
/**
 * Returns an action object used to set the default block name.
 * Ignored from documentation as the recommended usage for this action through setDefaultBlockName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */

function actions_setDefaultBlockName(name) {
  return {
    type: 'SET_DEFAULT_BLOCK_NAME',
    name
  };
}
/**
 * Returns an action object used to set the name of the block used as a fallback
 * for non-block content.
 * Ignored from documentation as the recommended usage for this action through setFreeformContentHandlerName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */

function setFreeformFallbackBlockName(name) {
  return {
    type: 'SET_FREEFORM_FALLBACK_BLOCK_NAME',
    name
  };
}
/**
 * Returns an action object used to set the name of the block used as a fallback
 * for unregistered blocks.
 * Ignored from documentation as the recommended usage for this action through setUnregisteredTypeHandlerName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */

function setUnregisteredFallbackBlockName(name) {
  return {
    type: 'SET_UNREGISTERED_FALLBACK_BLOCK_NAME',
    name
  };
}
/**
 * Returns an action object used to set the name of the block used
 * when grouping other blocks
 * eg: in "Group/Ungroup" interactions
 * Ignored from documentation as the recommended usage for this action through setGroupingBlockName from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} name Block name.
 *
 * @return {Object} Action object.
 */

function actions_setGroupingBlockName(name) {
  return {
    type: 'SET_GROUPING_BLOCK_NAME',
    name
  };
}
/**
 * Returns an action object used to set block categories.
 * Ignored from documentation as the recommended usage for this action through setCategories from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {WPBlockCategory[]} categories Block categories.
 *
 * @return {Object} Action object.
 */

function setCategories(categories) {
  return {
    type: 'SET_CATEGORIES',
    categories
  };
}
/**
 * Returns an action object used to update a category.
 * Ignored from documentation as the recommended usage for this action through updateCategory from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} slug     Block category slug.
 * @param {Object} category Object containing the category properties that should be updated.
 *
 * @return {Object} Action object.
 */

function updateCategory(slug, category) {
  return {
    type: 'UPDATE_CATEGORY',
    slug,
    category
  };
}
/**
 * Returns an action object used to add block collections
 * Ignored from documentation as the recommended usage for this action through registerBlockCollection from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} namespace The namespace of the blocks to put in the collection
 * @param {string} title     The title to display in the block inserter
 * @param {Object} icon      (optional) The icon to display in the block inserter
 *
 * @return {Object} Action object.
 */

function addBlockCollection(namespace, title, icon) {
  return {
    type: 'ADD_BLOCK_COLLECTION',
    namespace,
    title,
    icon
  };
}
/**
 * Returns an action object used to remove block collections
 * Ignored from documentation as the recommended usage for this action through unregisterBlockCollection from @wordpress/blocks.
 *
 * @ignore
 *
 * @param {string} namespace The namespace of the blocks to put in the collection
 *
 * @return {Object} Action object.
 */

function removeBlockCollection(namespace) {
  return {
    type: 'REMOVE_BLOCK_COLLECTION',
    namespace
  };
}
//# sourceMappingURL=actions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/constants.js
const STORE_NAME = 'core/blocks';
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */





/**
 * Store definition for the blocks namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const store = (0,redux_store/* default */.A)(STORE_NAME, {
  reducer: reducer,
  selectors: selectors_namespaceObject,
  actions: actions_namespaceObject
});
(0,build_module/* register */.kz)(store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+block-serialization-default-parser@4.47.0/node_modules/@wordpress/block-serialization-default-parser/build-module/index.js
/**
 * @type {string}
 */
let build_module_document;
/**
 * @type {number}
 */
let offset;
/**
 * @type {ParsedBlock[]}
 */
let output;
/**
 * @type {ParsedFrame[]}
 */
let stack;

/**
 * @typedef {Object|null} Attributes
 */

/**
 * @typedef {Object} ParsedBlock
 * @property {string|null}        blockName    Block name.
 * @property {Attributes}         attrs        Block attributes.
 * @property {ParsedBlock[]}      innerBlocks  Inner blocks.
 * @property {string}             innerHTML    Inner HTML.
 * @property {Array<string|null>} innerContent Inner content.
 */

/**
 * @typedef {Object} ParsedFrame
 * @property {ParsedBlock} block            Block.
 * @property {number}      tokenStart       Token start.
 * @property {number}      tokenLength      Token length.
 * @property {number}      prevOffset       Previous offset.
 * @property {number|null} leadingHtmlStart Leading HTML start.
 */

/**
 * @typedef {'no-more-tokens'|'void-block'|'block-opener'|'block-closer'} TokenType
 */

/**
 * @typedef {[TokenType, string, Attributes, number, number]} Token
 */

/**
 * Matches block comment delimiters
 *
 * While most of this pattern is straightforward the attribute parsing
 * incorporates a tricks to make sure we don't choke on specific input
 *
 *  - since JavaScript has no possessive quantifier or atomic grouping
 *    we are emulating it with a trick
 *
 *    we want a possessive quantifier or atomic group to prevent backtracking
 *    on the `}`s should we fail to match the remainder of the pattern
 *
 *    we can emulate this with a positive lookahead and back reference
 *    (a++)*c === ((?=(a+))\1)*c
 *
 *    let's examine an example:
 *      - /(a+)*c/.test('aaaaaaaaaaaaad') fails after over 49,000 steps
 *      - /(a++)*c/.test('aaaaaaaaaaaaad') fails after 85 steps
 *      - /(?>a+)*c/.test('aaaaaaaaaaaaad') fails after 126 steps
 *
 *    this is because the possessive `++` and the atomic group `(?>)`
 *    tell the engine that all those `a`s belong together as a single group
 *    and so it won't split it up when stepping backwards to try and match
 *
 *    if we use /((?=(a+))\1)*c/ then we get the same behavior as the atomic group
 *    or possessive and prevent the backtracking because the `a+` is matched but
 *    not captured. thus, we find the long string of `a`s and remember it, then
 *    reference it as a whole unit inside our pattern
 *
 *    @see http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead
 *    @see http://blog.stevenlevithan.com/archives/mimic-atomic-groups
 *    @see https://javascript.info/regexp-infinite-backtracking-problem
 *
 *    once browsers reliably support atomic grouping or possessive
 *    quantifiers natively we should remove this trick and simplify
 *
 * @type {RegExp}
 *
 * @since 3.8.0
 * @since 4.6.1 added optimization to prevent backtracking on attribute parsing
 */
const tokenizer = /<!--\s+(\/)?wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/g;

/**
 * Constructs a block object.
 *
 * @param {string|null}   blockName
 * @param {Attributes}    attrs
 * @param {ParsedBlock[]} innerBlocks
 * @param {string}        innerHTML
 * @param {string[]}      innerContent
 * @return {ParsedBlock} The block object.
 */
function Block(blockName, attrs, innerBlocks, innerHTML, innerContent) {
  return {
    blockName,
    attrs,
    innerBlocks,
    innerHTML,
    innerContent
  };
}

/**
 * Constructs a freeform block object.
 *
 * @param {string} innerHTML
 * @return {ParsedBlock} The freeform block object.
 */
function Freeform(innerHTML) {
  return Block(null, {}, [], innerHTML, [innerHTML]);
}

/**
 * Constructs a frame object.
 *
 * @param {ParsedBlock} block
 * @param {number}      tokenStart
 * @param {number}      tokenLength
 * @param {number}      prevOffset
 * @param {number|null} leadingHtmlStart
 * @return {ParsedFrame} The frame object.
 */
function Frame(block, tokenStart, tokenLength, prevOffset, leadingHtmlStart) {
  return {
    block,
    tokenStart,
    tokenLength,
    prevOffset: prevOffset || tokenStart + tokenLength,
    leadingHtmlStart
  };
}

/**
 * Parser function, that converts input HTML into a block based structure.
 *
 * @param {string} doc The HTML document to parse.
 *
 * @example
 * Input post:
 * ```html
 * <!-- wp:columns {"columns":3} -->
 * <div class="wp-block-columns has-3-columns"><!-- wp:column -->
 * <div class="wp-block-column"><!-- wp:paragraph -->
 * <p>Left</p>
 * <!-- /wp:paragraph --></div>
 * <!-- /wp:column -->
 *
 * <!-- wp:column -->
 * <div class="wp-block-column"><!-- wp:paragraph -->
 * <p><strong>Middle</strong></p>
 * <!-- /wp:paragraph --></div>
 * <!-- /wp:column -->
 *
 * <!-- wp:column -->
 * <div class="wp-block-column"></div>
 * <!-- /wp:column --></div>
 * <!-- /wp:columns -->
 * ```
 *
 * Parsing code:
 * ```js
 * import { parse } from '@wordpress/block-serialization-default-parser';
 *
 * parse( post ) === [
 *     {
 *         blockName: "core/columns",
 *         attrs: {
 *             columns: 3
 *         },
 *         innerBlocks: [
 *             {
 *                 blockName: "core/column",
 *                 attrs: null,
 *                 innerBlocks: [
 *                     {
 *                         blockName: "core/paragraph",
 *                         attrs: null,
 *                         innerBlocks: [],
 *                         innerHTML: "\n<p>Left</p>\n"
 *                     }
 *                 ],
 *                 innerHTML: '\n<div class="wp-block-column"></div>\n'
 *             },
 *             {
 *                 blockName: "core/column",
 *                 attrs: null,
 *                 innerBlocks: [
 *                     {
 *                         blockName: "core/paragraph",
 *                         attrs: null,
 *                         innerBlocks: [],
 *                         innerHTML: "\n<p><strong>Middle</strong></p>\n"
 *                     }
 *                 ],
 *                 innerHTML: '\n<div class="wp-block-column"></div>\n'
 *             },
 *             {
 *                 blockName: "core/column",
 *                 attrs: null,
 *                 innerBlocks: [],
 *                 innerHTML: '\n<div class="wp-block-column"></div>\n'
 *             }
 *         ],
 *         innerHTML: '\n<div class="wp-block-columns has-3-columns">\n\n\n\n</div>\n'
 *     }
 * ];
 * ```
 * @return {ParsedBlock[]} A block-based representation of the input HTML.
 */
const parse = doc => {
  build_module_document = doc;
  offset = 0;
  output = [];
  stack = [];
  tokenizer.lastIndex = 0;
  do {
    // twiddle our thumbs
  } while (proceed());
  return output;
};

/**
 * Parses the next token in the input document.
 *
 * @return {boolean} Returns true when there is more tokens to parse.
 */
function proceed() {
  const stackDepth = stack.length;
  const next = nextToken();
  const [tokenType, blockName, attrs, startOffset, tokenLength] = next;

  // We may have some HTML soup before the next block.
  const leadingHtmlStart = startOffset > offset ? offset : null;
  switch (tokenType) {
    case 'no-more-tokens':
      // If not in a block then flush output.
      if (0 === stackDepth) {
        addFreeform();
        return false;
      }

      // Otherwise we have a problem
      // This is an error
      // we have options
      //  - treat it all as freeform text
      //  - assume an implicit closer (easiest when not nesting)

      // For the easy case we'll assume an implicit closer.
      if (1 === stackDepth) {
        addBlockFromStack();
        return false;
      }

      // For the nested case where it's more difficult we'll
      // have to assume that multiple closers are missing
      // and so we'll collapse the whole stack piecewise.
      while (0 < stack.length) {
        addBlockFromStack();
      }
      return false;
    case 'void-block':
      // easy case is if we stumbled upon a void block
      // in the top-level of the document.
      if (0 === stackDepth) {
        if (null !== leadingHtmlStart) {
          output.push(Freeform(build_module_document.substr(leadingHtmlStart, startOffset - leadingHtmlStart)));
        }
        output.push(Block(blockName, attrs, [], '', []));
        offset = startOffset + tokenLength;
        return true;
      }

      // Otherwise we found an inner block.
      addInnerBlock(Block(blockName, attrs, [], '', []), startOffset, tokenLength);
      offset = startOffset + tokenLength;
      return true;
    case 'block-opener':
      // Track all newly-opened blocks on the stack.
      stack.push(Frame(Block(blockName, attrs, [], '', []), startOffset, tokenLength, startOffset + tokenLength, leadingHtmlStart));
      offset = startOffset + tokenLength;
      return true;
    case 'block-closer':
      // If we're missing an opener we're in trouble
      // This is an error.
      if (0 === stackDepth) {
        // We have options
        //  - assume an implicit opener
        //  - assume _this_ is the opener
        // - give up and close out the document.
        addFreeform();
        return false;
      }

      // If we're not nesting then this is easy - close the block.
      if (1 === stackDepth) {
        addBlockFromStack(startOffset);
        offset = startOffset + tokenLength;
        return true;
      }

      // Otherwise we're nested and we have to close out the current
      // block and add it as a innerBlock to the parent.
      const stackTop = /** @type {ParsedFrame} */stack.pop();
      const html = build_module_document.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);
      stackTop.block.innerHTML += html;
      stackTop.block.innerContent.push(html);
      stackTop.prevOffset = startOffset + tokenLength;
      addInnerBlock(stackTop.block, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);
      offset = startOffset + tokenLength;
      return true;
    default:
      // This is an error.
      addFreeform();
      return false;
  }
}

/**
 * Parse JSON if valid, otherwise return null
 *
 * Note that JSON coming from the block comment
 * delimiters is constrained to be an object
 * and cannot be things like `true` or `null`
 *
 * @param {string} input JSON input string to parse
 * @return {Object|null} parsed JSON if valid
 */
function parseJSON(input) {
  try {
    return JSON.parse(input);
  } catch (e) {
    return null;
  }
}

/**
 * Finds the next token in the document.
 *
 * @return {Token} The next matched token.
 */
function nextToken() {
  // Aye the magic
  // we're using a single RegExp to tokenize the block comment delimiters
  // we're also using a trick here because the only difference between a
  // block opener and a block closer is the leading `/` before `wp:` (and
  // a closer has no attributes). we can trap them both and process the
  // match back in JavaScript to see which one it was.
  const matches = tokenizer.exec(build_module_document);

  // We have no more tokens.
  if (null === matches) {
    return ['no-more-tokens', '', null, 0, 0];
  }
  const startedAt = matches.index;
  const [match, closerMatch, namespaceMatch, nameMatch, attrsMatch /* Internal/unused. */,, voidMatch] = matches;
  const length = match.length;
  const isCloser = !!closerMatch;
  const isVoid = !!voidMatch;
  const namespace = namespaceMatch || 'core/';
  const name = namespace + nameMatch;
  const hasAttrs = !!attrsMatch;
  const attrs = hasAttrs ? parseJSON(attrsMatch) : {};

  // This state isn't allowed
  // This is an error.
  if (isCloser && (isVoid || hasAttrs)) {
    // We can ignore them since they don't hurt anything
    // we may warn against this at some point or reject it.
  }
  if (isVoid) {
    return ['void-block', name, attrs, startedAt, length];
  }
  if (isCloser) {
    return ['block-closer', name, null, startedAt, length];
  }
  return ['block-opener', name, attrs, startedAt, length];
}

/**
 * Adds a freeform block to the output.
 *
 * @param {number} [rawLength]
 */
function addFreeform(rawLength) {
  const length = rawLength ? rawLength : build_module_document.length - offset;
  if (0 === length) {
    return;
  }
  output.push(Freeform(build_module_document.substr(offset, length)));
}

/**
 * Adds inner block to the parent block.
 *
 * @param {ParsedBlock} block
 * @param {number}      tokenStart
 * @param {number}      tokenLength
 * @param {number}      [lastOffset]
 */
function addInnerBlock(block, tokenStart, tokenLength, lastOffset) {
  const parent = stack[stack.length - 1];
  parent.block.innerBlocks.push(block);
  const html = build_module_document.substr(parent.prevOffset, tokenStart - parent.prevOffset);
  if (html) {
    parent.block.innerHTML += html;
    parent.block.innerContent.push(html);
  }
  parent.block.innerContent.push(null);
  parent.prevOffset = lastOffset ? lastOffset : tokenStart + tokenLength;
}

/**
 * Adds block from the stack to the output.
 *
 * @param {number} [endOffset]
 */
function addBlockFromStack(endOffset) {
  const {
    block,
    leadingHtmlStart,
    prevOffset,
    tokenStart
  } = /** @type {ParsedFrame} */stack.pop();
  const html = endOffset ? build_module_document.substr(prevOffset, endOffset - prevOffset) : build_module_document.substr(prevOffset);
  if (html) {
    block.innerHTML += html;
    block.innerContent.push(html);
  }
  if (null !== leadingHtmlStart) {
    output.push(Freeform(build_module_document.substr(leadingHtmlStart, tokenStart - leadingHtmlStart)));
  }
  output.push(block);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+autop@3.47.0/node_modules/@wordpress/autop/build-module/index.js
/**
 * The regular expression for an HTML element.
 *
 * @type {RegExp}
 */
const htmlSplitRegex = (() => {
  /* eslint-disable no-multi-spaces */
  const comments = '!' +
  // Start of comment, after the <.
  '(?:' +
  // Unroll the loop: Consume everything until --> is found.
  '-(?!->)' +
  // Dash not followed by end of comment.
  '[^\\-]*' +
  // Consume non-dashes.
  ')*' +
  // Loop possessively.
  '(?:-->)?'; // End of comment. If not found, match all input.

  const cdata = '!\\[CDATA\\[' +
  // Start of comment, after the <.
  '[^\\]]*' +
  // Consume non-].
  '(?:' +
  // Unroll the loop: Consume everything until ]]> is found.
  '](?!]>)' +
  // One ] not followed by end of comment.
  '[^\\]]*' +
  // Consume non-].
  ')*?' +
  // Loop possessively.
  '(?:]]>)?'; // End of comment. If not found, match all input.

  const escaped = '(?=' +
  // Is the element escaped?
  '!--' + '|' + '!\\[CDATA\\[' + ')' + '((?=!-)' +
  // If yes, which type?
  comments + '|' + cdata + ')';
  const regex = '(' +
  // Capture the entire match.
  '<' +
  // Find start of element.
  '(' +
  // Conditional expression follows.
  escaped +
  // Find end of escaped element.
  '|' +
  // ... else ...
  '[^>]*>?' +
  // Find end of normal element.
  ')' + ')';
  return new RegExp(regex);
  /* eslint-enable no-multi-spaces */
})();

/**
 * Separate HTML elements and comments from the text.
 *
 * @param {string} input The text which has to be formatted.
 *
 * @return {string[]} The formatted text.
 */
function htmlSplit(input) {
  const parts = [];
  let workingInput = input;
  let match;
  while (match = workingInput.match(htmlSplitRegex)) {
    // The `match` result, when invoked on a RegExp with the `g` flag (`/foo/g`) will not include `index`.
    // If the `g` flag is omitted, `index` is included.
    // `htmlSplitRegex` does not have the `g` flag so we can assert it will have an index number.
    // Assert `match.index` is a number.
    const index = /** @type {number} */match.index;
    parts.push(workingInput.slice(0, index));
    parts.push(match[0]);
    workingInput = workingInput.slice(index + match[0].length);
  }
  if (workingInput.length) {
    parts.push(workingInput);
  }
  return parts;
}

/**
 * Replace characters or phrases within HTML elements only.
 *
 * @param {string}                haystack     The text which has to be formatted.
 * @param {Record<string,string>} replacePairs In the form {from: 'to', …}.
 *
 * @return {string} The formatted text.
 */
function replaceInHtmlTags(haystack, replacePairs) {
  // Find all elements.
  const textArr = htmlSplit(haystack);
  let changed = false;

  // Extract all needles.
  const needles = Object.keys(replacePairs);

  // Loop through delimiters (elements) only.
  for (let i = 1; i < textArr.length; i += 2) {
    for (let j = 0; j < needles.length; j++) {
      const needle = needles[j];
      if (-1 !== textArr[i].indexOf(needle)) {
        textArr[i] = textArr[i].replace(new RegExp(needle, 'g'), replacePairs[needle]);
        changed = true;
        // After one strtr() break out of the foreach loop and look at next element.
        break;
      }
    }
  }
  if (changed) {
    haystack = textArr.join('');
  }
  return haystack;
}

/**
 * Replaces double line-breaks with paragraph elements.
 *
 * A group of regex replaces used to identify text formatted with newlines and
 * replace double line-breaks with HTML paragraph tags. The remaining line-
 * breaks after conversion become `<br />` tags, unless br is set to 'false'.
 *
 * @param {string}  text The text which has to be formatted.
 * @param {boolean} br   Optional. If set, will convert all remaining line-
 *                       breaks after paragraphing. Default true.
 *
 * @example
 *```js
 * import { autop } from '@wordpress/autop';
 * autop( 'my text' ); // "<p>my text</p>"
 * ```
 *
 * @return {string} Text which has been converted into paragraph tags.
 */
function autop(text, br = true) {
  const preTags = [];
  if (text.trim() === '') {
    return '';
  }

  // Just to make things a little easier, pad the end.
  text = text + '\n';

  /*
   * Pre tags shouldn't be touched by autop.
   * Replace pre tags with placeholders and bring them back after autop.
   */
  if (text.indexOf('<pre') !== -1) {
    const textParts = text.split('</pre>');
    const lastText = textParts.pop();
    text = '';
    for (let i = 0; i < textParts.length; i++) {
      const textPart = textParts[i];
      const start = textPart.indexOf('<pre');

      // Malformed html?
      if (start === -1) {
        text += textPart;
        continue;
      }
      const name = '<pre wp-pre-tag-' + i + '></pre>';
      preTags.push([name, textPart.substr(start) + '</pre>']);
      text += textPart.substr(0, start) + name;
    }
    text += lastText;
  }
  // Change multiple <br>s into two line breaks, which will turn into paragraphs.
  text = text.replace(/<br\s*\/?>\s*<br\s*\/?>/g, '\n\n');
  const allBlocks = '(?:table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary)';

  // Add a double line break above block-level opening tags.
  text = text.replace(new RegExp('(<' + allBlocks + '[\\s/>])', 'g'), '\n\n$1');

  // Add a double line break below block-level closing tags.
  text = text.replace(new RegExp('(</' + allBlocks + '>)', 'g'), '$1\n\n');

  // Standardize newline characters to "\n".
  text = text.replace(/\r\n|\r/g, '\n');

  // Find newlines in all elements and add placeholders.
  text = replaceInHtmlTags(text, {
    '\n': ' <!-- wpnl --> '
  });

  // Collapse line breaks before and after <option> elements so they don't get autop'd.
  if (text.indexOf('<option') !== -1) {
    text = text.replace(/\s*<option/g, '<option');
    text = text.replace(/<\/option>\s*/g, '</option>');
  }

  /*
   * Collapse line breaks inside <object> elements, before <param> and <embed> elements
   * so they don't get autop'd.
   */
  if (text.indexOf('</object>') !== -1) {
    text = text.replace(/(<object[^>]*>)\s*/g, '$1');
    text = text.replace(/\s*<\/object>/g, '</object>');
    text = text.replace(/\s*(<\/?(?:param|embed)[^>]*>)\s*/g, '$1');
  }

  /*
   * Collapse line breaks inside <audio> and <video> elements,
   * before and after <source> and <track> elements.
   */
  if (text.indexOf('<source') !== -1 || text.indexOf('<track') !== -1) {
    text = text.replace(/([<\[](?:audio|video)[^>\]]*[>\]])\s*/g, '$1');
    text = text.replace(/\s*([<\[]\/(?:audio|video)[>\]])/g, '$1');
    text = text.replace(/\s*(<(?:source|track)[^>]*>)\s*/g, '$1');
  }

  // Collapse line breaks before and after <figcaption> elements.
  if (text.indexOf('<figcaption') !== -1) {
    text = text.replace(/\s*(<figcaption[^>]*>)/, '$1');
    text = text.replace(/<\/figcaption>\s*/, '</figcaption>');
  }

  // Remove more than two contiguous line breaks.
  text = text.replace(/\n\n+/g, '\n\n');

  // Split up the contents into an array of strings, separated by double line breaks.
  const texts = text.split(/\n\s*\n/).filter(Boolean);

  // Reset text prior to rebuilding.
  text = '';

  // Rebuild the content as a string, wrapping every bit with a <p>.
  texts.forEach(textPiece => {
    text += '<p>' + textPiece.replace(/^\n*|\n*$/g, '') + '</p>\n';
  });

  // Under certain strange conditions it could create a P of entirely whitespace.
  text = text.replace(/<p>\s*<\/p>/g, '');

  // Add a closing <p> inside <div>, <address>, or <form> tag if missing.
  text = text.replace(/<p>([^<]+)<\/(div|address|form)>/g, '<p>$1</p></$2>');

  // If an opening or closing block element tag is wrapped in a <p>, unwrap it.
  text = text.replace(new RegExp('<p>\\s*(</?' + allBlocks + '[^>]*>)\\s*</p>', 'g'), '$1');

  // In some cases <li> may get wrapped in <p>, fix them.
  text = text.replace(/<p>(<li.+?)<\/p>/g, '$1');

  // If a <blockquote> is wrapped with a <p>, move it inside the <blockquote>.
  text = text.replace(/<p><blockquote([^>]*)>/gi, '<blockquote$1><p>');
  text = text.replace(/<\/blockquote><\/p>/g, '</p></blockquote>');

  // If an opening or closing block element tag is preceded by an opening <p> tag, remove it.
  text = text.replace(new RegExp('<p>\\s*(</?' + allBlocks + '[^>]*>)', 'g'), '$1');

  // If an opening or closing block element tag is followed by a closing <p> tag, remove it.
  text = text.replace(new RegExp('(</?' + allBlocks + '[^>]*>)\\s*</p>', 'g'), '$1');

  // Optionally insert line breaks.
  if (br) {
    // Replace newlines that shouldn't be touched with a placeholder.
    text = text.replace(/<(script|style).*?<\/\\1>/g, match => match[0].replace(/\n/g, '<WPPreserveNewline />'));

    // Normalize <br>
    text = text.replace(/<br>|<br\/>/g, '<br />');

    // Replace any new line characters that aren't preceded by a <br /> with a <br />.
    text = text.replace(/(<br \/>)?\s*\n/g, (a, b) => b ? a : '<br />\n');

    // Replace newline placeholders with newlines.
    text = text.replace(/<WPPreserveNewline \/>/g, '\n');
  }

  // If a <br /> tag is after an opening or closing block tag, remove it.
  text = text.replace(new RegExp('(</?' + allBlocks + '[^>]*>)\\s*<br />', 'g'), '$1');

  // If a <br /> tag is before a subset of opening or closing block tags, remove it.
  text = text.replace(/<br \/>(\s*<\/?(?:p|li|div|dl|dd|dt|th|pre|td|ul|ol)[^>]*>)/g, '$1');
  text = text.replace(/\n<\/p>$/g, '</p>');

  // Replace placeholder <pre> tags with their original content.
  preTags.forEach(preTag => {
    const [name, original] = preTag;
    text = text.replace(name, original);
  });

  // Restore newlines in all elements.
  if (-1 !== text.indexOf('<!-- wpnl -->')) {
    text = text.replace(/\s?<!-- wpnl -->\s?/g, '\n');
  }
  return text;
}

/**
 * Replaces `<p>` tags with two line breaks. "Opposite" of autop().
 *
 * Replaces `<p>` tags with two line breaks except where the `<p>` has attributes.
 * Unifies whitespace. Indents `<li>`, `<dt>` and `<dd>` for better readability.
 *
 * @param {string} html The content from the editor.
 *
 * @example
 * ```js
 * import { removep } from '@wordpress/autop';
 * removep( '<p>my text</p>' ); // "my text"
 * ```
 *
 * @return {string} The content with stripped paragraph tags.
 */
function build_module_removep(html) {
  const blocklist = 'blockquote|ul|ol|li|dl|dt|dd|table|thead|tbody|tfoot|tr|th|td|h[1-6]|fieldset|figure';
  const blocklist1 = blocklist + '|div|p';
  const blocklist2 = blocklist + '|pre';
  /** @type {string[]} */
  const preserve = [];
  let preserveLinebreaks = false;
  let preserveBr = false;
  if (!html) {
    return '';
  }

  // Protect script and style tags.
  if (html.indexOf('<script') !== -1 || html.indexOf('<style') !== -1) {
    html = html.replace(/<(script|style)[^>]*>[\s\S]*?<\/\1>/g, match => {
      preserve.push(match);
      return '<wp-preserve>';
    });
  }

  // Protect pre tags.
  if (html.indexOf('<pre') !== -1) {
    preserveLinebreaks = true;
    html = html.replace(/<pre[^>]*>[\s\S]+?<\/pre>/g, a => {
      a = a.replace(/<br ?\/?>(\r\n|\n)?/g, '<wp-line-break>');
      a = a.replace(/<\/?p( [^>]*)?>(\r\n|\n)?/g, '<wp-line-break>');
      return a.replace(/\r?\n/g, '<wp-line-break>');
    });
  }

  // Remove line breaks but keep <br> tags inside image captions.
  if (html.indexOf('[caption') !== -1) {
    preserveBr = true;
    html = html.replace(/\[caption[\s\S]+?\[\/caption\]/g, a => {
      return a.replace(/<br([^>]*)>/g, '<wp-temp-br$1>').replace(/[\r\n\t]+/, '');
    });
  }

  // Normalize white space characters before and after block tags.
  html = html.replace(new RegExp('\\s*</(' + blocklist1 + ')>\\s*', 'g'), '</$1>\n');
  html = html.replace(new RegExp('\\s*<((?:' + blocklist1 + ')(?: [^>]*)?)>', 'g'), '\n<$1>');

  // Mark </p> if it has any attributes.
  html = html.replace(/(<p [^>]+>[\s\S]*?)<\/p>/g, '$1</p#>');

  // Preserve the first <p> inside a <div>.
  html = html.replace(/<div( [^>]*)?>\s*<p>/gi, '<div$1>\n\n');

  // Remove paragraph tags.
  html = html.replace(/\s*<p>/gi, '');
  html = html.replace(/\s*<\/p>\s*/gi, '\n\n');

  // Normalize white space chars and remove multiple line breaks.
  html = html.replace(/\n[\s\u00a0]+\n/g, '\n\n');

  // Replace <br> tags with line breaks.
  html = html.replace(/(\s*)<br ?\/?>\s*/gi, (_, space) => {
    if (space && space.indexOf('\n') !== -1) {
      return '\n\n';
    }
    return '\n';
  });

  // Fix line breaks around <div>.
  html = html.replace(/\s*<div/g, '\n<div');
  html = html.replace(/<\/div>\s*/g, '</div>\n');

  // Fix line breaks around caption shortcodes.
  html = html.replace(/\s*\[caption([^\[]+)\[\/caption\]\s*/gi, '\n\n[caption$1[/caption]\n\n');
  html = html.replace(/caption\]\n\n+\[caption/g, 'caption]\n\n[caption');

  // Pad block elements tags with a line break.
  html = html.replace(new RegExp('\\s*<((?:' + blocklist2 + ')(?: [^>]*)?)\\s*>', 'g'), '\n<$1>');
  html = html.replace(new RegExp('\\s*</(' + blocklist2 + ')>\\s*', 'g'), '</$1>\n');

  // Indent <li>, <dt> and <dd> tags.
  html = html.replace(/<((li|dt|dd)[^>]*)>/g, ' \t<$1>');

  // Fix line breaks around <select> and <option>.
  if (html.indexOf('<option') !== -1) {
    html = html.replace(/\s*<option/g, '\n<option');
    html = html.replace(/\s*<\/select>/g, '\n</select>');
  }

  // Pad <hr> with two line breaks.
  if (html.indexOf('<hr') !== -1) {
    html = html.replace(/\s*<hr( [^>]*)?>\s*/g, '\n\n<hr$1>\n\n');
  }

  // Remove line breaks in <object> tags.
  if (html.indexOf('<object') !== -1) {
    html = html.replace(/<object[\s\S]+?<\/object>/g, a => {
      return a.replace(/[\r\n]+/g, '');
    });
  }

  // Unmark special paragraph closing tags.
  html = html.replace(/<\/p#>/g, '</p>\n');

  // Pad remaining <p> tags whit a line break.
  html = html.replace(/\s*(<p [^>]+>[\s\S]*?<\/p>)/g, '\n$1');

  // Trim.
  html = html.replace(/^\s+/, '');
  html = html.replace(/[\s\u00a0]+$/, '');
  if (preserveLinebreaks) {
    html = html.replace(/<wp-line-break>/g, '\n');
  }
  if (preserveBr) {
    html = html.replace(/<wp-temp-br([^>]*)>/g, '<br$1>');
  }

  // Restore preserved tags.
  if (preserve.length) {
    html = html.replace(/<wp-preserve>/g, () => {
      return (/** @type {string} */preserve.shift()
      );
    });
  }
  return html;
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/raw-html.js
var raw_html = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/raw-html.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/serialize.js
var serialize = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/serialize.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@4.24.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js + 2 modules
var is_shallow_equal_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+is-shallow-equal@4.24.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/serialize-raw-block.js
/**
 * Internal dependencies
 */

/**
 * @typedef {Object}   Options                   Serialization options.
 * @property {boolean} [isCommentDelimited=true] Whether to output HTML comments around blocks.
 */

/** @typedef {import("./").WPRawBlock} WPRawBlock */

/**
 * Serializes a block node into the native HTML-comment-powered block format.
 * CAVEAT: This function is intended for re-serializing blocks as parsed by
 * valid parsers and skips any validation steps. This is NOT a generic
 * serialization function for in-memory blocks. For most purposes, see the
 * following functions available in the `@wordpress/blocks` package:
 *
 * @see serializeBlock
 * @see serialize
 *
 * For more on the format of block nodes as returned by valid parsers:
 *
 * @see `@wordpress/block-serialization-default-parser` package
 * @see `@wordpress/block-serialization-spec-parser` package
 *
 * @param {WPRawBlock} rawBlock     A block node as returned by a valid parser.
 * @param {Options}    [options={}] Serialization options.
 *
 * @return {string} An HTML string representing a block.
 */

function serializeRawBlock(rawBlock) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    isCommentDelimited = true
  } = options;
  const {
    blockName,
    attrs = {},
    innerBlocks = [],
    innerContent = []
  } = rawBlock;
  let childIndex = 0;
  const content = innerContent.map(item => // `null` denotes a nested block, otherwise we have an HTML fragment.
  item !== null ? item : serializeRawBlock(innerBlocks[childIndex++], options)).join('\n').replace(/\n+/g, '\n').trim();
  return isCommentDelimited ? getCommentDelimitedContent(blockName, attrs, content) : content;
}
//# sourceMappingURL=serialize-raw-block.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/serializer.js


/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */




/** @typedef {import('./parser').WPBlock} WPBlock */

/**
 * @typedef {Object} WPBlockSerializationOptions Serialization Options.
 *
 * @property {boolean} isInnerBlocks Whether we are serializing inner blocks.
 */

/**
 * Returns the block's default classname from its name.
 *
 * @param {string} blockName The block name.
 *
 * @return {string} The block's default class.
 */

function getBlockDefaultClassName(blockName) {
  // Generated HTML classes for blocks follow the `wp-block-{name}` nomenclature.
  // Blocks provided by WordPress drop the prefixes 'core/' or 'core-' (historically used in 'core-embed/').
  const className = 'wp-block-' + blockName.replace(/\//, '-').replace(/^core-/, '');
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getBlockDefaultClassName', className, blockName);
}
/**
 * Returns the block's default menu item classname from its name.
 *
 * @param {string} blockName The block name.
 *
 * @return {string} The block's default menu item class.
 */

function getBlockMenuDefaultClassName(blockName) {
  // Generated HTML classes for blocks follow the `editor-block-list-item-{name}` nomenclature.
  // Blocks provided by WordPress drop the prefixes 'core/' or 'core-' (historically used in 'core-embed/').
  const className = 'editor-block-list-item-' + blockName.replace(/\//, '-').replace(/^core-/, '');
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getBlockMenuDefaultClassName', className, blockName);
}
const blockPropsProvider = {};
const innerBlocksPropsProvider = {};
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */

function getBlockProps() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    blockType,
    attributes
  } = blockPropsProvider;
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getSaveContent.extraProps', { ...props
  }, blockType, attributes);
}
/**
 * Call within a save function to get the props for the inner blocks wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */

function getInnerBlocksProps() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    innerBlocks
  } = innerBlocksPropsProvider; // Value is an array of blocks, so defer to block serializer.

  const html = serializer_serialize(innerBlocks, {
    isInnerBlocks: true
  }); // Use special-cased raw HTML tag to avoid default escaping.

  const children = (0,react.createElement)(raw_html/* default */.A, null, html);
  return { ...props,
    children
  };
}
/**
 * Given a block type containing a save render implementation and attributes, returns the
 * enhanced element to be saved or string when raw HTML expected.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {Object}        attributes      Block attributes.
 * @param {?Array}        innerBlocks     Nested blocks.
 *
 * @return {Object|string} Save element or raw HTML string.
 */

function getSaveElement(blockTypeOrName, attributes) {
  let innerBlocks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  let {
    save
  } = blockType; // Component classes are unsupported for save since serialization must
  // occur synchronously. For improved interoperability with higher-order
  // components which often return component class, emulate basic support.

  if (save.prototype instanceof react.Component) {
    const instance = new save({
      attributes
    });
    save = instance.render.bind(instance);
  }

  blockPropsProvider.blockType = blockType;
  blockPropsProvider.attributes = attributes;
  innerBlocksPropsProvider.innerBlocks = innerBlocks;
  let element = save({
    attributes,
    innerBlocks
  });

  if (element !== null && typeof element === 'object' && (0,hooks_build_module/* hasFilter */.FC)('blocks.getSaveContent.extraProps') && !(blockType.apiVersion > 1)) {
    /**
     * Filters the props applied to the block save result element.
     *
     * @param {Object}  props      Props applied to save element.
     * @param {WPBlock} blockType  Block type definition.
     * @param {Object}  attributes Block attributes.
     */
    const props = (0,hooks_build_module/* applyFilters */.W5)('blocks.getSaveContent.extraProps', { ...element.props
    }, blockType, attributes);

    if (!(0,is_shallow_equal_build_module/* default */.Ay)(props, element.props)) {
      element = (0,react.cloneElement)(element, props);
    }
  }
  /**
   * Filters the save result of a block during serialization.
   *
   * @param {WPElement} element    Block save result.
   * @param {WPBlock}   blockType  Block type definition.
   * @param {Object}    attributes Block attributes.
   */


  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getSaveElement', element, blockType, attributes);
}
/**
 * Given a block type containing a save render implementation and attributes, returns the
 * static markup to be saved.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {Object}        attributes      Block attributes.
 * @param {?Array}        innerBlocks     Nested blocks.
 *
 * @return {string} Save content.
 */

function getSaveContent(blockTypeOrName, attributes, innerBlocks) {
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  return (0,serialize/* default */.Ay)(getSaveElement(blockType, attributes, innerBlocks));
}
/**
 * Returns attributes which are to be saved and serialized into the block
 * comment delimiter.
 *
 * When a block exists in memory it contains as its attributes both those
 * parsed the block comment delimiter _and_ those which matched from the
 * contents of the block.
 *
 * This function returns only those attributes which are needed to persist and
 * which cannot be matched from the block content.
 *
 * @param {Object<string,*>} blockType  Block type.
 * @param {Object<string,*>} attributes Attributes from in-memory block data.
 *
 * @return {Object<string,*>} Subset of attributes for comment serialization.
 */

function getCommentAttributes(blockType, attributes) {
  var _blockType$attributes;

  return Object.entries((_blockType$attributes = blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}).reduce((accumulator, _ref) => {
    let [key, attributeSchema] = _ref;
    const value = attributes[key]; // Ignore undefined values.

    if (undefined === value) {
      return accumulator;
    } // Ignore all attributes but the ones with an "undefined" source
    // "undefined" source refers to attributes saved in the block comment.


    if (attributeSchema.source !== undefined) {
      return accumulator;
    } // Ignore default value.


    if ('default' in attributeSchema && attributeSchema.default === value) {
      return accumulator;
    } // Otherwise, include in comment set.


    accumulator[key] = value;
    return accumulator;
  }, {});
}
/**
 * Given an attributes object, returns a string in the serialized attributes
 * format prepared for post content.
 *
 * @param {Object} attributes Attributes object.
 *
 * @return {string} Serialized attributes.
 */

function serializeAttributes(attributes) {
  return JSON.stringify(attributes) // Don't break HTML comments.
  .replace(/--/g, '\\u002d\\u002d') // Don't break non-standard-compliant tools.
  .replace(/</g, '\\u003c').replace(/>/g, '\\u003e').replace(/&/g, '\\u0026') // Bypass server stripslashes behavior which would unescape stringify's
  // escaping of quotation mark.
  //
  // See: https://developer.wordpress.org/reference/functions/wp_kses_stripslashes/
  .replace(/\\"/g, '\\u0022');
}
/**
 * Given a block object, returns the Block's Inner HTML markup.
 *
 * @param {Object} block Block instance.
 *
 * @return {string} HTML.
 */

function getBlockInnerHTML(block) {
  // If block was parsed as invalid or encounters an error while generating
  // save content, use original content instead to avoid content loss. If a
  // block contains nested content, exempt it from this condition because we
  // otherwise have no access to its original content and content loss would
  // still occur.
  let saveContent = block.originalContent;

  if (block.isValid || block.innerBlocks.length) {
    try {
      saveContent = getSaveContent(block.name, block.attributes, block.innerBlocks);
    } catch (error) {}
  }

  return saveContent;
}
/**
 * Returns the content of a block, including comment delimiters.
 *
 * @param {string} rawBlockName Block name.
 * @param {Object} attributes   Block attributes.
 * @param {string} content      Block save content.
 *
 * @return {string} Comment-delimited block content.
 */

function getCommentDelimitedContent(rawBlockName, attributes, content) {
  const serializedAttributes = attributes && Object.entries(attributes).length ? serializeAttributes(attributes) + ' ' : ''; // Strip core blocks of their namespace prefix.

  const blockName = rawBlockName !== null && rawBlockName !== void 0 && rawBlockName.startsWith('core/') ? rawBlockName.slice(5) : rawBlockName; // @todo make the `wp:` prefix potentially configurable.

  if (!content) {
    return `<!-- wp:${blockName} ${serializedAttributes}/-->`;
  }

  return `<!-- wp:${blockName} ${serializedAttributes}-->\n` + content + `\n<!-- /wp:${blockName} -->`;
}
/**
 * Returns the content of a block, including comment delimiters, determining
 * serialized attributes and content form from the current state of the block.
 *
 * @param {WPBlock}                     block   Block instance.
 * @param {WPBlockSerializationOptions} options Serialization options.
 *
 * @return {string} Serialized block.
 */

function serializeBlock(block) {
  let {
    isInnerBlocks = false
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!block.isValid && block.__unstableBlockSource) {
    return serializeRawBlock(block.__unstableBlockSource);
  }

  const blockName = block.name;
  const saveContent = getBlockInnerHTML(block);

  if (blockName === getUnregisteredTypeHandlerName() || !isInnerBlocks && blockName === registration_getFreeformContentHandlerName()) {
    return saveContent;
  }

  const blockType = getBlockType(blockName);

  if (!blockType) {
    return saveContent;
  }

  const saveAttributes = getCommentAttributes(blockType, block.attributes);
  return getCommentDelimitedContent(blockName, saveAttributes, saveContent);
}
function __unstableSerializeAndClean(blocks) {
  // A single unmodified default block is assumed to
  // be equivalent to an empty post.
  if (blocks.length === 1 && isUnmodifiedDefaultBlock(blocks[0])) {
    blocks = [];
  }

  let content = serializer_serialize(blocks); // For compatibility, treat a post consisting of a
  // single freeform block as legacy content and apply
  // pre-block-editor removep'd content formatting.

  if (blocks.length === 1 && blocks[0].name === getFreeformContentHandlerName()) {
    content = removep(content);
  }

  return content;
}
/**
 * Takes a block or set of blocks and returns the serialized post content.
 *
 * @param {Array}                       blocks  Block(s) to serialize.
 * @param {WPBlockSerializationOptions} options Serialization options.
 *
 * @return {string} The post content.
 */

function serializer_serialize(blocks, options) {
  const blocksArray = Array.isArray(blocks) ? blocks : [blocks];
  return blocksArray.map(block => serializeBlock(block, options)).join('\n\n');
}
//# sourceMappingURL=serializer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/simple-html-tokenizer@0.5.11/node_modules/simple-html-tokenizer/dist/es6/index.js
/**
 * generated from https://raw.githubusercontent.com/w3c/html/26b5126f96f736f796b9e29718138919dd513744/entities.json
 * do not edit
 */
var namedCharRefs = {
    Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "\u2061", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "\u2061", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "\u2063", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "\u2062", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "\u200e", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\u000a", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "\u2060", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: "\"", QUOT: "\"", rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "\u200f", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "\u00ad", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\u0009", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "\u200d", zwnj: "\u200c"
};

var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
var CHARCODE = /^#([0-9]+)$/;
var NAMED = /^([A-Za-z0-9]+)$/;
var EntityParser = /** @class */ (function () {
    function EntityParser(named) {
        this.named = named;
    }
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    return EntityParser;
}());

var WSP = /[\t\n\f ]/;
var ALPHA = /[A-Za-z]/;
var CRLF = /\r\n?/g;
function isSpace(char) {
    return WSP.test(char);
}
function isAlpha(char) {
    return ALPHA.test(char);
}
function preprocessInput(input) {
    return input.replace(CRLF, '\n');
}

var EventedTokenizer = /** @class */ (function () {
    function EventedTokenizer(delegate, entityParser, mode) {
        if (mode === void 0) { mode = 'precompile'; }
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.mode = mode;
        this.state = "beforeData" /* beforeData */;
        this.line = -1;
        this.column = -1;
        this.input = '';
        this.index = -1;
        this.tagNameBuffer = '';
        this.states = {
            beforeData: function () {
                var char = this.peek();
                if (char === '<' && !this.isIgnoredEndTag()) {
                    this.transitionTo("tagOpen" /* tagOpen */);
                    this.markTagStart();
                    this.consume();
                }
                else {
                    if (this.mode === 'precompile' && char === '\n') {
                        var tag = this.tagNameBuffer.toLowerCase();
                        if (tag === 'pre' || tag === 'textarea') {
                            this.consume();
                        }
                    }
                    this.transitionTo("data" /* data */);
                    this.delegate.beginData();
                }
            },
            data: function () {
                var char = this.peek();
                var tag = this.tagNameBuffer;
                if (char === '<' && !this.isIgnoredEndTag()) {
                    this.delegate.finishData();
                    this.transitionTo("tagOpen" /* tagOpen */);
                    this.markTagStart();
                    this.consume();
                }
                else if (char === '&' && tag !== 'script' && tag !== 'style') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                }
                else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function () {
                var char = this.consume();
                if (char === '!') {
                    this.transitionTo("markupDeclarationOpen" /* markupDeclarationOpen */);
                }
                else if (char === '/') {
                    this.transitionTo("endTagOpen" /* endTagOpen */);
                }
                else if (char === '@' || char === ':' || isAlpha(char)) {
                    this.transitionTo("tagName" /* tagName */);
                    this.tagNameBuffer = '';
                    this.delegate.beginStartTag();
                    this.appendToTagName(char);
                }
            },
            markupDeclarationOpen: function () {
                var char = this.consume();
                if (char === '-' && this.peek() === '-') {
                    this.consume();
                    this.transitionTo("commentStart" /* commentStart */);
                    this.delegate.beginComment();
                }
                else {
                    var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();
                    if (maybeDoctype === 'DOCTYPE') {
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.transitionTo("doctype" /* doctype */);
                        if (this.delegate.beginDoctype)
                            this.delegate.beginDoctype();
                    }
                }
            },
            doctype: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("beforeDoctypeName" /* beforeDoctypeName */);
                }
            },
            beforeDoctypeName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else {
                    this.transitionTo("doctypeName" /* doctypeName */);
                    if (this.delegate.appendToDoctypeName)
                        this.delegate.appendToDoctypeName(char.toLowerCase());
                }
            },
            doctypeName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("afterDoctypeName" /* afterDoctypeName */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypeName)
                        this.delegate.appendToDoctypeName(char.toLowerCase());
                }
            },
            afterDoctypeName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();
                    var isPublic = nextSixChars.toUpperCase() === 'PUBLIC';
                    var isSystem = nextSixChars.toUpperCase() === 'SYSTEM';
                    if (isPublic || isSystem) {
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                        this.consume();
                    }
                    if (isPublic) {
                        this.transitionTo("afterDoctypePublicKeyword" /* afterDoctypePublicKeyword */);
                    }
                    else if (isSystem) {
                        this.transitionTo("afterDoctypeSystemKeyword" /* afterDoctypeSystemKeyword */);
                    }
                }
            },
            afterDoctypePublicKeyword: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.transitionTo("beforeDoctypePublicIdentifier" /* beforeDoctypePublicIdentifier */);
                    this.consume();
                }
                else if (char === '"') {
                    this.transitionTo("doctypePublicIdentifierDoubleQuoted" /* doctypePublicIdentifierDoubleQuoted */);
                    this.consume();
                }
                else if (char === "'") {
                    this.transitionTo("doctypePublicIdentifierSingleQuoted" /* doctypePublicIdentifierSingleQuoted */);
                    this.consume();
                }
                else if (char === '>') {
                    this.consume();
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
            },
            doctypePublicIdentifierDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.transitionTo("afterDoctypePublicIdentifier" /* afterDoctypePublicIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypePublicIdentifier)
                        this.delegate.appendToDoctypePublicIdentifier(char);
                }
            },
            doctypePublicIdentifierSingleQuoted: function () {
                var char = this.consume();
                if (char === "'") {
                    this.transitionTo("afterDoctypePublicIdentifier" /* afterDoctypePublicIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypePublicIdentifier)
                        this.delegate.appendToDoctypePublicIdentifier(char);
                }
            },
            afterDoctypePublicIdentifier: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("betweenDoctypePublicAndSystemIdentifiers" /* betweenDoctypePublicAndSystemIdentifiers */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '"') {
                    this.transitionTo("doctypeSystemIdentifierDoubleQuoted" /* doctypeSystemIdentifierDoubleQuoted */);
                }
                else if (char === "'") {
                    this.transitionTo("doctypeSystemIdentifierSingleQuoted" /* doctypeSystemIdentifierSingleQuoted */);
                }
            },
            betweenDoctypePublicAndSystemIdentifiers: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '"') {
                    this.transitionTo("doctypeSystemIdentifierDoubleQuoted" /* doctypeSystemIdentifierDoubleQuoted */);
                }
                else if (char === "'") {
                    this.transitionTo("doctypeSystemIdentifierSingleQuoted" /* doctypeSystemIdentifierSingleQuoted */);
                }
            },
            doctypeSystemIdentifierDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.transitionTo("afterDoctypeSystemIdentifier" /* afterDoctypeSystemIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypeSystemIdentifier)
                        this.delegate.appendToDoctypeSystemIdentifier(char);
                }
            },
            doctypeSystemIdentifierSingleQuoted: function () {
                var char = this.consume();
                if (char === "'") {
                    this.transitionTo("afterDoctypeSystemIdentifier" /* afterDoctypeSystemIdentifier */);
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    if (this.delegate.appendToDoctypeSystemIdentifier)
                        this.delegate.appendToDoctypeSystemIdentifier(char);
                }
            },
            afterDoctypeSystemIdentifier: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    return;
                }
                else if (char === '>') {
                    if (this.delegate.endDoctype)
                        this.delegate.endDoctype();
                    this.transitionTo("beforeData" /* beforeData */);
                }
            },
            commentStart: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentStartDash" /* commentStartDash */);
                }
                else if (char === '>') {
                    this.delegate.finishComment();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.appendToCommentData(char);
                    this.transitionTo("comment" /* comment */);
                }
            },
            commentStartDash: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentEnd" /* commentEnd */);
                }
                else if (char === '>') {
                    this.delegate.finishComment();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.appendToCommentData('-');
                    this.transitionTo("comment" /* comment */);
                }
            },
            comment: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentEndDash" /* commentEndDash */);
                }
                else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function () {
                var char = this.consume();
                if (char === '-') {
                    this.transitionTo("commentEnd" /* commentEnd */);
                }
                else {
                    this.delegate.appendToCommentData('-' + char);
                    this.transitionTo("comment" /* comment */);
                }
            },
            commentEnd: function () {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.appendToCommentData('--' + char);
                    this.transitionTo("comment" /* comment */);
                }
            },
            tagName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
                else if (char === '/') {
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '>') {
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.appendToTagName(char);
                }
            },
            endTagName: function () {
                var char = this.consume();
                if (isSpace(char)) {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                    this.tagNameBuffer = '';
                }
                else if (char === '/') {
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                    this.tagNameBuffer = '';
                }
                else if (char === '>') {
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                    this.tagNameBuffer = '';
                }
                else {
                    this.appendToTagName(char);
                }
            },
            beforeAttributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    return;
                }
                else if (char === '/') {
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                    this.consume();
                }
                else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '=') {
                    this.delegate.reportSyntaxError('attribute name cannot start with equals sign');
                    this.transitionTo("attributeName" /* attributeName */);
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
                else {
                    this.transitionTo("attributeName" /* attributeName */);
                    this.delegate.beginAttribute();
                }
            },
            attributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.transitionTo("afterAttributeName" /* afterAttributeName */);
                    this.consume();
                }
                else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '=') {
                    this.transitionTo("beforeAttributeValue" /* beforeAttributeValue */);
                    this.consume();
                }
                else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else if (char === '"' || char === "'" || char === '<') {
                    this.delegate.reportSyntaxError(char + ' is not a valid character within attribute names');
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
                else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    return;
                }
                else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '=') {
                    this.consume();
                    this.transitionTo("beforeAttributeValue" /* beforeAttributeValue */);
                }
                else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.transitionTo("attributeName" /* attributeName */);
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                }
                else if (char === '"') {
                    this.transitionTo("attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */);
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                }
                else if (char === "'") {
                    this.transitionTo("attributeValueSingleQuoted" /* attributeValueSingleQuoted */);
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                }
                else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function () {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.transitionTo("afterAttributeValueQuoted" /* afterAttributeValueQuoted */);
                }
                else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
                }
                else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function () {
                var char = this.consume();
                if (char === "'") {
                    this.delegate.finishAttributeValue();
                    this.transitionTo("afterAttributeValueQuoted" /* afterAttributeValueQuoted */);
                }
                else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
                }
                else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
                else if (char === '/') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef() || '&');
                }
                else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function () {
                var char = this.peek();
                if (isSpace(char)) {
                    this.consume();
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
                else if (char === '/') {
                    this.consume();
                    this.transitionTo("selfClosingStartTag" /* selfClosingStartTag */);
                }
                else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
            },
            selfClosingStartTag: function () {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.transitionTo("beforeData" /* beforeData */);
                }
                else {
                    this.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                }
            },
            endTagOpen: function () {
                var char = this.consume();
                if (char === '@' || char === ':' || isAlpha(char)) {
                    this.transitionTo("endTagName" /* endTagName */);
                    this.tagNameBuffer = '';
                    this.delegate.beginEndTag();
                    this.appendToTagName(char);
                }
            }
        };
        this.reset();
    }
    EventedTokenizer.prototype.reset = function () {
        this.transitionTo("beforeData" /* beforeData */);
        this.input = '';
        this.tagNameBuffer = '';
        this.index = 0;
        this.line = 1;
        this.column = 0;
        this.delegate.reset();
    };
    EventedTokenizer.prototype.transitionTo = function (state) {
        this.state = state;
    };
    EventedTokenizer.prototype.tokenize = function (input) {
        this.reset();
        this.tokenizePart(input);
        this.tokenizeEOF();
    };
    EventedTokenizer.prototype.tokenizePart = function (input) {
        this.input += preprocessInput(input);
        while (this.index < this.input.length) {
            var handler = this.states[this.state];
            if (handler !== undefined) {
                handler.call(this);
            }
            else {
                throw new Error("unhandled state " + this.state);
            }
        }
    };
    EventedTokenizer.prototype.tokenizeEOF = function () {
        this.flushData();
    };
    EventedTokenizer.prototype.flushData = function () {
        if (this.state === 'data') {
            this.delegate.finishData();
            this.transitionTo("beforeData" /* beforeData */);
        }
    };
    EventedTokenizer.prototype.peek = function () {
        return this.input.charAt(this.index);
    };
    EventedTokenizer.prototype.consume = function () {
        var char = this.peek();
        this.index++;
        if (char === '\n') {
            this.line++;
            this.column = 0;
        }
        else {
            this.column++;
        }
        return char;
    };
    EventedTokenizer.prototype.consumeCharRef = function () {
        var endIndex = this.input.indexOf(';', this.index);
        if (endIndex === -1) {
            return;
        }
        var entity = this.input.slice(this.index, endIndex);
        var chars = this.entityParser.parse(entity);
        if (chars) {
            var count = entity.length;
            // consume the entity chars
            while (count) {
                this.consume();
                count--;
            }
            // consume the `;`
            this.consume();
            return chars;
        }
    };
    EventedTokenizer.prototype.markTagStart = function () {
        this.delegate.tagOpen();
    };
    EventedTokenizer.prototype.appendToTagName = function (char) {
        this.tagNameBuffer += char;
        this.delegate.appendToTagName(char);
    };
    EventedTokenizer.prototype.isIgnoredEndTag = function () {
        var tag = this.tagNameBuffer;
        return (tag === 'title' && this.input.substring(this.index, this.index + 8) !== '</title>') ||
            (tag === 'style' && this.input.substring(this.index, this.index + 8) !== '</style>') ||
            (tag === 'script' && this.input.substring(this.index, this.index + 9) !== '</script>');
    };
    return EventedTokenizer;
}());

var Tokenizer = /** @class */ (function () {
    function Tokenizer(entityParser, options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.tokens = [];
        this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);
        this._currentAttribute = undefined;
    }
    Tokenizer.prototype.tokenize = function (input) {
        this.tokens = [];
        this.tokenizer.tokenize(input);
        return this.tokens;
    };
    Tokenizer.prototype.tokenizePart = function (input) {
        this.tokens = [];
        this.tokenizer.tokenizePart(input);
        return this.tokens;
    };
    Tokenizer.prototype.tokenizeEOF = function () {
        this.tokens = [];
        this.tokenizer.tokenizeEOF();
        return this.tokens[0];
    };
    Tokenizer.prototype.reset = function () {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
    };
    Tokenizer.prototype.current = function () {
        var token = this.token;
        if (token === null) {
            throw new Error('token was unexpectedly null');
        }
        if (arguments.length === 0) {
            return token;
        }
        for (var i = 0; i < arguments.length; i++) {
            if (token.type === arguments[i]) {
                return token;
            }
        }
        throw new Error("token type was unexpectedly " + token.type);
    };
    Tokenizer.prototype.push = function (token) {
        this.token = token;
        this.tokens.push(token);
    };
    Tokenizer.prototype.currentAttribute = function () {
        return this._currentAttribute;
    };
    Tokenizer.prototype.addLocInfo = function () {
        if (this.options.loc) {
            this.current().loc = {
                start: {
                    line: this.startLine,
                    column: this.startColumn
                },
                end: {
                    line: this.tokenizer.line,
                    column: this.tokenizer.column
                }
            };
        }
        this.startLine = this.tokenizer.line;
        this.startColumn = this.tokenizer.column;
    };
    // Data
    Tokenizer.prototype.beginDoctype = function () {
        this.push({
            type: "Doctype" /* Doctype */,
            name: '',
        });
    };
    Tokenizer.prototype.appendToDoctypeName = function (char) {
        this.current("Doctype" /* Doctype */).name += char;
    };
    Tokenizer.prototype.appendToDoctypePublicIdentifier = function (char) {
        var doctype = this.current("Doctype" /* Doctype */);
        if (doctype.publicIdentifier === undefined) {
            doctype.publicIdentifier = char;
        }
        else {
            doctype.publicIdentifier += char;
        }
    };
    Tokenizer.prototype.appendToDoctypeSystemIdentifier = function (char) {
        var doctype = this.current("Doctype" /* Doctype */);
        if (doctype.systemIdentifier === undefined) {
            doctype.systemIdentifier = char;
        }
        else {
            doctype.systemIdentifier += char;
        }
    };
    Tokenizer.prototype.endDoctype = function () {
        this.addLocInfo();
    };
    Tokenizer.prototype.beginData = function () {
        this.push({
            type: "Chars" /* Chars */,
            chars: ''
        });
    };
    Tokenizer.prototype.appendToData = function (char) {
        this.current("Chars" /* Chars */).chars += char;
    };
    Tokenizer.prototype.finishData = function () {
        this.addLocInfo();
    };
    // Comment
    Tokenizer.prototype.beginComment = function () {
        this.push({
            type: "Comment" /* Comment */,
            chars: ''
        });
    };
    Tokenizer.prototype.appendToCommentData = function (char) {
        this.current("Comment" /* Comment */).chars += char;
    };
    Tokenizer.prototype.finishComment = function () {
        this.addLocInfo();
    };
    // Tags - basic
    Tokenizer.prototype.tagOpen = function () { };
    Tokenizer.prototype.beginStartTag = function () {
        this.push({
            type: "StartTag" /* StartTag */,
            tagName: '',
            attributes: [],
            selfClosing: false
        });
    };
    Tokenizer.prototype.beginEndTag = function () {
        this.push({
            type: "EndTag" /* EndTag */,
            tagName: ''
        });
    };
    Tokenizer.prototype.finishTag = function () {
        this.addLocInfo();
    };
    Tokenizer.prototype.markTagAsSelfClosing = function () {
        this.current("StartTag" /* StartTag */).selfClosing = true;
    };
    // Tags - name
    Tokenizer.prototype.appendToTagName = function (char) {
        this.current("StartTag" /* StartTag */, "EndTag" /* EndTag */).tagName += char;
    };
    // Tags - attributes
    Tokenizer.prototype.beginAttribute = function () {
        this._currentAttribute = ['', '', false];
    };
    Tokenizer.prototype.appendToAttributeName = function (char) {
        this.currentAttribute()[0] += char;
    };
    Tokenizer.prototype.beginAttributeValue = function (isQuoted) {
        this.currentAttribute()[2] = isQuoted;
    };
    Tokenizer.prototype.appendToAttributeValue = function (char) {
        this.currentAttribute()[1] += char;
    };
    Tokenizer.prototype.finishAttributeValue = function () {
        this.current("StartTag" /* StartTag */).attributes.push(this._currentAttribute);
    };
    Tokenizer.prototype.reportSyntaxError = function (message) {
        this.current().syntaxError = message;
    };
    return Tokenizer;
}());

function tokenize(input, options) {
    var tokenizer = new Tokenizer(new EntityParser(namedCharRefs), options);
    return tokenizer.tokenize(input);
}


//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+html-entities@3.24.0/node_modules/@wordpress/html-entities/build-module/index.js
var html_entities_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+html-entities@3.24.0/node_modules/@wordpress/html-entities/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/validation/logger.js
/**
 * @typedef LoggerItem
 * @property {Function}   log  Which logger recorded the message
 * @property {Array<any>} args White arguments were supplied to the logger
 */
function createLogger() {
  /**
   * Creates a log handler with block validation prefix.
   *
   * @param {Function} logger Original logger function.
   *
   * @return {Function} Augmented logger function.
   */
  function createLogHandler(logger) {
    let log = function (message) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return logger('Block validation: ' + message, ...args);
    }; // In test environments, pre-process string substitutions to improve
    // readability of error messages. We'd prefer to avoid pulling in this
    // dependency in runtime environments, and it can be dropped by a combo
    // of Webpack env substitution + UglifyJS dead code elimination.


    if (false) {}

    return log;
  }

  return {
    // eslint-disable-next-line no-console
    error: createLogHandler(console.error),
    // eslint-disable-next-line no-console
    warning: createLogHandler(console.warn),

    getItems() {
      return [];
    }

  };
}
function createQueuedLogger() {
  /**
   * The list of enqueued log actions to print.
   *
   * @type {Array<LoggerItem>}
   */
  const queue = [];
  const logger = createLogger();
  return {
    error() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      queue.push({
        log: logger.error,
        args
      });
    },

    warning() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      queue.push({
        log: logger.warning,
        args
      });
    },

    getItems() {
      return queue;
    }

  };
}
//# sourceMappingURL=logger.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/validation/index.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */





/** @typedef {import('../parser').WPBlock} WPBlock */

/** @typedef {import('../registration').WPBlockType} WPBlockType */

/** @typedef {import('./logger').LoggerItem} LoggerItem */

const identity = x => x;
/**
 * Globally matches any consecutive whitespace
 *
 * @type {RegExp}
 */


const REGEXP_WHITESPACE = /[\t\n\r\v\f ]+/g;
/**
 * Matches a string containing only whitespace
 *
 * @type {RegExp}
 */

const REGEXP_ONLY_WHITESPACE = /^[\t\n\r\v\f ]*$/;
/**
 * Matches a CSS URL type value
 *
 * @type {RegExp}
 */

const REGEXP_STYLE_URL_TYPE = /^url\s*\(['"\s]*(.*?)['"\s]*\)$/;
/**
 * Boolean attributes are attributes whose presence as being assigned is
 * meaningful, even if only empty.
 *
 * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes
 * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3
 *
 * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )
 *     .filter( ( tr ) => tr.lastChild.textContent.indexOf( 'Boolean attribute' ) !== -1 )
 *     .reduce( ( result, tr ) => Object.assign( result, {
 *         [ tr.firstChild.textContent.trim() ]: true
 *     } ), {} ) ).sort();
 *
 * @type {Array}
 */

const BOOLEAN_ATTRIBUTES = ['allowfullscreen', 'allowpaymentrequest', 'allowusermedia', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'download', 'formnovalidate', 'hidden', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected', 'typemustmatch'];
/**
 * Enumerated attributes are attributes which must be of a specific value form.
 * Like boolean attributes, these are meaningful if specified, even if not of a
 * valid enumerated value.
 *
 * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#enumerated-attribute
 * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3
 *
 * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )
 *     .filter( ( tr ) => /^("(.+?)";?\s*)+/.test( tr.lastChild.textContent.trim() ) )
 *     .reduce( ( result, tr ) => Object.assign( result, {
 *         [ tr.firstChild.textContent.trim() ]: true
 *     } ), {} ) ).sort();
 *
 * @type {Array}
 */

const ENUMERATED_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'charset', 'contenteditable', 'crossorigin', 'decoding', 'dir', 'draggable', 'enctype', 'formenctype', 'formmethod', 'http-equiv', 'inputmode', 'kind', 'method', 'preload', 'scope', 'shape', 'spellcheck', 'translate', 'type', 'wrap'];
/**
 * Meaningful attributes are those who cannot be safely ignored when omitted in
 * one HTML markup string and not another.
 *
 * @type {Array}
 */

const MEANINGFUL_ATTRIBUTES = [...BOOLEAN_ATTRIBUTES, ...ENUMERATED_ATTRIBUTES];
/**
 * Array of functions which receive a text string on which to apply normalizing
 * behavior for consideration in text token equivalence, carefully ordered from
 * least-to-most expensive operations.
 *
 * @type {Array}
 */

const TEXT_NORMALIZATIONS = [identity, getTextWithCollapsedWhitespace];
/**
 * Regular expression matching a named character reference. In lieu of bundling
 * a full set of references, the pattern covers the minimal necessary to test
 * positively against the full set.
 *
 * "The ampersand must be followed by one of the names given in the named
 * character references section, using the same case."
 *
 * Tested aginst "12.5 Named character references":
 *
 * ```
 * const references = Array.from( document.querySelectorAll(
 *     '#named-character-references-table tr[id^=entity-] td:first-child'
 * ) ).map( ( code ) => code.textContent )
 * references.every( ( reference ) => /^[\da-z]+$/i.test( reference ) )
 * ```
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references
 * @see https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references
 *
 * @type {RegExp}
 */

const REGEXP_NAMED_CHARACTER_REFERENCE = /^[\da-z]+$/i;
/**
 * Regular expression matching a decimal character reference.
 *
 * "The ampersand must be followed by a U+0023 NUMBER SIGN character (#),
 * followed by one or more ASCII digits, representing a base-ten integer"
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references
 *
 * @type {RegExp}
 */

const REGEXP_DECIMAL_CHARACTER_REFERENCE = /^#\d+$/;
/**
 * Regular expression matching a hexadecimal character reference.
 *
 * "The ampersand must be followed by a U+0023 NUMBER SIGN character (#), which
 * must be followed by either a U+0078 LATIN SMALL LETTER X character (x) or a
 * U+0058 LATIN CAPITAL LETTER X character (X), which must then be followed by
 * one or more ASCII hex digits, representing a hexadecimal integer"
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references
 *
 * @type {RegExp}
 */

const REGEXP_HEXADECIMAL_CHARACTER_REFERENCE = /^#x[\da-f]+$/i;
/**
 * Returns true if the given string is a valid character reference segment, or
 * false otherwise. The text should be stripped of `&` and `;` demarcations.
 *
 * @param {string} text Text to test.
 *
 * @return {boolean} Whether text is valid character reference.
 */

function isValidCharacterReference(text) {
  return REGEXP_NAMED_CHARACTER_REFERENCE.test(text) || REGEXP_DECIMAL_CHARACTER_REFERENCE.test(text) || REGEXP_HEXADECIMAL_CHARACTER_REFERENCE.test(text);
}
/**
 * Subsitute EntityParser class for `simple-html-tokenizer` which uses the
 * implementation of `decodeEntities` from `html-entities`, in order to avoid
 * bundling a massive named character reference.
 *
 * @see https://github.com/tildeio/simple-html-tokenizer/tree/HEAD/src/entity-parser.ts
 */

class DecodeEntityParser {
  /**
   * Returns a substitute string for an entity string sequence between `&`
   * and `;`, or undefined if no substitution should occur.
   *
   * @param {string} entity Entity fragment discovered in HTML.
   *
   * @return {?string} Entity substitute value.
   */
  parse(entity) {
    if (isValidCharacterReference(entity)) {
      return (0,html_entities_build_module/* decodeEntities */.S)('&' + entity + ';');
    }
  }

}
/**
 * Given a specified string, returns an array of strings split by consecutive
 * whitespace, ignoring leading or trailing whitespace.
 *
 * @param {string} text Original text.
 *
 * @return {string[]} Text pieces split on whitespace.
 */

function getTextPiecesSplitOnWhitespace(text) {
  return text.trim().split(REGEXP_WHITESPACE);
}
/**
 * Given a specified string, returns a new trimmed string where all consecutive
 * whitespace is collapsed to a single space.
 *
 * @param {string} text Original text.
 *
 * @return {string} Trimmed text with consecutive whitespace collapsed.
 */

function getTextWithCollapsedWhitespace(text) {
  // This is an overly simplified whitespace comparison. The specification is
  // more prescriptive of whitespace behavior in inline and block contexts.
  //
  // See: https://medium.com/@patrickbrosset/when-does-white-space-matter-in-html-b90e8a7cdd33
  return getTextPiecesSplitOnWhitespace(text).join(' ');
}
/**
 * Returns attribute pairs of the given StartTag token, including only pairs
 * where the value is non-empty or the attribute is a boolean attribute, an
 * enumerated attribute, or a custom data- attribute.
 *
 * @see MEANINGFUL_ATTRIBUTES
 *
 * @param {Object} token StartTag token.
 *
 * @return {Array[]} Attribute pairs.
 */

function getMeaningfulAttributePairs(token) {
  return token.attributes.filter(pair => {
    const [key, value] = pair;
    return value || key.indexOf('data-') === 0 || MEANINGFUL_ATTRIBUTES.includes(key);
  });
}
/**
 * Returns true if two text tokens (with `chars` property) are equivalent, or
 * false otherwise.
 *
 * @param {Object} actual   Actual token.
 * @param {Object} expected Expected token.
 * @param {Object} logger   Validation logger object.
 *
 * @return {boolean} Whether two text tokens are equivalent.
 */

function isEquivalentTextTokens(actual, expected) {
  let logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createLogger();
  // This function is intentionally written as syntactically "ugly" as a hot
  // path optimization. Text is progressively normalized in order from least-
  // to-most operationally expensive, until the earliest point at which text
  // can be confidently inferred as being equal.
  let actualChars = actual.chars;
  let expectedChars = expected.chars;

  for (let i = 0; i < TEXT_NORMALIZATIONS.length; i++) {
    const normalize = TEXT_NORMALIZATIONS[i];
    actualChars = normalize(actualChars);
    expectedChars = normalize(expectedChars);

    if (actualChars === expectedChars) {
      return true;
    }
  }

  logger.warning('Expected text `%s`, saw `%s`.', expected.chars, actual.chars);
  return false;
}
/**
 * Given a CSS length value, returns a normalized CSS length value for strict equality
 * comparison.
 *
 * @param {string} value CSS length value.
 *
 * @return {string} Normalized CSS length value.
 */

function getNormalizedLength(value) {
  if (0 === parseFloat(value)) {
    return '0';
  } // Normalize strings with floats to always include a leading zero.


  if (value.indexOf('.') === 0) {
    return '0' + value;
  }

  return value;
}
/**
 * Given a style value, returns a normalized style value for strict equality
 * comparison.
 *
 * @param {string} value Style value.
 *
 * @return {string} Normalized style value.
 */

function getNormalizedStyleValue(value) {
  const textPieces = getTextPiecesSplitOnWhitespace(value);
  const normalizedPieces = textPieces.map(getNormalizedLength);
  const result = normalizedPieces.join(' ');
  return result // Normalize URL type to omit whitespace or quotes.
  .replace(REGEXP_STYLE_URL_TYPE, 'url($1)');
}
/**
 * Given a style attribute string, returns an object of style properties.
 *
 * @param {string} text Style attribute.
 *
 * @return {Object} Style properties.
 */

function getStyleProperties(text) {
  const pairs = text // Trim ending semicolon (avoid including in split)
  .replace(/;?\s*$/, '') // Split on property assignment.
  .split(';') // For each property assignment...
  .map(style => {
    // ...split further into key-value pairs.
    const [key, ...valueParts] = style.split(':');
    const value = valueParts.join(':');
    return [key.trim(), getNormalizedStyleValue(value.trim())];
  });
  return Object.fromEntries(pairs);
}
/**
 * Attribute-specific equality handlers
 *
 * @type {Object}
 */

const isEqualAttributesOfName = {
  class: (actual, expected) => {
    // Class matches if members are the same, even if out of order or
    // superfluous whitespace between.
    const [actualPieces, expectedPieces] = [actual, expected].map(getTextPiecesSplitOnWhitespace);
    const actualDiff = actualPieces.filter(c => !expectedPieces.includes(c));
    const expectedDiff = expectedPieces.filter(c => !actualPieces.includes(c));
    return actualDiff.length === 0 && expectedDiff.length === 0;
  },
  style: (actual, expected) => {
    return (0,lodash.isEqual)(...[actual, expected].map(getStyleProperties));
  },
  // For each boolean attribute, mere presence of attribute in both is enough
  // to assume equivalence.
  ...Object.fromEntries(BOOLEAN_ATTRIBUTES.map(attribute => [attribute, () => true]))
};
/**
 * Given two sets of attribute tuples, returns true if the attribute sets are
 * equivalent.
 *
 * @param {Array[]} actual   Actual attributes tuples.
 * @param {Array[]} expected Expected attributes tuples.
 * @param {Object}  logger   Validation logger object.
 *
 * @return {boolean} Whether attributes are equivalent.
 */

function isEqualTagAttributePairs(actual, expected) {
  let logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createLogger();

  // Attributes is tokenized as tuples. Their lengths should match. This also
  // avoids us needing to check both attributes sets, since if A has any keys
  // which do not exist in B, we know the sets to be different.
  if (actual.length !== expected.length) {
    logger.warning('Expected attributes %o, instead saw %o.', expected, actual);
    return false;
  } // Attributes are not guaranteed to occur in the same order. For validating
  // actual attributes, first convert the set of expected attribute values to
  // an object, for lookup by key.


  const expectedAttributes = {};

  for (let i = 0; i < expected.length; i++) {
    expectedAttributes[expected[i][0].toLowerCase()] = expected[i][1];
  }

  for (let i = 0; i < actual.length; i++) {
    const [name, actualValue] = actual[i];
    const nameLower = name.toLowerCase(); // As noted above, if missing member in B, assume different.

    if (!expectedAttributes.hasOwnProperty(nameLower)) {
      logger.warning('Encountered unexpected attribute `%s`.', name);
      return false;
    }

    const expectedValue = expectedAttributes[nameLower];
    const isEqualAttributes = isEqualAttributesOfName[nameLower];

    if (isEqualAttributes) {
      // Defer custom attribute equality handling.
      if (!isEqualAttributes(actualValue, expectedValue)) {
        logger.warning('Expected attribute `%s` of value `%s`, saw `%s`.', name, expectedValue, actualValue);
        return false;
      }
    } else if (actualValue !== expectedValue) {
      // Otherwise strict inequality should bail.
      logger.warning('Expected attribute `%s` of value `%s`, saw `%s`.', name, expectedValue, actualValue);
      return false;
    }
  }

  return true;
}
/**
 * Token-type-specific equality handlers
 *
 * @type {Object}
 */

const isEqualTokensOfType = {
  StartTag: function (actual, expected) {
    let logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createLogger();

    if (actual.tagName !== expected.tagName && // Optimization: Use short-circuit evaluation to defer case-
    // insensitive check on the assumption that the majority case will
    // have exactly equal tag names.
    actual.tagName.toLowerCase() !== expected.tagName.toLowerCase()) {
      logger.warning('Expected tag name `%s`, instead saw `%s`.', expected.tagName, actual.tagName);
      return false;
    }

    return isEqualTagAttributePairs(...[actual, expected].map(getMeaningfulAttributePairs), logger);
  },
  Chars: isEquivalentTextTokens,
  Comment: isEquivalentTextTokens
};
/**
 * Given an array of tokens, returns the first token which is not purely
 * whitespace.
 *
 * Mutates the tokens array.
 *
 * @param {Object[]} tokens Set of tokens to search.
 *
 * @return {Object} Next non-whitespace token.
 */

function getNextNonWhitespaceToken(tokens) {
  let token;

  while (token = tokens.shift()) {
    if (token.type !== 'Chars') {
      return token;
    }

    if (!REGEXP_ONLY_WHITESPACE.test(token.chars)) {
      return token;
    }
  }
}
/**
 * Tokenize an HTML string, gracefully handling any errors thrown during
 * underlying tokenization.
 *
 * @param {string} html   HTML string to tokenize.
 * @param {Object} logger Validation logger object.
 *
 * @return {Object[]|null} Array of valid tokenized HTML elements, or null on error
 */

function getHTMLTokens(html) {
  let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createLogger();

  try {
    return new Tokenizer(new DecodeEntityParser()).tokenize(html);
  } catch (e) {
    logger.warning('Malformed HTML detected: %s', html);
  }

  return null;
}
/**
 * Returns true if the next HTML token closes the current token.
 *
 * @param {Object}           currentToken Current token to compare with.
 * @param {Object|undefined} nextToken    Next token to compare against.
 *
 * @return {boolean} true if `nextToken` closes `currentToken`, false otherwise
 */


function isClosedByToken(currentToken, nextToken) {
  // Ensure this is a self closed token.
  if (!currentToken.selfClosing) {
    return false;
  } // Check token names and determine if nextToken is the closing tag for currentToken.


  if (nextToken && nextToken.tagName === currentToken.tagName && nextToken.type === 'EndTag') {
    return true;
  }

  return false;
}
/**
 * Returns true if the given HTML strings are effectively equivalent, or
 * false otherwise. Invalid HTML is not considered equivalent, even if the
 * strings directly match.
 *
 * @param {string} actual   Actual HTML string.
 * @param {string} expected Expected HTML string.
 * @param {Object} logger   Validation logger object.
 *
 * @return {boolean} Whether HTML strings are equivalent.
 */

function isEquivalentHTML(actual, expected) {
  let logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createLogger();

  // Short-circuit if markup is identical.
  if (actual === expected) {
    return true;
  } // Tokenize input content and reserialized save content.


  const [actualTokens, expectedTokens] = [actual, expected].map(html => getHTMLTokens(html, logger)); // If either is malformed then stop comparing - the strings are not equivalent.

  if (!actualTokens || !expectedTokens) {
    return false;
  }

  let actualToken, expectedToken;

  while (actualToken = getNextNonWhitespaceToken(actualTokens)) {
    expectedToken = getNextNonWhitespaceToken(expectedTokens); // Inequal if exhausted all expected tokens.

    if (!expectedToken) {
      logger.warning('Expected end of content, instead saw %o.', actualToken);
      return false;
    } // Inequal if next non-whitespace token of each set are not same type.


    if (actualToken.type !== expectedToken.type) {
      logger.warning('Expected token of type `%s` (%o), instead saw `%s` (%o).', expectedToken.type, expectedToken, actualToken.type, actualToken);
      return false;
    } // Defer custom token type equality handling, otherwise continue and
    // assume as equal.


    const isEqualTokens = isEqualTokensOfType[actualToken.type];

    if (isEqualTokens && !isEqualTokens(actualToken, expectedToken, logger)) {
      return false;
    } // Peek at the next tokens (actual and expected) to see if they close
    // a self-closing tag.


    if (isClosedByToken(actualToken, expectedTokens[0])) {
      // Consume the next expected token that closes the current actual
      // self-closing token.
      getNextNonWhitespaceToken(expectedTokens);
    } else if (isClosedByToken(expectedToken, actualTokens[0])) {
      // Consume the next actual token that closes the current expected
      // self-closing token.
      getNextNonWhitespaceToken(actualTokens);
    }
  }

  if (expectedToken = getNextNonWhitespaceToken(expectedTokens)) {
    // If any non-whitespace tokens remain in expected token set, this
    // indicates inequality.
    logger.warning('Expected %o, instead saw end of content.', expectedToken);
    return false;
  }

  return true;
}
/**
 * Returns an object with `isValid` property set to `true` if the parsed block
 * is valid given the input content. A block is considered valid if, when serialized
 * with assumed attributes, the content matches the original value. If block is
 * invalid, this function returns all validations issues as well.
 *
 * @param {string|Object} blockTypeOrName      Block type.
 * @param {Object}        attributes           Parsed block attributes.
 * @param {string}        originalBlockContent Original block content.
 * @param {Object}        logger               Validation logger object.
 *
 * @return {Object} Whether block is valid and contains validation messages.
 */

/**
 * Returns an object with `isValid` property set to `true` if the parsed block
 * is valid given the input content. A block is considered valid if, when serialized
 * with assumed attributes, the content matches the original value. If block is
 * invalid, this function returns all validations issues as well.
 *
 * @param {WPBlock}            block                          block object.
 * @param {WPBlockType|string} [blockTypeOrName = block.name] Block type or name, inferred from block if not given.
 *
 * @return {[boolean,Array<LoggerItem>]} validation results.
 */

function validateBlock(block) {
  let blockTypeOrName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : block.name;
  const isFallbackBlock = block.name === registration_getFreeformContentHandlerName() || block.name === getUnregisteredTypeHandlerName(); // Shortcut to avoid costly validation.

  if (isFallbackBlock) {
    return [true, []];
  }

  const logger = createQueuedLogger();
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  let generatedBlockContent;

  try {
    generatedBlockContent = getSaveContent(blockType, block.attributes);
  } catch (error) {
    logger.error('Block validation failed because an error occurred while generating block content:\n\n%s', error.toString());
    return [false, logger.getItems()];
  }

  const isValid = isEquivalentHTML(block.originalContent, generatedBlockContent, logger);

  if (!isValid) {
    logger.error('Block validation failed for `%s` (%o).\n\nContent generated by `save` function:\n\n%s\n\nContent retrieved from post body:\n\n%s', blockType.name, blockType, generatedBlockContent, block.originalContent);
  }

  return [isValid, logger.getItems()];
}
/**
 * Returns true if the parsed block is valid given the input content. A block
 * is considered valid if, when serialized with assumed attributes, the content
 * matches the original value.
 *
 * Logs to console in development environments when invalid.
 *
 * @deprecated Use validateBlock instead to avoid data loss.
 *
 * @param {string|Object} blockTypeOrName      Block type.
 * @param {Object}        attributes           Parsed block attributes.
 * @param {string}        originalBlockContent Original block content.
 *
 * @return {boolean} Whether block is valid.
 */

function isValidBlockContent(blockTypeOrName, attributes, originalBlockContent) {
  deprecated('isValidBlockContent introduces opportunity for data loss', {
    since: '12.6',
    plugin: 'Gutenberg',
    alternative: 'validateBlock'
  });
  const blockType = normalizeBlockType(blockTypeOrName);
  const block = {
    name: blockType.name,
    attributes,
    innerBlocks: [],
    originalContent: originalBlockContent
  };
  const [isValid] = validateBlock(block, blockType);
  return isValid;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/convert-legacy-block.js
/**
 * Convert legacy blocks to their canonical form. This function is used
 * both in the parser level for previous content and to convert such blocks
 * used in Custom Post Types templates.
 *
 * @param {string} name       The block's name
 * @param {Object} attributes The block's attributes
 *
 * @return {[string, Object]} The block's name and attributes, changed accordingly if a match was found
 */
function convertLegacyBlockNameAndAttributes(name, attributes) {
  const newAttributes = { ...attributes
  }; // Convert 'core/cover-image' block in existing content to 'core/cover'.

  if ('core/cover-image' === name) {
    name = 'core/cover';
  } // Convert 'core/text' blocks in existing content to 'core/paragraph'.


  if ('core/text' === name || 'core/cover-text' === name) {
    name = 'core/paragraph';
  } // Convert derivative blocks such as 'core/social-link-wordpress' to the
  // canonical form 'core/social-link'.


  if (name && name.indexOf('core/social-link-') === 0) {
    // Capture `social-link-wordpress` into `{"service":"wordpress"}`
    newAttributes.service = name.substring(17);
    name = 'core/social-link';
  } // Convert derivative blocks such as 'core-embed/instagram' to the
  // canonical form 'core/embed'.


  if (name && name.indexOf('core-embed/') === 0) {
    // Capture `core-embed/instagram` into `{"providerNameSlug":"instagram"}`
    const providerSlug = name.substring(11);
    const deprecated = {
      speaker: 'speaker-deck',
      polldaddy: 'crowdsignal'
    };
    newAttributes.providerNameSlug = providerSlug in deprecated ? deprecated[providerSlug] : providerSlug; // This is needed as the `responsive` attribute was passed
    // in a different way before the refactoring to block variations.

    if (!['amazon-kindle', 'wordpress'].includes(providerSlug)) {
      newAttributes.responsive = true;
    }

    name = 'core/embed';
  } // Convert Post Comment blocks in existing content to Comment blocks.
  // TODO: Remove these checks when WordPress 6.0 is released.


  if (name === 'core/post-comment-author') {
    name = 'core/comment-author-name';
  }

  if (name === 'core/post-comment-content') {
    name = 'core/comment-content';
  }

  if (name === 'core/post-comment-date') {
    name = 'core/comment-date';
  }

  if (name === 'core/comments-query-loop') {
    name = 'core/comments';
    const {
      className = ''
    } = newAttributes;

    if (!className.includes('wp-block-comments-query-loop')) {
      newAttributes.className = ['wp-block-comments-query-loop', className].join(' ');
    } // Note that we also had to add a deprecation to the block in order
    // for the ID change to work.

  }

  if (name === 'core/post-comments') {
    name = 'core/comments';
    newAttributes.legacy = true;
  }

  return [name, newAttributes];
}
//# sourceMappingURL=convert-legacy-block.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/hpq@1.4.0/node_modules/hpq/es/get-path.js
/**
 * Given object and string of dot-delimited path segments, returns value at
 * path or undefined if path cannot be resolved.
 *
 * @param object Lookup object
 * @param path   Path to resolve
 * @return       Resolved value
 */
function getPath(object, path) {
  var segments = path.split('.');
  var segment;
  while (segment = segments.shift()) {
    if (!(segment in object)) {
      return;
    }
    object = object[segment];
  }
  return object;
}
;// CONCATENATED MODULE: ../../node_modules/.pnpm/hpq@1.4.0/node_modules/hpq/es/index.js
/**
 * Internal dependencies
 */

/**
 * Function returning a DOM document created by `createHTMLDocument`. The same
 * document is returned between invocations.
 *
 * @return DOM document.
 */
var getDocument = function () {
  var doc;
  return function () {
    if (!doc) {
      doc = document.implementation.createHTMLDocument('');
    }
    return doc;
  };
}();

/**
 * Given a markup string or DOM element, creates an object aligning with the
 * shape of the matchers object, or the value returned by the matcher.
 *
 * @param source Source content
 * @param matchers Matcher function or object of matchers
 */

/**
 * Given a markup string or DOM element, creates an object aligning with the
 * shape of the matchers object, or the value returned by the matcher.
 *
 * @param source Source content
 * @param matchers Matcher function or object of matchers
 */
function es_parse(source, matchers) {
  if (!matchers) {
    return;
  }

  // Coerce to element
  if ('string' === typeof source) {
    var doc = getDocument();
    doc.body.innerHTML = source;
    source = doc.body;
  }

  // Return singular value
  if (typeof matchers === 'function') {
    return matchers(source);
  }

  // Bail if we can't handle matchers
  if (Object !== matchers.constructor) {
    return;
  }

  // Shape result by matcher object
  return Object.keys(matchers).reduce(function (memo, key) {
    var inner = matchers[key];
    memo[key] = es_parse(source, inner);
    return memo;
  }, {});
}

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by property if the attribute exists. If no selector is passed,
 * returns property of the query element.
 *
 * @param name Property name
 * @return Property value
 */

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by property if the attribute exists. If no selector is passed,
 * returns property of the query element.
 *
 * @param selector Optional selector
 * @param name Property name
 * @return Property value
 */
function prop(arg1, arg2) {
  var name;
  var selector;
  if (1 === arguments.length) {
    name = arg1;
    selector = undefined;
  } else {
    name = arg2;
    selector = arg1;
  }
  return function (node) {
    var match = node;
    if (selector) {
      match = node.querySelector(selector);
    }
    if (match) {
      return getPath(match, name);
    }
  };
}

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by name if the attribute exists. If no selector is passed,
 * returns attribute of the query element.
 *
 * @param name Attribute name
 * @return Attribute value
 */

/**
 * Generates a function which matches node of type selector, returning an
 * attribute by name if the attribute exists. If no selector is passed,
 * returns attribute of the query element.
 *
 * @param selector Optional selector
 * @param name Attribute name
 * @return Attribute value
 */
function attr(arg1, arg2) {
  var name;
  var selector;
  if (1 === arguments.length) {
    name = arg1;
    selector = undefined;
  } else {
    name = arg2;
    selector = arg1;
  }
  return function (node) {
    var attributes = prop(selector, 'attributes')(node);
    if (attributes && Object.prototype.hasOwnProperty.call(attributes, name)) {
      return attributes[name].value;
    }
  };
}

/**
 * Convenience for `prop( selector, 'innerHTML' )`.
 *
 * @see prop()
 *
 * @param selector Optional selector
 * @return Inner HTML
 */
function html(selector) {
  return prop(selector, 'innerHTML');
}

/**
 * Convenience for `prop( selector, 'textContent' )`.
 *
 * @see prop()
 *
 * @param selector Optional selector
 * @return Text content
 */
function es_text(selector) {
  return prop(selector, 'textContent');
}

/**
 * Creates a new matching context by first finding elements matching selector
 * using querySelectorAll before then running another `parse` on `matchers`
 * scoped to the matched elements.
 *
 * @see parse()
 *
 * @param selector Selector to match
 * @param matchers Matcher function or object of matchers
 * @return Matcher function which returns an array of matched value(s)
 */
function query(selector, matchers) {
  return function (node) {
    var matches = node.querySelectorAll(selector);
    return [].map.call(matches, function (match) {
      return es_parse(match, matchers);
    });
  };
}
// EXTERNAL MODULE: ../../node_modules/.pnpm/memize@1.1.0/node_modules/memize/index.js
var memize = __webpack_require__("../../node_modules/.pnpm/memize@1.1.0/node_modules/memize/index.js");
var memize_default = /*#__PURE__*/__webpack_require__.n(memize);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/matchers.js
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function matchers_html(selector, multilineTag) {
  return domNode => {
    let match = domNode;

    if (selector) {
      match = domNode.querySelector(selector);
    }

    if (!match) {
      return '';
    }

    if (multilineTag) {
      let value = '';
      const length = match.children.length;

      for (let index = 0; index < length; index++) {
        const child = match.children[index];

        if (child.nodeName.toLowerCase() !== multilineTag) {
          continue;
        }

        value += child.outerHTML;
      }

      return value;
    }

    return match.innerHTML;
  };
}
//# sourceMappingURL=matchers.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/node.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * A representation of a single node within a block's rich text value. If
 * representing a text node, the value is simply a string of the node value.
 * As representing an element node, it is an object of:
 *
 * 1. `type` (string): Tag name.
 * 2. `props` (object): Attributes and children array of WPBlockNode.
 *
 * @typedef {string|Object} WPBlockNode
 */

/**
 * Given a single node and a node type (e.g. `'br'`), returns true if the node
 * corresponds to that type, false otherwise.
 *
 * @param {WPBlockNode} node Block node to test
 * @param {string}      type Node to type to test against.
 *
 * @return {boolean} Whether node is of intended type.
 */

function isNodeOfType(node, type) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.isNodeOfType', {
    since: '6.1',
    version: '6.3',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return node && node.type === type;
}
/**
 * Given an object implementing the NamedNodeMap interface, returns a plain
 * object equivalent value of name, value key-value pairs.
 *
 * @see https://dom.spec.whatwg.org/#interface-namednodemap
 *
 * @param {NamedNodeMap} nodeMap NamedNodeMap to convert to object.
 *
 * @return {Object} Object equivalent value of NamedNodeMap.
 */


function getNamedNodeMapAsObject(nodeMap) {
  const result = {};

  for (let i = 0; i < nodeMap.length; i++) {
    const {
      name,
      value
    } = nodeMap[i];
    result[name] = value;
  }

  return result;
}
/**
 * Given a DOM Element or Text node, returns an equivalent block node. Throws
 * if passed any node type other than element or text.
 *
 * @throws {TypeError} If non-element/text node is passed.
 *
 * @param {Node} domNode DOM node to convert.
 *
 * @return {WPBlockNode} Block node equivalent to DOM node.
 */

function fromDOM(domNode) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.fromDOM', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.create',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });

  if (domNode.nodeType === domNode.TEXT_NODE) {
    return domNode.nodeValue;
  }

  if (domNode.nodeType !== domNode.ELEMENT_NODE) {
    throw new TypeError('A block node can only be created from a node of type text or ' + 'element.');
  }

  return {
    type: domNode.nodeName.toLowerCase(),
    props: { ...getNamedNodeMapAsObject(domNode.attributes),
      children: children_fromDOM(domNode.childNodes)
    }
  };
}
/**
 * Given a block node, returns its HTML string representation.
 *
 * @param {WPBlockNode} node Block node to convert to string.
 *
 * @return {string} String HTML representation of block node.
 */

function toHTML(node) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.toHTML', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.toHTMLString',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return children_toHTML([node]);
}
/**
 * Given a selector, returns an hpq matcher generating a WPBlockNode value
 * matching the selector result.
 *
 * @param {string} selector DOM selector.
 *
 * @return {Function} hpq matcher.
 */

function node_matcher(selector) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.node.matcher', {
    since: '6.1',
    version: '6.3',
    alternative: 'html source',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return domNode => {
    let match = domNode;

    if (selector) {
      match = domNode.querySelector(selector);
    }

    try {
      return fromDOM(match);
    } catch (error) {
      return null;
    }
  };
}
/**
 * Object of utility functions used in managing block attribute values of
 * source `node`.
 *
 * @see https://github.com/WordPress/gutenberg/pull/10439
 *
 * @deprecated since 4.0. The `node` source should not be used, and can be
 *             replaced by the `html` source.
 *
 * @private
 */

/* harmony default export */ const node = ({
  isNodeOfType,
  fromDOM,
  toHTML,
  matcher: node_matcher
});
//# sourceMappingURL=node.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/children.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * A representation of a block's rich text value.
 *
 * @typedef {WPBlockNode[]} WPBlockChildren
 */

/**
 * Given block children, returns a serialize-capable WordPress element.
 *
 * @param {WPBlockChildren} children Block children object to convert.
 *
 * @return {WPElement} A serialize-capable element.
 */

function getSerializeCapableElement(children) {
  // The fact that block children are compatible with the element serializer is
  // merely an implementation detail that currently serves to be true, but
  // should not be mistaken as being a guarantee on the external API. The
  // public API only offers guarantees to work with strings (toHTML) and DOM
  // elements (fromDOM), and should provide utilities to manipulate the value
  // rather than expect consumers to inspect or construct its shape (concat).
  return children;
}
/**
 * Given block children, returns an array of block nodes.
 *
 * @param {WPBlockChildren} children Block children object to convert.
 *
 * @return {Array<WPBlockNode>} An array of individual block nodes.
 */

function getChildrenArray(children) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.getChildrenArray', {
    since: '6.1',
    version: '6.3',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  }); // The fact that block children are compatible with the element serializer
  // is merely an implementation detail that currently serves to be true, but
  // should not be mistaken as being a guarantee on the external API.

  return children;
}
/**
 * Given two or more block nodes, returns a new block node representing a
 * concatenation of its values.
 *
 * @param {...WPBlockChildren} blockNodes Block nodes to concatenate.
 *
 * @return {WPBlockChildren} Concatenated block node.
 */


function concat() {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.concat', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.concat',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  const result = [];

  for (var _len = arguments.length, blockNodes = new Array(_len), _key = 0; _key < _len; _key++) {
    blockNodes[_key] = arguments[_key];
  }

  for (let i = 0; i < blockNodes.length; i++) {
    const blockNode = Array.isArray(blockNodes[i]) ? blockNodes[i] : [blockNodes[i]];

    for (let j = 0; j < blockNode.length; j++) {
      const child = blockNode[j];
      const canConcatToPreviousString = typeof child === 'string' && typeof result[result.length - 1] === 'string';

      if (canConcatToPreviousString) {
        result[result.length - 1] += child;
      } else {
        result.push(child);
      }
    }
  }

  return result;
}
/**
 * Given an iterable set of DOM nodes, returns equivalent block children.
 * Ignores any non-element/text nodes included in set.
 *
 * @param {Iterable.<Node>} domNodes Iterable set of DOM nodes to convert.
 *
 * @return {WPBlockChildren} Block children equivalent to DOM nodes.
 */

function children_fromDOM(domNodes) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.fromDOM', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.create',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  const result = [];

  for (let i = 0; i < domNodes.length; i++) {
    try {
      result.push(fromDOM(domNodes[i]));
    } catch (error) {// Simply ignore if DOM node could not be converted.
    }
  }

  return result;
}
/**
 * Given a block node, returns its HTML string representation.
 *
 * @param {WPBlockChildren} children Block node(s) to convert to string.
 *
 * @return {string} String HTML representation of block node.
 */

function children_toHTML(children) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.toHTML', {
    since: '6.1',
    version: '6.3',
    alternative: 'wp.richText.toHTMLString',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  const element = getSerializeCapableElement(children);
  return (0,serialize/* default */.Ay)(element);
}
/**
 * Given a selector, returns an hpq matcher generating a WPBlockChildren value
 * matching the selector result.
 *
 * @param {string} selector DOM selector.
 *
 * @return {Function} hpq matcher.
 */

function children_matcher(selector) {
  (0,deprecated_build_module/* default */.A)('wp.blocks.children.matcher', {
    since: '6.1',
    version: '6.3',
    alternative: 'html source',
    link: 'https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/'
  });
  return domNode => {
    let match = domNode;

    if (selector) {
      match = domNode.querySelector(selector);
    }

    if (match) {
      return children_fromDOM(match.childNodes);
    }

    return [];
  };
}
/**
 * Object of utility functions used in managing block attribute values of
 * source `children`.
 *
 * @see https://github.com/WordPress/gutenberg/pull/10439
 *
 * @deprecated since 4.0. The `children` source should not be used, and can be
 *             replaced by the `html` source.
 *
 * @private
 */

/* harmony default export */ const children = ({
  concat,
  getChildrenArray,
  fromDOM: children_fromDOM,
  toHTML: children_toHTML,
  matcher: children_matcher
});
//# sourceMappingURL=children.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/get-block-attributes.js
/**
 * External dependencies
 */



/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Higher-order hpq matcher which enhances an attribute matcher to return true
 * or false depending on whether the original matcher returns undefined. This
 * is useful for boolean attributes (e.g. disabled) whose attribute values may
 * be technically falsey (empty string), though their mere presence should be
 * enough to infer as true.
 *
 * @param {Function} matcher Original hpq matcher.
 *
 * @return {Function} Enhanced hpq matcher.
 */

const toBooleanAttributeMatcher = matcher => (0,pipe/* default */.h)([matcher, // Expected values from `attr( 'disabled' )`:
//
// <input>
// - Value:       `undefined`
// - Transformed: `false`
//
// <input disabled>
// - Value:       `''`
// - Transformed: `true`
//
// <input disabled="disabled">
// - Value:       `'disabled'`
// - Transformed: `true`
value => value !== undefined]);
/**
 * Returns true if value is of the given JSON schema type, or false otherwise.
 *
 * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
 *
 * @param {*}      value Value to test.
 * @param {string} type  Type to test.
 *
 * @return {boolean} Whether value is of type.
 */

function isOfType(value, type) {
  switch (type) {
    case 'string':
      return typeof value === 'string';

    case 'boolean':
      return typeof value === 'boolean';

    case 'object':
      return !!value && value.constructor === Object;

    case 'null':
      return value === null;

    case 'array':
      return Array.isArray(value);

    case 'integer':
    case 'number':
      return typeof value === 'number';
  }

  return true;
}
/**
 * Returns true if value is of an array of given JSON schema types, or false
 * otherwise.
 *
 * @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
 *
 * @param {*}        value Value to test.
 * @param {string[]} types Types to test.
 *
 * @return {boolean} Whether value is of types.
 */

function isOfTypes(value, types) {
  return types.some(type => isOfType(value, type));
}
/**
 * Given an attribute key, an attribute's schema, a block's raw content and the
 * commentAttributes returns the attribute value depending on its source
 * definition of the given attribute key.
 *
 * @param {string}      attributeKey      Attribute key.
 * @param {Object}      attributeSchema   Attribute's schema.
 * @param {string|Node} innerHTML         Block's raw content.
 * @param {Object}      commentAttributes Block's comment attributes.
 *
 * @return {*} Attribute value.
 */

function getBlockAttribute(attributeKey, attributeSchema, innerHTML, commentAttributes) {
  let value;

  switch (attributeSchema.source) {
    // An undefined source means that it's an attribute serialized to the
    // block's "comment".
    case undefined:
      value = commentAttributes ? commentAttributes[attributeKey] : undefined;
      break;

    case 'attribute':
    case 'property':
    case 'html':
    case 'text':
    case 'children':
    case 'node':
    case 'query':
    case 'tag':
      value = parseWithAttributeSchema(innerHTML, attributeSchema);
      break;
  }

  if (!isValidByType(value, attributeSchema.type) || !isValidByEnum(value, attributeSchema.enum)) {
    // Reject the value if it is not valid. Reverting to the undefined
    // value ensures the default is respected, if applicable.
    value = undefined;
  }

  if (value === undefined) {
    value = attributeSchema.default;
  }

  return value;
}
/**
 * Returns true if value is valid per the given block attribute schema type
 * definition, or false otherwise.
 *
 * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.1
 *
 * @param {*}                       value Value to test.
 * @param {?(Array<string>|string)} type  Block attribute schema type.
 *
 * @return {boolean} Whether value is valid.
 */

function isValidByType(value, type) {
  return type === undefined || isOfTypes(value, Array.isArray(type) ? type : [type]);
}
/**
 * Returns true if value is valid per the given block attribute schema enum
 * definition, or false otherwise.
 *
 * @see https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.2
 *
 * @param {*}      value   Value to test.
 * @param {?Array} enumSet Block attribute schema enum.
 *
 * @return {boolean} Whether value is valid.
 */

function isValidByEnum(value, enumSet) {
  return !Array.isArray(enumSet) || enumSet.includes(value);
}
/**
 * Returns an hpq matcher given a source object.
 *
 * @param {Object} sourceConfig Attribute Source object.
 *
 * @return {Function} A hpq Matcher.
 */

const matcherFromSource = memize_default()(sourceConfig => {
  switch (sourceConfig.source) {
    case 'attribute':
      let matcher = attr(sourceConfig.selector, sourceConfig.attribute);

      if (sourceConfig.type === 'boolean') {
        matcher = toBooleanAttributeMatcher(matcher);
      }

      return matcher;

    case 'html':
      return matchers_html(sourceConfig.selector, sourceConfig.multiline);

    case 'text':
      return es_text(sourceConfig.selector);

    case 'children':
      return children_matcher(sourceConfig.selector);

    case 'node':
      return node_matcher(sourceConfig.selector);

    case 'query':
      const subMatchers = (0,lodash.mapValues)(sourceConfig.query, matcherFromSource);
      return query(sourceConfig.selector, subMatchers);

    case 'tag':
      return (0,pipe/* default */.h)([prop(sourceConfig.selector, 'nodeName'), nodeName => nodeName ? nodeName.toLowerCase() : undefined]);

    default:
      // eslint-disable-next-line no-console
      console.error(`Unknown source type "${sourceConfig.source}"`);
  }
});
/**
 * Parse a HTML string into DOM tree.
 *
 * @param {string|Node} innerHTML HTML string or already parsed DOM node.
 *
 * @return {Node} Parsed DOM node.
 */

function parseHtml(innerHTML) {
  return es_parse(innerHTML, h => h);
}
/**
 * Given a block's raw content and an attribute's schema returns the attribute's
 * value depending on its source.
 *
 * @param {string|Node} innerHTML       Block's raw content.
 * @param {Object}      attributeSchema Attribute's schema.
 *
 * @return {*} Attribute value.
 */


function parseWithAttributeSchema(innerHTML, attributeSchema) {
  return matcherFromSource(attributeSchema)(parseHtml(innerHTML));
}
/**
 * Returns the block attributes of a registered block node given its type.
 *
 * @param {string|Object} blockTypeOrName Block type or name.
 * @param {string|Node}   innerHTML       Raw block content.
 * @param {?Object}       attributes      Known block attributes (from delimiters).
 *
 * @return {Object} All block attributes.
 */

function getBlockAttributes(blockTypeOrName, innerHTML) {
  let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const doc = parseHtml(innerHTML);
  const blockType = utils_normalizeBlockType(blockTypeOrName);
  const blockAttributes = (0,lodash.mapValues)(blockType.attributes, (schema, key) => getBlockAttribute(key, schema, doc, attributes));
  return (0,hooks_build_module/* applyFilters */.W5)('blocks.getBlockAttributes', blockAttributes, blockType, innerHTML, attributes);
}
//# sourceMappingURL=get-block-attributes.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/fix-custom-classname.js
/**
 * Internal dependencies
 */



const CLASS_ATTR_SCHEMA = {
  type: 'string',
  source: 'attribute',
  selector: '[data-custom-class-name] > *',
  attribute: 'class'
};
/**
 * Given an HTML string, returns an array of class names assigned to the root
 * element in the markup.
 *
 * @param {string} innerHTML Markup string from which to extract classes.
 *
 * @return {string[]} Array of class names assigned to the root element.
 */

function getHTMLRootElementClasses(innerHTML) {
  const parsed = parseWithAttributeSchema(`<div data-custom-class-name>${innerHTML}</div>`, CLASS_ATTR_SCHEMA);
  return parsed ? parsed.trim().split(/\s+/) : [];
}
/**
 * Given a parsed set of block attributes, if the block supports custom class
 * names and an unknown class (per the block's serialization behavior) is
 * found, the unknown classes are treated as custom classes. This prevents the
 * block from being considered as invalid.
 *
 * @param {Object} blockAttributes Original block attributes.
 * @param {Object} blockType       Block type settings.
 * @param {string} innerHTML       Original block markup.
 *
 * @return {Object} Filtered block attributes.
 */

function fixCustomClassname(blockAttributes, blockType, innerHTML) {
  if (hasBlockSupport(blockType, 'customClassName', true)) {
    // To determine difference, serialize block given the known set of
    // attributes, with the exception of `className`. This will determine
    // the default set of classes. From there, any difference in innerHTML
    // can be considered as custom classes.
    const {
      className: omittedClassName,
      ...attributesSansClassName
    } = blockAttributes;
    const serialized = getSaveContent(blockType, attributesSansClassName);
    const defaultClasses = getHTMLRootElementClasses(serialized);
    const actualClasses = getHTMLRootElementClasses(innerHTML);
    const customClasses = actualClasses.filter(className => !defaultClasses.includes(className));

    if (customClasses.length) {
      blockAttributes.className = customClasses.join(' ');
    } else if (serialized) {
      delete blockAttributes.className;
    }
  }

  return blockAttributes;
}
//# sourceMappingURL=fix-custom-classname.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/apply-built-in-validation-fixes.js
/**
 * Internal dependencies
 */

/**
 * Attempts to fix block invalidation by applying build-in validation fixes
 * like moving all extra classNames to the className attribute.
 *
 * @param {WPBlock}                               block     block object.
 * @param {import('../registration').WPBlockType} blockType Block type. This is normalize not necessary and
 *                                                          can be inferred from the block name,
 *                                                          but it's here for performance reasons.
 *
 * @return {WPBlock} Fixed block object
 */

function applyBuiltInValidationFixes(block, blockType) {
  const updatedBlockAttributes = fixCustomClassname(block.attributes, blockType, block.originalContent);
  return { ...block,
    attributes: updatedBlockAttributes
  };
}
//# sourceMappingURL=apply-built-in-validation-fixes.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/apply-block-deprecated-versions.js
/**
 * Internal dependencies
 */





/**
 * Function that takes no arguments and always returns false.
 *
 * @return {boolean} Always returns false.
 */

function stubFalse() {
  return false;
}
/**
 * Given a block object, returns a new copy of the block with any applicable
 * deprecated migrations applied, or the original block if it was both valid
 * and no eligible migrations exist.
 *
 * @param {import(".").WPBlock}                   block     Parsed and invalid block object.
 * @param {import(".").WPRawBlock}                rawBlock  Raw block object.
 * @param {import('../registration').WPBlockType} blockType Block type. This is normalize not necessary and
 *                                                          can be inferred from the block name,
 *                                                          but it's here for performance reasons.
 *
 * @return {import(".").WPBlock} Migrated block object.
 */


function applyBlockDeprecatedVersions(block, rawBlock, blockType) {
  const parsedAttributes = rawBlock.attrs;
  const {
    deprecated: deprecatedDefinitions
  } = blockType; // Bail early if there are no registered deprecations to be handled.

  if (!deprecatedDefinitions || !deprecatedDefinitions.length) {
    return block;
  } // By design, blocks lack any sort of version tracking. Instead, to process
  // outdated content the system operates a queue out of all the defined
  // attribute shapes and tries each definition until the input produces a
  // valid result. This mechanism seeks to avoid polluting the user-space with
  // machine-specific code. An invalid block is thus a block that could not be
  // matched successfully with any of the registered deprecation definitions.


  for (let i = 0; i < deprecatedDefinitions.length; i++) {
    // A block can opt into a migration even if the block is valid by
    // defining `isEligible` on its deprecation. If the block is both valid
    // and does not opt to migrate, skip.
    const {
      isEligible = stubFalse
    } = deprecatedDefinitions[i];

    if (block.isValid && !isEligible(parsedAttributes, block.innerBlocks)) {
      continue;
    } // Block type properties which could impact either serialization or
    // parsing are not considered in the deprecated block type by default,
    // and must be explicitly provided.


    const deprecatedBlockType = Object.assign(omit(blockType, DEPRECATED_ENTRY_KEYS), deprecatedDefinitions[i]);
    let migratedBlock = { ...block,
      attributes: getBlockAttributes(deprecatedBlockType, block.originalContent, parsedAttributes)
    }; // Ignore the deprecation if it produces a block which is not valid.

    let [isValid] = validateBlock(migratedBlock, deprecatedBlockType); // If the migrated block is not valid initially, try the built-in fixes.

    if (!isValid) {
      migratedBlock = applyBuiltInValidationFixes(migratedBlock, deprecatedBlockType);
      [isValid] = validateBlock(migratedBlock, deprecatedBlockType);
    } // An invalid block does not imply incorrect HTML but the fact block
    // source information could be lost on re-serialization.


    if (!isValid) {
      continue;
    }

    let migratedInnerBlocks = migratedBlock.innerBlocks;
    let migratedAttributes = migratedBlock.attributes; // A block may provide custom behavior to assign new attributes and/or
    // inner blocks.

    const {
      migrate
    } = deprecatedBlockType;

    if (migrate) {
      let migrated = migrate(migratedAttributes, block.innerBlocks);

      if (!Array.isArray(migrated)) {
        migrated = [migrated];
      }

      [migratedAttributes = parsedAttributes, migratedInnerBlocks = block.innerBlocks] = migrated;
    }

    block = { ...block,
      attributes: migratedAttributes,
      innerBlocks: migratedInnerBlocks,
      isValid: true,
      validationIssues: []
    };
  }

  return block;
}
//# sourceMappingURL=apply-block-deprecated-versions.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/parser/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */










/**
 * The raw structure of a block includes its attributes, inner
 * blocks, and inner HTML. It is important to distinguish inner blocks from
 * the HTML content of the block as only the latter is relevant for block
 * validation and edit operations.
 *
 * @typedef WPRawBlock
 *
 * @property {string=}         blockName    Block name
 * @property {Object=}         attrs        Block raw or comment attributes.
 * @property {string}          innerHTML    HTML content of the block.
 * @property {(string|null)[]} innerContent Content without inner blocks.
 * @property {WPRawBlock[]}    innerBlocks  Inner Blocks.
 */

/**
 * Fully parsed block object.
 *
 * @typedef WPBlock
 *
 * @property {string}     name                    Block name
 * @property {Object}     attributes              Block raw or comment attributes.
 * @property {WPBlock[]}  innerBlocks             Inner Blocks.
 * @property {string}     originalContent         Original content of the block before validation fixes.
 * @property {boolean}    isValid                 Whether the block is valid.
 * @property {Object[]}   validationIssues        Validation issues.
 * @property {WPRawBlock} [__unstableBlockSource] Un-processed original copy of block if created through parser.
 */

/**
 * @typedef  {Object}  ParseOptions
 * @property {boolean?} __unstableSkipMigrationLogs If a block is migrated from a deprecated version, skip logging the migration details.
 * @property {boolean?} __unstableSkipAutop         Whether to skip autop when processing freeform content.
 */

/**
 * Convert legacy blocks to their canonical form. This function is used
 * both in the parser level for previous content and to convert such blocks
 * used in Custom Post Types templates.
 *
 * @param {WPRawBlock} rawBlock
 *
 * @return {WPRawBlock} The block's name and attributes, changed accordingly if a match was found
 */

function convertLegacyBlocks(rawBlock) {
  const [correctName, correctedAttributes] = convertLegacyBlockNameAndAttributes(rawBlock.blockName, rawBlock.attrs);
  return { ...rawBlock,
    blockName: correctName,
    attrs: correctedAttributes
  };
}
/**
 * Normalize the raw block by applying the fallback block name if none given,
 * sanitize the parsed HTML...
 *
 * @param {WPRawBlock}    rawBlock The raw block object.
 * @param {ParseOptions?} options  Extra options for handling block parsing.
 *
 * @return {WPRawBlock} The normalized block object.
 */


function normalizeRawBlock(rawBlock, options) {
  const fallbackBlockName = registration_getFreeformContentHandlerName(); // If the grammar parsing don't produce any block name, use the freeform block.

  const rawBlockName = rawBlock.blockName || registration_getFreeformContentHandlerName();
  const rawAttributes = rawBlock.attrs || {};
  const rawInnerBlocks = rawBlock.innerBlocks || [];
  let rawInnerHTML = rawBlock.innerHTML.trim(); // Fallback content may be upgraded from classic content expecting implicit
  // automatic paragraphs, so preserve them. Assumes wpautop is idempotent,
  // meaning there are no negative consequences to repeated autop calls.

  if (rawBlockName === fallbackBlockName && !(options !== null && options !== void 0 && options.__unstableSkipAutop)) {
    rawInnerHTML = autop(rawInnerHTML).trim();
  }

  return { ...rawBlock,
    blockName: rawBlockName,
    attrs: rawAttributes,
    innerHTML: rawInnerHTML,
    innerBlocks: rawInnerBlocks
  };
}
/**
 * Uses the "unregistered blockType" to create a block object.
 *
 * @param {WPRawBlock} rawBlock block.
 *
 * @return {WPRawBlock} The unregistered block object.
 */

function createMissingBlockType(rawBlock) {
  const unregisteredFallbackBlock = getUnregisteredTypeHandlerName() || registration_getFreeformContentHandlerName(); // Preserve undelimited content for use by the unregistered type
  // handler. A block node's `innerHTML` isn't enough, as that field only
  // carries the block's own HTML and not its nested blocks.

  const originalUndelimitedContent = serializeRawBlock(rawBlock, {
    isCommentDelimited: false
  }); // Preserve full block content for use by the unregistered type
  // handler, block boundaries included.

  const originalContent = serializeRawBlock(rawBlock, {
    isCommentDelimited: true
  });
  return {
    blockName: unregisteredFallbackBlock,
    attrs: {
      originalName: rawBlock.blockName,
      originalContent,
      originalUndelimitedContent
    },
    innerHTML: rawBlock.blockName ? originalContent : rawBlock.innerHTML,
    innerBlocks: rawBlock.innerBlocks,
    innerContent: rawBlock.innerContent
  };
}
/**
 * Validates a block and wraps with validation meta.
 *
 * The name here is regrettable but `validateBlock` is already taken.
 *
 * @param {WPBlock}                               unvalidatedBlock
 * @param {import('../registration').WPBlockType} blockType
 * @return {WPBlock}                              validated block, with auto-fixes if initially invalid
 */


function applyBlockValidation(unvalidatedBlock, blockType) {
  // Attempt to validate the block.
  const [isValid] = validateBlock(unvalidatedBlock, blockType);

  if (isValid) {
    return { ...unvalidatedBlock,
      isValid,
      validationIssues: []
    };
  } // If the block is invalid, attempt some built-in fixes
  // like custom classNames handling.


  const fixedBlock = applyBuiltInValidationFixes(unvalidatedBlock, blockType); // Attempt to validate the block once again after the built-in fixes.

  const [isFixedValid, validationIssues] = validateBlock(unvalidatedBlock, blockType);
  return { ...fixedBlock,
    isValid: isFixedValid,
    validationIssues
  };
}
/**
 * Given a raw block returned by grammar parsing, returns a fully parsed block.
 *
 * @param {WPRawBlock}   rawBlock The raw block object.
 * @param {ParseOptions} options  Extra options for handling block parsing.
 *
 * @return {WPBlock} Fully parsed block.
 */


function parseRawBlock(rawBlock, options) {
  let normalizedBlock = normalizeRawBlock(rawBlock, options); // During the lifecycle of the project, we renamed some old blocks
  // and transformed others to new blocks. To avoid breaking existing content,
  // we added this function to properly parse the old content.

  normalizedBlock = convertLegacyBlocks(normalizedBlock); // Try finding the type for known block name.

  let blockType = getBlockType(normalizedBlock.blockName); // If not blockType is found for the specified name, fallback to the "unregistedBlockType".

  if (!blockType) {
    normalizedBlock = createMissingBlockType(normalizedBlock);
    blockType = getBlockType(normalizedBlock.blockName);
  } // If it's an empty freeform block or there's no blockType (no missing block handler)
  // Then, just ignore the block.
  // It might be a good idea to throw a warning here.
  // TODO: I'm unsure about the unregisteredFallbackBlock check,
  // it might ignore some dynamic unregistered third party blocks wrongly.


  const isFallbackBlock = normalizedBlock.blockName === registration_getFreeformContentHandlerName() || normalizedBlock.blockName === getUnregisteredTypeHandlerName();

  if (!blockType || !normalizedBlock.innerHTML && isFallbackBlock) {
    return;
  } // Parse inner blocks recursively.


  const parsedInnerBlocks = normalizedBlock.innerBlocks.map(innerBlock => parseRawBlock(innerBlock, options)) // See https://github.com/WordPress/gutenberg/pull/17164.
  .filter(innerBlock => !!innerBlock); // Get the fully parsed block.

  const parsedBlock = createBlock(normalizedBlock.blockName, getBlockAttributes(blockType, normalizedBlock.innerHTML, normalizedBlock.attrs), parsedInnerBlocks);
  parsedBlock.originalContent = normalizedBlock.innerHTML;
  const validatedBlock = applyBlockValidation(parsedBlock, blockType);
  const {
    validationIssues
  } = validatedBlock; // Run the block deprecation and migrations.
  // This is performed on both invalid and valid blocks because
  // migration using the `migrate` functions should run even
  // if the output is deemed valid.

  const updatedBlock = applyBlockDeprecatedVersions(validatedBlock, normalizedBlock, blockType);

  if (!updatedBlock.isValid) {
    // Preserve the original unprocessed version of the block
    // that we received (no fixes, no deprecations) so that
    // we can save it as close to exactly the same way as
    // we loaded it. This is important to avoid corruption
    // and data loss caused by block implementations trying
    // to process data that isn't fully recognized.
    updatedBlock.__unstableBlockSource = rawBlock;
  }

  if (!validatedBlock.isValid && updatedBlock.isValid && !(options !== null && options !== void 0 && options.__unstableSkipMigrationLogs)) {
    /* eslint-disable no-console */
    console.groupCollapsed('Updated Block: %s', blockType.name);
    console.info('Block successfully updated for `%s` (%o).\n\nNew content generated by `save` function:\n\n%s\n\nContent retrieved from post body:\n\n%s', blockType.name, blockType, getSaveContent(blockType, updatedBlock.attributes), updatedBlock.originalContent);
    console.groupEnd();
    /* eslint-enable no-console */
  } else if (!validatedBlock.isValid && !updatedBlock.isValid) {
    validationIssues.forEach(_ref => {
      let {
        log,
        args
      } = _ref;
      return log(...args);
    });
  }

  return updatedBlock;
}
/**
 * Utilizes an optimized token-driven parser based on the Gutenberg grammar spec
 * defined through a parsing expression grammar to take advantage of the regular
 * cadence provided by block delimiters -- composed syntactically through HTML
 * comments -- which, given a general HTML document as an input, returns a block
 * list array representation.
 *
 * This is a recursive-descent parser that scans linearly once through the input
 * document. Instead of directly recursing it utilizes a trampoline mechanism to
 * prevent stack overflow. This initial pass is mainly interested in separating
 * and isolating the blocks serialized in the document and manifestly not in the
 * content within the blocks.
 *
 * @see
 * https://developer.wordpress.org/block-editor/packages/packages-block-serialization-default-parser/
 *
 * @param {string}       content The post content.
 * @param {ParseOptions} options Extra options for handling block parsing.
 *
 * @return {Array} Block list.
 */

function parser_parse(content, options) {
  return parse(content).reduce((accumulator, rawBlock) => {
    const block = parseRawBlock(rawBlock, options);

    if (block) {
      accumulator.push(block);
    }

    return accumulator;
  }, []);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/get-raw-transforms.js
/**
 * Internal dependencies
 */

function getRawTransforms() {
  return getBlockTransforms('from').filter(_ref => {
    let {
      type
    } = _ref;
    return type === 'raw';
  }).map(transform => {
    return transform.isMatch ? transform : { ...transform,
      isMatch: node => transform.selector && node.matches(transform.selector)
    };
  });
}
//# sourceMappingURL=get-raw-transforms.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/html-to-blocks.js
/**
 * Internal dependencies
 */



/**
 * Converts HTML directly to blocks. Looks for a matching transform for each
 * top-level tag. The HTML should be filtered to not have any text between
 * top-level tags and formatted in a way that blocks can handle the HTML.
 *
 * @param {string}   html    HTML to convert.
 * @param {Function} handler The handler calling htmlToBlocks: either rawHandler
 *                           or pasteHandler.
 *
 * @return {Array} An array of blocks.
 */

function htmlToBlocks(html, handler) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = html;
  return Array.from(doc.body.children).flatMap(node => {
    const rawTransform = findTransform(getRawTransforms(), _ref => {
      let {
        isMatch
      } = _ref;
      return isMatch(node);
    });

    if (!rawTransform) {
      return createBlock( // Should not be hardcoded.
      'core/html', getBlockAttributes('core/html', node.outerHTML));
    }

    const {
      transform,
      blockName
    } = rawTransform;

    if (transform) {
      return transform(node, handler);
    }

    return createBlock(blockName, getBlockAttributes(blockName, node.outerHTML));
  });
}
//# sourceMappingURL=html-to-blocks.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-empty.js
/**
 * Recursively checks if an element is empty. An element is not empty if it
 * contains text or contains elements with attributes such as images.
 *
 * @param {Element} element The element to check.
 *
 * @return {boolean} Whether or not the element is empty.
 */
function isEmpty(element) {
  switch (element.nodeType) {
    case element.TEXT_NODE:
      // We cannot use \s since it includes special spaces which we want
      // to preserve.
      return /^[ \f\n\r\t\v\u00a0]*$/.test(element.nodeValue || '');

    case element.ELEMENT_NODE:
      if (element.hasAttributes()) {
        return false;
      } else if (!element.hasChildNodes()) {
        return true;
      }

      return (
        /** @type {Element[]} */
        Array.from(element.childNodes).every(isEmpty)
      );

    default:
      return true;
  }
}
//# sourceMappingURL=is-empty.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/phrasing-content.js
/**
 * All phrasing content elements.
 *
 * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0
 */

/**
 * @typedef {Record<string,SemanticElementDefinition>} ContentSchema
 */

/**
 * @typedef SemanticElementDefinition
 * @property {string[]}      [attributes] Content attributes
 * @property {ContentSchema} [children]   Content attributes
 */

/**
 * All text-level semantic elements.
 *
 * @see https://html.spec.whatwg.org/multipage/text-level-semantics.html
 *
 * @type {ContentSchema}
 */
const textContentSchema = {
  strong: {},
  em: {},
  s: {},
  del: {},
  ins: {},
  a: {
    attributes: ['href', 'target', 'rel', 'id']
  },
  code: {},
  abbr: {
    attributes: ['title']
  },
  sub: {},
  sup: {},
  br: {},
  small: {},
  // To do: fix blockquote.
  // cite: {},
  q: {
    attributes: ['cite']
  },
  dfn: {
    attributes: ['title']
  },
  data: {
    attributes: ['value']
  },
  time: {
    attributes: ['datetime']
  },
  var: {},
  samp: {},
  kbd: {},
  i: {},
  b: {},
  u: {},
  mark: {},
  ruby: {},
  rt: {},
  rp: {},
  bdi: {
    attributes: ['dir']
  },
  bdo: {
    attributes: ['dir']
  },
  wbr: {},
  '#text': {}
}; // Recursion is needed.
// Possible: strong > em > strong.
// Impossible: strong > strong.

const excludedElements = ['#text', 'br'];
Object.keys(textContentSchema).filter(element => !excludedElements.includes(element)).forEach(tag => {
  const {
    [tag]: removedTag,
    ...restSchema
  } = textContentSchema;
  textContentSchema[tag].children = restSchema;
});
/**
 * Embedded content elements.
 *
 * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#embedded-content-0
 *
 * @type {ContentSchema}
 */

const embeddedContentSchema = {
  audio: {
    attributes: ['src', 'preload', 'autoplay', 'mediagroup', 'loop', 'muted']
  },
  canvas: {
    attributes: ['width', 'height']
  },
  embed: {
    attributes: ['src', 'type', 'width', 'height']
  },
  img: {
    attributes: ['alt', 'src', 'srcset', 'usemap', 'ismap', 'width', 'height']
  },
  object: {
    attributes: ['data', 'type', 'name', 'usemap', 'form', 'width', 'height']
  },
  video: {
    attributes: ['src', 'poster', 'preload', 'autoplay', 'mediagroup', 'loop', 'muted', 'controls', 'width', 'height']
  }
};
/**
 * Phrasing content elements.
 *
 * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0
 */

const phrasingContentSchema = { ...textContentSchema,
  ...embeddedContentSchema
};
/**
 * Get schema of possible paths for phrasing content.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
 *
 * @param {string} [context] Set to "paste" to exclude invisible elements and
 *                           sensitive data.
 *
 * @return {Partial<ContentSchema>} Schema.
 */

function phrasing_content_getPhrasingContentSchema(context) {
  if (context !== 'paste') {
    return phrasingContentSchema;
  }
  /**
   * @type {Partial<ContentSchema>}
   */


  const {
    u,
    // Used to mark misspelling. Shouldn't be pasted.
    abbr,
    // Invisible.
    data,
    // Invisible.
    time,
    // Invisible.
    wbr,
    // Invisible.
    bdi,
    // Invisible.
    bdo,
    // Invisible.
    ...remainingContentSchema
  } = { ...phrasingContentSchema,
    // We shouldn't paste potentially sensitive information which is not
    // visible to the user when pasted, so strip the attributes.
    ins: {
      children: phrasingContentSchema.ins.children
    },
    del: {
      children: phrasingContentSchema.del.children
    }
  };
  return remainingContentSchema;
}
/**
 * Find out whether or not the given node is phrasing content.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content
 *
 * @param {Node} node The node to test.
 *
 * @return {boolean} True if phrasing content, false if not.
 */

function isPhrasingContent(node) {
  const tag = node.nodeName.toLowerCase();
  return phrasing_content_getPhrasingContentSchema().hasOwnProperty(tag) || tag === 'span';
}
/**
 * @param {Node} node
 * @return {boolean} Node is text content
 */

function isTextContent(node) {
  const tag = node.nodeName.toLowerCase();
  return textContentSchema.hasOwnProperty(tag) || tag === 'span';
}
//# sourceMappingURL=phrasing-content.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/normalise-blocks.js
/**
 * WordPress dependencies
 */

function normaliseBlocks(HTML) {
  const decuDoc = document.implementation.createHTMLDocument('');
  const accuDoc = document.implementation.createHTMLDocument('');
  const decu = decuDoc.body;
  const accu = accuDoc.body;
  decu.innerHTML = HTML;

  while (decu.firstChild) {
    const node = decu.firstChild; // Text nodes: wrap in a paragraph, or append to previous.

    if (node.nodeType === node.TEXT_NODE) {
      if (isEmpty(node)) {
        decu.removeChild(node);
      } else {
        if (!accu.lastChild || accu.lastChild.nodeName !== 'P') {
          accu.appendChild(accuDoc.createElement('P'));
        }

        accu.lastChild.appendChild(node);
      } // Element nodes.

    } else if (node.nodeType === node.ELEMENT_NODE) {
      // BR nodes: create a new paragraph on double, or append to previous.
      if (node.nodeName === 'BR') {
        if (node.nextSibling && node.nextSibling.nodeName === 'BR') {
          accu.appendChild(accuDoc.createElement('P'));
          decu.removeChild(node.nextSibling);
        } // Don't append to an empty paragraph.


        if (accu.lastChild && accu.lastChild.nodeName === 'P' && accu.lastChild.hasChildNodes()) {
          accu.lastChild.appendChild(node);
        } else {
          decu.removeChild(node);
        }
      } else if (node.nodeName === 'P') {
        // Only append non-empty paragraph nodes.
        if (isEmpty(node)) {
          decu.removeChild(node);
        } else {
          accu.appendChild(node);
        }
      } else if (isPhrasingContent(node)) {
        if (!accu.lastChild || accu.lastChild.nodeName !== 'P') {
          accu.appendChild(accuDoc.createElement('P'));
        }

        accu.lastChild.appendChild(node);
      } else {
        accu.appendChild(node);
      }
    } else {
      decu.removeChild(node);
    }
  }

  return accu.innerHTML;
}
//# sourceMappingURL=normalise-blocks.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js
var assert_is_defined = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/insert-after.js
/**
 * Internal dependencies
 */

/**
 * Given two DOM nodes, inserts the former in the DOM as the next sibling of
 * the latter.
 *
 * @param {Node} newNode       Node to be inserted.
 * @param {Node} referenceNode Node after which to perform the insertion.
 * @return {void}
 */

function insertAfter(newNode, referenceNode) {
  (0,assert_is_defined/* assertIsDefined */.e)(referenceNode.parentNode, 'referenceNode.parentNode');
  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
//# sourceMappingURL=insert-after.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/remove.js
var remove = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/remove.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/replace.js
/**
 * Internal dependencies
 */



/**
 * Given two DOM nodes, replaces the former with the latter in the DOM.
 *
 * @param {Element} processedNode Node to be removed.
 * @param {Element} newNode       Node to be inserted in its place.
 * @return {void}
 */

function replace(processedNode, newNode) {
  (0,assert_is_defined/* assertIsDefined */.e)(processedNode.parentNode, 'processedNode.parentNode');
  insertAfter(newNode, processedNode.parentNode);
  (0,remove/* default */.A)(processedNode);
}
//# sourceMappingURL=replace.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/special-comment-converter.js
/**
 * WordPress dependencies
 */

/**
 * Looks for `<!--nextpage-->` and `<!--more-->` comments and
 * replaces them with a custom element representing a future block.
 *
 * The custom element is a way to bypass the rest of the `raw-handling`
 * transforms, which would eliminate other kinds of node with which to carry
 * `<!--more-->`'s data: nodes with `data` attributes, empty paragraphs, etc.
 *
 * The custom element is then expected to be recognized by any registered
 * block's `raw` transform.
 *
 * @param {Node}     node The node to be processed.
 * @param {Document} doc  The document of the node.
 * @return {void}
 */

function specialCommentConverter(node, doc) {
  if (node.nodeType !== node.COMMENT_NODE) {
    return;
  }

  if (node.nodeValue === 'nextpage') {
    replace(node, createNextpage(doc));
    return;
  }

  if (node.nodeValue.indexOf('more') === 0) {
    moreCommentConverter(node, doc);
  }
}
/**
 * Convert `<!--more-->` as well as the `<!--more Some text-->` variant
 * and its `<!--noteaser-->` companion into the custom element
 * described in `specialCommentConverter()`.
 *
 * @param {Node}     node The node to be processed.
 * @param {Document} doc  The document of the node.
 * @return {void}
 */

function moreCommentConverter(node, doc) {
  // Grab any custom text in the comment.
  const customText = node.nodeValue.slice(4).trim();
  /*
   * When a `<!--more-->` comment is found, we need to look for any
   * `<!--noteaser-->` sibling, but it may not be a direct sibling
   * (whitespace typically lies in between)
   */

  let sibling = node;
  let noTeaser = false;

  while (sibling = sibling.nextSibling) {
    if (sibling.nodeType === sibling.COMMENT_NODE && sibling.nodeValue === 'noteaser') {
      noTeaser = true;
      (0,remove/* default */.A)(sibling);
      break;
    }
  }

  const moreBlock = createMore(customText, noTeaser, doc); // If our `<!--more-->` comment is in the middle of a paragraph, we should
  // split the paragraph in two and insert the more block in between. If not,
  // the more block will eventually end up being inserted after the paragraph.

  if (!node.parentNode || node.parentNode.nodeName !== 'P' || node.parentNode.childNodes.length === 1) {
    replace(node, moreBlock);
  } else {
    const childNodes = Array.from(node.parentNode.childNodes);
    const nodeIndex = childNodes.indexOf(node);
    const wrapperNode = node.parentNode.parentNode || doc.body;

    const paragraphBuilder = (acc, child) => {
      if (!acc) {
        acc = doc.createElement('p');
      }

      acc.appendChild(child);
      return acc;
    }; // Split the original parent node and insert our more block


    [childNodes.slice(0, nodeIndex).reduce(paragraphBuilder, null), moreBlock, childNodes.slice(nodeIndex + 1).reduce(paragraphBuilder, null)].forEach(element => element && wrapperNode.insertBefore(element, node.parentNode)); // Remove the old parent paragraph

    (0,remove/* default */.A)(node.parentNode);
  }
}

function createMore(customText, noTeaser, doc) {
  const node = doc.createElement('wp-block');
  node.dataset.block = 'core/more';

  if (customText) {
    node.dataset.customText = customText;
  }

  if (noTeaser) {
    // "Boolean" data attribute.
    node.dataset.noTeaser = '';
  }

  return node;
}

function createNextpage(doc) {
  const node = doc.createElement('wp-block');
  node.dataset.block = 'core/nextpage';
  return node;
}
//# sourceMappingURL=special-comment-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/unwrap.js
/**
 * Internal dependencies
 */

/**
 * Unwrap the given node. This means any child nodes are moved to the parent.
 *
 * @param {Node} node The node to unwrap.
 *
 * @return {void}
 */

function unwrap(node) {
  const parent = node.parentNode;
  (0,assert_is_defined/* assertIsDefined */.e)(parent, 'node.parentNode');

  while (node.firstChild) {
    parent.insertBefore(node.firstChild, node);
  }

  parent.removeChild(node);
}
//# sourceMappingURL=unwrap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/list-reducer.js
/**
 * WordPress dependencies
 */


function isList(node) {
  return node.nodeName === 'OL' || node.nodeName === 'UL';
}

function shallowTextContent(element) {
  return Array.from(element.childNodes).map(_ref => {
    let {
      nodeValue = ''
    } = _ref;
    return nodeValue;
  }).join('');
}

function listReducer(node) {
  if (!isList(node)) {
    return;
  }

  const list = node;
  const prevElement = node.previousElementSibling; // Merge with previous list if:
  // * There is a previous list of the same type.
  // * There is only one list item.

  if (prevElement && prevElement.nodeName === node.nodeName && list.children.length === 1) {
    // Move all child nodes, including any text nodes, if any.
    while (list.firstChild) {
      prevElement.appendChild(list.firstChild);
    }

    list.parentNode.removeChild(list);
  }

  const parentElement = node.parentNode; // Nested list with empty parent item.

  if (parentElement && parentElement.nodeName === 'LI' && parentElement.children.length === 1 && !/\S/.test(shallowTextContent(parentElement))) {
    const parentListItem = parentElement;
    const prevListItem = parentListItem.previousElementSibling;
    const parentList = parentListItem.parentNode;

    if (prevListItem) {
      prevListItem.appendChild(list);
      parentList.removeChild(parentListItem);
    } else {
      parentList.parentNode.insertBefore(list, parentList);
      parentList.parentNode.removeChild(parentList);
    }
  } // Invalid: OL/UL > OL/UL.


  if (parentElement && isList(parentElement)) {
    const prevListItem = node.previousElementSibling;

    if (prevListItem) {
      prevListItem.appendChild(node);
    } else {
      unwrap(node);
    }
  }
}
//# sourceMappingURL=list-reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/blockquote-normaliser.js
/**
 * Internal dependencies
 */

function blockquoteNormaliser(node) {
  if (node.nodeName !== 'BLOCKQUOTE') {
    return;
  }

  node.innerHTML = normaliseBlocks(node.innerHTML);
}
//# sourceMappingURL=blockquote-normaliser.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/figure-content-reducer.js
/**
 * WordPress dependencies
 */

/**
 * Whether or not the given node is figure content.
 *
 * @param {Node}   node   The node to check.
 * @param {Object} schema The schema to use.
 *
 * @return {boolean} True if figure content, false if not.
 */

function isFigureContent(node, schema) {
  var _schema$figure$childr, _schema$figure;

  const tag = node.nodeName.toLowerCase(); // We are looking for tags that can be a child of the figure tag, excluding
  // `figcaption` and any phrasing content.

  if (tag === 'figcaption' || isTextContent(node)) {
    return false;
  }

  return tag in ((_schema$figure$childr = schema === null || schema === void 0 ? void 0 : (_schema$figure = schema.figure) === null || _schema$figure === void 0 ? void 0 : _schema$figure.children) !== null && _schema$figure$childr !== void 0 ? _schema$figure$childr : {});
}
/**
 * Whether or not the given node can have an anchor.
 *
 * @param {Node}   node   The node to check.
 * @param {Object} schema The schema to use.
 *
 * @return {boolean} True if it can, false if not.
 */


function canHaveAnchor(node, schema) {
  var _schema$figure$childr2, _schema$figure2, _schema$figure2$child, _schema$figure2$child2;

  const tag = node.nodeName.toLowerCase();
  return tag in ((_schema$figure$childr2 = schema === null || schema === void 0 ? void 0 : (_schema$figure2 = schema.figure) === null || _schema$figure2 === void 0 ? void 0 : (_schema$figure2$child = _schema$figure2.children) === null || _schema$figure2$child === void 0 ? void 0 : (_schema$figure2$child2 = _schema$figure2$child.a) === null || _schema$figure2$child2 === void 0 ? void 0 : _schema$figure2$child2.children) !== null && _schema$figure$childr2 !== void 0 ? _schema$figure$childr2 : {});
}
/**
 * Wraps the given element in a figure element.
 *
 * @param {Element} element       The element to wrap.
 * @param {Element} beforeElement The element before which to place the figure.
 */


function wrapFigureContent(element) {
  let beforeElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element;
  const figure = element.ownerDocument.createElement('figure');
  beforeElement.parentNode.insertBefore(figure, beforeElement);
  figure.appendChild(element);
}
/**
 * This filter takes figure content out of paragraphs, wraps it in a figure
 * element, and moves any anchors with it if needed.
 *
 * @param {Node}     node   The node to filter.
 * @param {Document} doc    The document of the node.
 * @param {Object}   schema The schema to use.
 *
 * @return {void}
 */


function figureContentReducer(node, doc, schema) {
  if (!isFigureContent(node, schema)) {
    return;
  }

  let nodeToInsert = node;
  const parentNode = node.parentNode; // If the figure content can have an anchor and its parent is an anchor with
  // only the figure content, take the anchor out instead of just the content.

  if (canHaveAnchor(node, schema) && parentNode.nodeName === 'A' && parentNode.childNodes.length === 1) {
    nodeToInsert = node.parentNode;
  }

  const wrapper = nodeToInsert.closest('p,div'); // If wrapped in a paragraph or div, only extract if it's aligned or if
  // there is no text content.
  // Otherwise, if directly at the root, wrap in a figure element.

  if (wrapper) {
    // In jsdom-jscore, 'node.classList' can be undefined.
    // In this case, default to extract as it offers a better UI experience on mobile.
    if (!node.classList) {
      wrapFigureContent(nodeToInsert, wrapper);
    } else if (node.classList.contains('alignright') || node.classList.contains('alignleft') || node.classList.contains('aligncenter') || !wrapper.textContent.trim()) {
      wrapFigureContent(nodeToInsert, wrapper);
    }
  } else if (nodeToInsert.parentNode.nodeName === 'BODY') {
    wrapFigureContent(nodeToInsert);
  }
}
//# sourceMappingURL=figure-content-reducer.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js
var dist = __webpack_require__("../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+shortcode@3.47.0/node_modules/@wordpress/shortcode/build-module/index.js
/**
 * External dependencies
 */


/**
 * Shortcode attributes object.
 *
 * @typedef {Object} WPShortcodeAttrs
 *
 * @property {Object} named   Object with named attributes.
 * @property {Array}  numeric Array with numeric attributes.
 */

/**
 * Shortcode object.
 *
 * @typedef {Object} WPShortcode
 *
 * @property {string}           tag     Shortcode tag.
 * @property {WPShortcodeAttrs} attrs   Shortcode attributes.
 * @property {string}           content Shortcode content.
 * @property {string}           type    Shortcode type: `self-closing`,
 *                                      `closed`, or `single`.
 */

/**
 * @typedef {Object} WPShortcodeMatch
 *
 * @property {number}      index     Index the shortcode is found at.
 * @property {string}      content   Matched content.
 * @property {WPShortcode} shortcode Shortcode instance of the match.
 */

/**
 * Find the next matching shortcode.
 *
 * @param {string} tag   Shortcode tag.
 * @param {string} text  Text to search.
 * @param {number} index Index to start search from.
 *
 * @return {WPShortcodeMatch | undefined} Matched information.
 */
function next(tag, text, index = 0) {
  const re = regexp(tag);
  re.lastIndex = index;
  const match = re.exec(text);
  if (!match) {
    return;
  }

  // If we matched an escaped shortcode, try again.
  if ('[' === match[1] && ']' === match[7]) {
    return next(tag, text, re.lastIndex);
  }
  const result = {
    index: match.index,
    content: match[0],
    shortcode: fromMatch(match)
  };

  // If we matched a leading `[`, strip it from the match and increment the
  // index accordingly.
  if (match[1]) {
    result.content = result.content.slice(1);
    result.index++;
  }

  // If we matched a trailing `]`, strip it from the match.
  if (match[7]) {
    result.content = result.content.slice(0, -1);
  }
  return result;
}

/**
 * Replace matching shortcodes in a block of text.
 *
 * @param {string}   tag      Shortcode tag.
 * @param {string}   text     Text to search.
 * @param {Function} callback Function to process the match and return
 *                            replacement string.
 *
 * @return {string} Text with shortcodes replaced.
 */
function build_module_replace(tag, text, callback) {
  return text.replace(regexp(tag), function (match, left, $3, attrs, slash, content, closing, right) {
    // If both extra brackets exist, the shortcode has been properly
    // escaped.
    if (left === '[' && right === ']') {
      return match;
    }

    // Create the match object and pass it through the callback.
    const result = callback(fromMatch(arguments));

    // Make sure to return any of the extra brackets if they weren't used to
    // escape the shortcode.
    return result || result === '' ? left + result + right : match;
  });
}

/**
 * Generate a string from shortcode parameters.
 *
 * Creates a shortcode instance and returns a string.
 *
 * Accepts the same `options` as the `shortcode()` constructor, containing a
 * `tag` string, a string or object of `attrs`, a boolean indicating whether to
 * format the shortcode using a `single` tag, and a `content` string.
 *
 * @param {Object} options
 *
 * @return {string} String representation of the shortcode.
 */
function string(options) {
  return new shortcode(options).string();
}

/**
 * Generate a RegExp to identify a shortcode.
 *
 * The base regex is functionally equivalent to the one found in
 * `get_shortcode_regex()` in `wp-includes/shortcodes.php`.
 *
 * Capture groups:
 *
 * 1. An extra `[` to allow for escaping shortcodes with double `[[]]`
 * 2. The shortcode name
 * 3. The shortcode argument list
 * 4. The self closing `/`
 * 5. The content of a shortcode when it wraps some content.
 * 6. The closing tag.
 * 7. An extra `]` to allow for escaping shortcodes with double `[[]]`
 *
 * @param {string} tag Shortcode tag.
 *
 * @return {RegExp} Shortcode RegExp.
 */
function regexp(tag) {
  return new RegExp('\\[(\\[?)(' + tag + ')(?![\\w-])([^\\]\\/]*(?:\\/(?!\\])[^\\]\\/]*)*?)(?:(\\/)\\]|\\](?:([^\\[]*(?:\\[(?!\\/\\2\\])[^\\[]*)*)(\\[\\/\\2\\]))?)(\\]?)', 'g');
}

/**
 * Parse shortcode attributes.
 *
 * Shortcodes accept many types of attributes. These can chiefly be divided into
 * named and numeric attributes:
 *
 * Named attributes are assigned on a key/value basis, while numeric attributes
 * are treated as an array.
 *
 * Named attributes can be formatted as either `name="value"`, `name='value'`,
 * or `name=value`. Numeric attributes can be formatted as `"value"` or just
 * `value`.
 *
 * @param {string} text Serialised shortcode attributes.
 *
 * @return {WPShortcodeAttrs} Parsed shortcode attributes.
 */
const attrs = (0,dist/* default */.A)(text => {
  const named = {};
  const numeric = [];

  // This regular expression is reused from `shortcode_parse_atts()` in
  // `wp-includes/shortcodes.php`.
  //
  // Capture groups:
  //
  // 1. An attribute name, that corresponds to...
  // 2. a value in double quotes.
  // 3. An attribute name, that corresponds to...
  // 4. a value in single quotes.
  // 5. An attribute name, that corresponds to...
  // 6. an unquoted value.
  // 7. A numeric attribute in double quotes.
  // 8. A numeric attribute in single quotes.
  // 9. An unquoted numeric attribute.
  const pattern = /([\w-]+)\s*=\s*"([^"]*)"(?:\s|$)|([\w-]+)\s*=\s*'([^']*)'(?:\s|$)|([\w-]+)\s*=\s*([^\s'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|'([^']*)'(?:\s|$)|(\S+)(?:\s|$)/g;

  // Map zero-width spaces to actual spaces.
  text = text.replace(/[\u00a0\u200b]/g, ' ');
  let match;

  // Match and normalize attributes.
  while (match = pattern.exec(text)) {
    if (match[1]) {
      named[match[1].toLowerCase()] = match[2];
    } else if (match[3]) {
      named[match[3].toLowerCase()] = match[4];
    } else if (match[5]) {
      named[match[5].toLowerCase()] = match[6];
    } else if (match[7]) {
      numeric.push(match[7]);
    } else if (match[8]) {
      numeric.push(match[8]);
    } else if (match[9]) {
      numeric.push(match[9]);
    }
  }
  return {
    named,
    numeric
  };
});

/**
 * Generate a Shortcode Object from a RegExp match.
 *
 * Accepts a `match` object from calling `regexp.exec()` on a `RegExp` generated
 * by `regexp()`. `match` can also be set to the `arguments` from a callback
 * passed to `regexp.replace()`.
 *
 * @param {Array} match Match array.
 *
 * @return {WPShortcode} Shortcode instance.
 */
function fromMatch(match) {
  let type;
  if (match[4]) {
    type = 'self-closing';
  } else if (match[6]) {
    type = 'closed';
  } else {
    type = 'single';
  }
  return new shortcode({
    tag: match[2],
    attrs: match[3],
    type,
    content: match[5]
  });
}

/**
 * Creates a shortcode instance.
 *
 * To access a raw representation of a shortcode, pass an `options` object,
 * containing a `tag` string, a string or object of `attrs`, a string indicating
 * the `type` of the shortcode ('single', 'self-closing', or 'closed'), and a
 * `content` string.
 *
 * @param {Object} options Options as described.
 *
 * @return {WPShortcode} Shortcode instance.
 */
const shortcode = Object.assign(function (options) {
  const {
    tag,
    attrs: attributes,
    type,
    content
  } = options || {};
  Object.assign(this, {
    tag,
    type,
    content
  });

  // Ensure we have a correctly formatted `attrs` object.
  this.attrs = {
    named: {},
    numeric: []
  };
  if (!attributes) {
    return;
  }
  const attributeTypes = ['named', 'numeric'];

  // Parse a string of attributes.
  if (typeof attributes === 'string') {
    this.attrs = attrs(attributes);
    // Identify a correctly formatted `attrs` object.
  } else if (attributes.length === attributeTypes.length && attributeTypes.every((t, key) => t === attributes[key])) {
    this.attrs = attributes;
    // Handle a flat object of attributes.
  } else {
    Object.entries(attributes).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
}, {
  next,
  replace: build_module_replace,
  string,
  regexp,
  attrs,
  fromMatch
});
Object.assign(shortcode.prototype, {
  /**
   * Get a shortcode attribute.
   *
   * Automatically detects whether `attr` is named or numeric and routes it
   * accordingly.
   *
   * @param {(number|string)} attr Attribute key.
   *
   * @return {string} Attribute value.
   */
  get(attr) {
    return this.attrs[typeof attr === 'number' ? 'numeric' : 'named'][attr];
  },
  /**
   * Set a shortcode attribute.
   *
   * Automatically detects whether `attr` is named or numeric and routes it
   * accordingly.
   *
   * @param {(number|string)} attr  Attribute key.
   * @param {string}          value Attribute value.
   *
   * @return {WPShortcode} Shortcode instance.
   */
  set(attr, value) {
    this.attrs[typeof attr === 'number' ? 'numeric' : 'named'][attr] = value;
    return this;
  },
  /**
   * Transform the shortcode into a string.
   *
   * @return {string} String representation of the shortcode.
   */
  string() {
    let text = '[' + this.tag;
    this.attrs.numeric.forEach(value => {
      if (/\s/.test(value)) {
        text += ' "' + value + '"';
      } else {
        text += ' ' + value;
      }
    });
    Object.entries(this.attrs.named).forEach(([name, value]) => {
      text += ' ' + name + '="' + value + '"';
    });

    // If the tag is marked as `single` or `self-closing`, close the tag and
    // ignore any additional content.
    if ('single' === this.type) {
      return text + ']';
    } else if ('self-closing' === this.type) {
      return text + ' /]';
    }

    // Complete the opening tag.
    text += ']';
    if (this.content) {
      text += this.content;
    }

    // Add the closing tag.
    return text + '[/' + this.tag + ']';
  }
});
/* harmony default export */ const shortcode_build_module = ((/* unused pure expression or super */ null && (shortcode)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/shortcode-converter.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






const castArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];

function segmentHTMLToShortcodeBlock(HTML) {
  let lastIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let excludedBlockNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  // Get all matches.
  const transformsFrom = getBlockTransforms('from');
  const transformation = findTransform(transformsFrom, transform => excludedBlockNames.indexOf(transform.blockName) === -1 && transform.type === 'shortcode' && castArray(transform.tag).some(tag => regexp(tag).test(HTML)));

  if (!transformation) {
    return [HTML];
  }

  const transformTags = castArray(transformation.tag);
  const transformTag = transformTags.find(tag => regexp(tag).test(HTML));
  let match;
  const previousIndex = lastIndex;

  if (match = next(transformTag, HTML, lastIndex)) {
    var _match$shortcode$cont;

    lastIndex = match.index + match.content.length;
    const beforeHTML = HTML.substr(0, match.index);
    const afterHTML = HTML.substr(lastIndex); // If the shortcode content does not contain HTML and the shortcode is
    // not on a new line (or in paragraph from Markdown converter),
    // consider the shortcode as inline text, and thus skip conversion for
    // this segment.

    if (!((_match$shortcode$cont = match.shortcode.content) !== null && _match$shortcode$cont !== void 0 && _match$shortcode$cont.includes('<')) && !(/(\n|<p>)\s*$/.test(beforeHTML) && /^\s*(\n|<\/p>)/.test(afterHTML))) {
      return segmentHTMLToShortcodeBlock(HTML, lastIndex);
    } // If a transformation's `isMatch` predicate fails for the inbound
    // shortcode, try again by excluding the current block type.
    //
    // This is the only call to `segmentHTMLToShortcodeBlock` that should
    // ever carry over `excludedBlockNames`. Other calls in the module
    // should skip that argument as a way to reset the exclusion state, so
    // that one `isMatch` fail in an HTML fragment doesn't prevent any
    // valid matches in subsequent fragments.


    if (transformation.isMatch && !transformation.isMatch(match.shortcode.attrs)) {
      return segmentHTMLToShortcodeBlock(HTML, previousIndex, [...excludedBlockNames, transformation.blockName]);
    }

    let blocks = [];

    if (typeof transformation.transform === 'function') {
      // Passing all of `match` as second argument is intentionally broad
      // but shouldn't be too relied upon.
      //
      // See: https://github.com/WordPress/gutenberg/pull/3610#discussion_r152546926
      blocks = [].concat(transformation.transform(match.shortcode.attrs, match)); // Applying the built-in fixes can enhance the attributes with missing content like "className".

      blocks = blocks.map(block => {
        block.originalContent = match.shortcode.content;
        return applyBuiltInValidationFixes(block, getBlockType(block.name));
      });
    } else {
      const attributes = Object.fromEntries(Object.entries(transformation.attributes).filter(_ref => {
        let [, schema] = _ref;
        return schema.shortcode;
      }) // Passing all of `match` as second argument is intentionally broad
      // but shouldn't be too relied upon.
      //
      // See: https://github.com/WordPress/gutenberg/pull/3610#discussion_r152546926
      .map(_ref2 => {
        let [key, schema] = _ref2;
        return [key, schema.shortcode(match.shortcode.attrs, match)];
      }));
      const blockType = getBlockType(transformation.blockName);

      if (!blockType) {
        return [HTML];
      }

      const transformationBlockType = { ...blockType,
        attributes: transformation.attributes
      };
      let block = createBlock(transformation.blockName, getBlockAttributes(transformationBlockType, match.shortcode.content, attributes)); // Applying the built-in fixes can enhance the attributes with missing content like "className".

      block.originalContent = match.shortcode.content;
      block = applyBuiltInValidationFixes(block, transformationBlockType);
      blocks = [block];
    }

    return [...segmentHTMLToShortcodeBlock(beforeHTML), ...blocks, ...segmentHTMLToShortcodeBlock(afterHTML)];
  }

  return [HTML];
}

/* harmony default export */ const shortcode_converter = (segmentHTMLToShortcodeBlock);
//# sourceMappingURL=shortcode-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/utils.js
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



function getBlockContentSchemaFromTransforms(transforms, context) {
  const phrasingContentSchema = phrasing_content_getPhrasingContentSchema(context);
  const schemaArgs = {
    phrasingContentSchema,
    isPaste: context === 'paste'
  };
  const schemas = transforms.map(_ref => {
    let {
      isMatch,
      blockName,
      schema
    } = _ref;
    const hasAnchorSupport = hasBlockSupport(blockName, 'anchor');
    schema = typeof schema === 'function' ? schema(schemaArgs) : schema; // If the block does not has anchor support and the transform does not
    // provides an isMatch we can return the schema right away.

    if (!hasAnchorSupport && !isMatch) {
      return schema;
    }

    return (0,lodash.mapValues)(schema, value => {
      let attributes = value.attributes || []; // If the block supports the "anchor" functionality, it needs to keep its ID attribute.

      if (hasAnchorSupport) {
        attributes = [...attributes, 'id'];
      }

      return { ...value,
        attributes,
        isMatch: isMatch ? isMatch : undefined
      };
    });
  });
  return (0,lodash.mergeWith)({}, ...schemas, (objValue, srcValue, key) => {
    switch (key) {
      case 'children':
        {
          if (objValue === '*' || srcValue === '*') {
            return '*';
          }

          return { ...objValue,
            ...srcValue
          };
        }

      case 'attributes':
      case 'require':
        {
          return [...(objValue || []), ...(srcValue || [])];
        }

      case 'isMatch':
        {
          // If one of the values being merge is undefined (matches everything),
          // the result of the merge will be undefined.
          if (!objValue || !srcValue) {
            return undefined;
          } // When merging two isMatch functions, the result is a new function
          // that returns if one of the source functions returns true.


          return function () {
            return objValue(...arguments) || srcValue(...arguments);
          };
        }
    }
  });
}
/**
 * Gets the block content schema, which is extracted and merged from all
 * registered blocks with raw transfroms.
 *
 * @param {string} context Set to "paste" when in paste context, where the
 *                         schema is more strict.
 *
 * @return {Object} A complete block content schema.
 */

function getBlockContentSchema(context) {
  return getBlockContentSchemaFromTransforms(getRawTransforms(), context);
}
/**
 * Checks whether HTML can be considered plain text. That is, it does not contain
 * any elements that are not line breaks.
 *
 * @param {string} HTML The HTML to check.
 *
 * @return {boolean} Whether the HTML can be considered plain text.
 */

function isPlain(HTML) {
  return !/<(?!br[ />])/i.test(HTML);
}
/**
 * Given node filters, deeply filters and mutates a NodeList.
 *
 * @param {NodeList} nodeList The nodeList to filter.
 * @param {Array}    filters  An array of functions that can mutate with the provided node.
 * @param {Document} doc      The document of the nodeList.
 * @param {Object}   schema   The schema to use.
 */

function deepFilterNodeList(nodeList, filters, doc, schema) {
  Array.from(nodeList).forEach(node => {
    deepFilterNodeList(node.childNodes, filters, doc, schema);
    filters.forEach(item => {
      // Make sure the node is still attached to the document.
      if (!doc.contains(node)) {
        return;
      }

      item(node, doc, schema);
    });
  });
}
/**
 * Given node filters, deeply filters HTML tags.
 * Filters from the deepest nodes to the top.
 *
 * @param {string} HTML    The HTML to filter.
 * @param {Array}  filters An array of functions that can mutate with the provided node.
 * @param {Object} schema  The schema to use.
 *
 * @return {string} The filtered HTML.
 */

function deepFilterHTML(HTML) {
  let filters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let schema = arguments.length > 2 ? arguments[2] : undefined;
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = HTML;
  deepFilterNodeList(doc.body.childNodes, filters, doc, schema);
  return doc.body.innerHTML;
}
/**
 * Gets a sibling within text-level context.
 *
 * @param {Element} node  The subject node.
 * @param {string}  which "next" or "previous".
 */

function getSibling(node, which) {
  const sibling = node[`${which}Sibling`];

  if (sibling && isPhrasingContent(sibling)) {
    return sibling;
  }

  const {
    parentNode
  } = node;

  if (!parentNode || !isPhrasingContent(parentNode)) {
    return;
  }

  return getSibling(parentNode, which);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/index.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */











function deprecatedGetPhrasingContentSchema(context) {
  deprecated('wp.blocks.getPhrasingContentSchema', {
    since: '5.6',
    alternative: 'wp.dom.getPhrasingContentSchema'
  });
  return getPhrasingContentSchema(context);
}
/**
 * Converts an HTML string to known blocks.
 *
 * @param {Object} $1
 * @param {string} $1.HTML The HTML to convert.
 *
 * @return {Array} A list of blocks.
 */

function rawHandler(_ref) {
  let {
    HTML = ''
  } = _ref;

  // If we detect block delimiters, parse entirely as blocks.
  if (HTML.indexOf('<!-- wp:') !== -1) {
    return parser_parse(HTML);
  } // An array of HTML strings and block objects. The blocks replace matched
  // shortcodes.


  const pieces = shortcode_converter(HTML);
  const blockContentSchema = getBlockContentSchema();
  return pieces.map(piece => {
    // Already a block from shortcode.
    if (typeof piece !== 'string') {
      return piece;
    } // These filters are essential for some blocks to be able to transform
    // from raw HTML. These filters move around some content or add
    // additional tags, they do not remove any content.


    const filters = [// Needed to adjust invalid lists.
    listReducer, // Needed to create more and nextpage blocks.
    specialCommentConverter, // Needed to create media blocks.
    figureContentReducer, // Needed to create the quote block, which cannot handle text
    // without wrapper paragraphs.
    blockquoteNormaliser];
    piece = deepFilterHTML(piece, filters, blockContentSchema);
    piece = normaliseBlocks(piece);
    return htmlToBlocks(piece, rawHandler);
  }).flat().filter(Boolean);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/is-element.js
/* eslint-disable jsdoc/valid-types */

/**
 * @param {Node | null | undefined} node
 * @return {node is Element} True if node is an Element node
 */
function isElement(node) {
  /* eslint-enable jsdoc/valid-types */
  return !!node && node.nodeType === node.ELEMENT_NODE;
}
//# sourceMappingURL=is-element.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/clean-node-list.js
/**
 * Internal dependencies
 */







const noop = () => {};
/* eslint-disable jsdoc/valid-types */

/**
 * @typedef SchemaItem
 * @property {string[]}                            [attributes] Attributes.
 * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.
 * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.
 * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.
 * @property {boolean}                             allowEmpty   Whether to allow nodes without children.
 * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.
 */

/** @typedef {{ [tag: string]: SchemaItem }} Schema */

/* eslint-enable jsdoc/valid-types */

/**
 * Given a schema, unwraps or removes nodes, attributes and classes on a node
 * list.
 *
 * @param {NodeList} nodeList The nodeList to filter.
 * @param {Document} doc      The document of the nodeList.
 * @param {Schema}   schema   An array of functions that can mutate with the provided node.
 * @param {boolean}  inline   Whether to clean for inline mode.
 */


function cleanNodeList(nodeList, doc, schema, inline) {
  Array.from(nodeList).forEach((
  /** @type {Node & { nextElementSibling?: unknown }} */
  node) => {
    var _schema$tag$isMatch, _schema$tag;

    const tag = node.nodeName.toLowerCase(); // It's a valid child, if the tag exists in the schema without an isMatch
    // function, or with an isMatch function that matches the node.

    if (schema.hasOwnProperty(tag) && (!schema[tag].isMatch || (_schema$tag$isMatch = (_schema$tag = schema[tag]).isMatch) !== null && _schema$tag$isMatch !== void 0 && _schema$tag$isMatch.call(_schema$tag, node))) {
      if (isElement(node)) {
        const {
          attributes = [],
          classes = [],
          children,
          require = [],
          allowEmpty
        } = schema[tag]; // If the node is empty and it's supposed to have children,
        // remove the node.

        if (children && !allowEmpty && isEmpty(node)) {
          (0,remove/* default */.A)(node);
          return;
        }

        if (node.hasAttributes()) {
          // Strip invalid attributes.
          Array.from(node.attributes).forEach(_ref => {
            let {
              name
            } = _ref;

            if (name !== 'class' && !attributes.includes(name)) {
              node.removeAttribute(name);
            }
          }); // Strip invalid classes.
          // In jsdom-jscore, 'node.classList' can be undefined.
          // TODO: Explore patching this in jsdom-jscore.

          if (node.classList && node.classList.length) {
            const mattchers = classes.map(item => {
              if (typeof item === 'string') {
                return (
                /** @type {string} */
                className) => className === item;
              } else if (item instanceof RegExp) {
                return (
                /** @type {string} */
                className) => item.test(className);
              }

              return noop;
            });
            Array.from(node.classList).forEach(name => {
              if (!mattchers.some(isMatch => isMatch(name))) {
                node.classList.remove(name);
              }
            });

            if (!node.classList.length) {
              node.removeAttribute('class');
            }
          }
        }

        if (node.hasChildNodes()) {
          // Do not filter any content.
          if (children === '*') {
            return;
          } // Continue if the node is supposed to have children.


          if (children) {
            // If a parent requires certain children, but it does
            // not have them, drop the parent and continue.
            if (require.length && !node.querySelector(require.join(','))) {
              cleanNodeList(node.childNodes, doc, schema, inline);
              unwrap(node); // If the node is at the top, phrasing content, and
              // contains children that are block content, unwrap
              // the node because it is invalid.
            } else if (node.parentNode && node.parentNode.nodeName === 'BODY' && isPhrasingContent(node)) {
              cleanNodeList(node.childNodes, doc, schema, inline);

              if (Array.from(node.childNodes).some(child => !isPhrasingContent(child))) {
                unwrap(node);
              }
            } else {
              cleanNodeList(node.childNodes, doc, children, inline);
            } // Remove children if the node is not supposed to have any.

          } else {
            while (node.firstChild) {
              (0,remove/* default */.A)(node.firstChild);
            }
          }
        }
      } // Invalid child. Continue with schema at the same place and unwrap.

    } else {
      cleanNodeList(node.childNodes, doc, schema, inline); // For inline mode, insert a line break when unwrapping nodes that
      // are not phrasing content.

      if (inline && !isPhrasingContent(node) && node.nextElementSibling) {
        insertAfter(doc.createElement('br'), node);
      }

      unwrap(node);
    }
  });
}
//# sourceMappingURL=clean-node-list.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/remove-invalid-html.js
/**
 * Internal dependencies
 */

/**
 * Given a schema, unwraps or removes nodes, attributes and classes on HTML.
 *
 * @param {string}                             HTML   The HTML to clean up.
 * @param {import('./clean-node-list').Schema} schema Schema for the HTML.
 * @param {boolean}                            inline Whether to clean for inline mode.
 *
 * @return {string} The cleaned up HTML.
 */

function removeInvalidHTML(HTML, schema, inline) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = HTML;
  cleanNodeList(doc.body.childNodes, doc, schema, inline);
  return doc.body.innerHTML;
}
//# sourceMappingURL=remove-invalid-html.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/comment-remover.js
/**
 * WordPress dependencies
 */

/**
 * Looks for comments, and removes them.
 *
 * @param {Node} node The node to be processed.
 * @return {void}
 */

function commentRemover(node) {
  if (node.nodeType === node.COMMENT_NODE) {
    (0,remove/* default */.A)(node);
  }
}
//# sourceMappingURL=comment-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/is-inline-content.js
/**
 * WordPress dependencies
 */

/**
 * Checks if the given node should be considered inline content, optionally
 * depending on a context tag.
 *
 * @param {Node}   node       Node name.
 * @param {string} contextTag Tag name.
 *
 * @return {boolean} True if the node is inline content, false if nohe.
 */

function isInline(node, contextTag) {
  if (isTextContent(node)) {
    return true;
  }

  if (!contextTag) {
    return false;
  }

  const tag = node.nodeName.toLowerCase();
  const inlineAllowedTagGroups = [['ul', 'li', 'ol'], ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']];
  return inlineAllowedTagGroups.some(tagGroup => [tag, contextTag].filter(t => !tagGroup.includes(t)).length === 0);
}

function deepCheck(nodes, contextTag) {
  return nodes.every(node => isInline(node, contextTag) && deepCheck(Array.from(node.children), contextTag));
}

function isDoubleBR(node) {
  return node.nodeName === 'BR' && node.previousSibling && node.previousSibling.nodeName === 'BR';
}

function isInlineContent(HTML, contextTag) {
  const doc = document.implementation.createHTMLDocument('');
  doc.body.innerHTML = HTML;
  const nodes = Array.from(doc.body.children);
  return !nodes.some(isDoubleBR) && deepCheck(nodes, contextTag);
}
//# sourceMappingURL=is-inline-content.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/wrap.js
/**
 * Internal dependencies
 */

/**
 * Wraps the given node with a new node with the given tag name.
 *
 * @param {Element} newNode       The node to insert.
 * @param {Element} referenceNode The node to wrap.
 */

function wrap(newNode, referenceNode) {
  (0,assert_is_defined/* assertIsDefined */.e)(referenceNode.parentNode, 'referenceNode.parentNode');
  referenceNode.parentNode.insertBefore(newNode, referenceNode);
  newNode.appendChild(referenceNode);
}
//# sourceMappingURL=wrap.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/replace-tag.js
/**
 * Internal dependencies
 */

/**
 * Replaces the given node with a new node with the given tag name.
 *
 * @param {Element} node    The node to replace
 * @param {string}  tagName The new tag name.
 *
 * @return {Element} The new node.
 */

function replaceTag(node, tagName) {
  const newNode = node.ownerDocument.createElement(tagName);

  while (node.firstChild) {
    newNode.appendChild(node.firstChild);
  }

  (0,assert_is_defined/* assertIsDefined */.e)(node.parentNode, 'node.parentNode');
  node.parentNode.replaceChild(newNode, node);
  return newNode;
}
//# sourceMappingURL=replace-tag.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/phrasing-content-reducer.js
/**
 * WordPress dependencies
 */

function phrasingContentReducer(node, doc) {
  // In jsdom-jscore, 'node.style' can be null.
  // TODO: Explore fixing this by patching jsdom-jscore.
  if (node.nodeName === 'SPAN' && node.style) {
    const {
      fontWeight,
      fontStyle,
      textDecorationLine,
      textDecoration,
      verticalAlign
    } = node.style;

    if (fontWeight === 'bold' || fontWeight === '700') {
      wrap(doc.createElement('strong'), node);
    }

    if (fontStyle === 'italic') {
      wrap(doc.createElement('em'), node);
    } // Some DOM implementations (Safari, JSDom) don't support
    // style.textDecorationLine, so we check style.textDecoration as a
    // fallback.


    if (textDecorationLine === 'line-through' || textDecoration.includes('line-through')) {
      wrap(doc.createElement('s'), node);
    }

    if (verticalAlign === 'super') {
      wrap(doc.createElement('sup'), node);
    } else if (verticalAlign === 'sub') {
      wrap(doc.createElement('sub'), node);
    }
  } else if (node.nodeName === 'B') {
    node = replaceTag(node, 'strong');
  } else if (node.nodeName === 'I') {
    node = replaceTag(node, 'em');
  } else if (node.nodeName === 'A') {
    // In jsdom-jscore, 'node.target' can be null.
    // TODO: Explore fixing this by patching jsdom-jscore.
    if (node.target && node.target.toLowerCase() === '_blank') {
      node.rel = 'noreferrer noopener';
    } else {
      node.removeAttribute('target');
      node.removeAttribute('rel');
    } // Saves anchor elements name attribute as id


    if (node.name && !node.id) {
      node.id = node.name;
    } // Keeps id only if there is an internal link pointing to it


    if (node.id && !node.ownerDocument.querySelector(`[href="#${node.id}"]`)) {
      node.removeAttribute('id');
    }
  }
}
//# sourceMappingURL=phrasing-content-reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/head-remover.js
function headRemover(node) {
  if (node.nodeName !== 'SCRIPT' && node.nodeName !== 'NOSCRIPT' && node.nodeName !== 'TEMPLATE' && node.nodeName !== 'STYLE') {
    return;
  }

  node.parentNode.removeChild(node);
}
//# sourceMappingURL=head-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/ms-list-converter.js
/**
 * Browser dependencies
 */
const {
  parseInt: ms_list_converter_parseInt
} = window;

function ms_list_converter_isList(node) {
  return node.nodeName === 'OL' || node.nodeName === 'UL';
}

function msListConverter(node, doc) {
  if (node.nodeName !== 'P') {
    return;
  }

  const style = node.getAttribute('style');

  if (!style) {
    return;
  } // Quick check.


  if (style.indexOf('mso-list') === -1) {
    return;
  }

  const matches = /mso-list\s*:[^;]+level([0-9]+)/i.exec(style);

  if (!matches) {
    return;
  }

  let level = ms_list_converter_parseInt(matches[1], 10) - 1 || 0;
  const prevNode = node.previousElementSibling; // Add new list if no previous.

  if (!prevNode || !ms_list_converter_isList(prevNode)) {
    // See https://html.spec.whatwg.org/multipage/grouping-content.html#attr-ol-type.
    const type = node.textContent.trim().slice(0, 1);
    const isNumeric = /[1iIaA]/.test(type);
    const newListNode = doc.createElement(isNumeric ? 'ol' : 'ul');

    if (isNumeric) {
      newListNode.setAttribute('type', type);
    }

    node.parentNode.insertBefore(newListNode, node);
  }

  const listNode = node.previousElementSibling;
  const listType = listNode.nodeName;
  const listItem = doc.createElement('li');
  let receivingNode = listNode; // Remove the first span with list info.

  node.removeChild(node.firstChild); // Add content.

  while (node.firstChild) {
    listItem.appendChild(node.firstChild);
  } // Change pointer depending on indentation level.


  while (level--) {
    receivingNode = receivingNode.lastChild || receivingNode; // If it's a list, move pointer to the last item.

    if (ms_list_converter_isList(receivingNode)) {
      receivingNode = receivingNode.lastChild || receivingNode;
    }
  } // Make sure we append to a list.


  if (!ms_list_converter_isList(receivingNode)) {
    receivingNode = receivingNode.appendChild(doc.createElement(listType));
  } // Append the list item to the list.


  receivingNode.appendChild(listItem); // Remove the wrapper paragraph.

  node.parentNode.removeChild(node);
}
//# sourceMappingURL=ms-list-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blob@3.47.0/node_modules/@wordpress/blob/build-module/index.js
/**
 * @type {Record<string, File|undefined>}
 */
const cache = {};

/**
 * Create a blob URL from a file.
 *
 * @param {File} file The file to create a blob URL for.
 *
 * @return {string} The blob URL.
 */
function createBlobURL(file) {
  const url = window.URL.createObjectURL(file);
  cache[url] = file;
  return url;
}

/**
 * Retrieve a file based on a blob URL. The file must have been created by
 * `createBlobURL` and not removed by `revokeBlobURL`, otherwise it will return
 * `undefined`.
 *
 * @param {string} url The blob URL.
 *
 * @return {File|undefined} The file for the blob URL.
 */
function getBlobByURL(url) {
  return cache[url];
}

/**
 * Retrieve a blob type based on URL. The file must have been created by
 * `createBlobURL` and not removed by `revokeBlobURL`, otherwise it will return
 * `undefined`.
 *
 * @param {string} url The blob URL.
 *
 * @return {string|undefined} The blob type.
 */
function getBlobTypeByURL(url) {
  return getBlobByURL(url)?.type.split('/')[0]; // 0: media type , 1: file extension eg ( type: 'image/jpeg' ).
}

/**
 * Remove the resource and file cache from memory.
 *
 * @param {string} url The blob URL.
 */
function revokeBlobURL(url) {
  if (cache[url]) {
    window.URL.revokeObjectURL(url);
  }
  delete cache[url];
}

/**
 * Check whether a url is a blob url.
 *
 * @param {string|undefined} url The URL.
 *
 * @return {boolean} Is the url a blob url?
 */
function isBlobURL(url) {
  if (!url || !url.indexOf) {
    return false;
  }
  return url.indexOf('blob:') === 0;
}

/**
 * Downloads a file, e.g., a text or readable stream, in the browser.
 * Appropriate for downloading smaller file sizes, e.g., < 5 MB.
 *
 * Example usage:
 *
 * ```js
 * 	const fileContent = JSON.stringify(
 * 		{
 * 			"title": "My Post",
 * 		},
 * 		null,
 * 		2
 * 	);
 * 	const filename = 'file.json';
 *
 * 	downloadBlob( filename, fileContent, 'application/json' );
 * ```
 *
 * @param {string}   filename    File name.
 * @param {BlobPart} content     File content (BufferSource | Blob | string).
 * @param {string}   contentType (Optional) File mime type. Default is `''`.
 */
function downloadBlob(filename, content, contentType = '') {
  if (!filename || !content) {
    return;
  }
  const file = new window.Blob([content], {
    type: contentType
  });
  const url = window.URL.createObjectURL(file);
  const anchorElement = document.createElement('a');
  anchorElement.href = url;
  anchorElement.download = filename;
  anchorElement.style.display = 'none';
  document.body.appendChild(anchorElement);
  anchorElement.click();
  document.body.removeChild(anchorElement);
  window.URL.revokeObjectURL(url);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/image-corrector.js
/**
 * WordPress dependencies
 */

/**
 * Browser dependencies
 */

const {
  atob,
  File
} = window;
function imageCorrector(node) {
  if (node.nodeName !== 'IMG') {
    return;
  }

  if (node.src.indexOf('file:') === 0) {
    node.src = '';
  } // This piece cannot be tested outside a browser env.


  if (node.src.indexOf('data:') === 0) {
    const [properties, data] = node.src.split(',');
    const [type] = properties.slice(5).split(';');

    if (!data || !type) {
      node.src = '';
      return;
    }

    let decoded; // Can throw DOMException!

    try {
      decoded = atob(data);
    } catch (e) {
      node.src = '';
      return;
    }

    const uint8Array = new Uint8Array(decoded.length);

    for (let i = 0; i < uint8Array.length; i++) {
      uint8Array[i] = decoded.charCodeAt(i);
    }

    const name = type.replace('/', '.');
    const file = new File([uint8Array], name, {
      type
    });
    node.src = createBlobURL(file);
  } // Remove trackers and hardly visible images.


  if (node.height === 1 || node.width === 1) {
    node.parentNode.removeChild(node);
  }
}
//# sourceMappingURL=image-corrector.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/div-normaliser.js
/**
 * Internal dependencies
 */

function divNormaliser(node) {
  if (node.nodeName !== 'DIV') {
    return;
  }

  node.innerHTML = normaliseBlocks(node.innerHTML);
}
//# sourceMappingURL=div-normaliser.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/showdown@1.9.1/node_modules/showdown/dist/showdown.js
var showdown = __webpack_require__("../../node_modules/.pnpm/showdown@1.9.1/node_modules/showdown/dist/showdown.js");
var showdown_default = /*#__PURE__*/__webpack_require__.n(showdown);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/markdown-converter.js
/**
 * External dependencies
 */
 // Reuse the same showdown converter.

const converter = new (showdown_default()).Converter({
  noHeaderId: true,
  tables: true,
  literalMidWordUnderscores: true,
  omitExtraWLInCodeBlocks: true,
  simpleLineBreaks: true,
  strikethrough: true
});
/**
 * Corrects the Slack Markdown variant of the code block.
 * If uncorrected, it will be converted to inline code.
 *
 * @see https://get.slack.help/hc/en-us/articles/202288908-how-can-i-add-formatting-to-my-messages-#code-blocks
 *
 * @param {string} text The potential Markdown text to correct.
 *
 * @return {string} The corrected Markdown.
 */

function slackMarkdownVariantCorrector(text) {
  return text.replace(/((?:^|\n)```)([^\n`]+)(```(?:$|\n))/, (match, p1, p2, p3) => `${p1}\n${p2}\n${p3}`);
}

function bulletsToAsterisks(text) {
  return text.replace(/(^|\n)•( +)/g, '$1*$2');
}
/**
 * Converts a piece of text into HTML based on any Markdown present.
 * Also decodes any encoded HTML.
 *
 * @param {string} text The plain text to convert.
 *
 * @return {string} HTML.
 */


function markdownConverter(text) {
  return converter.makeHtml(slackMarkdownVariantCorrector(bulletsToAsterisks(text)));
}
//# sourceMappingURL=markdown-converter.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/iframe-remover.js
/**
 * Removes iframes.
 *
 * @param {Node} node The node to check.
 *
 * @return {void}
 */
function iframeRemover(node) {
  if (node.nodeName === 'IFRAME') {
    const text = node.ownerDocument.createTextNode(node.src);
    node.parentNode.replaceChild(text, node);
  }
}
//# sourceMappingURL=iframe-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/google-docs-uid-remover.js
/**
 * WordPress dependencies
 */

function googleDocsUIdRemover(node) {
  if (!node.id || node.id.indexOf('docs-internal-guid-') !== 0) {
    return;
  } // Google Docs sometimes wraps the content in a B tag. We don't want to keep
  // this.


  if (node.tagName === 'B') {
    unwrap(node);
  } else {
    node.removeAttribute('id');
  }
}
//# sourceMappingURL=google-docs-uid-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/html-formatting-remover.js
/**
 * Internal dependencies
 */


function isFormattingSpace(character) {
  return character === ' ' || character === '\r' || character === '\n' || character === '\t';
}
/**
 * Removes spacing that formats HTML.
 *
 * @see https://www.w3.org/TR/css-text-3/#white-space-processing
 *
 * @param {Node} node The node to be processed.
 * @return {void}
 */


function htmlFormattingRemover(node) {
  if (node.nodeType !== node.TEXT_NODE) {
    return;
  } // Ignore pre content. Note that this does not use Element#closest due to
  // a combination of (a) node may not be Element and (b) node.parentElement
  // does not have full support in all browsers (Internet Exporer).
  //
  // See: https://developer.mozilla.org/en-US/docs/Web/API/Node/parentElement#Browser_compatibility

  /** @type {Node?} */


  let parent = node;

  while (parent = parent.parentNode) {
    if (parent.nodeType === parent.ELEMENT_NODE && parent.nodeName === 'PRE') {
      return;
    }
  } // First, replace any sequence of HTML formatting space with a single space.


  let newData = node.data.replace(/[ \r\n\t]+/g, ' '); // Remove the leading space if the text element is at the start of a block,
  // is preceded by a line break element, or has a space in the previous
  // node.

  if (newData[0] === ' ') {
    const previousSibling = getSibling(node, 'previous');

    if (!previousSibling || previousSibling.nodeName === 'BR' || previousSibling.textContent.slice(-1) === ' ') {
      newData = newData.slice(1);
    }
  } // Remove the trailing space if the text element is at the end of a block,
  // is succeded by a line break element, or has a space in the next text
  // node.


  if (newData[newData.length - 1] === ' ') {
    const nextSibling = getSibling(node, 'next');

    if (!nextSibling || nextSibling.nodeName === 'BR' || nextSibling.nodeType === nextSibling.TEXT_NODE && isFormattingSpace(nextSibling.textContent[0])) {
      newData = newData.slice(0, -1);
    }
  } // If there's no data left, remove the node, so `previousSibling` stays
  // accurate. Otherwise, update the node data.


  if (!newData) {
    node.parentNode.removeChild(node);
  } else {
    node.data = newData;
  }
}
//# sourceMappingURL=html-formatting-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/br-remover.js
/**
 * Internal dependencies
 */

/**
 * Removes trailing br elements from text-level content.
 *
 * @param {Element} node Node to check.
 */

function brRemover(node) {
  if (node.nodeName !== 'BR') {
    return;
  }

  if (getSibling(node, 'next')) {
    return;
  }

  node.parentNode.removeChild(node);
}
//# sourceMappingURL=br-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/empty-paragraph-remover.js
/**
 * Removes empty paragraph elements.
 *
 * @param {Element} node Node to check.
 */
function emptyParagraphRemover(node) {
  if (node.nodeName !== 'P') {
    return;
  }

  if (node.hasChildNodes()) {
    return;
  }

  node.parentNode.removeChild(node);
}
//# sourceMappingURL=empty-paragraph-remover.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/slack-paragraph-corrector.js
/**
 * Replaces Slack paragraph markup with a double line break (later converted to
 * a proper paragraph).
 *
 * @param {Element} node Node to check.
 */
function slackParagraphCorrector(node) {
  if (node.nodeName !== 'SPAN') {
    return;
  }

  if (node.getAttribute('data-stringify-type') !== 'paragraph-break') {
    return;
  }

  const {
    parentNode
  } = node;
  parentNode.insertBefore(node.ownerDocument.createElement('br'), node);
  parentNode.insertBefore(node.ownerDocument.createElement('br'), node);
  parentNode.removeChild(node);
}
//# sourceMappingURL=slack-paragraph-corrector.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/raw-handling/paste-handler.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


























/**
 * Browser dependencies
 */

const {
  console: paste_handler_console
} = window;
/**
 * Filters HTML to only contain phrasing content.
 *
 * @param {string}  HTML               The HTML to filter.
 * @param {boolean} preserveWhiteSpace Whether or not to preserve consequent white space.
 *
 * @return {string} HTML only containing phrasing content.
 */

function filterInlineHTML(HTML, preserveWhiteSpace) {
  HTML = deepFilterHTML(HTML, [googleDocsUIdRemover, phrasingContentReducer, commentRemover]);
  HTML = removeInvalidHTML(HTML, phrasing_content_getPhrasingContentSchema('paste'), {
    inline: true
  });

  if (!preserveWhiteSpace) {
    HTML = deepFilterHTML(HTML, [htmlFormattingRemover, brRemover]);
  } // Allows us to ask for this information when we get a report.


  paste_handler_console.log('Processed inline HTML:\n\n', HTML);
  return HTML;
}
/**
 * Converts an HTML string to known blocks. Strips everything else.
 *
 * @param {Object}  options
 * @param {string}  [options.HTML]               The HTML to convert.
 * @param {string}  [options.plainText]          Plain text version.
 * @param {string}  [options.mode]               Handle content as blocks or inline content.
 *                                               * 'AUTO': Decide based on the content passed.
 *                                               * 'INLINE': Always handle as inline content, and return string.
 *                                               * 'BLOCKS': Always handle as blocks, and return array of blocks.
 * @param {Array}   [options.tagName]            The tag into which content will be inserted.
 * @param {boolean} [options.preserveWhiteSpace] Whether or not to preserve consequent white space.
 *
 * @return {Array|string} A list of blocks or a string, depending on `handlerMode`.
 */


function pasteHandler(_ref) {
  let {
    HTML = '',
    plainText = '',
    mode = 'AUTO',
    tagName,
    preserveWhiteSpace
  } = _ref;
  // First of all, strip any meta tags.
  HTML = HTML.replace(/<meta[^>]+>/g, ''); // Strip Windows markers.

  HTML = HTML.replace(/^\s*<html[^>]*>\s*<body[^>]*>(?:\s*<!--\s*StartFragment\s*-->)?/i, '');
  HTML = HTML.replace(/(?:<!--\s*EndFragment\s*-->\s*)?<\/body>\s*<\/html>\s*$/i, ''); // If we detect block delimiters in HTML, parse entirely as blocks.

  if (mode !== 'INLINE') {
    // Check plain text if there is no HTML.
    const content = HTML ? HTML : plainText;

    if (content.indexOf('<!-- wp:') !== -1) {
      return parser_parse(content);
    }
  } // Normalize unicode to use composed characters.
  // This is unsupported in IE 11 but it's a nice-to-have feature, not mandatory.
  // Not normalizing the content will only affect older browsers and won't
  // entirely break the app.
  // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
  // See: https://core.trac.wordpress.org/ticket/30130
  // See: https://github.com/WordPress/gutenberg/pull/6983#pullrequestreview-125151075


  if (String.prototype.normalize) {
    HTML = HTML.normalize();
  } // Parse Markdown (and encoded HTML) if:
  // * There is a plain text version.
  // * There is no HTML version, or it has no formatting.


  if (plainText && (!HTML || isPlain(HTML))) {
    HTML = plainText; // The markdown converter (Showdown) trims whitespace.

    if (!/^\s+$/.test(plainText)) {
      HTML = markdownConverter(HTML);
    } // Switch to inline mode if:
    // * The current mode is AUTO.
    // * The original plain text had no line breaks.
    // * The original plain text was not an HTML paragraph.
    // * The converted text is just a paragraph.


    if (mode === 'AUTO' && plainText.indexOf('\n') === -1 && plainText.indexOf('<p>') !== 0 && HTML.indexOf('<p>') === 0) {
      mode = 'INLINE';
    }
  }

  if (mode === 'INLINE') {
    return filterInlineHTML(HTML, preserveWhiteSpace);
  } // Must be run before checking if it's inline content.


  HTML = deepFilterHTML(HTML, [slackParagraphCorrector]); // An array of HTML strings and block objects. The blocks replace matched
  // shortcodes.

  const pieces = shortcode_converter(HTML); // The call to shortcodeConverter will always return more than one element
  // if shortcodes are matched. The reason is when shortcodes are matched
  // empty HTML strings are included.

  const hasShortcodes = pieces.length > 1;

  if (mode === 'AUTO' && !hasShortcodes && isInlineContent(HTML, tagName)) {
    return filterInlineHTML(HTML, preserveWhiteSpace);
  }

  const phrasingContentSchema = phrasing_content_getPhrasingContentSchema('paste');
  const blockContentSchema = getBlockContentSchema('paste');
  const blocks = pieces.map(piece => {
    // Already a block from shortcode.
    if (typeof piece !== 'string') {
      return piece;
    }

    const filters = [googleDocsUIdRemover, msListConverter, headRemover, listReducer, imageCorrector, phrasingContentReducer, specialCommentConverter, commentRemover, iframeRemover, figureContentReducer, blockquoteNormaliser, divNormaliser];
    const schema = { ...blockContentSchema,
      // Keep top-level phrasing content, normalised by `normaliseBlocks`.
      ...phrasingContentSchema
    };
    piece = deepFilterHTML(piece, filters, blockContentSchema);
    piece = removeInvalidHTML(piece, schema);
    piece = normaliseBlocks(piece);
    piece = deepFilterHTML(piece, [htmlFormattingRemover, brRemover, emptyParagraphRemover], blockContentSchema); // Allows us to ask for this information when we get a report.

    paste_handler_console.log('Processed HTML piece:\n\n', piece);
    return htmlToBlocks(piece, pasteHandler);
  }).flat().filter(Boolean); // If we're allowed to return inline content, and there is only one
  // inlineable block, and the original plain text content does not have any
  // line breaks, then treat it as inline paste.

  if (mode === 'AUTO' && blocks.length === 1 && hasBlockSupport(blocks[0].name, '__unstablePasteTextInline', false)) {
    const trimRegex = /^[\n]+|[\n]+$/g; // Don't catch line breaks at the start or end.

    const trimmedPlainText = plainText.replace(trimRegex, '');

    if (trimmedPlainText !== '' && trimmedPlainText.indexOf('\n') === -1) {
      return removeInvalidHTML(getBlockInnerHTML(blocks[0]), phrasingContentSchema).replace(trimRegex, '');
    }
  }

  return blocks;
}
//# sourceMappingURL=paste-handler.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/templates.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Checks whether a list of blocks matches a template by comparing the block names.
 *
 * @param {Array} blocks   Block list.
 * @param {Array} template Block template.
 *
 * @return {boolean} Whether the list of blocks matches a templates.
 */

function doBlocksMatchTemplate() {
  let blocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return blocks.length === template.length && template.every((_ref, index) => {
    let [name,, innerBlocksTemplate] = _ref;
    const block = blocks[index];
    return name === block.name && doBlocksMatchTemplate(block.innerBlocks, innerBlocksTemplate);
  });
}
/**
 * Synchronize a block list with a block template.
 *
 * Synchronizing a block list with a block template means that we loop over the blocks
 * keep the block as is if it matches the block at the same position in the template
 * (If it has the same name) and if doesn't match, we create a new block based on the template.
 * Extra blocks not present in the template are removed.
 *
 * @param {Array} blocks   Block list.
 * @param {Array} template Block template.
 *
 * @return {Array} Updated Block list.
 */

function synchronizeBlocksWithTemplate() {
  let blocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let template = arguments.length > 1 ? arguments[1] : undefined;

  // If no template is provided, return blocks unmodified.
  if (!template) {
    return blocks;
  }

  return template.map((_ref2, index) => {
    var _blockType$attributes;

    let [name, attributes, innerBlocksTemplate] = _ref2;
    const block = blocks[index];

    if (block && block.name === name) {
      const innerBlocks = synchronizeBlocksWithTemplate(block.innerBlocks, innerBlocksTemplate);
      return { ...block,
        innerBlocks
      };
    } // To support old templates that were using the "children" format
    // for the attributes using "html" strings now, we normalize the template attributes
    // before creating the blocks.


    const blockType = getBlockType(name);

    const isHTMLAttribute = attributeDefinition => (attributeDefinition === null || attributeDefinition === void 0 ? void 0 : attributeDefinition.source) === 'html';

    const isQueryAttribute = attributeDefinition => (attributeDefinition === null || attributeDefinition === void 0 ? void 0 : attributeDefinition.source) === 'query';

    const normalizeAttributes = (schema, values) => {
      if (!values) {
        return {};
      }

      return Object.fromEntries(Object.entries(values).map(_ref3 => {
        let [key, value] = _ref3;
        return [key, normalizeAttribute(schema[key], value)];
      }));
    };

    const normalizeAttribute = (definition, value) => {
      if (isHTMLAttribute(definition) && Array.isArray(value)) {
        // Introduce a deprecated call at this point
        // When we're confident that "children" format should be removed from the templates.
        return (0,serialize/* default */.Ay)(value);
      }

      if (isQueryAttribute(definition) && value) {
        return value.map(subValues => {
          return normalizeAttributes(definition.query, subValues);
        });
      }

      return value;
    };

    const normalizedAttributes = normalizeAttributes((_blockType$attributes = blockType === null || blockType === void 0 ? void 0 : blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}, attributes);
    let [blockName, blockAttributes] = convertLegacyBlockNameAndAttributes(name, normalizedAttributes); // If a Block is undefined at this point, use the core/missing block as
    // a placeholder for a better user experience.

    if (undefined === getBlockType(blockName)) {
      blockAttributes = {
        originalName: name,
        originalContent: '',
        originalUndelimitedContent: ''
      };
      blockName = 'core/missing';
    }

    return createBlock(blockName, blockAttributes, synchronizeBlocksWithTemplate([], innerBlocksTemplate));
  });
}
//# sourceMappingURL=templates.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/api/index.js
// The blocktype is the most important concept within the block API. It defines
// all aspects of the block configuration and its interfaces, including `edit`
// and `save`. The transforms specification allows converting one blocktype to
// another through formulas defined by either the source or the destination.
// Switching a blocktype is to be considered a one-way operation implying a
// transformation in the opposite way has to be handled explicitly.
 // The block tree is composed of a collection of block nodes. Blocks contained
// within other blocks are called inner blocks. An important design
// consideration is that inner blocks are -- conceptually -- not part of the
// territory established by the parent block that contains them.
//
// This has multiple practical implications: when parsing, we can safely dispose
// of any block boundary found within a block from the innerHTML property when
// transfering to state. Not doing so would have a compounding effect on memory
// and uncertainty over the source of truth. This can be illustrated in how,
// given a tree of `n` nested blocks, the entry node would have to contain the
// actual content of each block while each subsequent block node in the state
// tree would replicate the entire chain `n-1`, meaning the extreme end node
// would have been replicated `n` times as the tree is traversed and would
// generate uncertainty as to which one is to hold the current value of the
// block. For composition, it also means inner blocks can effectively be child
// components whose mechanisms can be shielded from the `edit` implementation
// and just passed along.



 // While block transformations account for a specific surface of the API, there
// are also raw transformations which handle arbitrary sources not made out of
// blocks but producing block basaed on various heursitics. This includes
// pasting rich text or HTML data.

 // The process of serialization aims to deflate the internal memory of the block
// editor and its state representation back into an HTML valid string. This
// process restores the document integrity and inserts invisible delimiters
// around each block with HTML comment boundaries which can contain any extra
// attributes needed to operate with the block later on.

 // Validation is the process of comparing a block source with its output before
// there is any user input or interaction with a block. When this operation
// fails -- for whatever reason -- the block is to be considered invalid. As
// part of validating a block the system will attempt to run the source against
// any provided deprecation definitions.
//
// Worth emphasizing that validation is not a case of whether the markup is
// merely HTML spec-compliant but about how the editor knows to create such
// markup and that its inability to create an identical result can be a strong
// indicator of potential data loss (the invalidation is then a protective
// measure).
//
// The invalidation process can also be deconstructed in phases: 1) validate the
// block exists; 2) validate the source matches the output; 3) validate the
// source matches deprecated outputs; 4) work through the significance of
// differences. These are stacked in a way that favors performance and optimizes
// for the majority of cases. That is to say, the evaluation logic can become
// more sophisticated the further down it goes in the process as the cost is
// accounted for. The first logic checks have to be extremely efficient since
// they will be run for all valid and invalid blocks alike. However, once a
// block is detected as invalid -- failing the three first steps -- it is
// adequate to spend more time determining validity before throwing a conflict.


 // Blocks are inherently indifferent about where the data they operate with ends
// up being saved. For example, all blocks can have a static and dynamic aspect
// to them depending on the needs. The static nature of a block is the `save()`
// definition that is meant to be serialized into HTML and which can be left
// void. Any block can also register a `render_callback` on the server, which
// makes its output dynamic either in part or in its totality.
//
// Child blocks are defined as a relationship that builds on top of the inner
// blocks mechanism. A child block is a block node of a particular type that can
// only exist within the inner block boundaries of a specific parent type. This
// allows block authors to compose specific blocks that are not meant to be used
// outside of a specified parent block context. Thus, child blocks extend the
// concept of inner blocks to support a more direct relationship between sets of
// blocks. The addition of parent–child would be a subset of the inner block
// functionality under the premise that certain blocks only make sense as
// children of another block.


 // Templates are, in a general sense, a basic collection of block nodes with any
// given set of predefined attributes that are supplied as the initial state of
// an inner blocks group. These nodes can, in turn, contain any number of nested
// blocks within their definition. Templates allow both to specify a default
// state for an editor session or a default set of blocks for any inner block
// implementation within a specific block.





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+blocks@11.21.0_react@17.0.2/node_modules/@wordpress/blocks/build-module/index.js
// A "block" is the abstract term used to describe units of markup that,
// when composed together, form the content or layout of a page.
// The API for blocks is exposed via `wp.blocks`.
//
// Supported blocks are registered by calling `registerBlockType`. Once registered,
// the block is made available as an option to the editor interface.
//
// Blocks are inferred from the HTML source of a post through a parsing mechanism
// and then stored as objects in state, from which it is then rendered for editing.



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-constrained-tabbing/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@3.47.0/node_modules/@wordpress/keycodes/build-module/index.js");
/* harmony import */ var _wordpress_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/index.js");
/* harmony import */ var _use_ref_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js");
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * In Dialogs/modals, the tabbing must be constrained to the content of
 * the wrapper element. This hook adds the behavior to the returned ref.
 *
 * @return {import('react').RefCallback<Element>} Element Ref.
 *
 * @example
 * ```js
 * import { useConstrainedTabbing } from '@wordpress/compose';
 *
 * const ConstrainedTabbingExample = () => {
 *     const constrainedTabbingRef = useConstrainedTabbing()
 *     return (
 *         <div ref={ constrainedTabbingRef }>
 *             <Button />
 *             <Button />
 *         </div>
 *     );
 * }
 * ```
 */

function useConstrainedTabbing() {
  return (0,_use_ref_effect__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)((
  /** @type {HTMLElement} */
  node) => {
    /** @type {number|undefined} */
    let timeoutId;

    function onKeyDown(
    /** @type {KeyboardEvent} */
    event) {
      const {
        keyCode,
        shiftKey,
        target
      } = event;

      if (keyCode !== _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_1__/* .TAB */ .wn) {
        return;
      }

      const action = shiftKey ? 'findPrevious' : 'findNext';
      const nextElement = _wordpress_dom__WEBPACK_IMPORTED_MODULE_2__/* .focus */ .XC.tabbable[action](
      /** @type {HTMLElement} */
      target) || null; // If the element that is about to receive focus is outside the
      // area, move focus to a div and insert it at the start or end of
      // the area, depending on the direction. Without preventing default
      // behaviour, the browser will then move focus to the next element.

      if (node.contains(nextElement)) {
        return;
      }

      const domAction = shiftKey ? 'append' : 'prepend';
      const {
        ownerDocument
      } = node;
      const trap = ownerDocument.createElement('div');
      trap.tabIndex = -1;
      node[domAction](trap);
      trap.focus(); // Remove after the browser moves focus to the next element.

      timeoutId = setTimeout(() => node.removeChild(trap));
    }

    node.addEventListener('keydown', onKeyDown);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
      clearTimeout(timeoutId);
    };
  }, []);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useConstrainedTabbing);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-debounce/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useDebounce)
/* harmony export */ });
/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/use-memo-one@1.1.3_react@17.0.2/node_modules/use-memo-one/dist/use-memo-one.esm.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _utils_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/utils/debounce/index.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Debounces a function similar to Lodash's `debounce`. A new debounced function will
 * be returned and any scheduled calls cancelled if any of the arguments change,
 * including the function to debounce, so please wrap functions created on
 * render in components in `useCallback`.
 *
 * @see https://docs-lodash.com/v4/debounce/
 *
 * @template {(...args: any[]) => void} TFunc
 *
 * @param {TFunc}                                          fn        The function to debounce.
 * @param {number}                                         [wait]    The number of milliseconds to delay.
 * @param {import('../../utils/debounce').DebounceOptions} [options] The options object.
 * @return {import('../../utils/debounce').DebouncedFunc<TFunc>} Debounced function.
 */

function useDebounce(fn, wait, options) {
  const debounced = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_0__/* .useMemoOne */ .MA)(() => (0,_utils_debounce__WEBPACK_IMPORTED_MODULE_1__/* .debounce */ .s)(fn, wait !== null && wait !== void 0 ? wait : 0, options), [fn, wait, options]);
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_2__.useEffect)(() => () => debounced.cancel(), [debounced]);
  return debounced;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-dialog/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@3.47.0/node_modules/@wordpress/keycodes/build-module/index.js");
/* harmony import */ var _use_constrained_tabbing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-constrained-tabbing/index.js");
/* harmony import */ var _use_focus_on_mount__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-on-mount/index.js");
/* harmony import */ var _use_focus_return__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-return/index.js");
/* harmony import */ var _use_focus_outside__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-outside/index.js");
/* harmony import */ var _use_merge_refs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */







/**
 * Returns a ref and props to apply to a dialog wrapper to enable the following behaviors:
 *  - constrained tabbing.
 *  - focus on mount.
 *  - return focus on unmount.
 *  - focus outside.
 *
 * @param  options Dialog Options.
 */
function useDialog(options) {
  const currentOptions = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    currentOptions.current = options;
  }, Object.values(options));
  const constrainedTabbingRef = (0,_use_constrained_tabbing__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)();
  const focusOnMountRef = (0,_use_focus_on_mount__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(options.focusOnMount);
  const focusReturnRef = (0,_use_focus_return__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)();
  const focusOutsideProps = (0,_use_focus_outside__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(event => {
    var _currentOptions$curre, _currentOptions$curre2;

    // This unstable prop  is here only to manage backward compatibility
    // for the Popover component otherwise, the onClose should be enough.
    if ((_currentOptions$curre = currentOptions.current) !== null && _currentOptions$curre !== void 0 && _currentOptions$curre.__unstableOnClose) {
      currentOptions.current.__unstableOnClose('focus-outside', event);
    } else if ((_currentOptions$curre2 = currentOptions.current) !== null && _currentOptions$curre2 !== void 0 && _currentOptions$curre2.onClose) {
      currentOptions.current.onClose();
    }
  });
  const closeOnEscapeRef = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(node => {
    if (!node) {
      return;
    }

    node.addEventListener('keydown', event => {
      var _currentOptions$curre3;

      // Close on escape.
      if (event.keyCode === _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_5__/* .ESCAPE */ ._f && !event.defaultPrevented && (_currentOptions$curre3 = currentOptions.current) !== null && _currentOptions$curre3 !== void 0 && _currentOptions$curre3.onClose) {
        event.preventDefault();
        currentOptions.current.onClose();
      }
    });
  }, []);
  return [(0,_use_merge_refs__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)([options.focusOnMount !== false ? constrainedTabbingRef : null, options.focusOnMount !== false ? focusReturnRef : null, options.focusOnMount !== false ? focusOnMountRef : null, closeOnEscapeRef]), { ...focusOutsideProps,
    tabIndex: -1
  }];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useDialog);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-on-mount/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useFocusOnMount)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _wordpress_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/index.js");
/**
 * WordPress dependencies
 */


/**
 * Hook used to focus the first tabbable element on mount.
 *
 * @param {boolean | 'firstElement'} focusOnMount Focus on mount mode.
 * @return {import('react').RefCallback<HTMLElement>} Ref callback.
 *
 * @example
 * ```js
 * import { useFocusOnMount } from '@wordpress/compose';
 *
 * const WithFocusOnMount = () => {
 *     const ref = useFocusOnMount()
 *     return (
 *         <div ref={ ref }>
 *             <Button />
 *             <Button />
 *         </div>
 *     );
 * }
 * ```
 */

function useFocusOnMount() {
  let focusOnMount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'firstElement';
  const focusOnMountRef = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(focusOnMount);
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    focusOnMountRef.current = focusOnMount;
  }, [focusOnMount]);
  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(node => {
    var _node$ownerDocument$a, _node$ownerDocument;

    if (!node || focusOnMountRef.current === false) {
      return;
    }

    if (node.contains((_node$ownerDocument$a = (_node$ownerDocument = node.ownerDocument) === null || _node$ownerDocument === void 0 ? void 0 : _node$ownerDocument.activeElement) !== null && _node$ownerDocument$a !== void 0 ? _node$ownerDocument$a : null)) {
      return;
    }

    let target = node;

    if (focusOnMountRef.current === 'firstElement') {
      const firstTabbable = _wordpress_dom__WEBPACK_IMPORTED_MODULE_1__/* .focus */ .XC.tabbable.find(node)[0];

      if (firstTabbable) {
        target =
        /** @type {HTMLElement} */
        firstTabbable;
      }
    }

    target.focus({
      // When focusing newly mounted dialogs,
      // the position of the popover is often not right on the first render
      // This prevents the layout shifts when focusing the dialogs.
      preventScroll: true
    });
  }, []);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-outside/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useFocusOutside)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Input types which are classified as button types, for use in considering
 * whether element is a (focus-normalized) button.
 */

const INPUT_BUTTON_TYPES = ['button', 'submit'];
/**
 * List of HTML button elements subject to focus normalization
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
 */

/**
 * Returns true if the given element is a button element subject to focus
 * normalization, or false otherwise.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
 *
 * @param  eventTarget The target from a mouse or touch event.
 *
 * @return Whether the element is a button element subject to focus normalization.
 */
function isFocusNormalizedButton(eventTarget) {
  if (!(eventTarget instanceof window.HTMLElement)) {
    return false;
  }

  switch (eventTarget.nodeName) {
    case 'A':
    case 'BUTTON':
      return true;

    case 'INPUT':
      return INPUT_BUTTON_TYPES.includes(eventTarget.type);
  }

  return false;
}

/**
 * A react hook that can be used to check whether focus has moved outside the
 * element the event handlers are bound to.
 *
 * @param  onFocusOutside A callback triggered when focus moves outside
 *                        the element the event handlers are bound to.
 *
 * @return An object containing event handlers. Bind the event handlers to a
 * wrapping element element to capture when focus moves outside that element.
 */
function useFocusOutside(onFocusOutside) {
  const currentOnFocusOutside = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(onFocusOutside);
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    currentOnFocusOutside.current = onFocusOutside;
  }, [onFocusOutside]);
  const preventBlurCheck = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  const blurCheckTimeoutId = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  /**
   * Cancel a blur check timeout.
   */

  const cancelBlurCheck = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    clearTimeout(blurCheckTimeoutId.current);
  }, []); // Cancel blur checks on unmount.

  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    return () => cancelBlurCheck();
  }, []); // Cancel a blur check if the callback or ref is no longer provided.

  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!onFocusOutside) {
      cancelBlurCheck();
    }
  }, [onFocusOutside, cancelBlurCheck]);
  /**
   * Handles a mousedown or mouseup event to respectively assign and
   * unassign a flag for preventing blur check on button elements. Some
   * browsers, namely Firefox and Safari, do not emit a focus event on
   * button elements when clicked, while others do. The logic here
   * intends to normalize this as treating click on buttons as focus.
   *
   * @param  event
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
   */

  const normalizeButtonFocus = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(event => {
    const {
      type,
      target
    } = event;
    const isInteractionEnd = ['mouseup', 'touchend'].includes(type);

    if (isInteractionEnd) {
      preventBlurCheck.current = false;
    } else if (isFocusNormalizedButton(target)) {
      preventBlurCheck.current = true;
    }
  }, []);
  /**
   * A callback triggered when a blur event occurs on the element the handler
   * is bound to.
   *
   * Calls the `onFocusOutside` callback in an immediate timeout if focus has
   * move outside the bound element and is still within the document.
   */

  const queueBlurCheck = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(event => {
    // React does not allow using an event reference asynchronously
    // due to recycling behavior, except when explicitly persisted.
    event.persist(); // Skip blur check if clicking button. See `normalizeButtonFocus`.

    if (preventBlurCheck.current) {
      return;
    }

    blurCheckTimeoutId.current = setTimeout(() => {
      // If document is not focused then focus should remain
      // inside the wrapped component and therefore we cancel
      // this blur event thereby leaving focus in place.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/hasFocus.
      if (!document.hasFocus()) {
        event.preventDefault();
        return;
      }

      if ('function' === typeof currentOnFocusOutside.current) {
        currentOnFocusOutside.current(event);
      }
    }, 0);
  }, []);
  return {
    onFocus: cancelBlurCheck,
    onMouseDown: normalizeButtonFocus,
    onMouseUp: normalizeButtonFocus,
    onTouchStart: normalizeButtonFocus,
    onTouchEnd: normalizeButtonFocus,
    onBlur: queueBlurCheck
  };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-focus-return/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * WordPress dependencies
 */

/**
 * When opening modals/sidebars/dialogs, the focus
 * must move to the opened area and return to the
 * previously focused element when closed.
 * The current hook implements the returning behavior.
 *
 * @param {() => void} [onFocusReturn] Overrides the default return behavior.
 * @return {import('react').RefCallback<HTMLElement>} Element Ref.
 *
 * @example
 * ```js
 * import { useFocusReturn } from '@wordpress/compose';
 *
 * const WithFocusReturn = () => {
 *     const ref = useFocusReturn()
 *     return (
 *         <div ref={ ref }>
 *             <Button />
 *             <Button />
 *         </div>
 *     );
 * }
 * ```
 */

function useFocusReturn(onFocusReturn) {
  /** @type {import('react').MutableRefObject<null | HTMLElement>} */
  const ref = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  /** @type {import('react').MutableRefObject<null | Element>} */

  const focusedBeforeMount = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const onFocusReturnRef = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(onFocusReturn);
  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    onFocusReturnRef.current = onFocusReturn;
  }, [onFocusReturn]);
  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(node => {
    if (node) {
      // Set ref to be used when unmounting.
      ref.current = node; // Only set when the node mounts.

      if (focusedBeforeMount.current) {
        return;
      }

      focusedBeforeMount.current = node.ownerDocument.activeElement;
    } else if (focusedBeforeMount.current) {
      var _ref$current, _ref$current2, _ref$current3;

      const isFocused = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.contains((_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.ownerDocument.activeElement);

      if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.isConnected && !isFocused) {
        return;
      } // Defer to the component's own explicit focus return behavior, if
      // specified. This allows for support that the `onFocusReturn`
      // decides to allow the default behavior to occur under some
      // conditions.


      if (onFocusReturnRef.current) {
        onFocusReturnRef.current();
      } else {
        var _focusedBeforeMount$c;

        /** @type {null | HTMLElement} */
        (_focusedBeforeMount$c = focusedBeforeMount.current) === null || _focusedBeforeMount$c === void 0 ? void 0 : _focusedBeforeMount$c.focus();
      }
    }
  }, []);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useFocusReturn);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * WordPress dependencies
 */

const instanceMap = new WeakMap();
/**
 * Creates a new id for a given object.
 *
 * @param  object Object reference to create an id for.
 * @return The instance id (index).
 */

function createId(object) {
  const instances = instanceMap.get(object) || 0;
  instanceMap.set(object, instances + 1);
  return instances;
}
/**
 * Specify the useInstanceId *function* signatures.
 *
 * More accurately, useInstanceId distinguishes between three different
 * signatures:
 *
 * 1. When only object is given, the returned value is a number
 * 2. When object and prefix is given, the returned value is a string
 * 3. When preferredId is given, the returned value is the type of preferredId
 */


/**
 * Provides a unique instance ID.
 *
 * @param  object        Object reference to create an id for.
 * @param  [prefix]      Prefix for the unique id.
 * @param  [preferredId] Default ID to use.
 * @return The unique instance id.
 */
function useInstanceId(object, prefix, preferredId) {
  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (preferredId) return preferredId;
    const id = createId(object);
    return prefix ? `${prefix}-${id}` : id;
  }, [object]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useInstanceId);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useMergeRefs)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * WordPress dependencies
 */

/* eslint-disable jsdoc/valid-types */

/**
 * @template T
 * @typedef {T extends import('react').Ref<infer R> ? R : never} TypeFromRef
 */

/* eslint-enable jsdoc/valid-types */

/**
 * @template T
 * @param {import('react').Ref<T>} ref
 * @param {T}                      value
 */

function assignRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref && ref.hasOwnProperty('current')) {
    /* eslint-disable jsdoc/no-undefined-types */

    /** @type {import('react').MutableRefObject<T>} */
    ref.current = value;
    /* eslint-enable jsdoc/no-undefined-types */
  }
}
/**
 * Merges refs into one ref callback.
 *
 * It also ensures that the merged ref callbacks are only called when they
 * change (as a result of a `useCallback` dependency update) OR when the ref
 * value changes, just as React does when passing a single ref callback to the
 * component.
 *
 * As expected, if you pass a new function on every render, the ref callback
 * will be called after every render.
 *
 * If you don't wish a ref callback to be called after every render, wrap it
 * with `useCallback( callback, dependencies )`. When a dependency changes, the
 * old ref callback will be called with `null` and the new ref callback will be
 * called with the same value.
 *
 * To make ref callbacks easier to use, you can also pass the result of
 * `useRefEffect`, which makes cleanup easier by allowing you to return a
 * cleanup function instead of handling `null`.
 *
 * It's also possible to _disable_ a ref (and its behaviour) by simply not
 * passing the ref.
 *
 * ```jsx
 * const ref = useRefEffect( ( node ) => {
 *   node.addEventListener( ... );
 *   return () => {
 *     node.removeEventListener( ... );
 *   };
 * }, [ ...dependencies ] );
 * const otherRef = useRef();
 * const mergedRefs useMergeRefs( [
 *   enabled && ref,
 *   otherRef,
 * ] );
 * return <div ref={ mergedRefs } />;
 * ```
 *
 * @template {import('react').Ref<any>} TRef
 * @param {Array<TRef>} refs The refs to be merged.
 *
 * @return {import('react').RefCallback<TypeFromRef<TRef>>} The merged ref callback.
 */


function useMergeRefs(refs) {
  const element = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  const isAttached = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  const didElementChange = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  /* eslint-disable jsdoc/no-undefined-types */

  /** @type {import('react').MutableRefObject<TRef[]>} */

  /* eslint-enable jsdoc/no-undefined-types */

  const previousRefs = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);
  const currentRefs = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)(refs); // Update on render before the ref callback is called, so the ref callback
  // always has access to the current refs.

  currentRefs.current = refs; // If any of the refs change, call the previous ref with `null` and the new
  // ref with the node, except when the element changes in the same cycle, in
  // which case the ref callbacks will already have been called.

  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    if (didElementChange.current === false && isAttached.current === true) {
      refs.forEach((ref, index) => {
        const previousRef = previousRefs.current[index];

        if (ref !== previousRef) {
          assignRef(previousRef, null);
          assignRef(ref, element.current);
        }
      });
    }

    previousRefs.current = refs;
  }, refs); // No dependencies, must be reset after every render so ref callbacks are
  // correctly called after a ref change.

  (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    didElementChange.current = false;
  }); // There should be no dependencies so that `callback` is only called when
  // the node changes.

  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(value => {
    // Update the element so it can be used when calling ref callbacks on a
    // dependency change.
    assignRef(element, value);
    didElementChange.current = true;
    isAttached.current = value !== null; // When an element changes, the current ref callback should be called
    // with the new element and the previous one with `null`.

    const refsToAssign = value ? currentRefs.current : previousRefs.current; // Update the latest refs.

    for (const ref of refsToAssign) {
      assignRef(ref, value);
    }
  }, []);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+compose@5.20.0_react@17.0.2/node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useRefEffect)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Effect-like ref callback. Just like with `useEffect`, this allows you to
 * return a cleanup function to be run if the ref changes or one of the
 * dependencies changes. The ref is provided as an argument to the callback
 * functions. The main difference between this and `useEffect` is that
 * the `useEffect` callback is not called when the ref changes, but this is.
 * Pass the returned ref callback as the component's ref and merge multiple refs
 * with `useMergeRefs`.
 *
 * It's worth noting that if the dependencies array is empty, there's not
 * strictly a need to clean up event handlers for example, because the node is
 * to be removed. It *is* necessary if you add dependencies because the ref
 * callback will be called multiple times for the same node.
 *
 * @param  callback     Callback with ref as argument.
 * @param  dependencies Dependencies of the callback.
 *
 * @return Ref callback.
 */

function useRefEffect(callback, dependencies) {
  const cleanup = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useCallback)(node => {
    if (node) {
      cleanup.current = callback(node);
    } else if (cleanup.current) {
      cleanup.current();
    }
  }, dependencies);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ useRegistry)
/* harmony export */ });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/context.js");
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * A custom react hook exposing the registry context for use.
 *
 * This exposes the `registry` value provided via the
 * <a href="#RegistryProvider">Registry Provider</a> to a component implementing
 * this hook.
 *
 * It acts similarly to the `useContext` react hook.
 *
 * Note: Generally speaking, `useRegistry` is a low level hook that in most cases
 * won't be needed for implementation. Most interactions with the `@wordpress/data`
 * API can be performed via the `useSelect` hook,  or the `withSelect` and
 * `withDispatch` higher order components.
 *
 * @example
 * ```js
 * import {
 *   RegistryProvider,
 *   createRegistry,
 *   useRegistry,
 * } from '@wordpress/data';
 *
 * const registry = createRegistry( {} );
 *
 * const SomeChildUsingRegistry = ( props ) => {
 *   const registry = useRegistry();
 *   // ...logic implementing the registry in other react hooks.
 * };
 *
 *
 * const ParentProvidingRegistry = ( props ) => {
 *   return <RegistryProvider value={ registry }>
 *     <SomeChildUsingRegistry { ...props } />
 *   </RegistryProvider>
 * };
 * ```
 *
 * @return {Function}  A custom react hook exposing the registry context value.
 */
function useRegistry() {
  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_1__/* .Context */ .ob);
}
//# sourceMappingURL=use-registry.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _registry_provider_use_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js");
/**
 * Internal dependencies
 */


/**
 * @typedef {import('../../types').StoreDescriptor<StoreConfig>} StoreDescriptor
 * @template {import('../../types').AnyConfig} StoreConfig
 */
/**
 * @typedef {import('../../types').UseDispatchReturn<StoreNameOrDescriptor>} UseDispatchReturn
 * @template StoreNameOrDescriptor
 */

/**
 * A custom react hook returning the current registry dispatch actions creators.
 *
 * Note: The component using this hook must be within the context of a
 * RegistryProvider.
 *
 * @template {undefined | string | StoreDescriptor<any>} StoreNameOrDescriptor
 * @param {StoreNameOrDescriptor} [storeNameOrDescriptor] Optionally provide the name of the
 *                                                        store or its descriptor from which to
 *                                                        retrieve action creators. If not
 *                                                        provided, the registry.dispatch
 *                                                        function is returned instead.
 *
 * @example
 * This illustrates a pattern where you may need to retrieve dynamic data from
 * the server via the `useSelect` hook to use in combination with the dispatch
 * action.
 *
 * ```jsx
 * import { useCallback } from 'react';
 * import { useDispatch, useSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function Button( { onClick, children } ) {
 *   return <button type="button" onClick={ onClick }>{ children }</button>
 * }
 *
 * const SaleButton = ( { children } ) => {
 *   const { stockNumber } = useSelect(
 *     ( select ) => select( myCustomStore ).getStockNumber(),
 *     []
 *   );
 *   const { startSale } = useDispatch( myCustomStore );
 *   const onClick = useCallback( () => {
 *     const discountPercent = stockNumber > 50 ? 10: 20;
 *     startSale( discountPercent );
 *   }, [ stockNumber ] );
 *   return <Button onClick={ onClick }>{ children }</Button>
 * }
 *
 * // Rendered somewhere in the application:
 * //
 * // <SaleButton>Start Sale!</SaleButton>
 * ```
 * @return {UseDispatchReturn<StoreNameOrDescriptor>} A custom react hook.
 */
const useDispatch = storeNameOrDescriptor => {
  const {
    dispatch
  } = (0,_registry_provider_use_registry__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)();
  return storeNameOrDescriptor === void 0 ? dispatch : dispatch(storeNameOrDescriptor);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useDispatch);
//# sourceMappingURL=use-dispatch.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/use-select/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ useSelect)
});

// UNUSED EXPORTS: useSuspenseSelect

// EXTERNAL MODULE: ../../node_modules/.pnpm/requestidlecallback@0.3.0/node_modules/requestidlecallback/index.js
var requestidlecallback = __webpack_require__("../../node_modules/.pnpm/requestidlecallback@0.3.0/node_modules/requestidlecallback/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+priority-queue@3.6.0/node_modules/@wordpress/priority-queue/build-module/request-idle-callback.js
/**
 * External dependencies
 */


/**
 * @typedef {( timeOrDeadline: IdleDeadline | number ) => void} Callback
 */

/**
 * @return {(callback: Callback) => void} RequestIdleCallback
 */
function createRequestIdleCallback() {
  if (typeof window === 'undefined') {
    return callback => {
      setTimeout(() => callback(Date.now()), 0);
    };
  }
  return window.requestIdleCallback;
}
/* harmony default export */ const request_idle_callback = (createRequestIdleCallback());
//# sourceMappingURL=request-idle-callback.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+priority-queue@3.6.0/node_modules/@wordpress/priority-queue/build-module/index.js
/**
 * Internal dependencies
 */


/**
 * Enqueued callback to invoke once idle time permits.
 *
 * @typedef {()=>void} WPPriorityQueueCallback
 */

/**
 * An object used to associate callbacks in a particular context grouping.
 *
 * @typedef {{}} WPPriorityQueueContext
 */

/**
 * Function to add callback to priority queue.
 *
 * @typedef {(element:WPPriorityQueueContext,item:WPPriorityQueueCallback)=>void} WPPriorityQueueAdd
 */

/**
 * Function to flush callbacks from priority queue.
 *
 * @typedef {(element:WPPriorityQueueContext)=>boolean} WPPriorityQueueFlush
 */

/**
 * Reset the queue.
 *
 * @typedef {()=>void} WPPriorityQueueReset
 */

/**
 * Priority queue instance.
 *
 * @typedef {Object} WPPriorityQueue
 *
 * @property {WPPriorityQueueAdd}   add    Add callback to queue for context.
 * @property {WPPriorityQueueFlush} flush  Flush queue for context.
 * @property {WPPriorityQueueFlush} cancel Clear queue for context.
 * @property {WPPriorityQueueReset} reset  Reset queue.
 */

/**
 * Creates a context-aware queue that only executes
 * the last task of a given context.
 *
 * @example
 *```js
 * import { createQueue } from '@wordpress/priority-queue';
 *
 * const queue = createQueue();
 *
 * // Context objects.
 * const ctx1 = {};
 * const ctx2 = {};
 *
 * // For a given context in the queue, only the last callback is executed.
 * queue.add( ctx1, () => console.log( 'This will be printed first' ) );
 * queue.add( ctx2, () => console.log( 'This won\'t be printed' ) );
 * queue.add( ctx2, () => console.log( 'This will be printed second' ) );
 *```
 *
 * @return {WPPriorityQueue} Queue object with `add`, `flush` and `reset` methods.
 */
const createQueue = () => {
  /** @type {Map<WPPriorityQueueContext, WPPriorityQueueCallback>} */
  const waitingList = new Map();
  let isRunning = false;

  /**
   * Callback to process as much queue as time permits.
   *
   * Map Iteration follows the original insertion order. This means that here
   * we can iterate the queue and know that the first contexts which were
   * added will be run first. On the other hand, if anyone adds a new callback
   * for an existing context it will supplant the previously-set callback for
   * that context because we reassigned that map key's value.
   *
   * In the case that a callback adds a new callback to its own context then
   * the callback it adds will appear at the end of the iteration and will be
   * run only after all other existing contexts have finished executing.
   *
   * @param {IdleDeadline|number} deadline Idle callback deadline object, or
   *                                       animation frame timestamp.
   */
  const runWaitingList = deadline => {
    for (const [nextElement, callback] of waitingList) {
      waitingList.delete(nextElement);
      callback();
      if ('number' === typeof deadline || deadline.timeRemaining() <= 0) {
        break;
      }
    }
    if (waitingList.size === 0) {
      isRunning = false;
      return;
    }
    request_idle_callback(runWaitingList);
  };

  /**
   * Add a callback to the queue for a given context.
   *
   * If errors with undefined callbacks are encountered double check that
   * all of your useSelect calls have the right dependencies set correctly
   * in their second parameter. Missing dependencies can cause unexpected
   * loops and race conditions in the queue.
   *
   * @type {WPPriorityQueueAdd}
   *
   * @param {WPPriorityQueueContext}  element Context object.
   * @param {WPPriorityQueueCallback} item    Callback function.
   */
  const add = (element, item) => {
    waitingList.set(element, item);
    if (!isRunning) {
      isRunning = true;
      request_idle_callback(runWaitingList);
    }
  };

  /**
   * Flushes queue for a given context, returning true if the flush was
   * performed, or false if there is no queue for the given context.
   *
   * @type {WPPriorityQueueFlush}
   *
   * @param {WPPriorityQueueContext} element Context object.
   *
   * @return {boolean} Whether flush was performed.
   */
  const flush = element => {
    const callback = waitingList.get(element);
    if (undefined === callback) {
      return false;
    }
    waitingList.delete(element);
    callback();
    return true;
  };

  /**
   * Clears the queue for a given context, cancelling the callbacks without
   * executing them. Returns `true` if there were scheduled callbacks to cancel,
   * or `false` if there was is no queue for the given context.
   *
   * @type {WPPriorityQueueFlush}
   *
   * @param {WPPriorityQueueContext} element Context object.
   *
   * @return {boolean} Whether any callbacks got cancelled.
   */
  const cancel = element => {
    return waitingList.delete(element);
  };

  /**
   * Reset the queue without running the pending callbacks.
   *
   * @type {WPPriorityQueueReset}
   */
  const reset = () => {
    waitingList.clear();
    isRunning = false;
  };
  return {
    add,
    flush,
    cancel,
    reset
  };
};
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.6.0/node_modules/@wordpress/is-shallow-equal/build-module/objects.js
/**
 * Returns true if the two objects are shallow equal, or false otherwise.
 *
 * @param {import('.').ComparableObject} a First object to compare.
 * @param {import('.').ComparableObject} b Second object to compare.
 *
 * @return {boolean} Whether the two objects are shallow equal.
 */
function isShallowEqualObjects(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  let i = 0;
  while (i < aKeys.length) {
    const key = aKeys[i];
    const aValue = a[key];
    if (
    // In iterating only the keys of the first object after verifying
    // equal lengths, account for the case that an explicit `undefined`
    // value in the first is implicitly undefined in the second.
    //
    // Example: isShallowEqualObjects( { a: undefined }, { b: 5 } )
    aValue === undefined && !b.hasOwnProperty(key) || aValue !== b[key]) {
      return false;
    }
    i++;
  }
  return true;
}
//# sourceMappingURL=objects.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.6.0/node_modules/@wordpress/is-shallow-equal/build-module/arrays.js
/**
 * Returns true if the two arrays are shallow equal, or false otherwise.
 *
 * @param {any[]} a First array to compare.
 * @param {any[]} b Second array to compare.
 *
 * @return {boolean} Whether the two arrays are shallow equal.
 */
function isShallowEqualArrays(a, b) {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0, len = a.length; i < len; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
//# sourceMappingURL=arrays.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+is-shallow-equal@5.6.0/node_modules/@wordpress/is-shallow-equal/build-module/index.js
/**
 * Internal dependencies
 */





/**
 * @typedef {Record<string, any>} ComparableObject
 */

/**
 * Returns true if the two arrays or objects are shallow equal, or false
 * otherwise. Also handles primitive values, just in case.
 *
 * @param {unknown} a First object or array to compare.
 * @param {unknown} b Second object or array to compare.
 *
 * @return {boolean} Whether the two values are shallow equal.
 */
function isShallowEqual(a, b) {
  if (a && b) {
    if (a.constructor === Object && b.constructor === Object) {
      return isShallowEqualObjects(a, b);
    } else if (Array.isArray(a) && Array.isArray(b)) {
      return isShallowEqualArrays(a, b);
    }
  }
  return a === b;
}
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js
var use_registry = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/async-mode-provider/context.js
/**
 * WordPress dependencies
 */

const Context = (0,react.createContext)(false);
const {
  Consumer,
  Provider
} = Context;
const AsyncModeConsumer = (/* unused pure expression or super */ null && (Consumer));

/**
 * Context Provider Component used to switch the data module component rerendering
 * between Sync and Async modes.
 *
 * @example
 *
 * ```js
 * import { useSelect, AsyncModeProvider } from '@wordpress/data';
 * import { store as blockEditorStore } from '@wordpress/block-editor';
 *
 * function BlockCount() {
 *   const count = useSelect( ( select ) => {
 *     return select( blockEditorStore ).getBlockCount()
 *   }, [] );
 *
 *   return count;
 * }
 *
 * function App() {
 *   return (
 *     <AsyncModeProvider value={ true }>
 *       <BlockCount />
 *     </AsyncModeProvider>
 *   );
 * }
 * ```
 *
 * In this example, the BlockCount component is rerendered asynchronously.
 * It means if a more critical task is being performed (like typing in an input),
 * the rerendering is delayed until the browser becomes IDLE.
 * It is possible to nest multiple levels of AsyncModeProvider to fine-tune the rendering behavior.
 *
 * @param {boolean} props.value Enable Async Mode.
 * @return {Component} The component to be rendered.
 */
/* harmony default export */ const context = ((/* unused pure expression or super */ null && (Provider)));
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/async-mode-provider/use-async-mode.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */

function useAsyncMode() {
  return (0,react.useContext)(Context);
}
//# sourceMappingURL=use-async-mode.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+data@10.6.0_react@17.0.2/node_modules/@wordpress/data/build-module/components/use-select/index.js
/**
 * WordPress dependencies
 */




/**
 * Internal dependencies
 */


const renderQueue = createQueue();

/**
 * @typedef {import('../../types').StoreDescriptor<C>} StoreDescriptor
 * @template {import('../../types').AnyConfig} C
 */
/**
 * @typedef {import('../../types').ReduxStoreConfig<State,Actions,Selectors>} ReduxStoreConfig
 * @template State
 * @template {Record<string,import('../../types').ActionCreator>} Actions
 * @template Selectors
 */
/** @typedef {import('../../types').MapSelect} MapSelect */
/**
 * @typedef {import('../../types').UseSelectReturn<T>} UseSelectReturn
 * @template {MapSelect|StoreDescriptor<any>} T
 */

function Store(registry, suspense) {
  const select = suspense ? registry.suspendSelect : registry.select;
  const queueContext = {};
  let lastMapSelect;
  let lastMapResult;
  let lastMapResultValid = false;
  let lastIsAsync;
  let subscriber;
  let didWarnUnstableReference;
  const storeStatesOnMount = new Map();
  function getStoreState(name) {
    var _registry$stores$name;
    // If there's no store property (custom generic store), return an empty
    // object. When comparing the state, the empty objects will cause the
    // equality check to fail, setting `lastMapResultValid` to false.
    return (_registry$stores$name = registry.stores[name]?.store?.getState?.()) !== null && _registry$stores$name !== void 0 ? _registry$stores$name : {};
  }
  const createSubscriber = stores => {
    // The set of stores the `subscribe` function is supposed to subscribe to. Here it is
    // initialized, and then the `updateStores` function can add new stores to it.
    const activeStores = [...stores];

    // The `subscribe` function, which is passed to the `useSyncExternalStore` hook, could
    // be called multiple times to establish multiple subscriptions. That's why we need to
    // keep a set of active subscriptions;
    const activeSubscriptions = new Set();
    function subscribe(listener) {
      // Maybe invalidate the value right after subscription was created.
      // React will call `getValue` after subscribing, to detect store
      // updates that happened in the interval between the `getValue` call
      // during render and creating the subscription, which is slightly
      // delayed. We need to ensure that this second `getValue` call will
      // compute a fresh value only if any of the store states have
      // changed in the meantime.
      if (lastMapResultValid) {
        for (const name of activeStores) {
          if (storeStatesOnMount.get(name) !== getStoreState(name)) {
            lastMapResultValid = false;
          }
        }
      }
      storeStatesOnMount.clear();
      const onStoreChange = () => {
        // Invalidate the value on store update, so that a fresh value is computed.
        lastMapResultValid = false;
        listener();
      };
      const onChange = () => {
        if (lastIsAsync) {
          renderQueue.add(queueContext, onStoreChange);
        } else {
          onStoreChange();
        }
      };
      const unsubs = [];
      function subscribeStore(storeName) {
        unsubs.push(registry.subscribe(onChange, storeName));
      }
      for (const storeName of activeStores) {
        subscribeStore(storeName);
      }
      activeSubscriptions.add(subscribeStore);
      return () => {
        activeSubscriptions.delete(subscribeStore);
        for (const unsub of unsubs.values()) {
          // The return value of the subscribe function could be undefined if the store is a custom generic store.
          unsub?.();
        }
        // Cancel existing store updates that were already scheduled.
        renderQueue.cancel(queueContext);
      };
    }

    // Check if `newStores` contains some stores we're not subscribed to yet, and add them.
    function updateStores(newStores) {
      for (const newStore of newStores) {
        if (activeStores.includes(newStore)) {
          continue;
        }

        // New `subscribe` calls will subscribe to `newStore`, too.
        activeStores.push(newStore);

        // Add `newStore` to existing subscriptions.
        for (const subscription of activeSubscriptions) {
          subscription(newStore);
        }
      }
    }
    return {
      subscribe,
      updateStores
    };
  };
  return (mapSelect, isAsync) => {
    function updateValue() {
      // If the last value is valid, and the `mapSelect` callback hasn't changed,
      // then we can safely return the cached value. The value can change only on
      // store update, and in that case value will be invalidated by the listener.
      if (lastMapResultValid && mapSelect === lastMapSelect) {
        return lastMapResult;
      }
      const listeningStores = {
        current: null
      };
      const mapResult = registry.__unstableMarkListeningStores(() => mapSelect(select, registry), listeningStores);
      if (false) {}
      if (!subscriber) {
        for (const name of listeningStores.current) {
          storeStatesOnMount.set(name, getStoreState(name));
        }
        subscriber = createSubscriber(listeningStores.current);
      } else {
        subscriber.updateStores(listeningStores.current);
      }

      // If the new value is shallow-equal to the old one, keep the old one so
      // that we don't trigger unwanted updates that do a `===` check.
      if (!isShallowEqual(lastMapResult, mapResult)) {
        lastMapResult = mapResult;
      }
      lastMapSelect = mapSelect;
      lastMapResultValid = true;
    }
    function getValue() {
      // Update the value in case it's been invalidated or `mapSelect` has changed.
      updateValue();
      return lastMapResult;
    }

    // When transitioning from async to sync mode, cancel existing store updates
    // that have been scheduled, and invalidate the value so that it's freshly
    // computed. It might have been changed by the update we just cancelled.
    if (lastIsAsync && !isAsync) {
      lastMapResultValid = false;
      renderQueue.cancel(queueContext);
    }
    updateValue();
    lastIsAsync = isAsync;

    // Return a pair of functions that can be passed to `useSyncExternalStore`.
    return {
      subscribe: subscriber.subscribe,
      getValue
    };
  };
}
function useStaticSelect(storeName) {
  return (0,use_registry/* default */.A)().select(storeName);
}
function useMappingSelect(suspense, mapSelect, deps) {
  const registry = (0,use_registry/* default */.A)();
  const isAsync = useAsyncMode();
  const store = (0,react.useMemo)(() => Store(registry, suspense), [registry, suspense]);

  // These are "pass-through" dependencies from the parent hook,
  // and the parent should catch any hook rule violations.
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const selector = (0,react.useCallback)(mapSelect, deps);
  const {
    subscribe,
    getValue
  } = store(selector, isAsync);
  const result = (0,react.useSyncExternalStore)(subscribe, getValue, getValue);
  (0,react.useDebugValue)(result);
  return result;
}

/**
 * Custom react hook for retrieving props from registered selectors.
 *
 * In general, this custom React hook follows the
 * [rules of hooks](https://react.dev/reference/rules/rules-of-hooks).
 *
 * @template {MapSelect | StoreDescriptor<any>} T
 * @param {T}         mapSelect Function called on every state change. The returned value is
 *                              exposed to the component implementing this hook. The function
 *                              receives the `registry.select` method on the first argument
 *                              and the `registry` on the second argument.
 *                              When a store key is passed, all selectors for the store will be
 *                              returned. This is only meant for usage of these selectors in event
 *                              callbacks, not for data needed to create the element tree.
 * @param {unknown[]} deps      If provided, this memoizes the mapSelect so the same `mapSelect` is
 *                              invoked on every state change unless the dependencies change.
 *
 * @example
 * ```js
 * import { useSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function HammerPriceDisplay( { currency } ) {
 *   const price = useSelect( ( select ) => {
 *     return select( myCustomStore ).getPrice( 'hammer', currency );
 *   }, [ currency ] );
 *   return new Intl.NumberFormat( 'en-US', {
 *     style: 'currency',
 *     currency,
 *   } ).format( price );
 * }
 *
 * // Rendered in the application:
 * // <HammerPriceDisplay currency="USD" />
 * ```
 *
 * In the above example, when `HammerPriceDisplay` is rendered into an
 * application, the price will be retrieved from the store state using the
 * `mapSelect` callback on `useSelect`. If the currency prop changes then
 * any price in the state for that currency is retrieved. If the currency prop
 * doesn't change and other props are passed in that do change, the price will
 * not change because the dependency is just the currency.
 *
 * When data is only used in an event callback, the data should not be retrieved
 * on render, so it may be useful to get the selectors function instead.
 *
 * **Don't use `useSelect` this way when calling the selectors in the render
 * function because your component won't re-render on a data change.**
 *
 * ```js
 * import { useSelect } from '@wordpress/data';
 * import { store as myCustomStore } from 'my-custom-store';
 *
 * function Paste( { children } ) {
 *   const { getSettings } = useSelect( myCustomStore );
 *   function onPaste() {
 *     // Do something with the settings.
 *     const settings = getSettings();
 *   }
 *   return <div onPaste={ onPaste }>{ children }</div>;
 * }
 * ```
 * @return {UseSelectReturn<T>} A custom react hook.
 */
function useSelect(mapSelect, deps) {
  // On initial call, on mount, determine the mode of this `useSelect` call
  // and then never allow it to change on subsequent updates.
  const staticSelectMode = typeof mapSelect !== 'function';
  const staticSelectModeRef = (0,react.useRef)(staticSelectMode);
  if (staticSelectMode !== staticSelectModeRef.current) {
    const prevMode = staticSelectModeRef.current ? 'static' : 'mapping';
    const nextMode = staticSelectMode ? 'static' : 'mapping';
    throw new Error(`Switching useSelect from ${prevMode} to ${nextMode} is not allowed`);
  }

  /* eslint-disable react-hooks/rules-of-hooks */
  // `staticSelectMode` is not allowed to change during the hook instance's,
  // lifetime, so the rules of hooks are not really violated.
  return staticSelectMode ? useStaticSelect(mapSelect) : useMappingSelect(false, mapSelect, deps);
  /* eslint-enable react-hooks/rules-of-hooks */
}

/**
 * A variant of the `useSelect` hook that has the same API, but is a compatible
 * Suspense-enabled data source.
 *
 * @template {MapSelect} T
 * @param {T}     mapSelect Function called on every state change. The
 *                          returned value is exposed to the component
 *                          using this hook. The function receives the
 *                          `registry.suspendSelect` method as the first
 *                          argument and the `registry` as the second one.
 * @param {Array} deps      A dependency array used to memoize the `mapSelect`
 *                          so that the same `mapSelect` is invoked on every
 *                          state change unless the dependencies change.
 *
 * @throws {Promise} A suspense Promise that is thrown if any of the called
 * selectors is in an unresolved state.
 *
 * @return {ReturnType<T>} Data object returned by the `mapSelect` function.
 */
function useSuspenseSelect(mapSelect, deps) {
  return useMappingSelect(true, mapSelect, deps);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/remove.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ remove)
/* harmony export */ });
/* harmony import */ var _utils_assert_is_defined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js");
/**
 * Internal dependencies
 */

/**
 * Given a DOM node, removes it from the DOM.
 *
 * @param {Node} node Node to be removed.
 * @return {void}
 */

function remove(node) {
  (0,_utils_assert_is_defined__WEBPACK_IMPORTED_MODULE_0__/* .assertIsDefined */ .e)(node.parentNode, 'node.parentNode');
  node.parentNode.removeChild(node);
}
//# sourceMappingURL=remove.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/safe-html.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ safeHTML)
/* harmony export */ });
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/dom/remove.js");
/**
 * Internal dependencies
 */

/**
 * Strips scripts and on* attributes from HTML.
 *
 * @param {string} html HTML to sanitize.
 *
 * @return {string} The sanitized HTML.
 */

function safeHTML(html) {
  const {
    body
  } = document.implementation.createHTMLDocument('');
  body.innerHTML = html;
  const elements = body.getElementsByTagName('*');
  let elementIndex = elements.length;

  while (elementIndex--) {
    const element = elements[elementIndex];

    if (element.tagName === 'SCRIPT') {
      (0,_remove__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(element);
    } else {
      let attributeIndex = element.attributes.length;

      while (attributeIndex--) {
        const {
          name: key
        } = element.attributes[attributeIndex];

        if (key.startsWith('on')) {
          element.removeAttribute(key);
        }
      }
    }
  }

  return body.innerHTML;
}
//# sourceMappingURL=safe-html.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  XC: () => (/* binding */ build_module_focus)
});

// UNUSED EXPORTS: __unstableStripHTML, computeCaretRect, documentHasSelection, documentHasTextSelection, documentHasUncollapsedSelection, getFilesFromDataTransfer, getOffsetParent, getPhrasingContentSchema, getRectangleFromRange, getScrollContainer, insertAfter, isEmpty, isEntirelySelected, isFormElement, isHorizontalEdge, isNumberInput, isPhrasingContent, isRTL, isTextContent, isTextField, isVerticalEdge, placeCaretAtHorizontalEdge, placeCaretAtVerticalEdge, remove, removeInvalidHTML, replace, replaceTag, safeHTML, unwrap, wrap

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/focusable.js
var focusable_namespaceObject = {};
__webpack_require__.r(focusable_namespaceObject);
__webpack_require__.d(focusable_namespaceObject, {
  find: () => (find)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/tabbable.js
var tabbable_namespaceObject = {};
__webpack_require__.r(tabbable_namespaceObject);
__webpack_require__.d(tabbable_namespaceObject, {
  find: () => (tabbable_find),
  findNext: () => (findNext),
  findPrevious: () => (findPrevious),
  isTabbableIndex: () => (isTabbableIndex)
});

;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/focusable.js
/**
 * References:
 *
 * Focusable:
 *  - https://www.w3.org/TR/html5/editing.html#focus-management
 *
 * Sequential focus navigation:
 *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
 *
 * Disabled elements:
 *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements
 *
 * getClientRects algorithm (requiring layout box):
 *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface
 *
 * AREA elements associated with an IMG:
 *  - https://w3c.github.io/html/editing.html#data-model
 */

/**
 * Returns a CSS selector used to query for focusable elements.
 *
 * @param {boolean} sequential If set, only query elements that are sequentially
 *                             focusable. Non-interactive elements with a
 *                             negative `tabindex` are focusable but not
 *                             sequentially focusable.
 *                             https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute
 *
 * @return {string} CSS selector.
 */
function buildSelector(sequential) {
  return [sequential ? '[tabindex]:not([tabindex^="-"])' : '[tabindex]', 'a[href]', 'button:not([disabled])', 'input:not([type="hidden"]):not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'iframe:not([tabindex^="-"])', 'object', 'embed', 'area[href]', '[contenteditable]:not([contenteditable=false])'].join(',');
}
/**
 * Returns true if the specified element is visible (i.e. neither display: none
 * nor visibility: hidden).
 *
 * @param {HTMLElement} element DOM element to test.
 *
 * @return {boolean} Whether element is visible.
 */


function isVisible(element) {
  return element.offsetWidth > 0 || element.offsetHeight > 0 || element.getClientRects().length > 0;
}
/**
 * Returns true if the specified area element is a valid focusable element, or
 * false otherwise. Area is only focusable if within a map where a named map
 * referenced by an image somewhere in the document.
 *
 * @param {HTMLAreaElement} element DOM area element to test.
 *
 * @return {boolean} Whether area element is valid for focus.
 */


function isValidFocusableArea(element) {
  /** @type {HTMLMapElement | null} */
  const map = element.closest('map[name]');

  if (!map) {
    return false;
  }
  /** @type {HTMLImageElement | null} */


  const img = element.ownerDocument.querySelector('img[usemap="#' + map.name + '"]');
  return !!img && isVisible(img);
}
/**
 * Returns all focusable elements within a given context.
 *
 * @param {Element} context              Element in which to search.
 * @param {Object}  [options]
 * @param {boolean} [options.sequential] If set, only return elements that are
 *                                       sequentially focusable.
 *                                       Non-interactive elements with a
 *                                       negative `tabindex` are focusable but
 *                                       not sequentially focusable.
 *                                       https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute
 *
 * @return {HTMLElement[]} Focusable elements.
 */


function find(context) {
  let {
    sequential = false
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  /* eslint-disable jsdoc/no-undefined-types */

  /** @type {NodeListOf<HTMLElement>} */

  /* eslint-enable jsdoc/no-undefined-types */
  const elements = context.querySelectorAll(buildSelector(sequential));
  return Array.from(elements).filter(element => {
    if (!isVisible(element)) {
      return false;
    }

    const {
      nodeName
    } = element;

    if ('AREA' === nodeName) {
      return isValidFocusableArea(
      /** @type {HTMLAreaElement} */
      element);
    }

    return true;
  });
}
//# sourceMappingURL=focusable.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/tabbable.js
/**
 * Internal dependencies
 */

/**
 * Returns the tab index of the given element. In contrast with the tabIndex
 * property, this normalizes the default (0) to avoid browser inconsistencies,
 * operating under the assumption that this function is only ever called with a
 * focusable node.
 *
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261
 *
 * @param {Element} element Element from which to retrieve.
 *
 * @return {number} Tab index of element (default 0).
 */

function getTabIndex(element) {
  const tabIndex = element.getAttribute('tabindex');
  return tabIndex === null ? 0 : parseInt(tabIndex, 10);
}
/**
 * Returns true if the specified element is tabbable, or false otherwise.
 *
 * @param {Element} element Element to test.
 *
 * @return {boolean} Whether element is tabbable.
 */


function isTabbableIndex(element) {
  return getTabIndex(element) !== -1;
}
/** @typedef {Element & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */

/**
 * Returns a stateful reducer function which constructs a filtered array of
 * tabbable elements, where at most one radio input is selected for a given
 * name, giving priority to checked input, falling back to the first
 * encountered.
 *
 * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.
 */

function createStatefulCollapseRadioGroup() {
  /** @type {Record<string, MaybeHTMLInputElement>} */
  const CHOSEN_RADIO_BY_NAME = {};
  return function collapseRadioGroup(
  /** @type {MaybeHTMLInputElement[]} */
  result,
  /** @type {MaybeHTMLInputElement} */
  element) {
    const {
      nodeName,
      type,
      checked,
      name
    } = element; // For all non-radio tabbables, construct to array by concatenating.

    if (nodeName !== 'INPUT' || type !== 'radio' || !name) {
      return result.concat(element);
    }

    const hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty(name); // Omit by skipping concatenation if the radio element is not chosen.

    const isChosen = checked || !hasChosen;

    if (!isChosen) {
      return result;
    } // At this point, if there had been a chosen element, the current
    // element is checked and should take priority. Retroactively remove
    // the element which had previously been considered the chosen one.


    if (hasChosen) {
      const hadChosenElement = CHOSEN_RADIO_BY_NAME[name];
      result = result.filter(e => e !== hadChosenElement);
    }

    CHOSEN_RADIO_BY_NAME[name] = element;
    return result.concat(element);
  };
}
/**
 * An array map callback, returning an object with the element value and its
 * array index location as properties. This is used to emulate a proper stable
 * sort where equal tabIndex should be left in order of their occurrence in the
 * document.
 *
 * @param {Element} element Element.
 * @param {number}  index   Array index of element.
 *
 * @return {{ element: Element, index: number }} Mapped object with element, index.
 */


function mapElementToObjectTabbable(element, index) {
  return {
    element,
    index
  };
}
/**
 * An array map callback, returning an element of the given mapped object's
 * element value.
 *
 * @param {{ element: Element }} object Mapped object with element.
 *
 * @return {Element} Mapped object element.
 */


function mapObjectTabbableToElement(object) {
  return object.element;
}
/**
 * A sort comparator function used in comparing two objects of mapped elements.
 *
 * @see mapElementToObjectTabbable
 *
 * @param {{ element: Element, index: number }} a First object to compare.
 * @param {{ element: Element, index: number }} b Second object to compare.
 *
 * @return {number} Comparator result.
 */


function compareObjectTabbables(a, b) {
  const aTabIndex = getTabIndex(a.element);
  const bTabIndex = getTabIndex(b.element);

  if (aTabIndex === bTabIndex) {
    return a.index - b.index;
  }

  return aTabIndex - bTabIndex;
}
/**
 * Givin focusable elements, filters out tabbable element.
 *
 * @param {Element[]} focusables Focusable elements to filter.
 *
 * @return {Element[]} Tabbable elements.
 */


function filterTabbable(focusables) {
  return focusables.filter(isTabbableIndex).map(mapElementToObjectTabbable).sort(compareObjectTabbables).map(mapObjectTabbableToElement).reduce(createStatefulCollapseRadioGroup(), []);
}
/**
 * @param {Element} context
 * @return {Element[]} Tabbable elements within the context.
 */


function tabbable_find(context) {
  return filterTabbable(find(context));
}
/**
 * Given a focusable element, find the preceding tabbable element.
 *
 * @param {Element} element The focusable element before which to look. Defaults
 *                          to the active element.
 *
 * @return {Element|undefined} Preceding tabbable element.
 */

function findPrevious(element) {
  return filterTabbable(find(element.ownerDocument.body)).reverse().find(focusable => {
    return (// eslint-disable-next-line no-bitwise
      element.compareDocumentPosition(focusable) & element.DOCUMENT_POSITION_PRECEDING
    );
  });
}
/**
 * Given a focusable element, find the next tabbable element.
 *
 * @param {Element} element The focusable element after which to look. Defaults
 *                          to the active element.
 *
 * @return {Element|undefined} Next tabbable element.
 */

function findNext(element) {
  return filterTabbable(find(element.ownerDocument.body)).find(focusable => {
    return (// eslint-disable-next-line no-bitwise
      element.compareDocumentPosition(focusable) & element.DOCUMENT_POSITION_FOLLOWING
    );
  });
}
//# sourceMappingURL=tabbable.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/index.js
/**
 * Internal dependencies
 */


/**
 * Object grouping `focusable` and `tabbable` utils
 * under the keys with the same name.
 */

const build_module_focus = {
  focusable: focusable_namespaceObject,
  tabbable: tabbable_namespaceObject
};



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+dom@3.27.0/node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ assertIsDefined)
/* harmony export */ });
function assertIsDefined(val, name) {
  if (false) {}
}
//# sourceMappingURL=assert-is-defined.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/raw-html.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ RawHTML)
/* harmony export */ });
/* harmony import */ var _react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * Internal dependencies
 */
 // Disable reason: JSDoc linter doesn't seem to parse the union (`&`) correctly.

/** @typedef {{children: string} & import('react').ComponentPropsWithoutRef<'div'>} RawHTMLProps */

/**
 * Component used as equivalent of Fragment with unescaped HTML, in cases where
 * it is desirable to render dangerous HTML without needing a wrapper element.
 * To preserve additional props, a `div` wrapper _will_ be created if any props
 * aside from `children` are passed.
 *
 * @param {RawHTMLProps} props Children should be a string of HTML or an array
 *                             of strings. Other props will be passed through
 *                             to the div wrapper.
 *
 * @return {JSX.Element} Dangerously-rendering component.
 */

function RawHTML(_ref) {
  let {
    children,
    ...props
  } = _ref;
  let rawHtml = ''; // Cast children as an array, and concatenate each element if it is a string.

  _react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children).forEach(child => {
    if (typeof child === 'string' && child.trim() !== '') {
      rawHtml += child;
    }
  }); // The `div` wrapper will be stripped by the `renderElement` serializer in
  // `./serialize.js` unless there are non-children props present.

  return (0,_react__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {
    dangerouslySetInnerHTML: {
      __html: rawHtml
    },
    ...props
  });
}
//# sourceMappingURL=raw-html.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/react.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oG: () => (/* binding */ concatChildren)
/* harmony export */ });
/* unused harmony export switchChildrenNodeName */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * External dependencies
 */
// eslint-disable-next-line @typescript-eslint/no-restricted-imports

/**
 * Object containing a React element.
 *
 * @typedef {import('react').ReactElement} WPElement
 */

/**
 * Object containing a React component.
 *
 * @typedef {import('react').ComponentType} WPComponent
 */

/**
 * Object containing a React synthetic event.
 *
 * @typedef {import('react').SyntheticEvent} WPSyntheticEvent
 */

/**
 * Object that provides utilities for dealing with React children.
 */


/**
 * Creates a copy of an element with extended props.
 *
 * @param {WPElement} element Element
 * @param {?Object}   props   Props to apply to cloned element
 *
 * @return {WPElement} Cloned element.
 */


/**
 * A base class to create WordPress Components (Refs, state and lifecycle hooks)
 */


/**
 * Creates a context object containing two components: a provider and consumer.
 *
 * @param {Object} defaultValue A default data stored in the context.
 *
 * @return {Object} Context object.
 */


/**
 * Returns a new element of given type. Type can be either a string tag name or
 * another function which itself returns an element.
 *
 * @param {?(string|Function)} type     Tag name or element creator
 * @param {Object}             props    Element properties, either attribute
 *                                      set to apply to DOM node or values to
 *                                      pass through to element creator
 * @param {...WPElement}       children Descendant elements
 *
 * @return {WPElement} Element.
 */


/**
 * Returns an object tracking a reference to a rendered element via its
 * `current` property as either a DOMElement or Element, dependent upon the
 * type of element rendered with the ref attribute.
 *
 * @return {Object} Ref object.
 */


/**
 * Component enhancer used to enable passing a ref to its wrapped component.
 * Pass a function argument which receives `props` and `ref` as its arguments,
 * returning an element using the forwarded ref. The return value is a new
 * component which forwards its ref.
 *
 * @param {Function} forwarder Function passed `props` and `ref`, expected to
 *                             return an element.
 *
 * @return {WPComponent} Enhanced component.
 */


/**
 * A component which renders its children without any wrapping element.
 */


/**
 * Checks if an object is a valid WPElement.
 *
 * @param {Object} objectToCheck The object to be checked.
 *
 * @return {boolean} true if objectToTest is a valid WPElement and false otherwise.
 */


/**
 * @see https://reactjs.org/docs/react-api.html#reactmemo
 */


/**
 * Component that activates additional checks and warnings for its descendants.
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#usecallback
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#usecontext
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#usedebugvalue
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#useeffect
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#useimperativehandle
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#uselayouteffect
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#usememo
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#usereducer
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#useref
 */


/**
 * @see https://reactjs.org/docs/hooks-reference.html#usestate
 */


/**
 * @see https://reactjs.org/docs/react-api.html#reactlazy
 */


/**
 * @see https://reactjs.org/docs/react-api.html#reactsuspense
 */


/**
 * Concatenate two or more React children objects.
 *
 * @param {...?Object} childrenArguments Array of children arguments (array of arrays/strings/objects) to concatenate.
 *
 * @return {Array} The concatenated value.
 */

function concatChildren() {
  for (var _len = arguments.length, childrenArguments = new Array(_len), _key = 0; _key < _len; _key++) {
    childrenArguments[_key] = arguments[_key];
  }

  return childrenArguments.reduce((accumulator, children, i) => {
    react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (child, j) => {
      if (child && 'string' !== typeof child) {
        child = (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, {
          key: [i, j].join()
        });
      }

      accumulator.push(child);
    });
    return accumulator;
  }, []);
}
/**
 * Switches the nodeName of all the elements in the children object.
 *
 * @param {?Object} children Children object.
 * @param {string}  nodeName Node name.
 *
 * @return {?Object} The updated children object.
 */

function switchChildrenNodeName(children, nodeName) {
  return children && Children.map(children, (elt, index) => {
    if (typeof (elt === null || elt === void 0 ? void 0 : elt.valueOf()) === 'string') {
      return createElement(nodeName, {
        key: index
      }, elt);
    }

    const {
      children: childrenProp,
      ...props
    } = elt.props;
    return createElement(nodeName, {
      key: index,
      ...props
    }, childrenProp);
  });
}
//# sourceMappingURL=react.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/serialize.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports hasPrefix, renderElement, renderNativeComponent, renderComponent, renderAttributes, renderStyle */
/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../../node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs");
/* harmony import */ var change_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/param-case@3.0.4/node_modules/param-case/dist.es2015/index.js");
/* harmony import */ var _wordpress_escape_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+escape-html@2.47.0/node_modules/@wordpress/escape-html/build-module/index.js");
/* harmony import */ var _react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _raw_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/raw-html.js");
/**
 * Parts of this source were derived and modified from fast-react-render,
 * released under the MIT license.
 *
 * https://github.com/alt-j/fast-react-render
 *
 * Copyright (c) 2016 Andrey Morozov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/** @typedef {import('./react').WPElement} WPElement */

const {
  Provider,
  Consumer
} = (0,_react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);
const ForwardRef = (0,_react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => {
  return null;
});
/**
 * Valid attribute types.
 *
 * @type {Set<string>}
 */

const ATTRIBUTES_TYPES = new Set(['string', 'boolean', 'number']);
/**
 * Element tags which can be self-closing.
 *
 * @type {Set<string>}
 */

const SELF_CLOSING_TAGS = new Set(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);
/**
 * Boolean attributes are attributes whose presence as being assigned is
 * meaningful, even if only empty.
 *
 * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes
 * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3
 *
 * Object.keys( [ ...document.querySelectorAll( '#attributes-1 > tbody > tr' ) ]
 *     .filter( ( tr ) => tr.lastChild.textContent.indexOf( 'Boolean attribute' ) !== -1 )
 *     .reduce( ( result, tr ) => Object.assign( result, {
 *         [ tr.firstChild.textContent.trim() ]: true
 *     } ), {} ) ).sort();
 *
 * @type {Set<string>}
 */

const BOOLEAN_ATTRIBUTES = new Set(['allowfullscreen', 'allowpaymentrequest', 'allowusermedia', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'download', 'formnovalidate', 'hidden', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected', 'typemustmatch']);
/**
 * Enumerated attributes are attributes which must be of a specific value form.
 * Like boolean attributes, these are meaningful if specified, even if not of a
 * valid enumerated value.
 *
 * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#enumerated-attribute
 * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3
 *
 * Object.keys( [ ...document.querySelectorAll( '#attributes-1 > tbody > tr' ) ]
 *     .filter( ( tr ) => /^("(.+?)";?\s*)+/.test( tr.lastChild.textContent.trim() ) )
 *     .reduce( ( result, tr ) => Object.assign( result, {
 *         [ tr.firstChild.textContent.trim() ]: true
 *     } ), {} ) ).sort();
 *
 * Some notable omissions:
 *
 *  - `alt`: https://blog.whatwg.org/omit-alt
 *
 * @type {Set<string>}
 */

const ENUMERATED_ATTRIBUTES = new Set(['autocapitalize', 'autocomplete', 'charset', 'contenteditable', 'crossorigin', 'decoding', 'dir', 'draggable', 'enctype', 'formenctype', 'formmethod', 'http-equiv', 'inputmode', 'kind', 'method', 'preload', 'scope', 'shape', 'spellcheck', 'translate', 'type', 'wrap']);
/**
 * Set of CSS style properties which support assignment of unitless numbers.
 * Used in rendering of style properties, where `px` unit is assumed unless
 * property is included in this set or value is zero.
 *
 * Generated via:
 *
 * Object.entries( document.createElement( 'div' ).style )
 *     .filter( ( [ key ] ) => (
 *         ! /^(webkit|ms|moz)/.test( key ) &&
 *         ( e.style[ key ] = 10 ) &&
 *         e.style[ key ] === '10'
 *     ) )
 *     .map( ( [ key ] ) => key )
 *     .sort();
 *
 * @type {Set<string>}
 */

const CSS_PROPERTIES_SUPPORTS_UNITLESS = new Set(['animation', 'animationIterationCount', 'baselineShift', 'borderImageOutset', 'borderImageSlice', 'borderImageWidth', 'columnCount', 'cx', 'cy', 'fillOpacity', 'flexGrow', 'flexShrink', 'floodOpacity', 'fontWeight', 'gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart', 'lineHeight', 'opacity', 'order', 'orphans', 'r', 'rx', 'ry', 'shapeImageThreshold', 'stopOpacity', 'strokeDasharray', 'strokeDashoffset', 'strokeMiterlimit', 'strokeOpacity', 'strokeWidth', 'tabSize', 'widows', 'x', 'y', 'zIndex', 'zoom']);
/**
 * Returns true if the specified string is prefixed by one of an array of
 * possible prefixes.
 *
 * @param {string}   string   String to check.
 * @param {string[]} prefixes Possible prefixes.
 *
 * @return {boolean} Whether string has prefix.
 */

function hasPrefix(string, prefixes) {
  return prefixes.some(prefix => string.indexOf(prefix) === 0);
}
/**
 * Returns true if the given prop name should be ignored in attributes
 * serialization, or false otherwise.
 *
 * @param {string} attribute Attribute to check.
 *
 * @return {boolean} Whether attribute should be ignored.
 */

function isInternalAttribute(attribute) {
  return 'key' === attribute || 'children' === attribute;
}
/**
 * Returns the normal form of the element's attribute value for HTML.
 *
 * @param {string} attribute Attribute name.
 * @param {*}      value     Non-normalized attribute value.
 *
 * @return {*} Normalized attribute value.
 */


function getNormalAttributeValue(attribute, value) {
  switch (attribute) {
    case 'style':
      return renderStyle(value);
  }

  return value;
}
/**
 * This is a map of all SVG attributes that have dashes. Map(lower case prop => dashed lower case attribute).
 * We need this to render e.g strokeWidth as stroke-width.
 *
 * List from: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute.
 */


const SVG_ATTRIBUTE_WITH_DASHES_LIST = ['accentHeight', 'alignmentBaseline', 'arabicForm', 'baselineShift', 'capHeight', 'clipPath', 'clipRule', 'colorInterpolation', 'colorInterpolationFilters', 'colorProfile', 'colorRendering', 'dominantBaseline', 'enableBackground', 'fillOpacity', 'fillRule', 'floodColor', 'floodOpacity', 'fontFamily', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontWeight', 'glyphName', 'glyphOrientationHorizontal', 'glyphOrientationVertical', 'horizAdvX', 'horizOriginX', 'imageRendering', 'letterSpacing', 'lightingColor', 'markerEnd', 'markerMid', 'markerStart', 'overlinePosition', 'overlineThickness', 'paintOrder', 'panose1', 'pointerEvents', 'renderingIntent', 'shapeRendering', 'stopColor', 'stopOpacity', 'strikethroughPosition', 'strikethroughThickness', 'strokeDasharray', 'strokeDashoffset', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity', 'strokeWidth', 'textAnchor', 'textDecoration', 'textRendering', 'underlinePosition', 'underlineThickness', 'unicodeBidi', 'unicodeRange', 'unitsPerEm', 'vAlphabetic', 'vHanging', 'vIdeographic', 'vMathematical', 'vectorEffect', 'vertAdvY', 'vertOriginX', 'vertOriginY', 'wordSpacing', 'writingMode', 'xmlnsXlink', 'xHeight'].reduce((map, attribute) => {
  // The keys are lower-cased for more robust lookup.
  map[attribute.toLowerCase()] = attribute;
  return map;
}, {});
/**
 * This is a map of all case-sensitive SVG attributes. Map(lowercase key => proper case attribute).
 * The keys are lower-cased for more robust lookup.
 * Note that this list only contains attributes that contain at least one capital letter.
 * Lowercase attributes don't need mapping, since we lowercase all attributes by default.
 */

const CASE_SENSITIVE_SVG_ATTRIBUTES = ['allowReorder', 'attributeName', 'attributeType', 'autoReverse', 'baseFrequency', 'baseProfile', 'calcMode', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'glyphRef', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'keySplines', 'keyTimes', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'refX', 'refY', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget', 'xChannelSelector', 'yChannelSelector'].reduce((map, attribute) => {
  // The keys are lower-cased for more robust lookup.
  map[attribute.toLowerCase()] = attribute;
  return map;
}, {});
/**
 * This is a map of all SVG attributes that have colons.
 * Keys are lower-cased and stripped of their colons for more robust lookup.
 */

const SVG_ATTRIBUTES_WITH_COLONS = ['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'xmlns:xlink'].reduce((map, attribute) => {
  map[attribute.replace(':', '').toLowerCase()] = attribute;
  return map;
}, {});
/**
 * Returns the normal form of the element's attribute name for HTML.
 *
 * @param {string} attribute Non-normalized attribute name.
 *
 * @return {string} Normalized attribute name.
 */

function getNormalAttributeName(attribute) {
  switch (attribute) {
    case 'htmlFor':
      return 'for';

    case 'className':
      return 'class';
  }

  const attributeLowerCase = attribute.toLowerCase();

  if (CASE_SENSITIVE_SVG_ATTRIBUTES[attributeLowerCase]) {
    return CASE_SENSITIVE_SVG_ATTRIBUTES[attributeLowerCase];
  } else if (SVG_ATTRIBUTE_WITH_DASHES_LIST[attributeLowerCase]) {
    return (0,change_case__WEBPACK_IMPORTED_MODULE_1__/* .paramCase */ .c)(SVG_ATTRIBUTE_WITH_DASHES_LIST[attributeLowerCase]);
  } else if (SVG_ATTRIBUTES_WITH_COLONS[attributeLowerCase]) {
    return SVG_ATTRIBUTES_WITH_COLONS[attributeLowerCase];
  }

  return attributeLowerCase;
}
/**
 * Returns the normal form of the style property name for HTML.
 *
 * - Converts property names to kebab-case, e.g. 'backgroundColor' → 'background-color'
 * - Leaves custom attributes alone, e.g. '--myBackgroundColor' → '--myBackgroundColor'
 * - Converts vendor-prefixed property names to -kebab-case, e.g. 'MozTransform' → '-moz-transform'
 *
 * @param {string} property Property name.
 *
 * @return {string} Normalized property name.
 */


function getNormalStylePropertyName(property) {
  if (property.startsWith('--')) {
    return property;
  }

  if (hasPrefix(property, ['ms', 'O', 'Moz', 'Webkit'])) {
    return '-' + (0,change_case__WEBPACK_IMPORTED_MODULE_1__/* .paramCase */ .c)(property);
  }

  return (0,change_case__WEBPACK_IMPORTED_MODULE_1__/* .paramCase */ .c)(property);
}
/**
 * Returns the normal form of the style property value for HTML. Appends a
 * default pixel unit if numeric, not a unitless property, and not zero.
 *
 * @param {string} property Property name.
 * @param {*}      value    Non-normalized property value.
 *
 * @return {*} Normalized property value.
 */


function getNormalStylePropertyValue(property, value) {
  if (typeof value === 'number' && 0 !== value && !CSS_PROPERTIES_SUPPORTS_UNITLESS.has(property)) {
    return value + 'px';
  }

  return value;
}
/**
 * Serializes a React element to string.
 *
 * @param {import('react').ReactNode} element         Element to serialize.
 * @param {Object}                    [context]       Context object.
 * @param {Object}                    [legacyContext] Legacy context object.
 *
 * @return {string} Serialized element.
 */


function renderElement(element, context) {
  let legacyContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (null === element || undefined === element || false === element) {
    return '';
  }

  if (Array.isArray(element)) {
    return renderChildren(element, context, legacyContext);
  }

  switch (typeof element) {
    case 'string':
      return (0,_wordpress_escape_html__WEBPACK_IMPORTED_MODULE_2__/* .escapeHTML */ .Zn)(element);

    case 'number':
      return element.toString();
  }

  const {
    type,
    props
  } =
  /** @type {{type?: any, props?: any}} */
  element;

  switch (type) {
    case _react__WEBPACK_IMPORTED_MODULE_0__.StrictMode:
    case _react__WEBPACK_IMPORTED_MODULE_0__.Fragment:
      return renderChildren(props.children, context, legacyContext);

    case _raw_html__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A:
      const {
        children,
        ...wrapperProps
      } = props;
      return renderNativeComponent(!Object.keys(wrapperProps).length ? null : 'div', { ...wrapperProps,
        dangerouslySetInnerHTML: {
          __html: children
        }
      }, context, legacyContext);
  }

  switch (typeof type) {
    case 'string':
      return renderNativeComponent(type, props, context, legacyContext);

    case 'function':
      if (type.prototype && typeof type.prototype.render === 'function') {
        return renderComponent(type, props, context, legacyContext);
      }

      return renderElement(type(props, legacyContext), context, legacyContext);
  }

  switch (type && type.$$typeof) {
    case Provider.$$typeof:
      return renderChildren(props.children, props.value, legacyContext);

    case Consumer.$$typeof:
      return renderElement(props.children(context || type._currentValue), context, legacyContext);

    case ForwardRef.$$typeof:
      return renderElement(type.render(props), context, legacyContext);
  }

  return '';
}
/**
 * Serializes a native component type to string.
 *
 * @param {?string} type            Native component type to serialize, or null if
 *                                  rendering as fragment of children content.
 * @param {Object}  props           Props object.
 * @param {Object}  [context]       Context object.
 * @param {Object}  [legacyContext] Legacy context object.
 *
 * @return {string} Serialized element.
 */

function renderNativeComponent(type, props, context) {
  let legacyContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  let content = '';

  if (type === 'textarea' && props.hasOwnProperty('value')) {
    // Textarea children can be assigned as value prop. If it is, render in
    // place of children. Ensure to omit so it is not assigned as attribute
    // as well.
    content = renderChildren(props.value, context, legacyContext);
    const {
      value,
      ...restProps
    } = props;
    props = restProps;
  } else if (props.dangerouslySetInnerHTML && typeof props.dangerouslySetInnerHTML.__html === 'string') {
    // Dangerous content is left unescaped.
    content = props.dangerouslySetInnerHTML.__html;
  } else if (typeof props.children !== 'undefined') {
    content = renderChildren(props.children, context, legacyContext);
  }

  if (!type) {
    return content;
  }

  const attributes = renderAttributes(props);

  if (SELF_CLOSING_TAGS.has(type)) {
    return '<' + type + attributes + '/>';
  }

  return '<' + type + attributes + '>' + content + '</' + type + '>';
}
/** @typedef {import('./react').WPComponent} WPComponent */

/**
 * Serializes a non-native component type to string.
 *
 * @param {WPComponent} Component       Component type to serialize.
 * @param {Object}      props           Props object.
 * @param {Object}      [context]       Context object.
 * @param {Object}      [legacyContext] Legacy context object.
 *
 * @return {string} Serialized element
 */

function renderComponent(Component, props, context) {
  let legacyContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const instance = new
  /** @type {import('react').ComponentClass} */
  Component(props, legacyContext);

  if (typeof // Ignore reason: Current prettier reformats parens and mangles type assertion
  // prettier-ignore

  /** @type {{getChildContext?: () => unknown}} */
  instance.getChildContext === 'function') {
    Object.assign(legacyContext,
    /** @type {{getChildContext?: () => unknown}} */
    instance.getChildContext());
  }

  const html = renderElement(instance.render(), context, legacyContext);
  return html;
}
/**
 * Serializes an array of children to string.
 *
 * @param {import('react').ReactNodeArray} children        Children to serialize.
 * @param {Object}                         [context]       Context object.
 * @param {Object}                         [legacyContext] Legacy context object.
 *
 * @return {string} Serialized children.
 */

function renderChildren(children, context) {
  let legacyContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let result = '';
  children = Array.isArray(children) ? children : [children];

  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    result += renderElement(child, context, legacyContext);
  }

  return result;
}
/**
 * Renders a props object as a string of HTML attributes.
 *
 * @param {Object} props Props object.
 *
 * @return {string} Attributes string.
 */


function renderAttributes(props) {
  let result = '';

  for (const key in props) {
    const attribute = getNormalAttributeName(key);

    if (!(0,_wordpress_escape_html__WEBPACK_IMPORTED_MODULE_2__/* .isValidAttributeName */ .i8)(attribute)) {
      continue;
    }

    let value = getNormalAttributeValue(key, props[key]); // If value is not of serializeable type, skip.

    if (!ATTRIBUTES_TYPES.has(typeof value)) {
      continue;
    } // Don't render internal attribute names.


    if (isInternalAttribute(key)) {
      continue;
    }

    const isBooleanAttribute = BOOLEAN_ATTRIBUTES.has(attribute); // Boolean attribute should be omitted outright if its value is false.

    if (isBooleanAttribute && value === false) {
      continue;
    }

    const isMeaningfulAttribute = isBooleanAttribute || hasPrefix(key, ['data-', 'aria-']) || ENUMERATED_ATTRIBUTES.has(attribute); // Only write boolean value as attribute if meaningful.

    if (typeof value === 'boolean' && !isMeaningfulAttribute) {
      continue;
    }

    result += ' ' + attribute; // Boolean attributes should write attribute name, but without value.
    // Mere presence of attribute name is effective truthiness.

    if (isBooleanAttribute) {
      continue;
    }

    if (typeof value === 'string') {
      value = (0,_wordpress_escape_html__WEBPACK_IMPORTED_MODULE_2__/* .escapeAttribute */ .Gj)(value);
    }

    result += '="' + value + '"';
  }

  return result;
}
/**
 * Renders a style object as a string attribute value.
 *
 * @param {Object} style Style object.
 *
 * @return {string} Style attribute value.
 */

function renderStyle(style) {
  // Only generate from object, e.g. tolerate string value.
  if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_4__/* .isPlainObject */ .Q)(style)) {
    return style;
  }

  let result;

  for (const property in style) {
    const value = style[property];

    if (null === value || undefined === value) {
      continue;
    }

    if (result) {
      result += ';';
    } else {
      result = '';
    }

    const normalName = getNormalStylePropertyName(property);
    const normalValue = getNormalStylePropertyValue(property, value);
    result += normalName + ':' + normalValue;
  }

  return result;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (renderElement);
//# sourceMappingURL=serialize.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+element@4.20.0/node_modules/@wordpress/element/build-module/utils.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ isEmptyElement)
/* harmony export */ });
/**
 * Checks if the provided WP element is empty.
 *
 * @param {*} element WP element to check.
 * @return {boolean} True when an element is considered empty.
 */
const isEmptyElement = element => {
  if (typeof element === 'number') {
    return false;
  }

  if (typeof (element === null || element === void 0 ? void 0 : element.valueOf()) === 'string' || Array.isArray(element)) {
    return !element.length;
  }

  return !element;
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+escape-html@2.47.0/node_modules/@wordpress/escape-html/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Gj: () => (/* binding */ escapeAttribute),
  jG: () => (/* binding */ escapeEditableHTML),
  Zn: () => (/* binding */ escapeHTML),
  i8: () => (/* binding */ isValidAttributeName)
});

// UNUSED EXPORTS: escapeAmpersand, escapeLessThan, escapeQuotationMark

;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+escape-html@2.47.0/node_modules/@wordpress/escape-html/build-module/escape-greater.js
/**
 * Returns a string with greater-than sign replaced.
 *
 * Note that if a resolution for Trac#45387 comes to fruition, it is no longer
 * necessary for `__unstableEscapeGreaterThan` to exist.
 *
 * See: https://core.trac.wordpress.org/ticket/45387
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */
function __unstableEscapeGreaterThan(value) {
  return value.replace(/>/g, '&gt;');
}
//# sourceMappingURL=escape-greater.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+escape-html@2.47.0/node_modules/@wordpress/escape-html/build-module/index.js
/**
 * Internal dependencies
 */


/**
 * Regular expression matching invalid attribute names.
 *
 * "Attribute names must consist of one or more characters other than controls,
 * U+0020 SPACE, U+0022 ("), U+0027 ('), U+003E (>), U+002F (/), U+003D (=),
 * and noncharacters."
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
 *
 * @type {RegExp}
 */
const REGEXP_INVALID_ATTRIBUTE_NAME = /[\u007F-\u009F "'>/="\uFDD0-\uFDEF]/;

/**
 * Returns a string with ampersands escaped. Note that this is an imperfect
 * implementation, where only ampersands which do not appear as a pattern of
 * named, decimal, or hexadecimal character references are escaped. Invalid
 * named references (i.e. ambiguous ampersand) are still permitted.
 *
 * @see https://w3c.github.io/html/syntax.html#character-references
 * @see https://w3c.github.io/html/syntax.html#ambiguous-ampersand
 * @see https://w3c.github.io/html/syntax.html#named-character-references
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */
function escapeAmpersand(value) {
  return value.replace(/&(?!([a-z0-9]+|#[0-9]+|#x[a-f0-9]+);)/gi, '&amp;');
}

/**
 * Returns a string with quotation marks replaced.
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */
function escapeQuotationMark(value) {
  return value.replace(/"/g, '&quot;');
}

/**
 * Returns a string with less-than sign replaced.
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */
function escapeLessThan(value) {
  return value.replace(/</g, '&lt;');
}

/**
 * Returns an escaped attribute value.
 *
 * @see https://w3c.github.io/html/syntax.html#elements-attributes
 *
 * "[...] the text cannot contain an ambiguous ampersand [...] must not contain
 * any literal U+0022 QUOTATION MARK characters (")"
 *
 * Note we also escape the greater than symbol, as this is used by wptexturize to
 * split HTML strings. This is a WordPress specific fix
 *
 * Note that if a resolution for Trac#45387 comes to fruition, it is no longer
 * necessary for `__unstableEscapeGreaterThan` to be used.
 *
 * See: https://core.trac.wordpress.org/ticket/45387
 *
 * @param {string} value Attribute value.
 *
 * @return {string} Escaped attribute value.
 */
function escapeAttribute(value) {
  return __unstableEscapeGreaterThan(escapeQuotationMark(escapeAmpersand(value)));
}

/**
 * Returns an escaped HTML element value.
 *
 * @see https://w3c.github.io/html/syntax.html#writing-html-documents-elements
 *
 * "the text must not contain the character U+003C LESS-THAN SIGN (<) or an
 * ambiguous ampersand."
 *
 * @param {string} value Element value.
 *
 * @return {string} Escaped HTML element value.
 */
function escapeHTML(value) {
  return escapeLessThan(escapeAmpersand(value));
}

/**
 * Returns an escaped Editable HTML element value. This is different from
 * `escapeHTML`, because for editable HTML, ALL ampersands must be escaped in
 * order to render the content correctly on the page.
 *
 * @param {string} value Element value.
 *
 * @return {string} Escaped HTML element value.
 */
function escapeEditableHTML(value) {
  return escapeLessThan(value.replace(/&/g, '&amp;'));
}

/**
 * Returns true if the given attribute name is valid, or false otherwise.
 *
 * @param {string} name Attribute name to test.
 *
 * @return {boolean} Whether attribute is valid.
 */
function isValidAttributeName(name) {
  return !REGEXP_INVALID_ATTRIBUTE_NAME.test(name);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+html-entities@3.24.0/node_modules/@wordpress/html-entities/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ decodeEntities)
/* harmony export */ });
/** @type {HTMLTextAreaElement} */
let _decodeTextArea;
/**
 * Decodes the HTML entities from a given string.
 *
 * @param {string} html String that contain HTML entities.
 *
 * @example
 * ```js
 * const result = decodeEntities( '&aacute;' );
 * console.log( result ); // result will be "á"
 * ```
 *
 * @return {string} The decoded string.
 */


function decodeEntities(html) {
  // Not a string, or no entities to decode.
  if ('string' !== typeof html || -1 === html.indexOf('&')) {
    return html;
  } // Create a textarea for decoding entities, that we can reuse.


  if (undefined === _decodeTextArea) {
    if (document.implementation && document.implementation.createHTMLDocument) {
      _decodeTextArea = document.implementation.createHTMLDocument('').createElement('textarea');
    } else {
      _decodeTextArea = document.createElement('textarea');
    }
  }

  _decodeTextArea.innerHTML = html;
  const decoded = _decodeTextArea.textContent;
  _decodeTextArea.innerHTML = '';
  /**
   * Cast to string, HTMLTextAreaElement should always have `string` textContent.
   *
   * > The `textContent` property of the `Node` interface represents the text content of the
   * > node and its descendants.
   * >
   * > Value: A string or `null`
   * >
   * > * If the node is a `document` or a Doctype, `textContent` returns `null`.
   * > * If the node is a CDATA section, comment, processing instruction, or text node,
   * >   textContent returns the text inside the node, i.e., the `Node.nodeValue`.
   * > * For other node types, `textContent returns the concatenation of the textContent of
   * >   every child node, excluding comments and processing instructions. (This is an empty
   * >   string if the node has no children.)
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent
   */

  return (
    /** @type {string} */
    decoded
  );
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  __: () => (/* reexport */ __),
  _x: () => (/* reexport */ _x),
  V8: () => (/* reexport */ isRTL),
  nv: () => (/* reexport */ sprintf_sprintf)
});

// UNUSED EXPORTS: _n, _nx, createI18n, defaultI18n, getLocaleData, hasTranslation, resetLocaleData, setLocaleData, subscribe

// EXTERNAL MODULE: ../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js
var dist = __webpack_require__("../../node_modules/.pnpm/memize@2.1.0/node_modules/memize/dist/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/sprintf-js@1.1.3/node_modules/sprintf-js/src/sprintf.js
var sprintf = __webpack_require__("../../node_modules/.pnpm/sprintf-js@1.1.3/node_modules/sprintf-js/src/sprintf.js");
var sprintf_default = /*#__PURE__*/__webpack_require__.n(sprintf);
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/sprintf.js
/**
 * External dependencies
 */



/**
 * Log to console, once per message; or more precisely, per referentially equal
 * argument set. Because Jed throws errors, we log these to the console instead
 * to avoid crashing the application.
 *
 * @param {...*} args Arguments to pass to `console.error`
 */
const logErrorOnce = (0,dist/* default */.A)(console.error); // eslint-disable-line no-console

/**
 * Returns a formatted string. If an error occurs in applying the format, the
 * original format string is returned.
 *
 * @param {string} format The format of the string to generate.
 * @param {...*}   args   Arguments to apply to the format.
 *
 * @see https://www.npmjs.com/package/sprintf-js
 *
 * @return {string} The formatted string.
 */
function sprintf_sprintf(format, ...args) {
  try {
    return sprintf_default().sprintf(format, ...args);
  } catch (error) {
    if (error instanceof Error) {
      logErrorOnce('sprintf error: \n\n' + error.toString());
    }
    return format;
  }
}
//# sourceMappingURL=sprintf.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/tannin@1.2.0/node_modules/tannin/index.js + 4 modules
var node_modules_tannin = __webpack_require__("../../node_modules/.pnpm/tannin@1.2.0/node_modules/tannin/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/create-i18n.js
/**
 * External dependencies
 */


/**
 * @typedef {Record<string,any>} LocaleData
 */

/**
 * Default locale data to use for Tannin domain when not otherwise provided.
 * Assumes an English plural forms expression.
 *
 * @type {LocaleData}
 */
const DEFAULT_LOCALE_DATA = {
  '': {
    /** @param {number} n */
    plural_forms(n) {
      return n === 1 ? 0 : 1;
    }
  }
};

/*
 * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,
 * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.
 */
const I18N_HOOK_REGEXP = /^i18n\.(n?gettext|has_translation)(_|$)/;

/**
 * @typedef {(domain?: string) => LocaleData} GetLocaleData
 *
 * Returns locale data by domain in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/**
 * @typedef {(data?: LocaleData, domain?: string) => void} SetLocaleData
 *
 * Merges locale data into the Tannin instance by domain. Note that this
 * function will overwrite the domain configuration. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/**
 * @typedef {(data?: LocaleData, domain?: string) => void} AddLocaleData
 *
 * Merges locale data into the Tannin instance by domain. Note that this
 * function will also merge the domain configuration. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/**
 * @typedef {(data?: LocaleData, domain?: string) => void} ResetLocaleData
 *
 * Resets all current Tannin instance locale data and sets the specified
 * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/** @typedef {() => void} SubscribeCallback */
/** @typedef {() => void} UnsubscribeCallback */
/**
 * @typedef {(callback: SubscribeCallback) => UnsubscribeCallback} Subscribe
 *
 * Subscribes to changes of locale data
 */
/**
 * @typedef {(domain?: string) => string} GetFilterDomain
 * Retrieve the domain to use when calling domain-specific filters.
 */
/**
 * @typedef {(text: string, domain?: string) => string} __
 *
 * Retrieve the translation of text.
 *
 * @see https://developer.wordpress.org/reference/functions/__/
 */
/**
 * @typedef {(text: string, context: string, domain?: string) => string} _x
 *
 * Retrieve translated string with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_x/
 */
/**
 * @typedef {(single: string, plural: string, number: number, domain?: string) => string} _n
 *
 * Translates and retrieves the singular or plural form based on the supplied
 * number.
 *
 * @see https://developer.wordpress.org/reference/functions/_n/
 */
/**
 * @typedef {(single: string, plural: string, number: number, context: string, domain?: string) => string} _nx
 *
 * Translates and retrieves the singular or plural form based on the supplied
 * number, with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_nx/
 */
/**
 * @typedef {() => boolean} IsRtl
 *
 * Check if current locale is RTL.
 *
 * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
 * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
 * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
 * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
 */
/**
 * @typedef {(single: string, context?: string, domain?: string) => boolean} HasTranslation
 *
 * Check if there is a translation for a given string in singular form.
 */
/** @typedef {import('@wordpress/hooks').Hooks} Hooks */

/**
 * An i18n instance
 *
 * @typedef I18n
 * @property {GetLocaleData}   getLocaleData   Returns locale data by domain in a Jed-formatted JSON object shape.
 * @property {SetLocaleData}   setLocaleData   Merges locale data into the Tannin instance by domain. Note that this
 *                                             function will overwrite the domain configuration. Accepts data in a
 *                                             Jed-formatted JSON object shape.
 * @property {AddLocaleData}   addLocaleData   Merges locale data into the Tannin instance by domain. Note that this
 *                                             function will also merge the domain configuration. Accepts data in a
 *                                             Jed-formatted JSON object shape.
 * @property {ResetLocaleData} resetLocaleData Resets all current Tannin instance locale data and sets the specified
 *                                             locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 * @property {Subscribe}       subscribe       Subscribes to changes of Tannin locale data.
 * @property {__}              __              Retrieve the translation of text.
 * @property {_x}              _x              Retrieve translated string with gettext context.
 * @property {_n}              _n              Translates and retrieves the singular or plural form based on the supplied
 *                                             number.
 * @property {_nx}             _nx             Translates and retrieves the singular or plural form based on the supplied
 *                                             number, with gettext context.
 * @property {IsRtl}           isRTL           Check if current locale is RTL.
 * @property {HasTranslation}  hasTranslation  Check if there is a translation for a given string.
 */

/**
 * Create an i18n instance
 *
 * @param {LocaleData} [initialData]   Locale data configuration.
 * @param {string}     [initialDomain] Domain for which configuration applies.
 * @param {Hooks}      [hooks]         Hooks implementation.
 *
 * @return {I18n} I18n instance.
 */
const createI18n = (initialData, initialDomain, hooks) => {
  /**
   * The underlying instance of Tannin to which exported functions interface.
   *
   * @type {Tannin}
   */
  const tannin = new node_modules_tannin/* default */.A({});
  const listeners = new Set();
  const notifyListeners = () => {
    listeners.forEach(listener => listener());
  };

  /**
   * Subscribe to changes of locale data.
   *
   * @param {SubscribeCallback} callback Subscription callback.
   * @return {UnsubscribeCallback} Unsubscribe callback.
   */
  const subscribe = callback => {
    listeners.add(callback);
    return () => listeners.delete(callback);
  };

  /** @type {GetLocaleData} */
  const getLocaleData = (domain = 'default') => tannin.data[domain];

  /**
   * @param {LocaleData} [data]
   * @param {string}     [domain]
   */
  const doSetLocaleData = (data, domain = 'default') => {
    tannin.data[domain] = {
      ...tannin.data[domain],
      ...data
    };

    // Populate default domain configuration (supported locale date which omits
    // a plural forms expression).
    tannin.data[domain][''] = {
      ...DEFAULT_LOCALE_DATA[''],
      ...tannin.data[domain]?.['']
    };

    // Clean up cached plural forms functions cache as it might be updated.
    delete tannin.pluralForms[domain];
  };

  /** @type {SetLocaleData} */
  const setLocaleData = (data, domain) => {
    doSetLocaleData(data, domain);
    notifyListeners();
  };

  /** @type {AddLocaleData} */
  const addLocaleData = (data, domain = 'default') => {
    tannin.data[domain] = {
      ...tannin.data[domain],
      ...data,
      // Populate default domain configuration (supported locale date which omits
      // a plural forms expression).
      '': {
        ...DEFAULT_LOCALE_DATA[''],
        ...tannin.data[domain]?.[''],
        ...data?.['']
      }
    };

    // Clean up cached plural forms functions cache as it might be updated.
    delete tannin.pluralForms[domain];
    notifyListeners();
  };

  /** @type {ResetLocaleData} */
  const resetLocaleData = (data, domain) => {
    // Reset all current Tannin locale data.
    tannin.data = {};

    // Reset cached plural forms functions cache.
    tannin.pluralForms = {};
    setLocaleData(data, domain);
  };

  /**
   * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not
   * otherwise previously assigned.
   *
   * @param {string|undefined} domain   Domain to retrieve the translated text.
   * @param {string|undefined} context  Context information for the translators.
   * @param {string}           single   Text to translate if non-plural. Used as
   *                                    fallback return value on a caught error.
   * @param {string}           [plural] The text to be used if the number is
   *                                    plural.
   * @param {number}           [number] The number to compare against to use
   *                                    either the singular or plural form.
   *
   * @return {string} The translated string.
   */
  const dcnpgettext = (domain = 'default', context, single, plural, number) => {
    if (!tannin.data[domain]) {
      // Use `doSetLocaleData` to set silently, without notifying listeners.
      doSetLocaleData(undefined, domain);
    }
    return tannin.dcnpgettext(domain, context, single, plural, number);
  };

  /** @type {GetFilterDomain} */
  const getFilterDomain = (domain = 'default') => domain;

  /** @type {__} */
  const __ = (text, domain) => {
    let translation = dcnpgettext(domain, undefined, text);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters text with its translation.
     *
     * @param {string} translation Translated text.
     * @param {string} text        Text to translate.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.gettext', translation, text, domain);
    return /** @type {string} */(
      /** @type {*} */hooks.applyFilters('i18n.gettext_' + getFilterDomain(domain), translation, text, domain)
    );
  };

  /** @type {_x} */
  const _x = (text, context, domain) => {
    let translation = dcnpgettext(domain, context, text);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters text with its translation based on context information.
     *
     * @param {string} translation Translated text.
     * @param {string} text        Text to translate.
     * @param {string} context     Context information for the translators.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.gettext_with_context', translation, text, context, domain);
    return /** @type {string} */(
      /** @type {*} */hooks.applyFilters('i18n.gettext_with_context_' + getFilterDomain(domain), translation, text, context, domain)
    );
  };

  /** @type {_n} */
  const _n = (single, plural, number, domain) => {
    let translation = dcnpgettext(domain, undefined, single, plural, number);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters the singular or plural form of a string.
     *
     * @param {string} translation Translated text.
     * @param {string} single      The text to be used if the number is singular.
     * @param {string} plural      The text to be used if the number is plural.
     * @param {string} number      The number to compare against to use either the singular or plural form.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.ngettext', translation, single, plural, number, domain);
    return /** @type {string} */(
      /** @type {*} */hooks.applyFilters('i18n.ngettext_' + getFilterDomain(domain), translation, single, plural, number, domain)
    );
  };

  /** @type {_nx} */
  const _nx = (single, plural, number, context, domain) => {
    let translation = dcnpgettext(domain, context, single, plural, number);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters the singular or plural form of a string with gettext context.
     *
     * @param {string} translation Translated text.
     * @param {string} single      The text to be used if the number is singular.
     * @param {string} plural      The text to be used if the number is plural.
     * @param {string} number      The number to compare against to use either the singular or plural form.
     * @param {string} context     Context information for the translators.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.ngettext_with_context', translation, single, plural, number, context, domain);
    return /** @type {string} */(
      /** @type {*} */hooks.applyFilters('i18n.ngettext_with_context_' + getFilterDomain(domain), translation, single, plural, number, context, domain)
    );
  };

  /** @type {IsRtl} */
  const isRTL = () => {
    return 'rtl' === _x('ltr', 'text direction');
  };

  /** @type {HasTranslation} */
  const hasTranslation = (single, context, domain) => {
    const key = context ? context + '\u0004' + single : single;
    let result = !!tannin.data?.[domain !== null && domain !== void 0 ? domain : 'default']?.[key];
    if (hooks) {
      /**
       * Filters the presence of a translation in the locale data.
       *
       * @param {boolean} hasTranslation Whether the translation is present or not..
       * @param {string}  single         The singular form of the translated text (used as key in locale data)
       * @param {string}  context        Context information for the translators.
       * @param {string}  domain         Text domain. Unique identifier for retrieving translated strings.
       */
      result = /** @type { boolean } */
      /** @type {*} */hooks.applyFilters('i18n.has_translation', result, single, context, domain);
      result = /** @type { boolean } */
      /** @type {*} */hooks.applyFilters('i18n.has_translation_' + getFilterDomain(domain), result, single, context, domain);
    }
    return result;
  };
  if (initialData) {
    setLocaleData(initialData, initialDomain);
  }
  if (hooks) {
    /**
     * @param {string} hookName
     */
    const onHookAddedOrRemoved = hookName => {
      if (I18N_HOOK_REGEXP.test(hookName)) {
        notifyListeners();
      }
    };
    hooks.addAction('hookAdded', 'core/i18n', onHookAddedOrRemoved);
    hooks.addAction('hookRemoved', 'core/i18n', onHookAddedOrRemoved);
  }
  return {
    getLocaleData,
    setLocaleData,
    addLocaleData,
    resetLocaleData,
    subscribe,
    __,
    _x,
    _n,
    _nx,
    isRTL,
    hasTranslation
  };
};
//# sourceMappingURL=create-i18n.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+hooks@3.57.0/node_modules/@wordpress/hooks/build-module/index.js + 10 modules
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+hooks@3.57.0/node_modules/@wordpress/hooks/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/default-i18n.js
/**
 * Internal dependencies
 */


/**
 * WordPress dependencies
 */

const i18n = createI18n(undefined, undefined, build_module/* defaultHooks */.se);

/**
 * Default, singleton instance of `I18n`.
 */
/* harmony default export */ const default_i18n = ((/* unused pure expression or super */ null && (i18n)));

/*
 * Comments in this file are duplicated from ./i18n due to
 * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722
 */

/**
 * @typedef {import('./create-i18n').LocaleData} LocaleData
 * @typedef {import('./create-i18n').SubscribeCallback} SubscribeCallback
 * @typedef {import('./create-i18n').UnsubscribeCallback} UnsubscribeCallback
 */

/**
 * Returns locale data by domain in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {string} [domain] Domain for which to get the data.
 * @return {LocaleData} Locale data.
 */
const getLocaleData = i18n.getLocaleData.bind(i18n);

/**
 * Merges locale data into the Tannin instance by domain. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {LocaleData} [data]   Locale data configuration.
 * @param {string}     [domain] Domain for which configuration applies.
 */
const setLocaleData = i18n.setLocaleData.bind(i18n);

/**
 * Resets all current Tannin instance locale data and sets the specified
 * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {LocaleData} [data]   Locale data configuration.
 * @param {string}     [domain] Domain for which configuration applies.
 */
const resetLocaleData = i18n.resetLocaleData.bind(i18n);

/**
 * Subscribes to changes of locale data
 *
 * @param {SubscribeCallback} callback Subscription callback
 * @return {UnsubscribeCallback} Unsubscribe callback
 */
const subscribe = i18n.subscribe.bind(i18n);

/**
 * Retrieve the translation of text.
 *
 * @see https://developer.wordpress.org/reference/functions/__/
 *
 * @param {string} text     Text to translate.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} Translated text.
 */
const __ = i18n.__.bind(i18n);

/**
 * Retrieve translated string with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_x/
 *
 * @param {string} text     Text to translate.
 * @param {string} context  Context information for the translators.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} Translated context string without pipe.
 */
const _x = i18n._x.bind(i18n);

/**
 * Translates and retrieves the singular or plural form based on the supplied
 * number.
 *
 * @see https://developer.wordpress.org/reference/functions/_n/
 *
 * @param {string} single   The text to be used if the number is singular.
 * @param {string} plural   The text to be used if the number is plural.
 * @param {number} number   The number to compare against to use either the
 *                          singular or plural form.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} The translated singular or plural form.
 */
const _n = i18n._n.bind(i18n);

/**
 * Translates and retrieves the singular or plural form based on the supplied
 * number, with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_nx/
 *
 * @param {string} single   The text to be used if the number is singular.
 * @param {string} plural   The text to be used if the number is plural.
 * @param {number} number   The number to compare against to use either the
 *                          singular or plural form.
 * @param {string} context  Context information for the translators.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} The translated singular or plural form.
 */
const _nx = i18n._nx.bind(i18n);

/**
 * Check if current locale is RTL.
 *
 * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
 * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
 * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
 * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
 *
 * @return {boolean} Whether locale is RTL.
 */
const isRTL = i18n.isRTL.bind(i18n);

/**
 * Check if there is a translation for a given string (in singular form).
 *
 * @param {string} single    Singular form of the string to look up.
 * @param {string} [context] Context information for the translators.
 * @param {string} [domain]  Domain to retrieve the translated text.
 * @return {boolean} Whether the translation exists or not.
 */
const hasTranslation = i18n.hasTranslation.bind(i18n);
//# sourceMappingURL=default-i18n.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+i18n@4.57.0/node_modules/@wordpress/i18n/build-module/index.js



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+icons@9.36.0/node_modules/@wordpress/icons/build-module/library/close.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var _wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/@wordpress+primitives@3.45.0/node_modules/@wordpress/primitives/build-module/svg/index.js");

/**
 * WordPress dependencies
 */

const close = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .SVG */ .t4, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_wordpress_primitives__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .wA, {
  d: "M13 11.8l6.1-6.3-1-1-6.1 6.2-6.1-6.2-1 1 6.1 6.3-6.5 6.7 1 1 6.5-6.6 6.5 6.6 1-1z"
}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (close);
//# sourceMappingURL=close.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ee: () => (/* reexport */ ShortcutProvider)
});

// UNUSED EXPORTS: __unstableUseShortcutEventMatch, store, useShortcut

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
var actions_namespaceObject = {};
__webpack_require__.r(actions_namespaceObject);
__webpack_require__.d(actions_namespaceObject, {
  registerShortcut: () => (registerShortcut),
  unregisterShortcut: () => (unregisterShortcut)
});

// NAMESPACE OBJECT: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
var selectors_namespaceObject = {};
__webpack_require__.r(selectors_namespaceObject);
__webpack_require__.d(selectors_namespaceObject, {
  getAllShortcutKeyCombinations: () => (getAllShortcutKeyCombinations),
  getAllShortcutRawKeyCombinations: () => (getAllShortcutRawKeyCombinations),
  getCategoryShortcuts: () => (getCategoryShortcuts),
  getShortcutAliases: () => (getShortcutAliases),
  getShortcutDescription: () => (getShortcutDescription),
  getShortcutKeyCombination: () => (getShortcutKeyCombination),
  getShortcutRepresentation: () => (getShortcutRepresentation)
});

// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@6.6.1_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js + 7 modules
var redux_store = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@6.6.1_react@17.0.2/node_modules/@wordpress/data/build-module/redux-store/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+data@6.6.1_react@17.0.2/node_modules/@wordpress/data/build-module/index.js
var build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+data@6.6.1_react@17.0.2/node_modules/@wordpress/data/build-module/index.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var lodash = __webpack_require__("../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/reducer.js
/**
 * External dependencies
 */

/**
 * Reducer returning the registered shortcuts
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function reducer() {
  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'REGISTER_SHORTCUT':
      return { ...state,
        [action.name]: {
          category: action.category,
          keyCombination: action.keyCombination,
          aliases: action.aliases,
          description: action.description
        }
      };

    case 'UNREGISTER_SHORTCUT':
      return (0,lodash.omit)(state, action.name);
  }

  return state;
}

/* harmony default export */ const store_reducer = (reducer);
//# sourceMappingURL=reducer.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
/** @typedef {import('@wordpress/keycodes').WPKeycodeModifier} WPKeycodeModifier */

/**
 * Keyboard key combination.
 *
 * @typedef {Object} WPShortcutKeyCombination
 *
 * @property {string}                      character Character.
 * @property {WPKeycodeModifier|undefined} modifier  Modifier.
 */

/**
 * Configuration of a registered keyboard shortcut.
 *
 * @typedef {Object} WPShortcutConfig
 *
 * @property {string}                     name           Shortcut name.
 * @property {string}                     category       Shortcut category.
 * @property {string}                     description    Shortcut description.
 * @property {WPShortcutKeyCombination}   keyCombination Shortcut key combination.
 * @property {WPShortcutKeyCombination[]} [aliases]      Shortcut aliases.
 */

/**
 * Returns an action object used to register a new keyboard shortcut.
 *
 * @param {WPShortcutConfig} config Shortcut config.
 *
 * @return {Object} action.
 */
function registerShortcut(_ref) {
  let {
    name,
    category,
    description,
    keyCombination,
    aliases
  } = _ref;
  return {
    type: 'REGISTER_SHORTCUT',
    name,
    category,
    keyCombination,
    aliases,
    description
  };
}
/**
 * Returns an action object used to unregister a keyboard shortcut.
 *
 * @param {string} name Shortcut name.
 *
 * @return {Object} action.
 */

function unregisterShortcut(name) {
  return {
    type: 'UNREGISTER_SHORTCUT',
    name
  };
}
//# sourceMappingURL=actions.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/rememo@3.0.0/node_modules/rememo/es/rememo.js
var rememo = __webpack_require__("../../node_modules/.pnpm/rememo@3.0.0/node_modules/rememo/es/rememo.js");
// EXTERNAL MODULE: ../../node_modules/.pnpm/@wordpress+keycodes@3.6.1/node_modules/@wordpress/keycodes/build-module/index.js + 1 modules
var keycodes_build_module = __webpack_require__("../../node_modules/.pnpm/@wordpress+keycodes@3.6.1/node_modules/@wordpress/keycodes/build-module/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/** @typedef {import('./actions').WPShortcutKeyCombination} WPShortcutKeyCombination */

/** @typedef {import('@wordpress/keycodes').WPKeycodeHandlerByModifier} WPKeycodeHandlerByModifier */

/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation.
 *
 * @type {Array<any>}
 */

const EMPTY_ARRAY = [];
/**
 * Shortcut formatting methods.
 *
 * @property {WPKeycodeHandlerByModifier} display     Display formatting.
 * @property {WPKeycodeHandlerByModifier} rawShortcut Raw shortcut formatting.
 * @property {WPKeycodeHandlerByModifier} ariaLabel   ARIA label formatting.
 */

const FORMATTING_METHODS = {
  display: keycodes_build_module/* displayShortcut */.dz,
  raw: keycodes_build_module/* rawShortcut */.JF,
  ariaLabel: keycodes_build_module/* shortcutAriaLabel */._A
};
/**
 * Returns a string representing the key combination.
 *
 * @param {?WPShortcutKeyCombination} shortcut       Key combination.
 * @param {keyof FORMATTING_METHODS}  representation Type of representation
 *                                                   (display, raw, ariaLabel).
 *
 * @return {string?} Shortcut representation.
 */

function getKeyCombinationRepresentation(shortcut, representation) {
  if (!shortcut) {
    return null;
  }

  return shortcut.modifier ? FORMATTING_METHODS[representation][shortcut.modifier](shortcut.character) : shortcut.character;
}
/**
 * Returns the main key combination for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {WPShortcutKeyCombination?} Key combination.
 */


function getShortcutKeyCombination(state, name) {
  return state[name] ? state[name].keyCombination : null;
}
/**
 * Returns a string representing the main key combination for a given shortcut name.
 *
 * @param {Object}                   state          Global state.
 * @param {string}                   name           Shortcut name.
 * @param {keyof FORMATTING_METHODS} representation Type of representation
 *                                                  (display, raw, ariaLabel).
 *
 * @return {string?} Shortcut representation.
 */

function getShortcutRepresentation(state, name) {
  let representation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'display';
  const shortcut = getShortcutKeyCombination(state, name);
  return getKeyCombinationRepresentation(shortcut, representation);
}
/**
 * Returns the shortcut description given its name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {string?} Shortcut description.
 */

function getShortcutDescription(state, name) {
  return state[name] ? state[name].description : null;
}
/**
 * Returns the aliases for a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {WPShortcutKeyCombination[]} Key combinations.
 */

function getShortcutAliases(state, name) {
  return state[name] && state[name].aliases ? state[name].aliases : EMPTY_ARRAY;
}
const getAllShortcutKeyCombinations = (0,rememo/* default */.A)((state, name) => {
  return (0,lodash.compact)([getShortcutKeyCombination(state, name), ...getShortcutAliases(state, name)]);
}, (state, name) => [state[name]]);
/**
 * Returns the raw representation of all the keyboard combinations of a given shortcut name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Shortcut name.
 *
 * @return {string[]} Shortcuts.
 */

const getAllShortcutRawKeyCombinations = (0,rememo/* default */.A)((state, name) => {
  return getAllShortcutKeyCombinations(state, name).map(combination => getKeyCombinationRepresentation(combination, 'raw'));
}, (state, name) => [state[name]]);
/**
 * Returns the shortcut names list for a given category name.
 *
 * @param {Object} state Global state.
 * @param {string} name  Category name.
 *
 * @return {string[]} Shortcut names.
 */

const getCategoryShortcuts = (0,rememo/* default */.A)((state, categoryName) => {
  return Object.entries(state).filter(_ref => {
    let [, shortcut] = _ref;
    return shortcut.category === categoryName;
  }).map(_ref2 => {
    let [name] = _ref2;
    return name;
  });
}, state => [state]);
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/store/index.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




const STORE_NAME = 'core/keyboard-shortcuts';
/**
 * Store definition for the keyboard shortcuts namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const store = (0,redux_store/* default */.A)(STORE_NAME, {
  reducer: store_reducer,
  actions: actions_namespaceObject,
  selectors: selectors_namespaceObject
});
(0,build_module/* register */.kz)(store);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut-event-match.js
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */


/**
 * Returns a function to check if a keyboard event matches a shortcut name.
 *
 * @return {Function} A function to to check if a keyboard event matches a
 *                    predefined shortcut combination.
 */

function use_shortcut_event_match_useShortcutEventMatch() {
  const {
    getAllShortcutKeyCombinations
  } = useSelect(keyboardShortcutsStore);
  /**
   * A function to check if a keyboard event matches a predefined shortcut
   * combination.
   *
   * @param {string}        name  Shortcut name.
   * @param {KeyboardEvent} event Event to check.
   *
   * @return {boolean} True if the event matches any shortcuts, false if not.
   */

  function isMatch(name, event) {
    return getAllShortcutKeyCombinations(name).some(_ref => {
      let {
        modifier,
        character
      } = _ref;
      return isKeyboardEvent[modifier](event, character);
    });
  }

  return isMatch;
}
//# sourceMappingURL=use-shortcut-event-match.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var react = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/context.js
/**
 * WordPress dependencies
 */

const context_context = (0,react.createContext)();
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut.js
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */



/**
 * Attach a keyboard shortcut handler.
 *
 * @param {string}   name               Shortcut name.
 * @param {Function} callback           Shortcut callback.
 * @param {Object}   options            Shortcut options.
 * @param {boolean}  options.isDisabled Whether to disable to shortut.
 */

function useShortcut(name, callback) {
  let {
    isDisabled
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const shortcuts = useContext(context);
  const isMatch = useShortcutEventMatch();
  const callbackRef = useRef();
  callbackRef.current = callback;
  useEffect(() => {
    if (isDisabled) {
      return;
    }

    function _callback(event) {
      if (isMatch(name, event)) {
        callbackRef.current(event);
      }
    }

    shortcuts.current.add(_callback);
    return () => {
      shortcuts.current.delete(_callback);
    };
  }, [name, isDisabled]);
}
//# sourceMappingURL=use-shortcut.js.map
// EXTERNAL MODULE: ../../node_modules/.pnpm/@babel+runtime@7.25.0/node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__("../../node_modules/.pnpm/@babel+runtime@7.25.0/node_modules/@babel/runtime/helpers/esm/extends.js");
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/components/shortcut-provider.js



/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const {
  Provider
} = context_context;
/**
 * Handles callbacks added to context by `useShortcut`.
 *
 * @param {Object} props Props to pass to `div`.
 *
 * @return {import('@wordpress/element').WPElement} Component.
 */

function ShortcutProvider(props) {
  const keyboardShortcuts = (0,react.useRef)(new Set());

  function onKeyDown(event) {
    if (props.onKeyDown) props.onKeyDown(event);

    for (const keyboardShortcut of keyboardShortcuts.current) {
      keyboardShortcut(event);
    }
  }
  /* eslint-disable jsx-a11y/no-static-element-interactions */


  return (0,react.createElement)(Provider, {
    value: keyboardShortcuts
  }, (0,react.createElement)("div", (0,esm_extends/* default */.A)({}, props, {
    onKeyDown: onKeyDown
  })));
  /* eslint-enable jsx-a11y/no-static-element-interactions */
}
//# sourceMappingURL=shortcut-provider.js.map
;// CONCATENATED MODULE: ../../node_modules/.pnpm/@wordpress+keyboard-shortcuts@3.4.1_react@17.0.2/node_modules/@wordpress/keyboard-shortcuts/build-module/index.js




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/@wordpress+primitives@3.55.0/node_modules/@wordpress/primitives/build-module/svg/index.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t4: () => (/* binding */ SVG),
/* harmony export */   wA: () => (/* binding */ Path)
/* harmony export */ });
/* unused harmony exports Circle, G, Line, Polygon, Rect, Defs, RadialGradient, LinearGradient, Stop */
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


/** @typedef {{isPressed?: boolean} & import('react').ComponentPropsWithoutRef<'svg'>} SVGProps */

/**
 * @param {import('react').ComponentPropsWithoutRef<'circle'>} props
 *
 * @return {JSX.Element} Circle component
 */
const Circle = props => createElement('circle', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'g'>} props
 *
 * @return {JSX.Element} G component
 */
const G = props => createElement('g', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'line'>} props
 *
 * @return {JSX.Element} Path component
 */
const Line = props => createElement('line', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'path'>} props
 *
 * @return {JSX.Element} Path component
 */
const Path = props => (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.createElement)('path', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'polygon'>} props
 *
 * @return {JSX.Element} Polygon component
 */
const Polygon = props => createElement('polygon', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'rect'>} props
 *
 * @return {JSX.Element} Rect component
 */
const Rect = props => createElement('rect', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'defs'>} props
 *
 * @return {JSX.Element} Defs component
 */
const Defs = props => createElement('defs', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'radialGradient'>} props
 *
 * @return {JSX.Element} RadialGradient component
 */
const RadialGradient = props => createElement('radialGradient', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'linearGradient'>} props
 *
 * @return {JSX.Element} LinearGradient component
 */
const LinearGradient = props => createElement('linearGradient', props);

/**
 * @param {import('react').ComponentPropsWithoutRef<'stop'>} props
 *
 * @return {JSX.Element} Stop component
 */
const Stop = props => createElement('stop', props);
const SVG = (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(
/**
 * @param {SVGProps}                                    props isPressed indicates whether the SVG should appear as pressed.
 *                                                            Other props will be passed through to svg component.
 * @param {import('react').ForwardedRef<SVGSVGElement>} ref   The forwarded ref to the SVG element.
 *
 * @return {JSX.Element} Stop component
 */
({
  className,
  isPressed,
  ...props
}, ref) => {
  const appliedProps = {
    ...props,
    className: classnames__WEBPACK_IMPORTED_MODULE_0___default()(className, {
      'is-pressed': isPressed
    }) || undefined,
    'aria-hidden': true,
    focusable: false
  };

  // Disable reason: We need to have a way to render HTML tag for web.
  // eslint-disable-next-line react/forbid-elements
  return (0,_wordpress_element__WEBPACK_IMPORTED_MODULE_1__.createElement)("svg", {
    ...appliedProps,
    ref: ref
  });
});
SVG.displayName = 'SVG';
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/.pnpm/autosize@4.0.4/node_modules/autosize/dist/autosize.js":
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else { var mod; }
})(this, function (module, exports) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			delete: function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	}();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function createEvent(name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = null;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				return;
			}

			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = '';
			ta.style.height = ta.scrollHeight + heightOffset + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that 
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight < styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map.delete(ta);
		}.bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function autosize(el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function autosize(el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	exports.default = autosize;
	module.exports = exports['default'];
});

/***/ }),

/***/ "../../node_modules/.pnpm/clipboard@2.0.11/node_modules/clipboard/dist/clipboard.js":
/***/ (function(module) {

/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 686:
/***/ (function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_623__) {

"use strict";

// EXPORTS
__nested_webpack_require_623__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ clipboard; }
});

// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
var tiny_emitter = __nested_webpack_require_623__(279);
var tiny_emitter_default = /*#__PURE__*/__nested_webpack_require_623__.n(tiny_emitter);
// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
var listen = __nested_webpack_require_623__(370);
var listen_default = /*#__PURE__*/__nested_webpack_require_623__.n(listen);
// EXTERNAL MODULE: ./node_modules/select/src/select.js
var src_select = __nested_webpack_require_623__(817);
var select_default = /*#__PURE__*/__nested_webpack_require_623__.n(src_select);
;// CONCATENATED MODULE: ./src/common/command.js
/**
 * Executes a given operation type.
 * @param {String} type
 * @return {Boolean}
 */
function command(type) {
  try {
    return document.execCommand(type);
  } catch (err) {
    return false;
  }
}
;// CONCATENATED MODULE: ./src/actions/cut.js


/**
 * Cut action wrapper.
 * @param {String|HTMLElement} target
 * @return {String}
 */

var ClipboardActionCut = function ClipboardActionCut(target) {
  var selectedText = select_default()(target);
  command('cut');
  return selectedText;
};

/* harmony default export */ var actions_cut = (ClipboardActionCut);
;// CONCATENATED MODULE: ./src/common/create-fake-element.js
/**
 * Creates a fake textarea element with a value.
 * @param {String} value
 * @return {HTMLElement}
 */
function createFakeElement(value) {
  var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
  var fakeElement = document.createElement('textarea'); // Prevent zooming on iOS

  fakeElement.style.fontSize = '12pt'; // Reset box model

  fakeElement.style.border = '0';
  fakeElement.style.padding = '0';
  fakeElement.style.margin = '0'; // Move element out of screen horizontally

  fakeElement.style.position = 'absolute';
  fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
  fakeElement.style.top = "".concat(yPosition, "px");
  fakeElement.setAttribute('readonly', '');
  fakeElement.value = value;
  return fakeElement;
}
;// CONCATENATED MODULE: ./src/actions/copy.js



/**
 * Create fake copy action wrapper using a fake element.
 * @param {String} target
 * @param {Object} options
 * @return {String}
 */

var fakeCopyAction = function fakeCopyAction(value, options) {
  var fakeElement = createFakeElement(value);
  options.container.appendChild(fakeElement);
  var selectedText = select_default()(fakeElement);
  command('copy');
  fakeElement.remove();
  return selectedText;
};
/**
 * Copy action wrapper.
 * @param {String|HTMLElement} target
 * @param {Object} options
 * @return {String}
 */


var ClipboardActionCopy = function ClipboardActionCopy(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    container: document.body
  };
  var selectedText = '';

  if (typeof target === 'string') {
    selectedText = fakeCopyAction(target, options);
  } else if (target instanceof HTMLInputElement && !['text', 'search', 'url', 'tel', 'password'].includes(target === null || target === void 0 ? void 0 : target.type)) {
    // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
    selectedText = fakeCopyAction(target.value, options);
  } else {
    selectedText = select_default()(target);
    command('copy');
  }

  return selectedText;
};

/* harmony default export */ var actions_copy = (ClipboardActionCopy);
;// CONCATENATED MODULE: ./src/actions/default.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



/**
 * Inner function which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 * @param {Object} options
 */

var ClipboardActionDefault = function ClipboardActionDefault() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Defines base properties passed from constructor.
  var _options$action = options.action,
      action = _options$action === void 0 ? 'copy' : _options$action,
      container = options.container,
      target = options.target,
      text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.

  if (action !== 'copy' && action !== 'cut') {
    throw new Error('Invalid "action" value, use either "copy" or "cut"');
  } // Sets the `target` property using an element that will be have its content copied.


  if (target !== undefined) {
    if (target && _typeof(target) === 'object' && target.nodeType === 1) {
      if (action === 'copy' && target.hasAttribute('disabled')) {
        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
      }

      if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
        throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
      }
    } else {
      throw new Error('Invalid "target" value, use a valid Element');
    }
  } // Define selection strategy based on `text` property.


  if (text) {
    return actions_copy(text, {
      container: container
    });
  } // Defines which selection strategy based on `target` property.


  if (target) {
    return action === 'cut' ? actions_cut(target) : actions_copy(target, {
      container: container
    });
  }
};

/* harmony default export */ var actions_default = (ClipboardActionDefault);
;// CONCATENATED MODULE: ./src/clipboard.js
function clipboard_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return clipboard_typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






/**
 * Helper function to retrieve attribute value.
 * @param {String} suffix
 * @param {Element} element
 */

function getAttributeValue(suffix, element) {
  var attribute = "data-clipboard-".concat(suffix);

  if (!element.hasAttribute(attribute)) {
    return;
  }

  return element.getAttribute(attribute);
}
/**
 * Base class which takes one or more elements, adds event listeners to them,
 * and instantiates a new `ClipboardAction` on each click.
 */


var Clipboard = /*#__PURE__*/function (_Emitter) {
  _inherits(Clipboard, _Emitter);

  var _super = _createSuper(Clipboard);

  /**
   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
   * @param {Object} options
   */
  function Clipboard(trigger, options) {
    var _this;

    _classCallCheck(this, Clipboard);

    _this = _super.call(this);

    _this.resolveOptions(options);

    _this.listenClick(trigger);

    return _this;
  }
  /**
   * Defines if attributes would be resolved using internal setter functions
   * or custom functions that were passed in the constructor.
   * @param {Object} options
   */


  _createClass(Clipboard, [{
    key: "resolveOptions",
    value: function resolveOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
      this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
      this.text = typeof options.text === 'function' ? options.text : this.defaultText;
      this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
    }
    /**
     * Adds a click event listener to the passed trigger.
     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
     */

  }, {
    key: "listenClick",
    value: function listenClick(trigger) {
      var _this2 = this;

      this.listener = listen_default()(trigger, 'click', function (e) {
        return _this2.onClick(e);
      });
    }
    /**
     * Defines a new `ClipboardAction` on each click event.
     * @param {Event} e
     */

  }, {
    key: "onClick",
    value: function onClick(e) {
      var trigger = e.delegateTarget || e.currentTarget;
      var action = this.action(trigger) || 'copy';
      var text = actions_default({
        action: action,
        container: this.container,
        target: this.target(trigger),
        text: this.text(trigger)
      }); // Fires an event based on the copy operation result.

      this.emit(text ? 'success' : 'error', {
        action: action,
        text: text,
        trigger: trigger,
        clearSelection: function clearSelection() {
          if (trigger) {
            trigger.focus();
          }

          window.getSelection().removeAllRanges();
        }
      });
    }
    /**
     * Default `action` lookup function.
     * @param {Element} trigger
     */

  }, {
    key: "defaultAction",
    value: function defaultAction(trigger) {
      return getAttributeValue('action', trigger);
    }
    /**
     * Default `target` lookup function.
     * @param {Element} trigger
     */

  }, {
    key: "defaultTarget",
    value: function defaultTarget(trigger) {
      var selector = getAttributeValue('target', trigger);

      if (selector) {
        return document.querySelector(selector);
      }
    }
    /**
     * Allow fire programmatically a copy action
     * @param {String|HTMLElement} target
     * @param {Object} options
     * @returns Text copied.
     */

  }, {
    key: "defaultText",

    /**
     * Default `text` lookup function.
     * @param {Element} trigger
     */
    value: function defaultText(trigger) {
      return getAttributeValue('text', trigger);
    }
    /**
     * Destroy lifecycle.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.listener.destroy();
    }
  }], [{
    key: "copy",
    value: function copy(target) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        container: document.body
      };
      return actions_copy(target, options);
    }
    /**
     * Allow fire programmatically a cut action
     * @param {String|HTMLElement} target
     * @returns Text cutted.
     */

  }, {
    key: "cut",
    value: function cut(target) {
      return actions_cut(target);
    }
    /**
     * Returns the support of the given action, or all actions if no action is
     * given.
     * @param {String} [action]
     */

  }, {
    key: "isSupported",
    value: function isSupported() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
      var actions = typeof action === 'string' ? [action] : action;
      var support = !!document.queryCommandSupported;
      actions.forEach(function (action) {
        support = support && !!document.queryCommandSupported(action);
      });
      return support;
    }
  }]);

  return Clipboard;
}((tiny_emitter_default()));

/* harmony default export */ var clipboard = (Clipboard);

/***/ }),

/***/ 828:
/***/ (function(module) {

var DOCUMENT_NODE_TYPE = 9;

/**
 * A polyfill for Element.matches()
 */
if (typeof Element !== 'undefined' && !Element.prototype.matches) {
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector ||
                    proto.mozMatchesSelector ||
                    proto.msMatchesSelector ||
                    proto.oMatchesSelector ||
                    proto.webkitMatchesSelector;
}

/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */
function closest (element, selector) {
    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === 'function' &&
            element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
    }
}

module.exports = closest;


/***/ }),

/***/ 438:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_15749__) {

var closest = __nested_webpack_require_15749__(828);

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function _delegate(element, selector, type, callback, useCapture) {
    var listenerFn = listener.apply(this, arguments);

    element.addEventListener(type, listenerFn, useCapture);

    return {
        destroy: function() {
            element.removeEventListener(type, listenerFn, useCapture);
        }
    }
}

/**
 * Delegates event to a selector.
 *
 * @param {Element|String|Array} [elements]
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function delegate(elements, selector, type, callback, useCapture) {
    // Handle the regular Element usage
    if (typeof elements.addEventListener === 'function') {
        return _delegate.apply(null, arguments);
    }

    // Handle Element-less usage, it defaults to global delegation
    if (typeof type === 'function') {
        // Use `document` as the first parameter, then apply arguments
        // This is a short way to .unshift `arguments` without running into deoptimizations
        return _delegate.bind(null, document).apply(null, arguments);
    }

    // Handle Selector-based usage
    if (typeof elements === 'string') {
        elements = document.querySelectorAll(elements);
    }

    // Handle Array-like based usage
    return Array.prototype.map.call(elements, function (element) {
        return _delegate(element, selector, type, callback, useCapture);
    });
}

/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */
function listener(element, selector, type, callback) {
    return function(e) {
        e.delegateTarget = closest(e.target, selector);

        if (e.delegateTarget) {
            callback.call(element, e);
        }
    }
}

module.exports = delegate;


/***/ }),

/***/ 879:
/***/ (function(__unused_webpack_module, exports) {

/**
 * Check if argument is a HTML element.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.node = function(value) {
    return value !== undefined
        && value instanceof HTMLElement
        && value.nodeType === 1;
};

/**
 * Check if argument is a list of HTML elements.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.nodeList = function(value) {
    var type = Object.prototype.toString.call(value);

    return value !== undefined
        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
        && ('length' in value)
        && (value.length === 0 || exports.node(value[0]));
};

/**
 * Check if argument is a string.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.string = function(value) {
    return typeof value === 'string'
        || value instanceof String;
};

/**
 * Check if argument is a function.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.fn = function(value) {
    var type = Object.prototype.toString.call(value);

    return type === '[object Function]';
};


/***/ }),

/***/ 370:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_19113__) {

var is = __nested_webpack_require_19113__(879);
var delegate = __nested_webpack_require_19113__(438);

/**
 * Validates all params and calls the right
 * listener function based on its target type.
 *
 * @param {String|HTMLElement|HTMLCollection|NodeList} target
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listen(target, type, callback) {
    if (!target && !type && !callback) {
        throw new Error('Missing required arguments');
    }

    if (!is.string(type)) {
        throw new TypeError('Second argument must be a String');
    }

    if (!is.fn(callback)) {
        throw new TypeError('Third argument must be a Function');
    }

    if (is.node(target)) {
        return listenNode(target, type, callback);
    }
    else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
    }
    else if (is.string(target)) {
        return listenSelector(target, type, callback);
    }
    else {
        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
    }
}

/**
 * Adds an event listener to a HTML element
 * and returns a remove listener function.
 *
 * @param {HTMLElement} node
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNode(node, type, callback) {
    node.addEventListener(type, callback);

    return {
        destroy: function() {
            node.removeEventListener(type, callback);
        }
    }
}

/**
 * Add an event listener to a list of HTML elements
 * and returns a remove listener function.
 *
 * @param {NodeList|HTMLCollection} nodeList
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNodeList(nodeList, type, callback) {
    Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
    });

    return {
        destroy: function() {
            Array.prototype.forEach.call(nodeList, function(node) {
                node.removeEventListener(type, callback);
            });
        }
    }
}

/**
 * Add an event listener to a selector
 * and returns a remove listener function.
 *
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenSelector(selector, type, callback) {
    return delegate(document.body, selector, type, callback);
}

module.exports = listen;


/***/ }),

/***/ 817:
/***/ (function(module) {

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;


/***/ }),

/***/ 279:
/***/ (function(module) {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_24495__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_24495__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_24495__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_24495__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_24495__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_24495__.o(definition, key) && !__nested_webpack_require_24495__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_24495__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_24495__(686);
/******/ })()
.default;
});

/***/ }),

/***/ "../../node_modules/.pnpm/colord@2.9.3/node_modules/colord/plugins/a11y.mjs":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var o=function(o){var t=o/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},t=function(t){return.2126*o(t.r)+.7152*o(t.g)+.0722*o(t.b)};/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(o){o.prototype.luminance=function(){return o=t(this.rgba),void 0===(r=2)&&(r=0),void 0===n&&(n=Math.pow(10,r)),Math.round(n*o)/n+0;var o,r,n},o.prototype.contrast=function(r){void 0===r&&(r="#FFF");var n,a,i,e,v,u,d,c=r instanceof o?r:new o(r);return e=this.rgba,v=c.toRgb(),u=t(e),d=t(v),n=u>d?(u+.05)/(d+.05):(d+.05)/(u+.05),void 0===(a=2)&&(a=0),void 0===i&&(i=Math.pow(10,a)),Math.floor(i*n)/i+0},o.prototype.isReadable=function(o,t){return void 0===o&&(o="#FFF"),void 0===t&&(t={}),this.contrast(o)>=(e=void 0===(i=(r=t).size)?"normal":i,"AAA"===(a=void 0===(n=r.level)?"AA":n)&&"normal"===e?7:"AA"===a&&"large"===e?3:4.5);var r,n,a,i,e}}


/***/ }),

/***/ "../../node_modules/.pnpm/computed-style@0.1.4/node_modules/computed-style/dist/computedStyle.commonjs.js":
/***/ ((module) => {

// This code has been refactored for 140 bytes
// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js
var computedStyle = function (el, prop, getComputedStyle) {
  getComputedStyle = window.getComputedStyle;

  // In one fell swoop
  return (
    // If we have getComputedStyle
    getComputedStyle ?
      // Query it
      // TODO: From CSS-Query notes, we might need (node, null) for FF
      getComputedStyle(el) :

    // Otherwise, we are in IE and use currentStyle
      el.currentStyle
  )[
    // Switch to camelCase for CSSOM
    // DEV: Grabbed from jQuery
    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194
    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597
    prop.replace(/-(\w)/gi, function (word, letter) {
      return letter.toUpperCase();
    })
  ];
};

module.exports = computedStyle;


/***/ }),

/***/ "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/base.js":
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*istanbul ignore start*/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = Diff;

/*istanbul ignore end*/
function Diff() {}

Diff.prototype = {
  /*istanbul ignore start*/

  /*istanbul ignore end*/
  diff: function diff(oldString, newString) {
    /*istanbul ignore start*/
    var
    /*istanbul ignore end*/
    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath =
        /*istanbul ignore start*/
        void 0
        /*istanbul ignore end*/
        ;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  castInput: function castInput(value) {
    return value;
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  tokenize: function tokenize(value) {
    return value.split('');
  },

  /*istanbul ignore start*/

  /*istanbul ignore end*/
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2Jhc2UuanMiXSwibmFtZXMiOlsiRGlmZiIsInByb3RvdHlwZSIsImRpZmYiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJvcHRpb25zIiwiY2FsbGJhY2siLCJzZWxmIiwiZG9uZSIsInZhbHVlIiwic2V0VGltZW91dCIsInVuZGVmaW5lZCIsImNhc3RJbnB1dCIsInJlbW92ZUVtcHR5IiwidG9rZW5pemUiLCJuZXdMZW4iLCJsZW5ndGgiLCJvbGRMZW4iLCJlZGl0TGVuZ3RoIiwibWF4RWRpdExlbmd0aCIsImJlc3RQYXRoIiwibmV3UG9zIiwiY29tcG9uZW50cyIsIm9sZFBvcyIsImV4dHJhY3RDb21tb24iLCJqb2luIiwiY291bnQiLCJleGVjRWRpdExlbmd0aCIsImRpYWdvbmFsUGF0aCIsImJhc2VQYXRoIiwiYWRkUGF0aCIsInJlbW92ZVBhdGgiLCJjYW5BZGQiLCJjYW5SZW1vdmUiLCJjbG9uZVBhdGgiLCJwdXNoQ29tcG9uZW50IiwiYnVpbGRWYWx1ZXMiLCJ1c2VMb25nZXN0VG9rZW4iLCJleGVjIiwicmV0IiwiYWRkZWQiLCJyZW1vdmVkIiwibGFzdCIsInB1c2giLCJjb21tb25Db3VudCIsImVxdWFscyIsImxlZnQiLCJyaWdodCIsImNvbXBhcmF0b3IiLCJpZ25vcmVDYXNlIiwidG9Mb3dlckNhc2UiLCJhcnJheSIsImkiLCJzcGxpdCIsImNoYXJzIiwiY29tcG9uZW50UG9zIiwiY29tcG9uZW50TGVuIiwiY29tcG9uZW50Iiwic2xpY2UiLCJtYXAiLCJvbGRWYWx1ZSIsInRtcCIsImxhc3RDb21wb25lbnQiLCJwb3AiLCJwYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZSxTQUFTQSxJQUFULEdBQWdCLENBQUU7O0FBRWpDQSxJQUFJLENBQUNDLFNBQUwsR0FBaUI7QUFBQTs7QUFBQTtBQUNmQyxFQUFBQSxJQURlLGdCQUNWQyxTQURVLEVBQ0NDLFNBREQsRUFDMEI7QUFBQTtBQUFBO0FBQUE7QUFBZEMsSUFBQUEsT0FBYyx1RUFBSixFQUFJO0FBQ3ZDLFFBQUlDLFFBQVEsR0FBR0QsT0FBTyxDQUFDQyxRQUF2Qjs7QUFDQSxRQUFJLE9BQU9ELE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakNDLE1BQUFBLFFBQVEsR0FBR0QsT0FBWDtBQUNBQSxNQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEOztBQUNELFNBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUVBLFFBQUlFLElBQUksR0FBRyxJQUFYOztBQUVBLGFBQVNDLElBQVQsQ0FBY0MsS0FBZCxFQUFxQjtBQUNuQixVQUFJSCxRQUFKLEVBQWM7QUFDWkksUUFBQUEsVUFBVSxDQUFDLFlBQVc7QUFBRUosVUFBQUEsUUFBUSxDQUFDSyxTQUFELEVBQVlGLEtBQVosQ0FBUjtBQUE2QixTQUEzQyxFQUE2QyxDQUE3QyxDQUFWO0FBQ0EsZUFBTyxJQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZUFBT0EsS0FBUDtBQUNEO0FBQ0YsS0FqQnNDLENBbUJ2Qzs7O0FBQ0FOLElBQUFBLFNBQVMsR0FBRyxLQUFLUyxTQUFMLENBQWVULFNBQWYsQ0FBWjtBQUNBQyxJQUFBQSxTQUFTLEdBQUcsS0FBS1EsU0FBTCxDQUFlUixTQUFmLENBQVo7QUFFQUQsSUFBQUEsU0FBUyxHQUFHLEtBQUtVLFdBQUwsQ0FBaUIsS0FBS0MsUUFBTCxDQUFjWCxTQUFkLENBQWpCLENBQVo7QUFDQUMsSUFBQUEsU0FBUyxHQUFHLEtBQUtTLFdBQUwsQ0FBaUIsS0FBS0MsUUFBTCxDQUFjVixTQUFkLENBQWpCLENBQVo7QUFFQSxRQUFJVyxNQUFNLEdBQUdYLFNBQVMsQ0FBQ1ksTUFBdkI7QUFBQSxRQUErQkMsTUFBTSxHQUFHZCxTQUFTLENBQUNhLE1BQWxEO0FBQ0EsUUFBSUUsVUFBVSxHQUFHLENBQWpCO0FBQ0EsUUFBSUMsYUFBYSxHQUFHSixNQUFNLEdBQUdFLE1BQTdCO0FBQ0EsUUFBSUcsUUFBUSxHQUFHLENBQUM7QUFBRUMsTUFBQUEsTUFBTSxFQUFFLENBQUMsQ0FBWDtBQUFjQyxNQUFBQSxVQUFVLEVBQUU7QUFBMUIsS0FBRCxDQUFmLENBN0J1QyxDQStCdkM7O0FBQ0EsUUFBSUMsTUFBTSxHQUFHLEtBQUtDLGFBQUwsQ0FBbUJKLFFBQVEsQ0FBQyxDQUFELENBQTNCLEVBQWdDaEIsU0FBaEMsRUFBMkNELFNBQTNDLEVBQXNELENBQXRELENBQWI7O0FBQ0EsUUFBSWlCLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWUMsTUFBWixHQUFxQixDQUFyQixJQUEwQk4sTUFBMUIsSUFBb0NRLE1BQU0sR0FBRyxDQUFULElBQWNOLE1BQXRELEVBQThEO0FBQzVEO0FBQ0EsYUFBT1QsSUFBSSxDQUFDLENBQUM7QUFBQ0MsUUFBQUEsS0FBSyxFQUFFLEtBQUtnQixJQUFMLENBQVVyQixTQUFWLENBQVI7QUFBOEJzQixRQUFBQSxLQUFLLEVBQUV0QixTQUFTLENBQUNZO0FBQS9DLE9BQUQsQ0FBRCxDQUFYO0FBQ0QsS0FwQ3NDLENBc0N2Qzs7O0FBQ0EsYUFBU1csY0FBVCxHQUEwQjtBQUN4QixXQUFLLElBQUlDLFlBQVksR0FBRyxDQUFDLENBQUQsR0FBS1YsVUFBN0IsRUFBeUNVLFlBQVksSUFBSVYsVUFBekQsRUFBcUVVLFlBQVksSUFBSSxDQUFyRixFQUF3RjtBQUN0RixZQUFJQyxRQUFRO0FBQUE7QUFBQTtBQUFaO0FBQUE7O0FBQ0EsWUFBSUMsT0FBTyxHQUFHVixRQUFRLENBQUNRLFlBQVksR0FBRyxDQUFoQixDQUF0QjtBQUFBLFlBQ0lHLFVBQVUsR0FBR1gsUUFBUSxDQUFDUSxZQUFZLEdBQUcsQ0FBaEIsQ0FEekI7QUFBQSxZQUVJTCxPQUFNLEdBQUcsQ0FBQ1EsVUFBVSxHQUFHQSxVQUFVLENBQUNWLE1BQWQsR0FBdUIsQ0FBbEMsSUFBdUNPLFlBRnBEOztBQUdBLFlBQUlFLE9BQUosRUFBYTtBQUNYO0FBQ0FWLFVBQUFBLFFBQVEsQ0FBQ1EsWUFBWSxHQUFHLENBQWhCLENBQVIsR0FBNkJqQixTQUE3QjtBQUNEOztBQUVELFlBQUlxQixNQUFNLEdBQUdGLE9BQU8sSUFBSUEsT0FBTyxDQUFDVCxNQUFSLEdBQWlCLENBQWpCLEdBQXFCTixNQUE3QztBQUFBLFlBQ0lrQixTQUFTLEdBQUdGLFVBQVUsSUFBSSxLQUFLUixPQUFuQixJQUE2QkEsT0FBTSxHQUFHTixNQUR0RDs7QUFFQSxZQUFJLENBQUNlLE1BQUQsSUFBVyxDQUFDQyxTQUFoQixFQUEyQjtBQUN6QjtBQUNBYixVQUFBQSxRQUFRLENBQUNRLFlBQUQsQ0FBUixHQUF5QmpCLFNBQXpCO0FBQ0E7QUFDRCxTQWhCcUYsQ0FrQnRGO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBSSxDQUFDcUIsTUFBRCxJQUFZQyxTQUFTLElBQUlILE9BQU8sQ0FBQ1QsTUFBUixHQUFpQlUsVUFBVSxDQUFDVixNQUF6RCxFQUFrRTtBQUNoRVEsVUFBQUEsUUFBUSxHQUFHSyxTQUFTLENBQUNILFVBQUQsQ0FBcEI7QUFDQXhCLFVBQUFBLElBQUksQ0FBQzRCLGFBQUwsQ0FBbUJOLFFBQVEsQ0FBQ1AsVUFBNUIsRUFBd0NYLFNBQXhDLEVBQW1ELElBQW5EO0FBQ0QsU0FIRCxNQUdPO0FBQ0xrQixVQUFBQSxRQUFRLEdBQUdDLE9BQVgsQ0FESyxDQUNlOztBQUNwQkQsVUFBQUEsUUFBUSxDQUFDUixNQUFUO0FBQ0FkLFVBQUFBLElBQUksQ0FBQzRCLGFBQUwsQ0FBbUJOLFFBQVEsQ0FBQ1AsVUFBNUIsRUFBd0MsSUFBeEMsRUFBOENYLFNBQTlDO0FBQ0Q7O0FBRURZLFFBQUFBLE9BQU0sR0FBR2hCLElBQUksQ0FBQ2lCLGFBQUwsQ0FBbUJLLFFBQW5CLEVBQTZCekIsU0FBN0IsRUFBd0NELFNBQXhDLEVBQW1EeUIsWUFBbkQsQ0FBVCxDQTlCc0YsQ0FnQ3RGOztBQUNBLFlBQUlDLFFBQVEsQ0FBQ1IsTUFBVCxHQUFrQixDQUFsQixJQUF1Qk4sTUFBdkIsSUFBaUNRLE9BQU0sR0FBRyxDQUFULElBQWNOLE1BQW5ELEVBQTJEO0FBQ3pELGlCQUFPVCxJQUFJLENBQUM0QixXQUFXLENBQUM3QixJQUFELEVBQU9zQixRQUFRLENBQUNQLFVBQWhCLEVBQTRCbEIsU0FBNUIsRUFBdUNELFNBQXZDLEVBQWtESSxJQUFJLENBQUM4QixlQUF2RCxDQUFaLENBQVg7QUFDRCxTQUZELE1BRU87QUFDTDtBQUNBakIsVUFBQUEsUUFBUSxDQUFDUSxZQUFELENBQVIsR0FBeUJDLFFBQXpCO0FBQ0Q7QUFDRjs7QUFFRFgsTUFBQUEsVUFBVTtBQUNYLEtBbEZzQyxDQW9GdkM7QUFDQTtBQUNBOzs7QUFDQSxRQUFJWixRQUFKLEVBQWM7QUFDWCxnQkFBU2dDLElBQVQsR0FBZ0I7QUFDZjVCLFFBQUFBLFVBQVUsQ0FBQyxZQUFXO0FBQ3BCOztBQUNBO0FBQ0EsY0FBSVEsVUFBVSxHQUFHQyxhQUFqQixFQUFnQztBQUM5QixtQkFBT2IsUUFBUSxFQUFmO0FBQ0Q7O0FBRUQsY0FBSSxDQUFDcUIsY0FBYyxFQUFuQixFQUF1QjtBQUNyQlcsWUFBQUEsSUFBSTtBQUNMO0FBQ0YsU0FWUyxFQVVQLENBVk8sQ0FBVjtBQVdELE9BWkEsR0FBRDtBQWFELEtBZEQsTUFjTztBQUNMLGFBQU9wQixVQUFVLElBQUlDLGFBQXJCLEVBQW9DO0FBQ2xDLFlBQUlvQixHQUFHLEdBQUdaLGNBQWMsRUFBeEI7O0FBQ0EsWUFBSVksR0FBSixFQUFTO0FBQ1AsaUJBQU9BLEdBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRixHQTlHYzs7QUFBQTs7QUFBQTtBQWdIZkosRUFBQUEsYUFoSGUseUJBZ0hEYixVQWhIQyxFQWdIV2tCLEtBaEhYLEVBZ0hrQkMsT0FoSGxCLEVBZ0gyQjtBQUN4QyxRQUFJQyxJQUFJLEdBQUdwQixVQUFVLENBQUNBLFVBQVUsQ0FBQ04sTUFBWCxHQUFvQixDQUFyQixDQUFyQjs7QUFDQSxRQUFJMEIsSUFBSSxJQUFJQSxJQUFJLENBQUNGLEtBQUwsS0FBZUEsS0FBdkIsSUFBZ0NFLElBQUksQ0FBQ0QsT0FBTCxLQUFpQkEsT0FBckQsRUFBOEQ7QUFDNUQ7QUFDQTtBQUNBbkIsTUFBQUEsVUFBVSxDQUFDQSxVQUFVLENBQUNOLE1BQVgsR0FBb0IsQ0FBckIsQ0FBVixHQUFvQztBQUFDVSxRQUFBQSxLQUFLLEVBQUVnQixJQUFJLENBQUNoQixLQUFMLEdBQWEsQ0FBckI7QUFBd0JjLFFBQUFBLEtBQUssRUFBRUEsS0FBL0I7QUFBc0NDLFFBQUFBLE9BQU8sRUFBRUE7QUFBL0MsT0FBcEM7QUFDRCxLQUpELE1BSU87QUFDTG5CLE1BQUFBLFVBQVUsQ0FBQ3FCLElBQVgsQ0FBZ0I7QUFBQ2pCLFFBQUFBLEtBQUssRUFBRSxDQUFSO0FBQVdjLFFBQUFBLEtBQUssRUFBRUEsS0FBbEI7QUFBeUJDLFFBQUFBLE9BQU8sRUFBRUE7QUFBbEMsT0FBaEI7QUFDRDtBQUNGLEdBekhjOztBQUFBOztBQUFBO0FBMEhmakIsRUFBQUEsYUExSGUseUJBMEhESyxRQTFIQyxFQTBIU3pCLFNBMUhULEVBMEhvQkQsU0ExSHBCLEVBMEgrQnlCLFlBMUgvQixFQTBINkM7QUFDMUQsUUFBSWIsTUFBTSxHQUFHWCxTQUFTLENBQUNZLE1BQXZCO0FBQUEsUUFDSUMsTUFBTSxHQUFHZCxTQUFTLENBQUNhLE1BRHZCO0FBQUEsUUFFSUssTUFBTSxHQUFHUSxRQUFRLENBQUNSLE1BRnRCO0FBQUEsUUFHSUUsTUFBTSxHQUFHRixNQUFNLEdBQUdPLFlBSHRCO0FBQUEsUUFLSWdCLFdBQVcsR0FBRyxDQUxsQjs7QUFNQSxXQUFPdkIsTUFBTSxHQUFHLENBQVQsR0FBYU4sTUFBYixJQUF1QlEsTUFBTSxHQUFHLENBQVQsR0FBYU4sTUFBcEMsSUFBOEMsS0FBSzRCLE1BQUwsQ0FBWXpDLFNBQVMsQ0FBQ2lCLE1BQU0sR0FBRyxDQUFWLENBQXJCLEVBQW1DbEIsU0FBUyxDQUFDb0IsTUFBTSxHQUFHLENBQVYsQ0FBNUMsQ0FBckQsRUFBZ0g7QUFDOUdGLE1BQUFBLE1BQU07QUFDTkUsTUFBQUEsTUFBTTtBQUNOcUIsTUFBQUEsV0FBVztBQUNaOztBQUVELFFBQUlBLFdBQUosRUFBaUI7QUFDZmYsTUFBQUEsUUFBUSxDQUFDUCxVQUFULENBQW9CcUIsSUFBcEIsQ0FBeUI7QUFBQ2pCLFFBQUFBLEtBQUssRUFBRWtCO0FBQVIsT0FBekI7QUFDRDs7QUFFRGYsSUFBQUEsUUFBUSxDQUFDUixNQUFULEdBQWtCQSxNQUFsQjtBQUNBLFdBQU9FLE1BQVA7QUFDRCxHQTdJYzs7QUFBQTs7QUFBQTtBQStJZnNCLEVBQUFBLE1BL0llLGtCQStJUkMsSUEvSVEsRUErSUZDLEtBL0lFLEVBK0lLO0FBQ2xCLFFBQUksS0FBSzFDLE9BQUwsQ0FBYTJDLFVBQWpCLEVBQTZCO0FBQzNCLGFBQU8sS0FBSzNDLE9BQUwsQ0FBYTJDLFVBQWIsQ0FBd0JGLElBQXhCLEVBQThCQyxLQUE5QixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT0QsSUFBSSxLQUFLQyxLQUFULElBQ0QsS0FBSzFDLE9BQUwsQ0FBYTRDLFVBQWIsSUFBMkJILElBQUksQ0FBQ0ksV0FBTCxPQUF1QkgsS0FBSyxDQUFDRyxXQUFOLEVBRHhEO0FBRUQ7QUFDRixHQXRKYzs7QUFBQTs7QUFBQTtBQXVKZnJDLEVBQUFBLFdBdkplLHVCQXVKSHNDLEtBdkpHLEVBdUpJO0FBQ2pCLFFBQUlaLEdBQUcsR0FBRyxFQUFWOztBQUNBLFNBQUssSUFBSWEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDbkMsTUFBMUIsRUFBa0NvQyxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFVBQUlELEtBQUssQ0FBQ0MsQ0FBRCxDQUFULEVBQWM7QUFDWmIsUUFBQUEsR0FBRyxDQUFDSSxJQUFKLENBQVNRLEtBQUssQ0FBQ0MsQ0FBRCxDQUFkO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPYixHQUFQO0FBQ0QsR0EvSmM7O0FBQUE7O0FBQUE7QUFnS2YzQixFQUFBQSxTQWhLZSxxQkFnS0xILEtBaEtLLEVBZ0tFO0FBQ2YsV0FBT0EsS0FBUDtBQUNELEdBbEtjOztBQUFBOztBQUFBO0FBbUtmSyxFQUFBQSxRQW5LZSxvQkFtS05MLEtBbktNLEVBbUtDO0FBQ2QsV0FBT0EsS0FBSyxDQUFDNEMsS0FBTixDQUFZLEVBQVosQ0FBUDtBQUNELEdBcktjOztBQUFBOztBQUFBO0FBc0tmNUIsRUFBQUEsSUF0S2UsZ0JBc0tWNkIsS0F0S1UsRUFzS0g7QUFDVixXQUFPQSxLQUFLLENBQUM3QixJQUFOLENBQVcsRUFBWCxDQUFQO0FBQ0Q7QUF4S2MsQ0FBakI7O0FBMktBLFNBQVNXLFdBQVQsQ0FBcUJsQyxJQUFyQixFQUEyQm9CLFVBQTNCLEVBQXVDbEIsU0FBdkMsRUFBa0RELFNBQWxELEVBQTZEa0MsZUFBN0QsRUFBOEU7QUFDNUUsTUFBSWtCLFlBQVksR0FBRyxDQUFuQjtBQUFBLE1BQ0lDLFlBQVksR0FBR2xDLFVBQVUsQ0FBQ04sTUFEOUI7QUFBQSxNQUVJSyxNQUFNLEdBQUcsQ0FGYjtBQUFBLE1BR0lFLE1BQU0sR0FBRyxDQUhiOztBQUtBLFNBQU9nQyxZQUFZLEdBQUdDLFlBQXRCLEVBQW9DRCxZQUFZLEVBQWhELEVBQW9EO0FBQ2xELFFBQUlFLFNBQVMsR0FBR25DLFVBQVUsQ0FBQ2lDLFlBQUQsQ0FBMUI7O0FBQ0EsUUFBSSxDQUFDRSxTQUFTLENBQUNoQixPQUFmLEVBQXdCO0FBQ3RCLFVBQUksQ0FBQ2dCLFNBQVMsQ0FBQ2pCLEtBQVgsSUFBb0JILGVBQXhCLEVBQXlDO0FBQ3ZDLFlBQUk1QixLQUFLLEdBQUdMLFNBQVMsQ0FBQ3NELEtBQVYsQ0FBZ0JyQyxNQUFoQixFQUF3QkEsTUFBTSxHQUFHb0MsU0FBUyxDQUFDL0IsS0FBM0MsQ0FBWjtBQUNBakIsUUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUNrRCxHQUFOLENBQVUsVUFBU2xELEtBQVQsRUFBZ0IyQyxDQUFoQixFQUFtQjtBQUNuQyxjQUFJUSxRQUFRLEdBQUd6RCxTQUFTLENBQUNvQixNQUFNLEdBQUc2QixDQUFWLENBQXhCO0FBQ0EsaUJBQU9RLFFBQVEsQ0FBQzVDLE1BQVQsR0FBa0JQLEtBQUssQ0FBQ08sTUFBeEIsR0FBaUM0QyxRQUFqQyxHQUE0Q25ELEtBQW5EO0FBQ0QsU0FITyxDQUFSO0FBS0FnRCxRQUFBQSxTQUFTLENBQUNoRCxLQUFWLEdBQWtCUCxJQUFJLENBQUN1QixJQUFMLENBQVVoQixLQUFWLENBQWxCO0FBQ0QsT0FSRCxNQVFPO0FBQ0xnRCxRQUFBQSxTQUFTLENBQUNoRCxLQUFWLEdBQWtCUCxJQUFJLENBQUN1QixJQUFMLENBQVVyQixTQUFTLENBQUNzRCxLQUFWLENBQWdCckMsTUFBaEIsRUFBd0JBLE1BQU0sR0FBR29DLFNBQVMsQ0FBQy9CLEtBQTNDLENBQVYsQ0FBbEI7QUFDRDs7QUFDREwsTUFBQUEsTUFBTSxJQUFJb0MsU0FBUyxDQUFDL0IsS0FBcEIsQ0Fac0IsQ0FjdEI7O0FBQ0EsVUFBSSxDQUFDK0IsU0FBUyxDQUFDakIsS0FBZixFQUFzQjtBQUNwQmpCLFFBQUFBLE1BQU0sSUFBSWtDLFNBQVMsQ0FBQy9CLEtBQXBCO0FBQ0Q7QUFDRixLQWxCRCxNQWtCTztBQUNMK0IsTUFBQUEsU0FBUyxDQUFDaEQsS0FBVixHQUFrQlAsSUFBSSxDQUFDdUIsSUFBTCxDQUFVdEIsU0FBUyxDQUFDdUQsS0FBVixDQUFnQm5DLE1BQWhCLEVBQXdCQSxNQUFNLEdBQUdrQyxTQUFTLENBQUMvQixLQUEzQyxDQUFWLENBQWxCO0FBQ0FILE1BQUFBLE1BQU0sSUFBSWtDLFNBQVMsQ0FBQy9CLEtBQXBCLENBRkssQ0FJTDtBQUNBO0FBQ0E7O0FBQ0EsVUFBSTZCLFlBQVksSUFBSWpDLFVBQVUsQ0FBQ2lDLFlBQVksR0FBRyxDQUFoQixDQUFWLENBQTZCZixLQUFqRCxFQUF3RDtBQUN0RCxZQUFJcUIsR0FBRyxHQUFHdkMsVUFBVSxDQUFDaUMsWUFBWSxHQUFHLENBQWhCLENBQXBCO0FBQ0FqQyxRQUFBQSxVQUFVLENBQUNpQyxZQUFZLEdBQUcsQ0FBaEIsQ0FBVixHQUErQmpDLFVBQVUsQ0FBQ2lDLFlBQUQsQ0FBekM7QUFDQWpDLFFBQUFBLFVBQVUsQ0FBQ2lDLFlBQUQsQ0FBVixHQUEyQk0sR0FBM0I7QUFDRDtBQUNGO0FBQ0YsR0F2QzJFLENBeUM1RTtBQUNBO0FBQ0E7OztBQUNBLE1BQUlDLGFBQWEsR0FBR3hDLFVBQVUsQ0FBQ2tDLFlBQVksR0FBRyxDQUFoQixDQUE5Qjs7QUFDQSxNQUFJQSxZQUFZLEdBQUcsQ0FBZixJQUNHLE9BQU9NLGFBQWEsQ0FBQ3JELEtBQXJCLEtBQStCLFFBRGxDLEtBRUlxRCxhQUFhLENBQUN0QixLQUFkLElBQXVCc0IsYUFBYSxDQUFDckIsT0FGekMsS0FHR3ZDLElBQUksQ0FBQzJDLE1BQUwsQ0FBWSxFQUFaLEVBQWdCaUIsYUFBYSxDQUFDckQsS0FBOUIsQ0FIUCxFQUc2QztBQUMzQ2EsSUFBQUEsVUFBVSxDQUFDa0MsWUFBWSxHQUFHLENBQWhCLENBQVYsQ0FBNkIvQyxLQUE3QixJQUFzQ3FELGFBQWEsQ0FBQ3JELEtBQXBEO0FBQ0FhLElBQUFBLFVBQVUsQ0FBQ3lDLEdBQVg7QUFDRDs7QUFFRCxTQUFPekMsVUFBUDtBQUNEOztBQUVELFNBQVNZLFNBQVQsQ0FBbUI4QixJQUFuQixFQUF5QjtBQUN2QixTQUFPO0FBQUUzQyxJQUFBQSxNQUFNLEVBQUUyQyxJQUFJLENBQUMzQyxNQUFmO0FBQXVCQyxJQUFBQSxVQUFVLEVBQUUwQyxJQUFJLENBQUMxQyxVQUFMLENBQWdCb0MsS0FBaEIsQ0FBc0IsQ0FBdEI7QUFBbkMsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlmZigpIHt9XG5cbkRpZmYucHJvdG90eXBlID0ge1xuICBkaWZmKG9sZFN0cmluZywgbmV3U3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgc3ViY2xhc3NlcyB0byBtYXNzYWdlIHRoZSBpbnB1dCBwcmlvciB0byBydW5uaW5nXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcbiAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuXG4gICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xuICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcblxuICAgIGxldCBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLCBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xuICAgIGxldCBlZGl0TGVuZ3RoID0gMTtcbiAgICBsZXQgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcbiAgICBsZXQgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcblxuICAgIC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXG4gICAgbGV0IG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xuICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICByZXR1cm4gZG9uZShbe3ZhbHVlOiB0aGlzLmpvaW4obmV3U3RyaW5nKSwgY291bnQ6IG5ld1N0cmluZy5sZW5ndGh9XSk7XG4gICAgfVxuXG4gICAgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgZm9yIChsZXQgZGlhZ29uYWxQYXRoID0gLTEgKiBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggPD0gZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoICs9IDIpIHtcbiAgICAgICAgbGV0IGJhc2VQYXRoO1xuICAgICAgICBsZXQgYWRkUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdLFxuICAgICAgICAgICAgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdLFxuICAgICAgICAgICAgb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuICAgICAgICBpZiAoYWRkUGF0aCkge1xuICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XG4gICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXG4gICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gb2xkUG9zICYmIG9sZFBvcyA8IG9sZExlbjtcbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcbiAgICAgICAgaWYgKCFjYW5BZGQgfHwgKGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSkge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcbiAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgICAgaWYgKGJhc2VQYXRoLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZGl0TGVuZ3RoKys7XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXG4gICAgLy8gaXMgcHJvZHVjZWQuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAoZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKGVkaXRMZW5ndGggPiBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICBsZXQgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIGxldCBsYXN0ID0gY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goe2NvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XG4gICAgfVxuICB9LFxuICBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XG4gICAgbGV0IG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcbiAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxuXG4gICAgICAgIGNvbW1vbkNvdW50ID0gMDtcbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xuICAgICAgbmV3UG9zKys7XG4gICAgICBvbGRQb3MrKztcbiAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe2NvdW50OiBjb21tb25Db3VudH0pO1xuICAgIH1cblxuICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcbiAgICByZXR1cm4gb2xkUG9zO1xuICB9LFxuXG4gIGVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0XG4gICAgICAgIHx8ICh0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycmF5W2ldKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgY2FzdElucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0b2tlbml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG4gIH0sXG4gIGpvaW4oY2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcbiAgbGV0IGNvbXBvbmVudFBvcyA9IDAsXG4gICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgIG5ld1BvcyA9IDAsXG4gICAgICBvbGRQb3MgPSAwO1xuXG4gIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsdWUsIGkpIHtcbiAgICAgICAgICBsZXQgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XG4gICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICB9XG4gICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuXG4gICAgICAvLyBDb21tb24gY2FzZVxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcblxuICAgICAgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cbiAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xuICAgICAgICBsZXQgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXG4gIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cbiAgbGV0IGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuICBpZiAoY29tcG9uZW50TGVuID4gMVxuICAgICAgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAmJiAobGFzdENvbXBvbmVudC5hZGRlZCB8fCBsYXN0Q29tcG9uZW50LnJlbW92ZWQpXG4gICAgICAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICByZXR1cm4geyBuZXdQb3M6IHBhdGgubmV3UG9zLCBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMCkgfTtcbn1cbiJdfQ==


/***/ }),

/***/ "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/character.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/*istanbul ignore start*/


__webpack_unused_export__ = ({
  value: true
});
exports.JJ = diffChars;
__webpack_unused_export__ = void 0;

/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(__webpack_require__("../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/lib/diff/base.js"))
/*istanbul ignore end*/
;

/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*istanbul ignore end*/
var characterDiff = new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
.
/*istanbul ignore start*/
default
/*istanbul ignore end*/
();

/*istanbul ignore start*/
__webpack_unused_export__ = characterDiff;

/*istanbul ignore end*/
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaWZmL2NoYXJhY3Rlci5qcyJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJEaWZmIiwiRGlmZiIsImRpZmZDaGFycyIsIm9sZFN0ciIsIm5ld1N0ciIsIm9wdGlvbnMiLCJkaWZmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7QUFFTyxJQUFNQSxhQUFhLEdBQUc7QUFBSUM7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBQUE7QUFBSjtBQUFBLEVBQXRCOzs7Ozs7QUFDQSxTQUFTQyxTQUFULENBQW1CQyxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLE9BQW5DLEVBQTRDO0FBQUUsU0FBT0wsYUFBYSxDQUFDTSxJQUFkLENBQW1CSCxNQUFuQixFQUEyQkMsTUFBM0IsRUFBbUNDLE9BQW5DLENBQVA7QUFBcUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGlmZiBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgY29uc3QgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7IHJldHVybiBjaGFyYWN0ZXJEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpOyB9XG4iXX0=


/***/ }),

/***/ "../../node_modules/.pnpm/gradient-parser@0.1.5/node_modules/gradient-parser/build/node.js":
/***/ ((__unused_webpack_module, exports) => {

// Copyright (c) 2014 Rafael Caricio. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var GradientParser = {};

GradientParser.parse = (function() {

  var tokens = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };

  var input = '';

  function error(msg) {
    var err = new Error(input + ': ' + msg);
    err.source = input;
    throw err;
  }

  function getAST() {
    var ast = matchListDefinitions();

    if (input.length > 0) {
      error('Invalid input not EOF');
    }

    return ast;
  }

  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }

  function matchDefinition() {
    return matchGradient(
            'linear-gradient',
            tokens.linearGradient,
            matchLinearOrientation) ||

          matchGradient(
            'repeating-linear-gradient',
            tokens.repeatingLinearGradient,
            matchLinearOrientation) ||

          matchGradient(
            'radial-gradient',
            tokens.radialGradient,
            matchListRadialOrientations) ||

          matchGradient(
            'repeating-radial-gradient',
            tokens.repeatingRadialGradient,
            matchListRadialOrientations);
  }

  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {

      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error('Missing comma before color stops');
        }
      }

      return {
        type: gradientType,
        orientation: orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }

  function matchCall(pattern, callback) {
    var captures = scan(pattern);

    if (captures) {
      if (!scan(tokens.startCall)) {
        error('Missing (');
      }

      result = callback(captures);

      if (!scan(tokens.endCall)) {
        error('Missing )');
      }

      return result;
    }
  }

  function matchLinearOrientation() {
    return matchSideOrCorner() ||
      matchAngle();
  }

  function matchSideOrCorner() {
    return match('directional', tokens.sideOrCorner, 1);
  }

  function matchAngle() {
    return match('angular', tokens.angleValue, 1);
  }

  function matchListRadialOrientations() {
    var radialOrientations,
        radialOrientation = matchRadialOrientation(),
        lookaheadCache;

    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);

      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }

    return radialOrientations;
  }

  function matchRadialOrientation() {
    var radialType = matchCircle() ||
      matchEllipse();

    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var defaultPosition = matchPositioning();
      if (defaultPosition) {
        radialType = {
          type: 'default-radial',
          at: defaultPosition
        };
      }
    }

    return radialType;
  }

  function matchCircle() {
    var circle = match('shape', /^(circle)/i, 0);

    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }

    return circle;
  }

  function matchEllipse() {
    var ellipse = match('shape', /^(ellipse)/i, 0);

    if (ellipse) {
      ellipse.style =  matchDistance() || matchExtentKeyword();
    }

    return ellipse;
  }

  function matchExtentKeyword() {
    return match('extent-keyword', tokens.extentKeywords, 1);
  }

  function matchAtPosition() {
    if (match('position', /^at/, 0)) {
      var positioning = matchPositioning();

      if (!positioning) {
        error('Missing positioning value');
      }

      return positioning;
    }
  }

  function matchPositioning() {
    var location = matchCoordinates();

    if (location.x || location.y) {
      return {
        type: 'position',
        value: location
      };
    }
  }

  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }

  function matchListing(matcher) {
    var captures = matcher(),
      result = [];

    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error('One extra comma');
        }
      }
    }

    return result;
  }

  function matchColorStop() {
    var color = matchColor();

    if (!color) {
      error('Expected color definition');
    }

    color.length = matchDistance();
    return color;
  }

  function matchColor() {
    return matchHexColor() ||
      matchRGBAColor() ||
      matchRGBColor() ||
      matchLiteralColor();
  }

  function matchLiteralColor() {
    return match('literal', tokens.literalColor, 0);
  }

  function matchHexColor() {
    return match('hex', tokens.hexColor, 1);
  }

  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return  {
        type: 'rgb',
        value: matchListing(matchNumber)
      };
    });
  }

  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return  {
        type: 'rgba',
        value: matchListing(matchNumber)
      };
    });
  }

  function matchNumber() {
    return scan(tokens.number)[1];
  }

  function matchDistance() {
    return match('%', tokens.percentageValue, 1) ||
      matchPositionKeyword() ||
      matchLength();
  }

  function matchPositionKeyword() {
    return match('position-keyword', tokens.positionKeywords, 1);
  }

  function matchLength() {
    return match('px', tokens.pixelValue, 1) ||
      match('em', tokens.emValue, 1);
  }

  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type: type,
        value: captures[captureIndex]
      };
    }
  }

  function scan(regexp) {
    var captures,
        blankCaptures;

    blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
        consume(blankCaptures[0].length);
    }

    captures = regexp.exec(input);
    if (captures) {
        consume(captures[0].length);
    }

    return captures;
  }

  function consume(size) {
    input = input.substr(size);
  }

  return function(code) {
    input = code.toString();
    return getAST();
  };
})();

exports.parse = (GradientParser || {}).parse;


/***/ }),

/***/ "../../node_modules/.pnpm/line-height@0.3.1/node_modules/line-height/lib/line-height.js":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Load in dependencies
var computedStyle = __webpack_require__("../../node_modules/.pnpm/computed-style@0.1.4/node_modules/computed-style/dist/computedStyle.commonjs.js");

/**
 * Calculate the `line-height` of a given node
 * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.
 * @returns {Number} `line-height` of the element in pixels
 */
function lineHeight(node) {
  // Grab the line-height via style
  var lnHeightStr = computedStyle(node, 'line-height');
  var lnHeight = parseFloat(lnHeightStr, 10);

  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')
  if (lnHeightStr === lnHeight + '') {
    // Save the old lineHeight style and update the em unit to the element
    var _lnHeightStyle = node.style.lineHeight;
    node.style.lineHeight = lnHeightStr + 'em';

    // Calculate the em based height
    lnHeightStr = computedStyle(node, 'line-height');
    lnHeight = parseFloat(lnHeightStr, 10);

    // Revert the lineHeight style
    if (_lnHeightStyle) {
      node.style.lineHeight = _lnHeightStyle;
    } else {
      delete node.style.lineHeight;
    }
  }

  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)
  // DEV: `em` units are converted to `pt` in IE6
  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length
  if (lnHeightStr.indexOf('pt') !== -1) {
    lnHeight *= 4;
    lnHeight /= 3;
  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)
  } else if (lnHeightStr.indexOf('mm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 25.4;
  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)
  } else if (lnHeightStr.indexOf('cm') !== -1) {
    lnHeight *= 96;
    lnHeight /= 2.54;
  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)
  } else if (lnHeightStr.indexOf('in') !== -1) {
    lnHeight *= 96;
  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)
  } else if (lnHeightStr.indexOf('pc') !== -1) {
    lnHeight *= 16;
  }

  // Continue our computation
  lnHeight = Math.round(lnHeight);

  // If the line-height is "normal", calculate by font-size
  if (lnHeightStr === 'normal') {
    // Create a temporary node
    var nodeName = node.nodeName;
    var _node = document.createElement(nodeName);
    _node.innerHTML = '&nbsp;';

    // If we have a text area, reset it to only 1 row
    // https://github.com/twolfson/line-height/issues/4
    if (nodeName.toUpperCase() === 'TEXTAREA') {
      _node.setAttribute('rows', '1');
    }

    // Set the font-size of the element
    var fontSizeStr = computedStyle(node, 'font-size');
    _node.style.fontSize = fontSizeStr;

    // Remove default padding/border which can affect offset height
    // https://github.com/twolfson/line-height/issues/4
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight
    _node.style.padding = '0px';
    _node.style.border = '0px';

    // Append it to the body
    var body = document.body;
    body.appendChild(_node);

    // Assume the line height of the element is the height
    var height = _node.offsetHeight;
    lnHeight = height;

    // Remove our child from the DOM
    body.removeChild(_node);
  }

  // Return the calculated height
  return lnHeight;
}

// Export lineHeight
module.exports = lineHeight;


/***/ }),

/***/ "../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-autosize-textarea/lib/TextareaAutosize.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
exports.__esModule = true;
var React = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
var PropTypes = __webpack_require__("../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js");
var autosize = __webpack_require__("../../node_modules/.pnpm/autosize@4.0.4/node_modules/autosize/dist/autosize.js");
var _getLineHeight = __webpack_require__("../../node_modules/.pnpm/line-height@0.3.1/node_modules/line-height/lib/line-height.js");
var getLineHeight = _getLineHeight;
var RESIZED = "autosize:resized";
/**
 * A light replacement for built-in textarea component
 * which automaticaly adjusts its height to match the content
 */
var TextareaAutosizeClass = /** @class */ (function (_super) {
    __extends(TextareaAutosizeClass, _super);
    function TextareaAutosizeClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            lineHeight: null
        };
        _this.textarea = null;
        _this.onResize = function (e) {
            if (_this.props.onResize) {
                _this.props.onResize(e);
            }
        };
        _this.updateLineHeight = function () {
            if (_this.textarea) {
                _this.setState({
                    lineHeight: getLineHeight(_this.textarea)
                });
            }
        };
        _this.onChange = function (e) {
            var onChange = _this.props.onChange;
            _this.currentValue = e.currentTarget.value;
            onChange && onChange(e);
        };
        return _this;
    }
    TextareaAutosizeClass.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, maxRows = _a.maxRows, async = _a.async;
        if (typeof maxRows === "number") {
            this.updateLineHeight();
        }
        if (typeof maxRows === "number" || async) {
            /*
              the defer is needed to:
                - force "autosize" to activate the scrollbar when this.props.maxRows is passed
                - support StyledComponents (see #71)
            */
            setTimeout(function () { return _this.textarea && autosize(_this.textarea); });
        }
        else {
            this.textarea && autosize(this.textarea);
        }
        if (this.textarea) {
            this.textarea.addEventListener(RESIZED, this.onResize);
        }
    };
    TextareaAutosizeClass.prototype.componentWillUnmount = function () {
        if (this.textarea) {
            this.textarea.removeEventListener(RESIZED, this.onResize);
            autosize.destroy(this.textarea);
        }
    };
    TextareaAutosizeClass.prototype.render = function () {
        var _this = this;
        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
        return (React.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {
                _this.textarea = element;
                if (typeof _this.props.innerRef === 'function') {
                    _this.props.innerRef(element);
                }
                else if (_this.props.innerRef) {
                    _this.props.innerRef.current = element;
                }
            } }), children));
    };
    TextareaAutosizeClass.prototype.componentDidUpdate = function () {
        this.textarea && autosize.update(this.textarea);
    };
    TextareaAutosizeClass.defaultProps = {
        rows: 1,
        async: false
    };
    TextareaAutosizeClass.propTypes = {
        rows: PropTypes.number,
        maxRows: PropTypes.number,
        onResize: PropTypes.func,
        innerRef: PropTypes.any,
        async: PropTypes.bool
    };
    return TextareaAutosizeClass;
}(React.Component));
exports.TextareaAutosize = React.forwardRef(function (props, ref) {
    return React.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
});


/***/ }),

/***/ "../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-autosize-textarea/lib/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = true;
var TextareaAutosize_1 = __webpack_require__("../../node_modules/.pnpm/react-autosize-textarea@7.1.0_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-autosize-textarea/lib/TextareaAutosize.js");
exports.A = TextareaAutosize_1.TextareaAutosize;


/***/ }),

/***/ "../../node_modules/.pnpm/react-colorful@5.6.1_react-dom@17.0.2_react@17.0.2__react@17.0.2/node_modules/react-colorful/dist/index.mjs":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gy: () => (/* binding */ ye),
/* harmony export */   jI: () => (/* binding */ Z),
/* harmony export */   p9: () => (/* binding */ He),
/* harmony export */   xp: () => (/* binding */ ue)
/* harmony export */ });
/* unused harmony exports HexAlphaColorPicker, HexColorInput, HslColorPicker, HslStringColorPicker, HslaColorPicker, HsvColorPicker, HsvStringColorPicker, HsvaColorPicker, HsvaStringColorPicker, RgbColorPicker, RgbaColorPicker, setNonce */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function c(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r.indexOf(t=a[n])>=0||(o[t]=e[t]);return o}function i(e){var t=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e),n=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(function(e){t.current&&t.current(e)});return t.current=e,n.current}var s=function(e,r,t){return void 0===r&&(r=0),void 0===t&&(t=1),e>t?t:e<r?r:e},f=function(e){return"touches"in e},v=function(e){return e&&e.ownerDocument.defaultView||self},d=function(e,r,t){var n=e.getBoundingClientRect(),o=f(r)?function(e,r){for(var t=0;t<e.length;t++)if(e[t].identifier===r)return e[t];return e[0]}(r.touches,t):r;return{left:s((o.pageX-(n.left+v(e).pageXOffset))/n.width),top:s((o.pageY-(n.top+v(e).pageYOffset))/n.height)}},h=function(e){!f(e)&&e.preventDefault()},m=react__WEBPACK_IMPORTED_MODULE_0__.memo(function(o){var a=o.onMove,l=o.onKey,s=c(o,["onMove","onKey"]),m=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),g=i(a),p=i(l),b=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),_=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1),x=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function(){var e=function(e){h(e),(f(e)?e.touches.length>0:e.buttons>0)&&m.current?g(d(m.current,e,b.current)):t(!1)},r=function(){return t(!1)};function t(t){var n=_.current,o=v(m.current),a=t?o.addEventListener:o.removeEventListener;a(n?"touchmove":"mousemove",e),a(n?"touchend":"mouseup",r)}return[function(e){var r=e.nativeEvent,n=m.current;if(n&&(h(r),!function(e,r){return r&&!f(e)}(r,_.current)&&n)){if(f(r)){_.current=!0;var o=r.changedTouches||[];o.length&&(b.current=o[0].identifier)}n.focus(),g(d(n,r,b.current)),t(!0)}},function(e){var r=e.which||e.keyCode;r<37||r>40||(e.preventDefault(),p({left:39===r?.05:37===r?-.05:0,top:40===r?.05:38===r?-.05:0}))},t]},[p,g]),C=x[0],E=x[1],H=x[2];return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){return H},[H]),react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",u({},s,{onTouchStart:C,onMouseDown:C,className:"react-colorful__interactive",ref:m,onKeyDown:E,tabIndex:0,role:"slider"}))}),g=function(e){return e.filter(Boolean).join(" ")},p=function(r){var t=r.color,n=r.left,o=r.top,a=void 0===o?.5:o,l=g(["react-colorful__pointer",r.className]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:l,style:{top:100*a+"%",left:100*n+"%"}},react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:t}}))},b=function(e,r,t){return void 0===r&&(r=0),void 0===t&&(t=Math.pow(10,r)),Math.round(t*e)/t},_={grad:.9,turn:360,rad:360/(2*Math.PI)},x=function(e){return L(C(e))},C=function(e){return"#"===e[0]&&(e=e.substring(1)),e.length<6?{r:parseInt(e[0]+e[0],16),g:parseInt(e[1]+e[1],16),b:parseInt(e[2]+e[2],16),a:4===e.length?b(parseInt(e[3]+e[3],16)/255,2):1}:{r:parseInt(e.substring(0,2),16),g:parseInt(e.substring(2,4),16),b:parseInt(e.substring(4,6),16),a:8===e.length?b(parseInt(e.substring(6,8),16)/255,2):1}},E=function(e,r){return void 0===r&&(r="deg"),Number(e)*(_[r]||1)},H=function(e){var r=/hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);return r?N({h:E(r[1],r[2]),s:Number(r[3]),l:Number(r[4]),a:void 0===r[5]?1:Number(r[5])/(r[6]?100:1)}):{h:0,s:0,v:0,a:1}},M=H,N=function(e){var r=e.s,t=e.l;return{h:e.h,s:(r*=(t<50?t:100-t)/100)>0?2*r/(t+r)*100:0,v:t+r,a:e.a}},w=function(e){return K(I(e))},y=function(e){var r=e.s,t=e.v,n=e.a,o=(200-r)*t/100;return{h:b(e.h),s:b(o>0&&o<200?r*t/100/(o<=100?o:200-o)*100:0),l:b(o/2),a:b(n,2)}},q=function(e){var r=y(e);return"hsl("+r.h+", "+r.s+"%, "+r.l+"%)"},k=function(e){var r=y(e);return"hsla("+r.h+", "+r.s+"%, "+r.l+"%, "+r.a+")"},I=function(e){var r=e.h,t=e.s,n=e.v,o=e.a;r=r/360*6,t/=100,n/=100;var a=Math.floor(r),l=n*(1-t),u=n*(1-(r-a)*t),c=n*(1-(1-r+a)*t),i=a%6;return{r:b(255*[n,u,l,l,c,n][i]),g:b(255*[c,n,n,u,l,l][i]),b:b(255*[l,l,c,n,n,u][i]),a:b(o,2)}},O=function(e){var r=/hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);return r?A({h:E(r[1],r[2]),s:Number(r[3]),v:Number(r[4]),a:void 0===r[5]?1:Number(r[5])/(r[6]?100:1)}):{h:0,s:0,v:0,a:1}},j=O,z=function(e){var r=/rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);return r?L({r:Number(r[1])/(r[2]?100/255:1),g:Number(r[3])/(r[4]?100/255:1),b:Number(r[5])/(r[6]?100/255:1),a:void 0===r[7]?1:Number(r[7])/(r[8]?100:1)}):{h:0,s:0,v:0,a:1}},B=z,D=function(e){var r=e.toString(16);return r.length<2?"0"+r:r},K=function(e){var r=e.r,t=e.g,n=e.b,o=e.a,a=o<1?D(b(255*o)):"";return"#"+D(r)+D(t)+D(n)+a},L=function(e){var r=e.r,t=e.g,n=e.b,o=e.a,a=Math.max(r,t,n),l=a-Math.min(r,t,n),u=l?a===r?(t-n)/l:a===t?2+(n-r)/l:4+(r-t)/l:0;return{h:b(60*(u<0?u+6:u)),s:b(a?l/a*100:0),v:b(a/255*100),a:o}},A=function(e){return{h:b(e.h),s:b(e.s),v:b(e.v),a:b(e.a,2)}},S=react__WEBPACK_IMPORTED_MODULE_0__.memo(function(r){var t=r.hue,n=r.onChange,o=g(["react-colorful__hue",r.className]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:o},react__WEBPACK_IMPORTED_MODULE_0__.createElement(m,{onMove:function(e){n({h:360*e.left})},onKey:function(e){n({h:s(t+360*e.left,0,360)})},"aria-label":"Hue","aria-valuenow":b(t),"aria-valuemax":"360","aria-valuemin":"0"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(p,{className:"react-colorful__hue-pointer",left:t/360,color:q({h:t,s:100,v:100,a:1})})))}),T=react__WEBPACK_IMPORTED_MODULE_0__.memo(function(r){var t=r.hsva,n=r.onChange,o={backgroundColor:q({h:t.h,s:100,v:100,a:1})};return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:"react-colorful__saturation",style:o},react__WEBPACK_IMPORTED_MODULE_0__.createElement(m,{onMove:function(e){n({s:100*e.left,v:100-100*e.top})},onKey:function(e){n({s:s(t.s+100*e.left,0,100),v:s(t.v-100*e.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+b(t.s)+"%, Brightness "+b(t.v)+"%"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(p,{className:"react-colorful__saturation-pointer",top:1-t.v/100,left:t.s/100,color:q(t)})))}),F=function(e,r){if(e===r)return!0;for(var t in e)if(e[t]!==r[t])return!1;return!0},P=function(e,r){return e.replace(/\s/g,"")===r.replace(/\s/g,"")},X=function(e,r){return e.toLowerCase()===r.toLowerCase()||F(C(e),C(r))};function Y(e,t,l){var u=i(l),c=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function(){return e.toHsva(t)}),s=c[0],f=c[1],v=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({color:t,hsva:s});(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){if(!e.equal(t,v.current.color)){var r=e.toHsva(t);v.current={hsva:r,color:t},f(r)}},[t,e]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function(){var r;F(s,v.current.hsva)||e.equal(r=e.fromHsva(s),v.current.color)||(v.current={hsva:s,color:r},u(r))},[s,e,u]);var d=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(e){f(function(r){return Object.assign({},r,e)})},[]);return[s,d]}var R,V="undefined"!=typeof window?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect,$=function(){return R||( true?__webpack_require__.nc:0)},G=function(e){R=e},J=new Map,Q=function(e){V(function(){var r=e.current?e.current.ownerDocument:document;if(void 0!==r&&!J.has(r)){var t=r.createElement("style");t.innerHTML='.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}',J.set(r,t);var n=$();n&&t.setAttribute("nonce",n),r.head.appendChild(t)}},[])},U=function(t){var n=t.className,o=t.colorModel,a=t.color,l=void 0===a?o.defaultColor:a,i=t.onChange,s=c(t,["className","colorModel","color","onChange"]),f=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);Q(f);var v=Y(o,l,i),d=v[0],h=v[1],m=g(["react-colorful",n]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",u({},s,{ref:f,className:m}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{hsva:d,onChange:h}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(S,{hue:d.h,onChange:h,className:"react-colorful__last-control"}))},W={defaultColor:"000",toHsva:x,fromHsva:function(e){return w({h:e.h,s:e.s,v:e.v,a:1})},equal:X},Z=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(U,u({},r,{colorModel:W}))},ee=function(r){var t=r.className,n=r.hsva,o=r.onChange,a={backgroundImage:"linear-gradient(90deg, "+k(Object.assign({},n,{a:0}))+", "+k(Object.assign({},n,{a:1}))+")"},l=g(["react-colorful__alpha",t]),u=b(100*n.a);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:l},react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{className:"react-colorful__alpha-gradient",style:a}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(m,{onMove:function(e){o({a:e.left})},onKey:function(e){o({a:s(n.a+e.left)})},"aria-label":"Alpha","aria-valuetext":u+"%","aria-valuenow":u,"aria-valuemin":"0","aria-valuemax":"100"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(p,{className:"react-colorful__alpha-pointer",left:n.a,color:k(n)})))},re=function(t){var n=t.className,o=t.colorModel,a=t.color,l=void 0===a?o.defaultColor:a,i=t.onChange,s=c(t,["className","colorModel","color","onChange"]),f=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);Q(f);var v=Y(o,l,i),d=v[0],h=v[1],m=g(["react-colorful",n]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",u({},s,{ref:f,className:m}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(T,{hsva:d,onChange:h}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(S,{hue:d.h,onChange:h}),react__WEBPACK_IMPORTED_MODULE_0__.createElement(ee,{hsva:d,onChange:h,className:"react-colorful__last-control"}))},te={defaultColor:"0001",toHsva:x,fromHsva:w,equal:X},ne=function(r){return e.createElement(re,u({},r,{colorModel:te}))},oe={defaultColor:{h:0,s:0,l:0,a:1},toHsva:N,fromHsva:y,equal:F},ae=function(r){return e.createElement(re,u({},r,{colorModel:oe}))},le={defaultColor:"hsla(0, 0%, 0%, 1)",toHsva:H,fromHsva:k,equal:P},ue=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(re,u({},r,{colorModel:le}))},ce={defaultColor:{h:0,s:0,l:0},toHsva:function(e){return N({h:e.h,s:e.s,l:e.l,a:1})},fromHsva:function(e){return{h:(r=y(e)).h,s:r.s,l:r.l};var r},equal:F},ie=function(r){return e.createElement(U,u({},r,{colorModel:ce}))},se={defaultColor:"hsl(0, 0%, 0%)",toHsva:M,fromHsva:q,equal:P},fe=function(r){return e.createElement(U,u({},r,{colorModel:se}))},ve={defaultColor:{h:0,s:0,v:0,a:1},toHsva:function(e){return e},fromHsva:A,equal:F},de=function(r){return e.createElement(re,u({},r,{colorModel:ve}))},he={defaultColor:"hsva(0, 0%, 0%, 1)",toHsva:O,fromHsva:function(e){var r=A(e);return"hsva("+r.h+", "+r.s+"%, "+r.v+"%, "+r.a+")"},equal:P},me=function(r){return e.createElement(re,u({},r,{colorModel:he}))},ge={defaultColor:{h:0,s:0,v:0},toHsva:function(e){return{h:e.h,s:e.s,v:e.v,a:1}},fromHsva:function(e){var r=A(e);return{h:r.h,s:r.s,v:r.v}},equal:F},pe=function(r){return e.createElement(U,u({},r,{colorModel:ge}))},be={defaultColor:"hsv(0, 0%, 0%)",toHsva:j,fromHsva:function(e){var r=A(e);return"hsv("+r.h+", "+r.s+"%, "+r.v+"%)"},equal:P},_e=function(r){return e.createElement(U,u({},r,{colorModel:be}))},xe={defaultColor:{r:0,g:0,b:0,a:1},toHsva:L,fromHsva:I,equal:F},Ce=function(r){return e.createElement(re,u({},r,{colorModel:xe}))},Ee={defaultColor:"rgba(0, 0, 0, 1)",toHsva:z,fromHsva:function(e){var r=I(e);return"rgba("+r.r+", "+r.g+", "+r.b+", "+r.a+")"},equal:P},He=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(re,u({},r,{colorModel:Ee}))},Me={defaultColor:{r:0,g:0,b:0},toHsva:function(e){return L({r:e.r,g:e.g,b:e.b,a:1})},fromHsva:function(e){return{r:(r=I(e)).r,g:r.g,b:r.b};var r},equal:F},Ne=function(r){return e.createElement(U,u({},r,{colorModel:Me}))},we={defaultColor:"rgb(0, 0, 0)",toHsva:B,fromHsva:function(e){var r=I(e);return"rgb("+r.r+", "+r.g+", "+r.b+")"},equal:P},ye=function(r){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(U,u({},r,{colorModel:we}))},qe=/^#?([0-9A-F]{3,8})$/i,ke=function(r){var t=r.color,l=void 0===t?"":t,s=r.onChange,f=r.onBlur,v=r.escape,d=r.validate,h=r.format,m=r.process,g=c(r,["color","onChange","onBlur","escape","validate","format","process"]),p=o(function(){return v(l)}),b=p[0],_=p[1],x=i(s),C=i(f),E=a(function(e){var r=v(e.target.value);_(r),d(r)&&x(m?m(r):r)},[v,m,d,x]),H=a(function(e){d(e.target.value)||_(v(l)),C(e)},[l,v,d,C]);return n(function(){_(v(l))},[l,v]),e.createElement("input",u({},g,{value:h?h(b):b,spellCheck:"false",onChange:E,onBlur:H}))},Ie=function(e){return"#"+e},Oe=function(r){var t=r.prefixed,n=r.alpha,o=c(r,["prefixed","alpha"]),l=a(function(e){return e.replace(/([^0-9A-F]+)/gi,"").substring(0,n?8:6)},[n]),i=a(function(e){return function(e,r){var t=qe.exec(e),n=t?t[1].length:0;return 3===n||6===n||!!r&&4===n||!!r&&8===n}(e,n)},[n]);return e.createElement(ke,u({},o,{escape:l,format:t?Ie:void 0,process:Ie,validate:i}))};
//# sourceMappingURL=index.module.js.map


/***/ }),

/***/ "../../node_modules/.pnpm/remove-accents@0.4.4/node_modules/remove-accents/index.js":
/***/ ((module) => {

var characterMap = {
	"À": "A",
	"Á": "A",
	"Â": "A",
	"Ã": "A",
	"Ä": "A",
	"Å": "A",
	"Ấ": "A",
	"Ắ": "A",
	"Ẳ": "A",
	"Ẵ": "A",
	"Ặ": "A",
	"Æ": "AE",
	"Ầ": "A",
	"Ằ": "A",
	"Ȃ": "A",
	"Ç": "C",
	"Ḉ": "C",
	"È": "E",
	"É": "E",
	"Ê": "E",
	"Ë": "E",
	"Ế": "E",
	"Ḗ": "E",
	"Ề": "E",
	"Ḕ": "E",
	"Ḝ": "E",
	"Ȇ": "E",
	"Ì": "I",
	"Í": "I",
	"Î": "I",
	"Ï": "I",
	"Ḯ": "I",
	"Ȋ": "I",
	"Ð": "D",
	"Ñ": "N",
	"Ò": "O",
	"Ó": "O",
	"Ô": "O",
	"Õ": "O",
	"Ö": "O",
	"Ø": "O",
	"Ố": "O",
	"Ṍ": "O",
	"Ṓ": "O",
	"Ȏ": "O",
	"Ù": "U",
	"Ú": "U",
	"Û": "U",
	"Ü": "U",
	"Ý": "Y",
	"à": "a",
	"á": "a",
	"â": "a",
	"ã": "a",
	"ä": "a",
	"å": "a",
	"ấ": "a",
	"ắ": "a",
	"ẳ": "a",
	"ẵ": "a",
	"ặ": "a",
	"æ": "ae",
	"ầ": "a",
	"ằ": "a",
	"ȃ": "a",
	"ç": "c",
	"ḉ": "c",
	"è": "e",
	"é": "e",
	"ê": "e",
	"ë": "e",
	"ế": "e",
	"ḗ": "e",
	"ề": "e",
	"ḕ": "e",
	"ḝ": "e",
	"ȇ": "e",
	"ì": "i",
	"í": "i",
	"î": "i",
	"ï": "i",
	"ḯ": "i",
	"ȋ": "i",
	"ð": "d",
	"ñ": "n",
	"ò": "o",
	"ó": "o",
	"ô": "o",
	"õ": "o",
	"ö": "o",
	"ø": "o",
	"ố": "o",
	"ṍ": "o",
	"ṓ": "o",
	"ȏ": "o",
	"ù": "u",
	"ú": "u",
	"û": "u",
	"ü": "u",
	"ý": "y",
	"ÿ": "y",
	"Ā": "A",
	"ā": "a",
	"Ă": "A",
	"ă": "a",
	"Ą": "A",
	"ą": "a",
	"Ć": "C",
	"ć": "c",
	"Ĉ": "C",
	"ĉ": "c",
	"Ċ": "C",
	"ċ": "c",
	"Č": "C",
	"č": "c",
	"C̆": "C",
	"c̆": "c",
	"Ď": "D",
	"ď": "d",
	"Đ": "D",
	"đ": "d",
	"Ē": "E",
	"ē": "e",
	"Ĕ": "E",
	"ĕ": "e",
	"Ė": "E",
	"ė": "e",
	"Ę": "E",
	"ę": "e",
	"Ě": "E",
	"ě": "e",
	"Ĝ": "G",
	"Ǵ": "G",
	"ĝ": "g",
	"ǵ": "g",
	"Ğ": "G",
	"ğ": "g",
	"Ġ": "G",
	"ġ": "g",
	"Ģ": "G",
	"ģ": "g",
	"Ĥ": "H",
	"ĥ": "h",
	"Ħ": "H",
	"ħ": "h",
	"Ḫ": "H",
	"ḫ": "h",
	"Ĩ": "I",
	"ĩ": "i",
	"Ī": "I",
	"ī": "i",
	"Ĭ": "I",
	"ĭ": "i",
	"Į": "I",
	"į": "i",
	"İ": "I",
	"ı": "i",
	"Ĳ": "IJ",
	"ĳ": "ij",
	"Ĵ": "J",
	"ĵ": "j",
	"Ķ": "K",
	"ķ": "k",
	"Ḱ": "K",
	"ḱ": "k",
	"K̆": "K",
	"k̆": "k",
	"Ĺ": "L",
	"ĺ": "l",
	"Ļ": "L",
	"ļ": "l",
	"Ľ": "L",
	"ľ": "l",
	"Ŀ": "L",
	"ŀ": "l",
	"Ł": "l",
	"ł": "l",
	"Ḿ": "M",
	"ḿ": "m",
	"M̆": "M",
	"m̆": "m",
	"Ń": "N",
	"ń": "n",
	"Ņ": "N",
	"ņ": "n",
	"Ň": "N",
	"ň": "n",
	"ŉ": "n",
	"N̆": "N",
	"n̆": "n",
	"Ō": "O",
	"ō": "o",
	"Ŏ": "O",
	"ŏ": "o",
	"Ő": "O",
	"ő": "o",
	"Œ": "OE",
	"œ": "oe",
	"P̆": "P",
	"p̆": "p",
	"Ŕ": "R",
	"ŕ": "r",
	"Ŗ": "R",
	"ŗ": "r",
	"Ř": "R",
	"ř": "r",
	"R̆": "R",
	"r̆": "r",
	"Ȓ": "R",
	"ȓ": "r",
	"Ś": "S",
	"ś": "s",
	"Ŝ": "S",
	"ŝ": "s",
	"Ş": "S",
	"Ș": "S",
	"ș": "s",
	"ş": "s",
	"Š": "S",
	"š": "s",
	"ß": "ss",
	"Ţ": "T",
	"ţ": "t",
	"ț": "t",
	"Ț": "T",
	"Ť": "T",
	"ť": "t",
	"Ŧ": "T",
	"ŧ": "t",
	"T̆": "T",
	"t̆": "t",
	"Ũ": "U",
	"ũ": "u",
	"Ū": "U",
	"ū": "u",
	"Ŭ": "U",
	"ŭ": "u",
	"Ů": "U",
	"ů": "u",
	"Ű": "U",
	"ű": "u",
	"Ų": "U",
	"ų": "u",
	"Ȗ": "U",
	"ȗ": "u",
	"V̆": "V",
	"v̆": "v",
	"Ŵ": "W",
	"ŵ": "w",
	"Ẃ": "W",
	"ẃ": "w",
	"X̆": "X",
	"x̆": "x",
	"Ŷ": "Y",
	"ŷ": "y",
	"Ÿ": "Y",
	"Y̆": "Y",
	"y̆": "y",
	"Ź": "Z",
	"ź": "z",
	"Ż": "Z",
	"ż": "z",
	"Ž": "Z",
	"ž": "z",
	"ſ": "s",
	"ƒ": "f",
	"Ơ": "O",
	"ơ": "o",
	"Ư": "U",
	"ư": "u",
	"Ǎ": "A",
	"ǎ": "a",
	"Ǐ": "I",
	"ǐ": "i",
	"Ǒ": "O",
	"ǒ": "o",
	"Ǔ": "U",
	"ǔ": "u",
	"Ǖ": "U",
	"ǖ": "u",
	"Ǘ": "U",
	"ǘ": "u",
	"Ǚ": "U",
	"ǚ": "u",
	"Ǜ": "U",
	"ǜ": "u",
	"Ứ": "U",
	"ứ": "u",
	"Ṹ": "U",
	"ṹ": "u",
	"Ǻ": "A",
	"ǻ": "a",
	"Ǽ": "AE",
	"ǽ": "ae",
	"Ǿ": "O",
	"ǿ": "o",
	"Þ": "TH",
	"þ": "th",
	"Ṕ": "P",
	"ṕ": "p",
	"Ṥ": "S",
	"ṥ": "s",
	"X́": "X",
	"x́": "x",
	"Ѓ": "Г",
	"ѓ": "г",
	"Ќ": "К",
	"ќ": "к",
	"A̋": "A",
	"a̋": "a",
	"E̋": "E",
	"e̋": "e",
	"I̋": "I",
	"i̋": "i",
	"Ǹ": "N",
	"ǹ": "n",
	"Ồ": "O",
	"ồ": "o",
	"Ṑ": "O",
	"ṑ": "o",
	"Ừ": "U",
	"ừ": "u",
	"Ẁ": "W",
	"ẁ": "w",
	"Ỳ": "Y",
	"ỳ": "y",
	"Ȁ": "A",
	"ȁ": "a",
	"Ȅ": "E",
	"ȅ": "e",
	"Ȉ": "I",
	"ȉ": "i",
	"Ȍ": "O",
	"ȍ": "o",
	"Ȑ": "R",
	"ȑ": "r",
	"Ȕ": "U",
	"ȕ": "u",
	"B̌": "B",
	"b̌": "b",
	"Č̣": "C",
	"č̣": "c",
	"Ê̌": "E",
	"ê̌": "e",
	"F̌": "F",
	"f̌": "f",
	"Ǧ": "G",
	"ǧ": "g",
	"Ȟ": "H",
	"ȟ": "h",
	"J̌": "J",
	"ǰ": "j",
	"Ǩ": "K",
	"ǩ": "k",
	"M̌": "M",
	"m̌": "m",
	"P̌": "P",
	"p̌": "p",
	"Q̌": "Q",
	"q̌": "q",
	"Ř̩": "R",
	"ř̩": "r",
	"Ṧ": "S",
	"ṧ": "s",
	"V̌": "V",
	"v̌": "v",
	"W̌": "W",
	"w̌": "w",
	"X̌": "X",
	"x̌": "x",
	"Y̌": "Y",
	"y̌": "y",
	"A̧": "A",
	"a̧": "a",
	"B̧": "B",
	"b̧": "b",
	"Ḑ": "D",
	"ḑ": "d",
	"Ȩ": "E",
	"ȩ": "e",
	"Ɛ̧": "E",
	"ɛ̧": "e",
	"Ḩ": "H",
	"ḩ": "h",
	"I̧": "I",
	"i̧": "i",
	"Ɨ̧": "I",
	"ɨ̧": "i",
	"M̧": "M",
	"m̧": "m",
	"O̧": "O",
	"o̧": "o",
	"Q̧": "Q",
	"q̧": "q",
	"U̧": "U",
	"u̧": "u",
	"X̧": "X",
	"x̧": "x",
	"Z̧": "Z",
	"z̧": "z",
	"й":"и",
	"Й":"И",
	"ё":"е",
	"Ё":"Е",
};

var chars = Object.keys(characterMap).join('|');
var allAccents = new RegExp(chars, 'g');
var firstAccent = new RegExp(chars, '');

function matcher(match) {
	return characterMap[match];
}

var removeAccents = function(string) {	
	return string.replace(allAccents, matcher);
};

var hasAccents = function(string) {
	return !!string.match(firstAccent);
};

module.exports = removeAccents;
module.exports.has = hasAccents;
module.exports.remove = removeAccents;


/***/ }),

/***/ "../../node_modules/.pnpm/showdown@1.9.1/node_modules/showdown/dist/showdown.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;/*! showdown v 1.9.1 - 02-11-2019 */
(function(){
/**
 * Created by Tivie on 13-07-2015.
 */

function getDefaultOpts (simple) {
  'use strict';

  var defaultOptions = {
    omitExtraWLInCodeBlocks: {
      defaultValue: false,
      describe: 'Omit the default extra whiteline added to code blocks',
      type: 'boolean'
    },
    noHeaderId: {
      defaultValue: false,
      describe: 'Turn on/off generated header id',
      type: 'boolean'
    },
    prefixHeaderId: {
      defaultValue: false,
      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
      type: 'string'
    },
    rawPrefixHeaderId: {
      defaultValue: false,
      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
      type: 'boolean'
    },
    ghCompatibleHeaderId: {
      defaultValue: false,
      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
      type: 'boolean'
    },
    rawHeaderId: {
      defaultValue: false,
      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
      type: 'boolean'
    },
    headerLevelStart: {
      defaultValue: false,
      describe: 'The header blocks level start',
      type: 'integer'
    },
    parseImgDimensions: {
      defaultValue: false,
      describe: 'Turn on/off image dimension parsing',
      type: 'boolean'
    },
    simplifiedAutoLink: {
      defaultValue: false,
      describe: 'Turn on/off GFM autolink style',
      type: 'boolean'
    },
    excludeTrailingPunctuationFromURLs: {
      defaultValue: false,
      describe: 'Excludes trailing punctuation from links generated with autoLinking',
      type: 'boolean'
    },
    literalMidWordUnderscores: {
      defaultValue: false,
      describe: 'Parse midword underscores as literal underscores',
      type: 'boolean'
    },
    literalMidWordAsterisks: {
      defaultValue: false,
      describe: 'Parse midword asterisks as literal asterisks',
      type: 'boolean'
    },
    strikethrough: {
      defaultValue: false,
      describe: 'Turn on/off strikethrough support',
      type: 'boolean'
    },
    tables: {
      defaultValue: false,
      describe: 'Turn on/off tables support',
      type: 'boolean'
    },
    tablesHeaderId: {
      defaultValue: false,
      describe: 'Add an id to table headers',
      type: 'boolean'
    },
    ghCodeBlocks: {
      defaultValue: true,
      describe: 'Turn on/off GFM fenced code blocks support',
      type: 'boolean'
    },
    tasklists: {
      defaultValue: false,
      describe: 'Turn on/off GFM tasklist support',
      type: 'boolean'
    },
    smoothLivePreview: {
      defaultValue: false,
      describe: 'Prevents weird effects in live previews due to incomplete input',
      type: 'boolean'
    },
    smartIndentationFix: {
      defaultValue: false,
      description: 'Tries to smartly fix indentation in es6 strings',
      type: 'boolean'
    },
    disableForced4SpacesIndentedSublists: {
      defaultValue: false,
      description: 'Disables the requirement of indenting nested sublists by 4 spaces',
      type: 'boolean'
    },
    simpleLineBreaks: {
      defaultValue: false,
      description: 'Parses simple line breaks as <br> (GFM Style)',
      type: 'boolean'
    },
    requireSpaceBeforeHeadingText: {
      defaultValue: false,
      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
      type: 'boolean'
    },
    ghMentions: {
      defaultValue: false,
      description: 'Enables github @mentions',
      type: 'boolean'
    },
    ghMentionsLink: {
      defaultValue: 'https://github.com/{u}',
      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
      type: 'string'
    },
    encodeEmails: {
      defaultValue: true,
      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
      type: 'boolean'
    },
    openLinksInNewWindow: {
      defaultValue: false,
      description: 'Open all links in new windows',
      type: 'boolean'
    },
    backslashEscapesHTMLTags: {
      defaultValue: false,
      description: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
      type: 'boolean'
    },
    emoji: {
      defaultValue: false,
      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',
      type: 'boolean'
    },
    underline: {
      defaultValue: false,
      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
      type: 'boolean'
    },
    completeHTMLDocument: {
      defaultValue: false,
      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
      type: 'boolean'
    },
    metadata: {
      defaultValue: false,
      description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
      type: 'boolean'
    },
    splitAdjacentBlockquotes: {
      defaultValue: false,
      description: 'Split adjacent blockquote blocks',
      type: 'boolean'
    }
  };
  if (simple === false) {
    return JSON.parse(JSON.stringify(defaultOptions));
  }
  var ret = {};
  for (var opt in defaultOptions) {
    if (defaultOptions.hasOwnProperty(opt)) {
      ret[opt] = defaultOptions[opt].defaultValue;
    }
  }
  return ret;
}

function allOptionsOn () {
  'use strict';
  var options = getDefaultOpts(true),
      ret = {};
  for (var opt in options) {
    if (options.hasOwnProperty(opt)) {
      ret[opt] = true;
    }
  }
  return ret;
}

/**
 * Created by Tivie on 06-01-2015.
 */

// Private properties
var showdown = {},
    parsers = {},
    extensions = {},
    globalOptions = getDefaultOpts(true),
    setFlavor = 'vanilla',
    flavor = {
      github: {
        omitExtraWLInCodeBlocks:              true,
        simplifiedAutoLink:                   true,
        excludeTrailingPunctuationFromURLs:   true,
        literalMidWordUnderscores:            true,
        strikethrough:                        true,
        tables:                               true,
        tablesHeaderId:                       true,
        ghCodeBlocks:                         true,
        tasklists:                            true,
        disableForced4SpacesIndentedSublists: true,
        simpleLineBreaks:                     true,
        requireSpaceBeforeHeadingText:        true,
        ghCompatibleHeaderId:                 true,
        ghMentions:                           true,
        backslashEscapesHTMLTags:             true,
        emoji:                                true,
        splitAdjacentBlockquotes:             true
      },
      original: {
        noHeaderId:                           true,
        ghCodeBlocks:                         false
      },
      ghost: {
        omitExtraWLInCodeBlocks:              true,
        parseImgDimensions:                   true,
        simplifiedAutoLink:                   true,
        excludeTrailingPunctuationFromURLs:   true,
        literalMidWordUnderscores:            true,
        strikethrough:                        true,
        tables:                               true,
        tablesHeaderId:                       true,
        ghCodeBlocks:                         true,
        tasklists:                            true,
        smoothLivePreview:                    true,
        simpleLineBreaks:                     true,
        requireSpaceBeforeHeadingText:        true,
        ghMentions:                           false,
        encodeEmails:                         true
      },
      vanilla: getDefaultOpts(true),
      allOn: allOptionsOn()
    };

/**
 * helper namespace
 * @type {{}}
 */
showdown.helper = {};

/**
 * TODO LEGACY SUPPORT CODE
 * @type {{}}
 */
showdown.extensions = {};

/**
 * Set a global option
 * @static
 * @param {string} key
 * @param {*} value
 * @returns {showdown}
 */
showdown.setOption = function (key, value) {
  'use strict';
  globalOptions[key] = value;
  return this;
};

/**
 * Get a global option
 * @static
 * @param {string} key
 * @returns {*}
 */
showdown.getOption = function (key) {
  'use strict';
  return globalOptions[key];
};

/**
 * Get the global options
 * @static
 * @returns {{}}
 */
showdown.getOptions = function () {
  'use strict';
  return globalOptions;
};

/**
 * Reset global options to the default values
 * @static
 */
showdown.resetOptions = function () {
  'use strict';
  globalOptions = getDefaultOpts(true);
};

/**
 * Set the flavor showdown should use as default
 * @param {string} name
 */
showdown.setFlavor = function (name) {
  'use strict';
  if (!flavor.hasOwnProperty(name)) {
    throw Error(name + ' flavor was not found');
  }
  showdown.resetOptions();
  var preset = flavor[name];
  setFlavor = name;
  for (var option in preset) {
    if (preset.hasOwnProperty(option)) {
      globalOptions[option] = preset[option];
    }
  }
};

/**
 * Get the currently set flavor
 * @returns {string}
 */
showdown.getFlavor = function () {
  'use strict';
  return setFlavor;
};

/**
 * Get the options of a specified flavor. Returns undefined if the flavor was not found
 * @param {string} name Name of the flavor
 * @returns {{}|undefined}
 */
showdown.getFlavorOptions = function (name) {
  'use strict';
  if (flavor.hasOwnProperty(name)) {
    return flavor[name];
  }
};

/**
 * Get the default options
 * @static
 * @param {boolean} [simple=true]
 * @returns {{}}
 */
showdown.getDefaultOptions = function (simple) {
  'use strict';
  return getDefaultOpts(simple);
};

/**
 * Get or set a subParser
 *
 * subParser(name)       - Get a registered subParser
 * subParser(name, func) - Register a subParser
 * @static
 * @param {string} name
 * @param {function} [func]
 * @returns {*}
 */
showdown.subParser = function (name, func) {
  'use strict';
  if (showdown.helper.isString(name)) {
    if (typeof func !== 'undefined') {
      parsers[name] = func;
    } else {
      if (parsers.hasOwnProperty(name)) {
        return parsers[name];
      } else {
        throw Error('SubParser named ' + name + ' not registered!');
      }
    }
  }
};

/**
 * Gets or registers an extension
 * @static
 * @param {string} name
 * @param {object|function=} ext
 * @returns {*}
 */
showdown.extension = function (name, ext) {
  'use strict';

  if (!showdown.helper.isString(name)) {
    throw Error('Extension \'name\' must be a string');
  }

  name = showdown.helper.stdExtName(name);

  // Getter
  if (showdown.helper.isUndefined(ext)) {
    if (!extensions.hasOwnProperty(name)) {
      throw Error('Extension named ' + name + ' is not registered!');
    }
    return extensions[name];

    // Setter
  } else {
    // Expand extension if it's wrapped in a function
    if (typeof ext === 'function') {
      ext = ext();
    }

    // Ensure extension is an array
    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }

    var validExtension = validate(ext, name);

    if (validExtension.valid) {
      extensions[name] = ext;
    } else {
      throw Error(validExtension.error);
    }
  }
};

/**
 * Gets all extensions registered
 * @returns {{}}
 */
showdown.getAllExtensions = function () {
  'use strict';
  return extensions;
};

/**
 * Remove an extension
 * @param {string} name
 */
showdown.removeExtension = function (name) {
  'use strict';
  delete extensions[name];
};

/**
 * Removes all extensions
 */
showdown.resetExtensions = function () {
  'use strict';
  extensions = {};
};

/**
 * Validate extension
 * @param {array} extension
 * @param {string} name
 * @returns {{valid: boolean, error: string}}
 */
function validate (extension, name) {
  'use strict';

  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
      ret = {
        valid: true,
        error: ''
      };

  if (!showdown.helper.isArray(extension)) {
    extension = [extension];
  }

  for (var i = 0; i < extension.length; ++i) {
    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
        ext = extension[i];
    if (typeof ext !== 'object') {
      ret.valid = false;
      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
      return ret;
    }

    if (!showdown.helper.isString(ext.type)) {
      ret.valid = false;
      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
      return ret;
    }

    var type = ext.type = ext.type.toLowerCase();

    // normalize extension type
    if (type === 'language') {
      type = ext.type = 'lang';
    }

    if (type === 'html') {
      type = ext.type = 'output';
    }

    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
      ret.valid = false;
      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
      return ret;
    }

    if (type === 'listener') {
      if (showdown.helper.isUndefined(ext.listeners)) {
        ret.valid = false;
        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
        return ret;
      }
    } else {
      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
        ret.valid = false;
        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
        return ret;
      }
    }

    if (ext.listeners) {
      if (typeof ext.listeners !== 'object') {
        ret.valid = false;
        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
        return ret;
      }
      for (var ln in ext.listeners) {
        if (ext.listeners.hasOwnProperty(ln)) {
          if (typeof ext.listeners[ln] !== 'function') {
            ret.valid = false;
            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
            return ret;
          }
        }
      }
    }

    if (ext.filter) {
      if (typeof ext.filter !== 'function') {
        ret.valid = false;
        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
        return ret;
      }
    } else if (ext.regex) {
      if (showdown.helper.isString(ext.regex)) {
        ext.regex = new RegExp(ext.regex, 'g');
      }
      if (!(ext.regex instanceof RegExp)) {
        ret.valid = false;
        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
        return ret;
      }
      if (showdown.helper.isUndefined(ext.replace)) {
        ret.valid = false;
        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
        return ret;
      }
    }
  }
  return ret;
}

/**
 * Validate extension
 * @param {object} ext
 * @returns {boolean}
 */
showdown.validateExtension = function (ext) {
  'use strict';

  var validateExtension = validate(ext, null);
  if (!validateExtension.valid) {
    console.warn(validateExtension.error);
    return false;
  }
  return true;
};

/**
 * showdownjs helper functions
 */

if (!showdown.hasOwnProperty('helper')) {
  showdown.helper = {};
}

/**
 * Check if var is string
 * @static
 * @param {string} a
 * @returns {boolean}
 */
showdown.helper.isString = function (a) {
  'use strict';
  return (typeof a === 'string' || a instanceof String);
};

/**
 * Check if var is a function
 * @static
 * @param {*} a
 * @returns {boolean}
 */
showdown.helper.isFunction = function (a) {
  'use strict';
  var getType = {};
  return a && getType.toString.call(a) === '[object Function]';
};

/**
 * isArray helper function
 * @static
 * @param {*} a
 * @returns {boolean}
 */
showdown.helper.isArray = function (a) {
  'use strict';
  return Array.isArray(a);
};

/**
 * Check if value is undefined
 * @static
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 */
showdown.helper.isUndefined = function (value) {
  'use strict';
  return typeof value === 'undefined';
};

/**
 * ForEach helper function
 * Iterates over Arrays and Objects (own properties only)
 * @static
 * @param {*} obj
 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
 */
showdown.helper.forEach = function (obj, callback) {
  'use strict';
  // check if obj is defined
  if (showdown.helper.isUndefined(obj)) {
    throw new Error('obj param is required');
  }

  if (showdown.helper.isUndefined(callback)) {
    throw new Error('callback param is required');
  }

  if (!showdown.helper.isFunction(callback)) {
    throw new Error('callback param must be a function/closure');
  }

  if (typeof obj.forEach === 'function') {
    obj.forEach(callback);
  } else if (showdown.helper.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      callback(obj[i], i, obj);
    }
  } else if (typeof (obj) === 'object') {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        callback(obj[prop], prop, obj);
      }
    }
  } else {
    throw new Error('obj does not seem to be an array or an iterable object');
  }
};

/**
 * Standardidize extension name
 * @static
 * @param {string} s extension name
 * @returns {string}
 */
showdown.helper.stdExtName = function (s) {
  'use strict';
  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
};

function escapeCharactersCallback (wholeMatch, m1) {
  'use strict';
  var charCodeToEscape = m1.charCodeAt(0);
  return '¨E' + charCodeToEscape + 'E';
}

/**
 * Callback used to escape characters when passing through String.replace
 * @static
 * @param {string} wholeMatch
 * @param {string} m1
 * @returns {string}
 */
showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

/**
 * Escape characters in a string
 * @static
 * @param {string} text
 * @param {string} charsToEscape
 * @param {boolean} afterBackslash
 * @returns {XML|string|void|*}
 */
showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
  'use strict';
  // First we have to escape the escape characters so that
  // we can build a character class out of them
  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

  if (afterBackslash) {
    regexString = '\\\\' + regexString;
  }

  var regex = new RegExp(regexString, 'g');
  text = text.replace(regex, escapeCharactersCallback);

  return text;
};

/**
 * Unescape HTML entities
 * @param txt
 * @returns {string}
 */
showdown.helper.unescapeHTMLEntities = function (txt) {
  'use strict';

  return txt
    .replace(/&quot;/g, '"')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');
};

var rgxFindMatchPos = function (str, left, right, flags) {
  'use strict';
  var f = flags || '',
      g = f.indexOf('g') > -1,
      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
      l = new RegExp(left, f.replace(/g/g, '')),
      pos = [],
      t, s, m, start, end;

  do {
    t = 0;
    while ((m = x.exec(str))) {
      if (l.test(m[0])) {
        if (!(t++)) {
          s = x.lastIndex;
          start = s - m[0].length;
        }
      } else if (t) {
        if (!--t) {
          end = m.index + m[0].length;
          var obj = {
            left: {start: start, end: s},
            match: {start: s, end: m.index},
            right: {start: m.index, end: end},
            wholeMatch: {start: start, end: end}
          };
          pos.push(obj);
          if (!g) {
            return pos;
          }
        }
      }
    }
  } while (t && (x.lastIndex = s));

  return pos;
};

/**
 * matchRecursiveRegExp
 *
 * (c) 2007 Steven Levithan <stevenlevithan.com>
 * MIT License
 *
 * Accepts a string to search, a left and right format delimiter
 * as regex patterns, and optional regex flags. Returns an array
 * of matches, allowing nested instances of left/right delimiters.
 * Use the "g" flag to return all matches, otherwise only the
 * first is returned. Be careful to ensure that the left and
 * right format delimiters produce mutually exclusive matches.
 * Backreferences are not supported within the right delimiter
 * due to how it is internally combined with the left delimiter.
 * When matching strings whose format delimiters are unbalanced
 * to the left or right, the output is intentionally as a
 * conventional regex library with recursion support would
 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
 * "<" and ">" as the delimiters (both strings contain a single,
 * balanced instance of "<x>").
 *
 * examples:
 * matchRecursiveRegExp("test", "\\(", "\\)")
 * returns: []
 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
 * returns: ["t<<e>><s>", ""]
 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
 * returns: ["test"]
 */
showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {
  'use strict';

  var matchPos = rgxFindMatchPos (str, left, right, flags),
      results = [];

  for (var i = 0; i < matchPos.length; ++i) {
    results.push([
      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
      str.slice(matchPos[i].match.start, matchPos[i].match.end),
      str.slice(matchPos[i].left.start, matchPos[i].left.end),
      str.slice(matchPos[i].right.start, matchPos[i].right.end)
    ]);
  }
  return results;
};

/**
 *
 * @param {string} str
 * @param {string|function} replacement
 * @param {string} left
 * @param {string} right
 * @param {string} flags
 * @returns {string}
 */
showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {
  'use strict';

  if (!showdown.helper.isFunction(replacement)) {
    var repStr = replacement;
    replacement = function () {
      return repStr;
    };
  }

  var matchPos = rgxFindMatchPos(str, left, right, flags),
      finalStr = str,
      lng = matchPos.length;

  if (lng > 0) {
    var bits = [];
    if (matchPos[0].wholeMatch.start !== 0) {
      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
    }
    for (var i = 0; i < lng; ++i) {
      bits.push(
        replacement(
          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
          str.slice(matchPos[i].match.start, matchPos[i].match.end),
          str.slice(matchPos[i].left.start, matchPos[i].left.end),
          str.slice(matchPos[i].right.start, matchPos[i].right.end)
        )
      );
      if (i < lng - 1) {
        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
      }
    }
    if (matchPos[lng - 1].wholeMatch.end < str.length) {
      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
    }
    finalStr = bits.join('');
  }
  return finalStr;
};

/**
 * Returns the index within the passed String object of the first occurrence of the specified regex,
 * starting the search at fromIndex. Returns -1 if the value is not found.
 *
 * @param {string} str string to search
 * @param {RegExp} regex Regular expression to search
 * @param {int} [fromIndex = 0] Index to start the search
 * @returns {Number}
 * @throws InvalidArgumentError
 */
showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
  'use strict';
  if (!showdown.helper.isString(str)) {
    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
  }
  if (regex instanceof RegExp === false) {
    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
  }
  var indexOf = str.substring(fromIndex || 0).search(regex);
  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
};

/**
 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
 * @param {string} str string to split
 * @param {int} index index to split string at
 * @returns {[string,string]}
 * @throws InvalidArgumentError
 */
showdown.helper.splitAtIndex = function (str, index) {
  'use strict';
  if (!showdown.helper.isString(str)) {
    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
  }
  return [str.substring(0, index), str.substring(index)];
};

/**
 * Obfuscate an e-mail address through the use of Character Entities,
 * transforming ASCII characters into their equivalent decimal or hex entities.
 *
 * Since it has a random component, subsequent calls to this function produce different results
 *
 * @param {string} mail
 * @returns {string}
 */
showdown.helper.encodeEmailAddress = function (mail) {
  'use strict';
  var encode = [
    function (ch) {
      return '&#' + ch.charCodeAt(0) + ';';
    },
    function (ch) {
      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
    },
    function (ch) {
      return ch;
    }
  ];

  mail = mail.replace(/./g, function (ch) {
    if (ch === '@') {
      // this *must* be encoded. I insist.
      ch = encode[Math.floor(Math.random() * 2)](ch);
    } else {
      var r = Math.random();
      // roughly 10% raw, 45% hex, 45% dec
      ch = (
        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
      );
    }
    return ch;
  });

  return mail;
};

/**
 *
 * @param str
 * @param targetLength
 * @param padString
 * @returns {string}
 */
showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
  'use strict';
  /*jshint bitwise: false*/
  // eslint-disable-next-line space-infix-ops
  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
  /*jshint bitwise: true*/
  padString = String(padString || ' ');
  if (str.length > targetLength) {
    return String(str);
  } else {
    targetLength = targetLength - str.length;
    if (targetLength > padString.length) {
      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
    }
    return String(str) + padString.slice(0,targetLength);
  }
};

/**
 * POLYFILLS
 */
// use this instead of builtin is undefined for IE8 compatibility
if (typeof console === 'undefined') {
  console = {
    warn: function (msg) {
      'use strict';
      alert(msg);
    },
    log: function (msg) {
      'use strict';
      alert(msg);
    },
    error: function (msg) {
      'use strict';
      throw msg;
    }
  };
}

/**
 * Common regexes.
 * We declare some common regexes to improve performance
 */
showdown.helper.regexes = {
  asteriskDashAndColon: /([*_:~])/g
};

/**
 * EMOJIS LIST
 */
showdown.helper.emojis = {
  '+1':'\ud83d\udc4d',
  '-1':'\ud83d\udc4e',
  '100':'\ud83d\udcaf',
  '1234':'\ud83d\udd22',
  '1st_place_medal':'\ud83e\udd47',
  '2nd_place_medal':'\ud83e\udd48',
  '3rd_place_medal':'\ud83e\udd49',
  '8ball':'\ud83c\udfb1',
  'a':'\ud83c\udd70\ufe0f',
  'ab':'\ud83c\udd8e',
  'abc':'\ud83d\udd24',
  'abcd':'\ud83d\udd21',
  'accept':'\ud83c\ude51',
  'aerial_tramway':'\ud83d\udea1',
  'airplane':'\u2708\ufe0f',
  'alarm_clock':'\u23f0',
  'alembic':'\u2697\ufe0f',
  'alien':'\ud83d\udc7d',
  'ambulance':'\ud83d\ude91',
  'amphora':'\ud83c\udffa',
  'anchor':'\u2693\ufe0f',
  'angel':'\ud83d\udc7c',
  'anger':'\ud83d\udca2',
  'angry':'\ud83d\ude20',
  'anguished':'\ud83d\ude27',
  'ant':'\ud83d\udc1c',
  'apple':'\ud83c\udf4e',
  'aquarius':'\u2652\ufe0f',
  'aries':'\u2648\ufe0f',
  'arrow_backward':'\u25c0\ufe0f',
  'arrow_double_down':'\u23ec',
  'arrow_double_up':'\u23eb',
  'arrow_down':'\u2b07\ufe0f',
  'arrow_down_small':'\ud83d\udd3d',
  'arrow_forward':'\u25b6\ufe0f',
  'arrow_heading_down':'\u2935\ufe0f',
  'arrow_heading_up':'\u2934\ufe0f',
  'arrow_left':'\u2b05\ufe0f',
  'arrow_lower_left':'\u2199\ufe0f',
  'arrow_lower_right':'\u2198\ufe0f',
  'arrow_right':'\u27a1\ufe0f',
  'arrow_right_hook':'\u21aa\ufe0f',
  'arrow_up':'\u2b06\ufe0f',
  'arrow_up_down':'\u2195\ufe0f',
  'arrow_up_small':'\ud83d\udd3c',
  'arrow_upper_left':'\u2196\ufe0f',
  'arrow_upper_right':'\u2197\ufe0f',
  'arrows_clockwise':'\ud83d\udd03',
  'arrows_counterclockwise':'\ud83d\udd04',
  'art':'\ud83c\udfa8',
  'articulated_lorry':'\ud83d\ude9b',
  'artificial_satellite':'\ud83d\udef0',
  'astonished':'\ud83d\ude32',
  'athletic_shoe':'\ud83d\udc5f',
  'atm':'\ud83c\udfe7',
  'atom_symbol':'\u269b\ufe0f',
  'avocado':'\ud83e\udd51',
  'b':'\ud83c\udd71\ufe0f',
  'baby':'\ud83d\udc76',
  'baby_bottle':'\ud83c\udf7c',
  'baby_chick':'\ud83d\udc24',
  'baby_symbol':'\ud83d\udebc',
  'back':'\ud83d\udd19',
  'bacon':'\ud83e\udd53',
  'badminton':'\ud83c\udff8',
  'baggage_claim':'\ud83d\udec4',
  'baguette_bread':'\ud83e\udd56',
  'balance_scale':'\u2696\ufe0f',
  'balloon':'\ud83c\udf88',
  'ballot_box':'\ud83d\uddf3',
  'ballot_box_with_check':'\u2611\ufe0f',
  'bamboo':'\ud83c\udf8d',
  'banana':'\ud83c\udf4c',
  'bangbang':'\u203c\ufe0f',
  'bank':'\ud83c\udfe6',
  'bar_chart':'\ud83d\udcca',
  'barber':'\ud83d\udc88',
  'baseball':'\u26be\ufe0f',
  'basketball':'\ud83c\udfc0',
  'basketball_man':'\u26f9\ufe0f',
  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
  'bat':'\ud83e\udd87',
  'bath':'\ud83d\udec0',
  'bathtub':'\ud83d\udec1',
  'battery':'\ud83d\udd0b',
  'beach_umbrella':'\ud83c\udfd6',
  'bear':'\ud83d\udc3b',
  'bed':'\ud83d\udecf',
  'bee':'\ud83d\udc1d',
  'beer':'\ud83c\udf7a',
  'beers':'\ud83c\udf7b',
  'beetle':'\ud83d\udc1e',
  'beginner':'\ud83d\udd30',
  'bell':'\ud83d\udd14',
  'bellhop_bell':'\ud83d\udece',
  'bento':'\ud83c\udf71',
  'biking_man':'\ud83d\udeb4',
  'bike':'\ud83d\udeb2',
  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
  'bikini':'\ud83d\udc59',
  'biohazard':'\u2623\ufe0f',
  'bird':'\ud83d\udc26',
  'birthday':'\ud83c\udf82',
  'black_circle':'\u26ab\ufe0f',
  'black_flag':'\ud83c\udff4',
  'black_heart':'\ud83d\udda4',
  'black_joker':'\ud83c\udccf',
  'black_large_square':'\u2b1b\ufe0f',
  'black_medium_small_square':'\u25fe\ufe0f',
  'black_medium_square':'\u25fc\ufe0f',
  'black_nib':'\u2712\ufe0f',
  'black_small_square':'\u25aa\ufe0f',
  'black_square_button':'\ud83d\udd32',
  'blonde_man':'\ud83d\udc71',
  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
  'blossom':'\ud83c\udf3c',
  'blowfish':'\ud83d\udc21',
  'blue_book':'\ud83d\udcd8',
  'blue_car':'\ud83d\ude99',
  'blue_heart':'\ud83d\udc99',
  'blush':'\ud83d\ude0a',
  'boar':'\ud83d\udc17',
  'boat':'\u26f5\ufe0f',
  'bomb':'\ud83d\udca3',
  'book':'\ud83d\udcd6',
  'bookmark':'\ud83d\udd16',
  'bookmark_tabs':'\ud83d\udcd1',
  'books':'\ud83d\udcda',
  'boom':'\ud83d\udca5',
  'boot':'\ud83d\udc62',
  'bouquet':'\ud83d\udc90',
  'bowing_man':'\ud83d\ude47',
  'bow_and_arrow':'\ud83c\udff9',
  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
  'bowling':'\ud83c\udfb3',
  'boxing_glove':'\ud83e\udd4a',
  'boy':'\ud83d\udc66',
  'bread':'\ud83c\udf5e',
  'bride_with_veil':'\ud83d\udc70',
  'bridge_at_night':'\ud83c\udf09',
  'briefcase':'\ud83d\udcbc',
  'broken_heart':'\ud83d\udc94',
  'bug':'\ud83d\udc1b',
  'building_construction':'\ud83c\udfd7',
  'bulb':'\ud83d\udca1',
  'bullettrain_front':'\ud83d\ude85',
  'bullettrain_side':'\ud83d\ude84',
  'burrito':'\ud83c\udf2f',
  'bus':'\ud83d\ude8c',
  'business_suit_levitating':'\ud83d\udd74',
  'busstop':'\ud83d\ude8f',
  'bust_in_silhouette':'\ud83d\udc64',
  'busts_in_silhouette':'\ud83d\udc65',
  'butterfly':'\ud83e\udd8b',
  'cactus':'\ud83c\udf35',
  'cake':'\ud83c\udf70',
  'calendar':'\ud83d\udcc6',
  'call_me_hand':'\ud83e\udd19',
  'calling':'\ud83d\udcf2',
  'camel':'\ud83d\udc2b',
  'camera':'\ud83d\udcf7',
  'camera_flash':'\ud83d\udcf8',
  'camping':'\ud83c\udfd5',
  'cancer':'\u264b\ufe0f',
  'candle':'\ud83d\udd6f',
  'candy':'\ud83c\udf6c',
  'canoe':'\ud83d\udef6',
  'capital_abcd':'\ud83d\udd20',
  'capricorn':'\u2651\ufe0f',
  'car':'\ud83d\ude97',
  'card_file_box':'\ud83d\uddc3',
  'card_index':'\ud83d\udcc7',
  'card_index_dividers':'\ud83d\uddc2',
  'carousel_horse':'\ud83c\udfa0',
  'carrot':'\ud83e\udd55',
  'cat':'\ud83d\udc31',
  'cat2':'\ud83d\udc08',
  'cd':'\ud83d\udcbf',
  'chains':'\u26d3',
  'champagne':'\ud83c\udf7e',
  'chart':'\ud83d\udcb9',
  'chart_with_downwards_trend':'\ud83d\udcc9',
  'chart_with_upwards_trend':'\ud83d\udcc8',
  'checkered_flag':'\ud83c\udfc1',
  'cheese':'\ud83e\uddc0',
  'cherries':'\ud83c\udf52',
  'cherry_blossom':'\ud83c\udf38',
  'chestnut':'\ud83c\udf30',
  'chicken':'\ud83d\udc14',
  'children_crossing':'\ud83d\udeb8',
  'chipmunk':'\ud83d\udc3f',
  'chocolate_bar':'\ud83c\udf6b',
  'christmas_tree':'\ud83c\udf84',
  'church':'\u26ea\ufe0f',
  'cinema':'\ud83c\udfa6',
  'circus_tent':'\ud83c\udfaa',
  'city_sunrise':'\ud83c\udf07',
  'city_sunset':'\ud83c\udf06',
  'cityscape':'\ud83c\udfd9',
  'cl':'\ud83c\udd91',
  'clamp':'\ud83d\udddc',
  'clap':'\ud83d\udc4f',
  'clapper':'\ud83c\udfac',
  'classical_building':'\ud83c\udfdb',
  'clinking_glasses':'\ud83e\udd42',
  'clipboard':'\ud83d\udccb',
  'clock1':'\ud83d\udd50',
  'clock10':'\ud83d\udd59',
  'clock1030':'\ud83d\udd65',
  'clock11':'\ud83d\udd5a',
  'clock1130':'\ud83d\udd66',
  'clock12':'\ud83d\udd5b',
  'clock1230':'\ud83d\udd67',
  'clock130':'\ud83d\udd5c',
  'clock2':'\ud83d\udd51',
  'clock230':'\ud83d\udd5d',
  'clock3':'\ud83d\udd52',
  'clock330':'\ud83d\udd5e',
  'clock4':'\ud83d\udd53',
  'clock430':'\ud83d\udd5f',
  'clock5':'\ud83d\udd54',
  'clock530':'\ud83d\udd60',
  'clock6':'\ud83d\udd55',
  'clock630':'\ud83d\udd61',
  'clock7':'\ud83d\udd56',
  'clock730':'\ud83d\udd62',
  'clock8':'\ud83d\udd57',
  'clock830':'\ud83d\udd63',
  'clock9':'\ud83d\udd58',
  'clock930':'\ud83d\udd64',
  'closed_book':'\ud83d\udcd5',
  'closed_lock_with_key':'\ud83d\udd10',
  'closed_umbrella':'\ud83c\udf02',
  'cloud':'\u2601\ufe0f',
  'cloud_with_lightning':'\ud83c\udf29',
  'cloud_with_lightning_and_rain':'\u26c8',
  'cloud_with_rain':'\ud83c\udf27',
  'cloud_with_snow':'\ud83c\udf28',
  'clown_face':'\ud83e\udd21',
  'clubs':'\u2663\ufe0f',
  'cocktail':'\ud83c\udf78',
  'coffee':'\u2615\ufe0f',
  'coffin':'\u26b0\ufe0f',
  'cold_sweat':'\ud83d\ude30',
  'comet':'\u2604\ufe0f',
  'computer':'\ud83d\udcbb',
  'computer_mouse':'\ud83d\uddb1',
  'confetti_ball':'\ud83c\udf8a',
  'confounded':'\ud83d\ude16',
  'confused':'\ud83d\ude15',
  'congratulations':'\u3297\ufe0f',
  'construction':'\ud83d\udea7',
  'construction_worker_man':'\ud83d\udc77',
  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
  'control_knobs':'\ud83c\udf9b',
  'convenience_store':'\ud83c\udfea',
  'cookie':'\ud83c\udf6a',
  'cool':'\ud83c\udd92',
  'policeman':'\ud83d\udc6e',
  'copyright':'\u00a9\ufe0f',
  'corn':'\ud83c\udf3d',
  'couch_and_lamp':'\ud83d\udecb',
  'couple':'\ud83d\udc6b',
  'couple_with_heart_woman_man':'\ud83d\udc91',
  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
  'couplekiss_man_woman':'\ud83d\udc8f',
  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
  'cow':'\ud83d\udc2e',
  'cow2':'\ud83d\udc04',
  'cowboy_hat_face':'\ud83e\udd20',
  'crab':'\ud83e\udd80',
  'crayon':'\ud83d\udd8d',
  'credit_card':'\ud83d\udcb3',
  'crescent_moon':'\ud83c\udf19',
  'cricket':'\ud83c\udfcf',
  'crocodile':'\ud83d\udc0a',
  'croissant':'\ud83e\udd50',
  'crossed_fingers':'\ud83e\udd1e',
  'crossed_flags':'\ud83c\udf8c',
  'crossed_swords':'\u2694\ufe0f',
  'crown':'\ud83d\udc51',
  'cry':'\ud83d\ude22',
  'crying_cat_face':'\ud83d\ude3f',
  'crystal_ball':'\ud83d\udd2e',
  'cucumber':'\ud83e\udd52',
  'cupid':'\ud83d\udc98',
  'curly_loop':'\u27b0',
  'currency_exchange':'\ud83d\udcb1',
  'curry':'\ud83c\udf5b',
  'custard':'\ud83c\udf6e',
  'customs':'\ud83d\udec3',
  'cyclone':'\ud83c\udf00',
  'dagger':'\ud83d\udde1',
  'dancer':'\ud83d\udc83',
  'dancing_women':'\ud83d\udc6f',
  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
  'dango':'\ud83c\udf61',
  'dark_sunglasses':'\ud83d\udd76',
  'dart':'\ud83c\udfaf',
  'dash':'\ud83d\udca8',
  'date':'\ud83d\udcc5',
  'deciduous_tree':'\ud83c\udf33',
  'deer':'\ud83e\udd8c',
  'department_store':'\ud83c\udfec',
  'derelict_house':'\ud83c\udfda',
  'desert':'\ud83c\udfdc',
  'desert_island':'\ud83c\udfdd',
  'desktop_computer':'\ud83d\udda5',
  'male_detective':'\ud83d\udd75\ufe0f',
  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
  'diamonds':'\u2666\ufe0f',
  'disappointed':'\ud83d\ude1e',
  'disappointed_relieved':'\ud83d\ude25',
  'dizzy':'\ud83d\udcab',
  'dizzy_face':'\ud83d\ude35',
  'do_not_litter':'\ud83d\udeaf',
  'dog':'\ud83d\udc36',
  'dog2':'\ud83d\udc15',
  'dollar':'\ud83d\udcb5',
  'dolls':'\ud83c\udf8e',
  'dolphin':'\ud83d\udc2c',
  'door':'\ud83d\udeaa',
  'doughnut':'\ud83c\udf69',
  'dove':'\ud83d\udd4a',
  'dragon':'\ud83d\udc09',
  'dragon_face':'\ud83d\udc32',
  'dress':'\ud83d\udc57',
  'dromedary_camel':'\ud83d\udc2a',
  'drooling_face':'\ud83e\udd24',
  'droplet':'\ud83d\udca7',
  'drum':'\ud83e\udd41',
  'duck':'\ud83e\udd86',
  'dvd':'\ud83d\udcc0',
  'e-mail':'\ud83d\udce7',
  'eagle':'\ud83e\udd85',
  'ear':'\ud83d\udc42',
  'ear_of_rice':'\ud83c\udf3e',
  'earth_africa':'\ud83c\udf0d',
  'earth_americas':'\ud83c\udf0e',
  'earth_asia':'\ud83c\udf0f',
  'egg':'\ud83e\udd5a',
  'eggplant':'\ud83c\udf46',
  'eight_pointed_black_star':'\u2734\ufe0f',
  'eight_spoked_asterisk':'\u2733\ufe0f',
  'electric_plug':'\ud83d\udd0c',
  'elephant':'\ud83d\udc18',
  'email':'\u2709\ufe0f',
  'end':'\ud83d\udd1a',
  'envelope_with_arrow':'\ud83d\udce9',
  'euro':'\ud83d\udcb6',
  'european_castle':'\ud83c\udff0',
  'european_post_office':'\ud83c\udfe4',
  'evergreen_tree':'\ud83c\udf32',
  'exclamation':'\u2757\ufe0f',
  'expressionless':'\ud83d\ude11',
  'eye':'\ud83d\udc41',
  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
  'eyeglasses':'\ud83d\udc53',
  'eyes':'\ud83d\udc40',
  'face_with_head_bandage':'\ud83e\udd15',
  'face_with_thermometer':'\ud83e\udd12',
  'fist_oncoming':'\ud83d\udc4a',
  'factory':'\ud83c\udfed',
  'fallen_leaf':'\ud83c\udf42',
  'family_man_woman_boy':'\ud83d\udc6a',
  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'fast_forward':'\u23e9',
  'fax':'\ud83d\udce0',
  'fearful':'\ud83d\ude28',
  'feet':'\ud83d\udc3e',
  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
  'ferris_wheel':'\ud83c\udfa1',
  'ferry':'\u26f4',
  'field_hockey':'\ud83c\udfd1',
  'file_cabinet':'\ud83d\uddc4',
  'file_folder':'\ud83d\udcc1',
  'film_projector':'\ud83d\udcfd',
  'film_strip':'\ud83c\udf9e',
  'fire':'\ud83d\udd25',
  'fire_engine':'\ud83d\ude92',
  'fireworks':'\ud83c\udf86',
  'first_quarter_moon':'\ud83c\udf13',
  'first_quarter_moon_with_face':'\ud83c\udf1b',
  'fish':'\ud83d\udc1f',
  'fish_cake':'\ud83c\udf65',
  'fishing_pole_and_fish':'\ud83c\udfa3',
  'fist_raised':'\u270a',
  'fist_left':'\ud83e\udd1b',
  'fist_right':'\ud83e\udd1c',
  'flags':'\ud83c\udf8f',
  'flashlight':'\ud83d\udd26',
  'fleur_de_lis':'\u269c\ufe0f',
  'flight_arrival':'\ud83d\udeec',
  'flight_departure':'\ud83d\udeeb',
  'floppy_disk':'\ud83d\udcbe',
  'flower_playing_cards':'\ud83c\udfb4',
  'flushed':'\ud83d\ude33',
  'fog':'\ud83c\udf2b',
  'foggy':'\ud83c\udf01',
  'football':'\ud83c\udfc8',
  'footprints':'\ud83d\udc63',
  'fork_and_knife':'\ud83c\udf74',
  'fountain':'\u26f2\ufe0f',
  'fountain_pen':'\ud83d\udd8b',
  'four_leaf_clover':'\ud83c\udf40',
  'fox_face':'\ud83e\udd8a',
  'framed_picture':'\ud83d\uddbc',
  'free':'\ud83c\udd93',
  'fried_egg':'\ud83c\udf73',
  'fried_shrimp':'\ud83c\udf64',
  'fries':'\ud83c\udf5f',
  'frog':'\ud83d\udc38',
  'frowning':'\ud83d\ude26',
  'frowning_face':'\u2639\ufe0f',
  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
  'frowning_woman':'\ud83d\ude4d',
  'middle_finger':'\ud83d\udd95',
  'fuelpump':'\u26fd\ufe0f',
  'full_moon':'\ud83c\udf15',
  'full_moon_with_face':'\ud83c\udf1d',
  'funeral_urn':'\u26b1\ufe0f',
  'game_die':'\ud83c\udfb2',
  'gear':'\u2699\ufe0f',
  'gem':'\ud83d\udc8e',
  'gemini':'\u264a\ufe0f',
  'ghost':'\ud83d\udc7b',
  'gift':'\ud83c\udf81',
  'gift_heart':'\ud83d\udc9d',
  'girl':'\ud83d\udc67',
  'globe_with_meridians':'\ud83c\udf10',
  'goal_net':'\ud83e\udd45',
  'goat':'\ud83d\udc10',
  'golf':'\u26f3\ufe0f',
  'golfing_man':'\ud83c\udfcc\ufe0f',
  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
  'gorilla':'\ud83e\udd8d',
  'grapes':'\ud83c\udf47',
  'green_apple':'\ud83c\udf4f',
  'green_book':'\ud83d\udcd7',
  'green_heart':'\ud83d\udc9a',
  'green_salad':'\ud83e\udd57',
  'grey_exclamation':'\u2755',
  'grey_question':'\u2754',
  'grimacing':'\ud83d\ude2c',
  'grin':'\ud83d\ude01',
  'grinning':'\ud83d\ude00',
  'guardsman':'\ud83d\udc82',
  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
  'guitar':'\ud83c\udfb8',
  'gun':'\ud83d\udd2b',
  'haircut_woman':'\ud83d\udc87',
  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
  'hamburger':'\ud83c\udf54',
  'hammer':'\ud83d\udd28',
  'hammer_and_pick':'\u2692',
  'hammer_and_wrench':'\ud83d\udee0',
  'hamster':'\ud83d\udc39',
  'hand':'\u270b',
  'handbag':'\ud83d\udc5c',
  'handshake':'\ud83e\udd1d',
  'hankey':'\ud83d\udca9',
  'hatched_chick':'\ud83d\udc25',
  'hatching_chick':'\ud83d\udc23',
  'headphones':'\ud83c\udfa7',
  'hear_no_evil':'\ud83d\ude49',
  'heart':'\u2764\ufe0f',
  'heart_decoration':'\ud83d\udc9f',
  'heart_eyes':'\ud83d\ude0d',
  'heart_eyes_cat':'\ud83d\ude3b',
  'heartbeat':'\ud83d\udc93',
  'heartpulse':'\ud83d\udc97',
  'hearts':'\u2665\ufe0f',
  'heavy_check_mark':'\u2714\ufe0f',
  'heavy_division_sign':'\u2797',
  'heavy_dollar_sign':'\ud83d\udcb2',
  'heavy_heart_exclamation':'\u2763\ufe0f',
  'heavy_minus_sign':'\u2796',
  'heavy_multiplication_x':'\u2716\ufe0f',
  'heavy_plus_sign':'\u2795',
  'helicopter':'\ud83d\ude81',
  'herb':'\ud83c\udf3f',
  'hibiscus':'\ud83c\udf3a',
  'high_brightness':'\ud83d\udd06',
  'high_heel':'\ud83d\udc60',
  'hocho':'\ud83d\udd2a',
  'hole':'\ud83d\udd73',
  'honey_pot':'\ud83c\udf6f',
  'horse':'\ud83d\udc34',
  'horse_racing':'\ud83c\udfc7',
  'hospital':'\ud83c\udfe5',
  'hot_pepper':'\ud83c\udf36',
  'hotdog':'\ud83c\udf2d',
  'hotel':'\ud83c\udfe8',
  'hotsprings':'\u2668\ufe0f',
  'hourglass':'\u231b\ufe0f',
  'hourglass_flowing_sand':'\u23f3',
  'house':'\ud83c\udfe0',
  'house_with_garden':'\ud83c\udfe1',
  'houses':'\ud83c\udfd8',
  'hugs':'\ud83e\udd17',
  'hushed':'\ud83d\ude2f',
  'ice_cream':'\ud83c\udf68',
  'ice_hockey':'\ud83c\udfd2',
  'ice_skate':'\u26f8',
  'icecream':'\ud83c\udf66',
  'id':'\ud83c\udd94',
  'ideograph_advantage':'\ud83c\ude50',
  'imp':'\ud83d\udc7f',
  'inbox_tray':'\ud83d\udce5',
  'incoming_envelope':'\ud83d\udce8',
  'tipping_hand_woman':'\ud83d\udc81',
  'information_source':'\u2139\ufe0f',
  'innocent':'\ud83d\ude07',
  'interrobang':'\u2049\ufe0f',
  'iphone':'\ud83d\udcf1',
  'izakaya_lantern':'\ud83c\udfee',
  'jack_o_lantern':'\ud83c\udf83',
  'japan':'\ud83d\uddfe',
  'japanese_castle':'\ud83c\udfef',
  'japanese_goblin':'\ud83d\udc7a',
  'japanese_ogre':'\ud83d\udc79',
  'jeans':'\ud83d\udc56',
  'joy':'\ud83d\ude02',
  'joy_cat':'\ud83d\ude39',
  'joystick':'\ud83d\udd79',
  'kaaba':'\ud83d\udd4b',
  'key':'\ud83d\udd11',
  'keyboard':'\u2328\ufe0f',
  'keycap_ten':'\ud83d\udd1f',
  'kick_scooter':'\ud83d\udef4',
  'kimono':'\ud83d\udc58',
  'kiss':'\ud83d\udc8b',
  'kissing':'\ud83d\ude17',
  'kissing_cat':'\ud83d\ude3d',
  'kissing_closed_eyes':'\ud83d\ude1a',
  'kissing_heart':'\ud83d\ude18',
  'kissing_smiling_eyes':'\ud83d\ude19',
  'kiwi_fruit':'\ud83e\udd5d',
  'koala':'\ud83d\udc28',
  'koko':'\ud83c\ude01',
  'label':'\ud83c\udff7',
  'large_blue_circle':'\ud83d\udd35',
  'large_blue_diamond':'\ud83d\udd37',
  'large_orange_diamond':'\ud83d\udd36',
  'last_quarter_moon':'\ud83c\udf17',
  'last_quarter_moon_with_face':'\ud83c\udf1c',
  'latin_cross':'\u271d\ufe0f',
  'laughing':'\ud83d\ude06',
  'leaves':'\ud83c\udf43',
  'ledger':'\ud83d\udcd2',
  'left_luggage':'\ud83d\udec5',
  'left_right_arrow':'\u2194\ufe0f',
  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
  'lemon':'\ud83c\udf4b',
  'leo':'\u264c\ufe0f',
  'leopard':'\ud83d\udc06',
  'level_slider':'\ud83c\udf9a',
  'libra':'\u264e\ufe0f',
  'light_rail':'\ud83d\ude88',
  'link':'\ud83d\udd17',
  'lion':'\ud83e\udd81',
  'lips':'\ud83d\udc44',
  'lipstick':'\ud83d\udc84',
  'lizard':'\ud83e\udd8e',
  'lock':'\ud83d\udd12',
  'lock_with_ink_pen':'\ud83d\udd0f',
  'lollipop':'\ud83c\udf6d',
  'loop':'\u27bf',
  'loud_sound':'\ud83d\udd0a',
  'loudspeaker':'\ud83d\udce2',
  'love_hotel':'\ud83c\udfe9',
  'love_letter':'\ud83d\udc8c',
  'low_brightness':'\ud83d\udd05',
  'lying_face':'\ud83e\udd25',
  'm':'\u24c2\ufe0f',
  'mag':'\ud83d\udd0d',
  'mag_right':'\ud83d\udd0e',
  'mahjong':'\ud83c\udc04\ufe0f',
  'mailbox':'\ud83d\udceb',
  'mailbox_closed':'\ud83d\udcea',
  'mailbox_with_mail':'\ud83d\udcec',
  'mailbox_with_no_mail':'\ud83d\udced',
  'man':'\ud83d\udc68',
  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
  'man_dancing':'\ud83d\udd7a',
  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
  'man_in_tuxedo':'\ud83e\udd35',
  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
  'man_with_gua_pi_mao':'\ud83d\udc72',
  'man_with_turban':'\ud83d\udc73',
  'tangerine':'\ud83c\udf4a',
  'mans_shoe':'\ud83d\udc5e',
  'mantelpiece_clock':'\ud83d\udd70',
  'maple_leaf':'\ud83c\udf41',
  'martial_arts_uniform':'\ud83e\udd4b',
  'mask':'\ud83d\ude37',
  'massage_woman':'\ud83d\udc86',
  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
  'meat_on_bone':'\ud83c\udf56',
  'medal_military':'\ud83c\udf96',
  'medal_sports':'\ud83c\udfc5',
  'mega':'\ud83d\udce3',
  'melon':'\ud83c\udf48',
  'memo':'\ud83d\udcdd',
  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
  'menorah':'\ud83d\udd4e',
  'mens':'\ud83d\udeb9',
  'metal':'\ud83e\udd18',
  'metro':'\ud83d\ude87',
  'microphone':'\ud83c\udfa4',
  'microscope':'\ud83d\udd2c',
  'milk_glass':'\ud83e\udd5b',
  'milky_way':'\ud83c\udf0c',
  'minibus':'\ud83d\ude90',
  'minidisc':'\ud83d\udcbd',
  'mobile_phone_off':'\ud83d\udcf4',
  'money_mouth_face':'\ud83e\udd11',
  'money_with_wings':'\ud83d\udcb8',
  'moneybag':'\ud83d\udcb0',
  'monkey':'\ud83d\udc12',
  'monkey_face':'\ud83d\udc35',
  'monorail':'\ud83d\ude9d',
  'moon':'\ud83c\udf14',
  'mortar_board':'\ud83c\udf93',
  'mosque':'\ud83d\udd4c',
  'motor_boat':'\ud83d\udee5',
  'motor_scooter':'\ud83d\udef5',
  'motorcycle':'\ud83c\udfcd',
  'motorway':'\ud83d\udee3',
  'mount_fuji':'\ud83d\uddfb',
  'mountain':'\u26f0',
  'mountain_biking_man':'\ud83d\udeb5',
  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
  'mountain_cableway':'\ud83d\udea0',
  'mountain_railway':'\ud83d\ude9e',
  'mountain_snow':'\ud83c\udfd4',
  'mouse':'\ud83d\udc2d',
  'mouse2':'\ud83d\udc01',
  'movie_camera':'\ud83c\udfa5',
  'moyai':'\ud83d\uddff',
  'mrs_claus':'\ud83e\udd36',
  'muscle':'\ud83d\udcaa',
  'mushroom':'\ud83c\udf44',
  'musical_keyboard':'\ud83c\udfb9',
  'musical_note':'\ud83c\udfb5',
  'musical_score':'\ud83c\udfbc',
  'mute':'\ud83d\udd07',
  'nail_care':'\ud83d\udc85',
  'name_badge':'\ud83d\udcdb',
  'national_park':'\ud83c\udfde',
  'nauseated_face':'\ud83e\udd22',
  'necktie':'\ud83d\udc54',
  'negative_squared_cross_mark':'\u274e',
  'nerd_face':'\ud83e\udd13',
  'neutral_face':'\ud83d\ude10',
  'new':'\ud83c\udd95',
  'new_moon':'\ud83c\udf11',
  'new_moon_with_face':'\ud83c\udf1a',
  'newspaper':'\ud83d\udcf0',
  'newspaper_roll':'\ud83d\uddde',
  'next_track_button':'\u23ed',
  'ng':'\ud83c\udd96',
  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
  'no_good_woman':'\ud83d\ude45',
  'night_with_stars':'\ud83c\udf03',
  'no_bell':'\ud83d\udd15',
  'no_bicycles':'\ud83d\udeb3',
  'no_entry':'\u26d4\ufe0f',
  'no_entry_sign':'\ud83d\udeab',
  'no_mobile_phones':'\ud83d\udcf5',
  'no_mouth':'\ud83d\ude36',
  'no_pedestrians':'\ud83d\udeb7',
  'no_smoking':'\ud83d\udead',
  'non-potable_water':'\ud83d\udeb1',
  'nose':'\ud83d\udc43',
  'notebook':'\ud83d\udcd3',
  'notebook_with_decorative_cover':'\ud83d\udcd4',
  'notes':'\ud83c\udfb6',
  'nut_and_bolt':'\ud83d\udd29',
  'o':'\u2b55\ufe0f',
  'o2':'\ud83c\udd7e\ufe0f',
  'ocean':'\ud83c\udf0a',
  'octopus':'\ud83d\udc19',
  'oden':'\ud83c\udf62',
  'office':'\ud83c\udfe2',
  'oil_drum':'\ud83d\udee2',
  'ok':'\ud83c\udd97',
  'ok_hand':'\ud83d\udc4c',
  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
  'ok_woman':'\ud83d\ude46',
  'old_key':'\ud83d\udddd',
  'older_man':'\ud83d\udc74',
  'older_woman':'\ud83d\udc75',
  'om':'\ud83d\udd49',
  'on':'\ud83d\udd1b',
  'oncoming_automobile':'\ud83d\ude98',
  'oncoming_bus':'\ud83d\ude8d',
  'oncoming_police_car':'\ud83d\ude94',
  'oncoming_taxi':'\ud83d\ude96',
  'open_file_folder':'\ud83d\udcc2',
  'open_hands':'\ud83d\udc50',
  'open_mouth':'\ud83d\ude2e',
  'open_umbrella':'\u2602\ufe0f',
  'ophiuchus':'\u26ce',
  'orange_book':'\ud83d\udcd9',
  'orthodox_cross':'\u2626\ufe0f',
  'outbox_tray':'\ud83d\udce4',
  'owl':'\ud83e\udd89',
  'ox':'\ud83d\udc02',
  'package':'\ud83d\udce6',
  'page_facing_up':'\ud83d\udcc4',
  'page_with_curl':'\ud83d\udcc3',
  'pager':'\ud83d\udcdf',
  'paintbrush':'\ud83d\udd8c',
  'palm_tree':'\ud83c\udf34',
  'pancakes':'\ud83e\udd5e',
  'panda_face':'\ud83d\udc3c',
  'paperclip':'\ud83d\udcce',
  'paperclips':'\ud83d\udd87',
  'parasol_on_ground':'\u26f1',
  'parking':'\ud83c\udd7f\ufe0f',
  'part_alternation_mark':'\u303d\ufe0f',
  'partly_sunny':'\u26c5\ufe0f',
  'passenger_ship':'\ud83d\udef3',
  'passport_control':'\ud83d\udec2',
  'pause_button':'\u23f8',
  'peace_symbol':'\u262e\ufe0f',
  'peach':'\ud83c\udf51',
  'peanuts':'\ud83e\udd5c',
  'pear':'\ud83c\udf50',
  'pen':'\ud83d\udd8a',
  'pencil2':'\u270f\ufe0f',
  'penguin':'\ud83d\udc27',
  'pensive':'\ud83d\ude14',
  'performing_arts':'\ud83c\udfad',
  'persevere':'\ud83d\ude23',
  'person_fencing':'\ud83e\udd3a',
  'pouting_woman':'\ud83d\ude4e',
  'phone':'\u260e\ufe0f',
  'pick':'\u26cf',
  'pig':'\ud83d\udc37',
  'pig2':'\ud83d\udc16',
  'pig_nose':'\ud83d\udc3d',
  'pill':'\ud83d\udc8a',
  'pineapple':'\ud83c\udf4d',
  'ping_pong':'\ud83c\udfd3',
  'pisces':'\u2653\ufe0f',
  'pizza':'\ud83c\udf55',
  'place_of_worship':'\ud83d\uded0',
  'plate_with_cutlery':'\ud83c\udf7d',
  'play_or_pause_button':'\u23ef',
  'point_down':'\ud83d\udc47',
  'point_left':'\ud83d\udc48',
  'point_right':'\ud83d\udc49',
  'point_up':'\u261d\ufe0f',
  'point_up_2':'\ud83d\udc46',
  'police_car':'\ud83d\ude93',
  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
  'poodle':'\ud83d\udc29',
  'popcorn':'\ud83c\udf7f',
  'post_office':'\ud83c\udfe3',
  'postal_horn':'\ud83d\udcef',
  'postbox':'\ud83d\udcee',
  'potable_water':'\ud83d\udeb0',
  'potato':'\ud83e\udd54',
  'pouch':'\ud83d\udc5d',
  'poultry_leg':'\ud83c\udf57',
  'pound':'\ud83d\udcb7',
  'rage':'\ud83d\ude21',
  'pouting_cat':'\ud83d\ude3e',
  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
  'pray':'\ud83d\ude4f',
  'prayer_beads':'\ud83d\udcff',
  'pregnant_woman':'\ud83e\udd30',
  'previous_track_button':'\u23ee',
  'prince':'\ud83e\udd34',
  'princess':'\ud83d\udc78',
  'printer':'\ud83d\udda8',
  'purple_heart':'\ud83d\udc9c',
  'purse':'\ud83d\udc5b',
  'pushpin':'\ud83d\udccc',
  'put_litter_in_its_place':'\ud83d\udeae',
  'question':'\u2753',
  'rabbit':'\ud83d\udc30',
  'rabbit2':'\ud83d\udc07',
  'racehorse':'\ud83d\udc0e',
  'racing_car':'\ud83c\udfce',
  'radio':'\ud83d\udcfb',
  'radio_button':'\ud83d\udd18',
  'radioactive':'\u2622\ufe0f',
  'railway_car':'\ud83d\ude83',
  'railway_track':'\ud83d\udee4',
  'rainbow':'\ud83c\udf08',
  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
  'raised_back_of_hand':'\ud83e\udd1a',
  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
  'raised_hands':'\ud83d\ude4c',
  'raising_hand_woman':'\ud83d\ude4b',
  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
  'ram':'\ud83d\udc0f',
  'ramen':'\ud83c\udf5c',
  'rat':'\ud83d\udc00',
  'record_button':'\u23fa',
  'recycle':'\u267b\ufe0f',
  'red_circle':'\ud83d\udd34',
  'registered':'\u00ae\ufe0f',
  'relaxed':'\u263a\ufe0f',
  'relieved':'\ud83d\ude0c',
  'reminder_ribbon':'\ud83c\udf97',
  'repeat':'\ud83d\udd01',
  'repeat_one':'\ud83d\udd02',
  'rescue_worker_helmet':'\u26d1',
  'restroom':'\ud83d\udebb',
  'revolving_hearts':'\ud83d\udc9e',
  'rewind':'\u23ea',
  'rhinoceros':'\ud83e\udd8f',
  'ribbon':'\ud83c\udf80',
  'rice':'\ud83c\udf5a',
  'rice_ball':'\ud83c\udf59',
  'rice_cracker':'\ud83c\udf58',
  'rice_scene':'\ud83c\udf91',
  'right_anger_bubble':'\ud83d\uddef',
  'ring':'\ud83d\udc8d',
  'robot':'\ud83e\udd16',
  'rocket':'\ud83d\ude80',
  'rofl':'\ud83e\udd23',
  'roll_eyes':'\ud83d\ude44',
  'roller_coaster':'\ud83c\udfa2',
  'rooster':'\ud83d\udc13',
  'rose':'\ud83c\udf39',
  'rosette':'\ud83c\udff5',
  'rotating_light':'\ud83d\udea8',
  'round_pushpin':'\ud83d\udccd',
  'rowing_man':'\ud83d\udea3',
  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
  'rugby_football':'\ud83c\udfc9',
  'running_man':'\ud83c\udfc3',
  'running_shirt_with_sash':'\ud83c\udfbd',
  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
  'sa':'\ud83c\ude02\ufe0f',
  'sagittarius':'\u2650\ufe0f',
  'sake':'\ud83c\udf76',
  'sandal':'\ud83d\udc61',
  'santa':'\ud83c\udf85',
  'satellite':'\ud83d\udce1',
  'saxophone':'\ud83c\udfb7',
  'school':'\ud83c\udfeb',
  'school_satchel':'\ud83c\udf92',
  'scissors':'\u2702\ufe0f',
  'scorpion':'\ud83e\udd82',
  'scorpius':'\u264f\ufe0f',
  'scream':'\ud83d\ude31',
  'scream_cat':'\ud83d\ude40',
  'scroll':'\ud83d\udcdc',
  'seat':'\ud83d\udcba',
  'secret':'\u3299\ufe0f',
  'see_no_evil':'\ud83d\ude48',
  'seedling':'\ud83c\udf31',
  'selfie':'\ud83e\udd33',
  'shallow_pan_of_food':'\ud83e\udd58',
  'shamrock':'\u2618\ufe0f',
  'shark':'\ud83e\udd88',
  'shaved_ice':'\ud83c\udf67',
  'sheep':'\ud83d\udc11',
  'shell':'\ud83d\udc1a',
  'shield':'\ud83d\udee1',
  'shinto_shrine':'\u26e9',
  'ship':'\ud83d\udea2',
  'shirt':'\ud83d\udc55',
  'shopping':'\ud83d\udecd',
  'shopping_cart':'\ud83d\uded2',
  'shower':'\ud83d\udebf',
  'shrimp':'\ud83e\udd90',
  'signal_strength':'\ud83d\udcf6',
  'six_pointed_star':'\ud83d\udd2f',
  'ski':'\ud83c\udfbf',
  'skier':'\u26f7',
  'skull':'\ud83d\udc80',
  'skull_and_crossbones':'\u2620\ufe0f',
  'sleeping':'\ud83d\ude34',
  'sleeping_bed':'\ud83d\udecc',
  'sleepy':'\ud83d\ude2a',
  'slightly_frowning_face':'\ud83d\ude41',
  'slightly_smiling_face':'\ud83d\ude42',
  'slot_machine':'\ud83c\udfb0',
  'small_airplane':'\ud83d\udee9',
  'small_blue_diamond':'\ud83d\udd39',
  'small_orange_diamond':'\ud83d\udd38',
  'small_red_triangle':'\ud83d\udd3a',
  'small_red_triangle_down':'\ud83d\udd3b',
  'smile':'\ud83d\ude04',
  'smile_cat':'\ud83d\ude38',
  'smiley':'\ud83d\ude03',
  'smiley_cat':'\ud83d\ude3a',
  'smiling_imp':'\ud83d\ude08',
  'smirk':'\ud83d\ude0f',
  'smirk_cat':'\ud83d\ude3c',
  'smoking':'\ud83d\udeac',
  'snail':'\ud83d\udc0c',
  'snake':'\ud83d\udc0d',
  'sneezing_face':'\ud83e\udd27',
  'snowboarder':'\ud83c\udfc2',
  'snowflake':'\u2744\ufe0f',
  'snowman':'\u26c4\ufe0f',
  'snowman_with_snow':'\u2603\ufe0f',
  'sob':'\ud83d\ude2d',
  'soccer':'\u26bd\ufe0f',
  'soon':'\ud83d\udd1c',
  'sos':'\ud83c\udd98',
  'sound':'\ud83d\udd09',
  'space_invader':'\ud83d\udc7e',
  'spades':'\u2660\ufe0f',
  'spaghetti':'\ud83c\udf5d',
  'sparkle':'\u2747\ufe0f',
  'sparkler':'\ud83c\udf87',
  'sparkles':'\u2728',
  'sparkling_heart':'\ud83d\udc96',
  'speak_no_evil':'\ud83d\ude4a',
  'speaker':'\ud83d\udd08',
  'speaking_head':'\ud83d\udde3',
  'speech_balloon':'\ud83d\udcac',
  'speedboat':'\ud83d\udea4',
  'spider':'\ud83d\udd77',
  'spider_web':'\ud83d\udd78',
  'spiral_calendar':'\ud83d\uddd3',
  'spiral_notepad':'\ud83d\uddd2',
  'spoon':'\ud83e\udd44',
  'squid':'\ud83e\udd91',
  'stadium':'\ud83c\udfdf',
  'star':'\u2b50\ufe0f',
  'star2':'\ud83c\udf1f',
  'star_and_crescent':'\u262a\ufe0f',
  'star_of_david':'\u2721\ufe0f',
  'stars':'\ud83c\udf20',
  'station':'\ud83d\ude89',
  'statue_of_liberty':'\ud83d\uddfd',
  'steam_locomotive':'\ud83d\ude82',
  'stew':'\ud83c\udf72',
  'stop_button':'\u23f9',
  'stop_sign':'\ud83d\uded1',
  'stopwatch':'\u23f1',
  'straight_ruler':'\ud83d\udccf',
  'strawberry':'\ud83c\udf53',
  'stuck_out_tongue':'\ud83d\ude1b',
  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
  'studio_microphone':'\ud83c\udf99',
  'stuffed_flatbread':'\ud83e\udd59',
  'sun_behind_large_cloud':'\ud83c\udf25',
  'sun_behind_rain_cloud':'\ud83c\udf26',
  'sun_behind_small_cloud':'\ud83c\udf24',
  'sun_with_face':'\ud83c\udf1e',
  'sunflower':'\ud83c\udf3b',
  'sunglasses':'\ud83d\ude0e',
  'sunny':'\u2600\ufe0f',
  'sunrise':'\ud83c\udf05',
  'sunrise_over_mountains':'\ud83c\udf04',
  'surfing_man':'\ud83c\udfc4',
  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
  'sushi':'\ud83c\udf63',
  'suspension_railway':'\ud83d\ude9f',
  'sweat':'\ud83d\ude13',
  'sweat_drops':'\ud83d\udca6',
  'sweat_smile':'\ud83d\ude05',
  'sweet_potato':'\ud83c\udf60',
  'swimming_man':'\ud83c\udfca',
  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
  'symbols':'\ud83d\udd23',
  'synagogue':'\ud83d\udd4d',
  'syringe':'\ud83d\udc89',
  'taco':'\ud83c\udf2e',
  'tada':'\ud83c\udf89',
  'tanabata_tree':'\ud83c\udf8b',
  'taurus':'\u2649\ufe0f',
  'taxi':'\ud83d\ude95',
  'tea':'\ud83c\udf75',
  'telephone_receiver':'\ud83d\udcde',
  'telescope':'\ud83d\udd2d',
  'tennis':'\ud83c\udfbe',
  'tent':'\u26fa\ufe0f',
  'thermometer':'\ud83c\udf21',
  'thinking':'\ud83e\udd14',
  'thought_balloon':'\ud83d\udcad',
  'ticket':'\ud83c\udfab',
  'tickets':'\ud83c\udf9f',
  'tiger':'\ud83d\udc2f',
  'tiger2':'\ud83d\udc05',
  'timer_clock':'\u23f2',
  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
  'tired_face':'\ud83d\ude2b',
  'tm':'\u2122\ufe0f',
  'toilet':'\ud83d\udebd',
  'tokyo_tower':'\ud83d\uddfc',
  'tomato':'\ud83c\udf45',
  'tongue':'\ud83d\udc45',
  'top':'\ud83d\udd1d',
  'tophat':'\ud83c\udfa9',
  'tornado':'\ud83c\udf2a',
  'trackball':'\ud83d\uddb2',
  'tractor':'\ud83d\ude9c',
  'traffic_light':'\ud83d\udea5',
  'train':'\ud83d\ude8b',
  'train2':'\ud83d\ude86',
  'tram':'\ud83d\ude8a',
  'triangular_flag_on_post':'\ud83d\udea9',
  'triangular_ruler':'\ud83d\udcd0',
  'trident':'\ud83d\udd31',
  'triumph':'\ud83d\ude24',
  'trolleybus':'\ud83d\ude8e',
  'trophy':'\ud83c\udfc6',
  'tropical_drink':'\ud83c\udf79',
  'tropical_fish':'\ud83d\udc20',
  'truck':'\ud83d\ude9a',
  'trumpet':'\ud83c\udfba',
  'tulip':'\ud83c\udf37',
  'tumbler_glass':'\ud83e\udd43',
  'turkey':'\ud83e\udd83',
  'turtle':'\ud83d\udc22',
  'tv':'\ud83d\udcfa',
  'twisted_rightwards_arrows':'\ud83d\udd00',
  'two_hearts':'\ud83d\udc95',
  'two_men_holding_hands':'\ud83d\udc6c',
  'two_women_holding_hands':'\ud83d\udc6d',
  'u5272':'\ud83c\ude39',
  'u5408':'\ud83c\ude34',
  'u55b6':'\ud83c\ude3a',
  'u6307':'\ud83c\ude2f\ufe0f',
  'u6708':'\ud83c\ude37\ufe0f',
  'u6709':'\ud83c\ude36',
  'u6e80':'\ud83c\ude35',
  'u7121':'\ud83c\ude1a\ufe0f',
  'u7533':'\ud83c\ude38',
  'u7981':'\ud83c\ude32',
  'u7a7a':'\ud83c\ude33',
  'umbrella':'\u2614\ufe0f',
  'unamused':'\ud83d\ude12',
  'underage':'\ud83d\udd1e',
  'unicorn':'\ud83e\udd84',
  'unlock':'\ud83d\udd13',
  'up':'\ud83c\udd99',
  'upside_down_face':'\ud83d\ude43',
  'v':'\u270c\ufe0f',
  'vertical_traffic_light':'\ud83d\udea6',
  'vhs':'\ud83d\udcfc',
  'vibration_mode':'\ud83d\udcf3',
  'video_camera':'\ud83d\udcf9',
  'video_game':'\ud83c\udfae',
  'violin':'\ud83c\udfbb',
  'virgo':'\u264d\ufe0f',
  'volcano':'\ud83c\udf0b',
  'volleyball':'\ud83c\udfd0',
  'vs':'\ud83c\udd9a',
  'vulcan_salute':'\ud83d\udd96',
  'walking_man':'\ud83d\udeb6',
  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
  'waning_crescent_moon':'\ud83c\udf18',
  'waning_gibbous_moon':'\ud83c\udf16',
  'warning':'\u26a0\ufe0f',
  'wastebasket':'\ud83d\uddd1',
  'watch':'\u231a\ufe0f',
  'water_buffalo':'\ud83d\udc03',
  'watermelon':'\ud83c\udf49',
  'wave':'\ud83d\udc4b',
  'wavy_dash':'\u3030\ufe0f',
  'waxing_crescent_moon':'\ud83c\udf12',
  'wc':'\ud83d\udebe',
  'weary':'\ud83d\ude29',
  'wedding':'\ud83d\udc92',
  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
  'whale':'\ud83d\udc33',
  'whale2':'\ud83d\udc0b',
  'wheel_of_dharma':'\u2638\ufe0f',
  'wheelchair':'\u267f\ufe0f',
  'white_check_mark':'\u2705',
  'white_circle':'\u26aa\ufe0f',
  'white_flag':'\ud83c\udff3\ufe0f',
  'white_flower':'\ud83d\udcae',
  'white_large_square':'\u2b1c\ufe0f',
  'white_medium_small_square':'\u25fd\ufe0f',
  'white_medium_square':'\u25fb\ufe0f',
  'white_small_square':'\u25ab\ufe0f',
  'white_square_button':'\ud83d\udd33',
  'wilted_flower':'\ud83e\udd40',
  'wind_chime':'\ud83c\udf90',
  'wind_face':'\ud83c\udf2c',
  'wine_glass':'\ud83c\udf77',
  'wink':'\ud83d\ude09',
  'wolf':'\ud83d\udc3a',
  'woman':'\ud83d\udc69',
  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
  'womans_clothes':'\ud83d\udc5a',
  'womans_hat':'\ud83d\udc52',
  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
  'womens':'\ud83d\udeba',
  'world_map':'\ud83d\uddfa',
  'worried':'\ud83d\ude1f',
  'wrench':'\ud83d\udd27',
  'writing_hand':'\u270d\ufe0f',
  'x':'\u274c',
  'yellow_heart':'\ud83d\udc9b',
  'yen':'\ud83d\udcb4',
  'yin_yang':'\u262f\ufe0f',
  'yum':'\ud83d\ude0b',
  'zap':'\u26a1\ufe0f',
  'zipper_mouth_face':'\ud83e\udd10',
  'zzz':'\ud83d\udca4',

  /* special emojis :P */
  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
};

/**
 * Created by Estevao on 31-05-2015.
 */

/**
 * Showdown Converter class
 * @class
 * @param {object} [converterOptions]
 * @returns {Converter}
 */
showdown.Converter = function (converterOptions) {
  'use strict';

  var
      /**
       * Options used by this converter
       * @private
       * @type {{}}
       */
      options = {},

      /**
       * Language extensions used by this converter
       * @private
       * @type {Array}
       */
      langExtensions = [],

      /**
       * Output modifiers extensions used by this converter
       * @private
       * @type {Array}
       */
      outputModifiers = [],

      /**
       * Event listeners
       * @private
       * @type {{}}
       */
      listeners = {},

      /**
       * The flavor set in this converter
       */
      setConvFlavor = setFlavor,

      /**
       * Metadata of the document
       * @type {{parsed: {}, raw: string, format: string}}
       */
      metadata = {
        parsed: {},
        raw: '',
        format: ''
      };

  _constructor();

  /**
   * Converter constructor
   * @private
   */
  function _constructor () {
    converterOptions = converterOptions || {};

    for (var gOpt in globalOptions) {
      if (globalOptions.hasOwnProperty(gOpt)) {
        options[gOpt] = globalOptions[gOpt];
      }
    }

    // Merge options
    if (typeof converterOptions === 'object') {
      for (var opt in converterOptions) {
        if (converterOptions.hasOwnProperty(opt)) {
          options[opt] = converterOptions[opt];
        }
      }
    } else {
      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
      ' was passed instead.');
    }

    if (options.extensions) {
      showdown.helper.forEach(options.extensions, _parseExtension);
    }
  }

  /**
   * Parse extension
   * @param {*} ext
   * @param {string} [name='']
   * @private
   */
  function _parseExtension (ext, name) {

    name = name || null;
    // If it's a string, the extension was previously loaded
    if (showdown.helper.isString(ext)) {
      ext = showdown.helper.stdExtName(ext);
      name = ext;

      // LEGACY_SUPPORT CODE
      if (showdown.extensions[ext]) {
        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
          'Please inform the developer that the extension should be updated!');
        legacyExtensionLoading(showdown.extensions[ext], ext);
        return;
        // END LEGACY SUPPORT CODE

      } else if (!showdown.helper.isUndefined(extensions[ext])) {
        ext = extensions[ext];

      } else {
        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
      }
    }

    if (typeof ext === 'function') {
      ext = ext();
    }

    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }

    var validExt = validate(ext, name);
    if (!validExt.valid) {
      throw Error(validExt.error);
    }

    for (var i = 0; i < ext.length; ++i) {
      switch (ext[i].type) {

        case 'lang':
          langExtensions.push(ext[i]);
          break;

        case 'output':
          outputModifiers.push(ext[i]);
          break;
      }
      if (ext[i].hasOwnProperty('listeners')) {
        for (var ln in ext[i].listeners) {
          if (ext[i].listeners.hasOwnProperty(ln)) {
            listen(ln, ext[i].listeners[ln]);
          }
        }
      }
    }

  }

  /**
   * LEGACY_SUPPORT
   * @param {*} ext
   * @param {string} name
   */
  function legacyExtensionLoading (ext, name) {
    if (typeof ext === 'function') {
      ext = ext(new showdown.Converter());
    }
    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }
    var valid = validate(ext, name);

    if (!valid.valid) {
      throw Error(valid.error);
    }

    for (var i = 0; i < ext.length; ++i) {
      switch (ext[i].type) {
        case 'lang':
          langExtensions.push(ext[i]);
          break;
        case 'output':
          outputModifiers.push(ext[i]);
          break;
        default:// should never reach here
          throw Error('Extension loader error: Type unrecognized!!!');
      }
    }
  }

  /**
   * Listen to an event
   * @param {string} name
   * @param {function} callback
   */
  function listen (name, callback) {
    if (!showdown.helper.isString(name)) {
      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
    }

    if (typeof callback !== 'function') {
      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
    }

    if (!listeners.hasOwnProperty(name)) {
      listeners[name] = [];
    }
    listeners[name].push(callback);
  }

  function rTrimInputText (text) {
    var rsp = text.match(/^\s*/)[0].length,
        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
    return text.replace(rgx, '');
  }

  /**
   * Dispatch an event
   * @private
   * @param {string} evtName Event name
   * @param {string} text Text
   * @param {{}} options Converter Options
   * @param {{}} globals
   * @returns {string}
   */
  this._dispatch = function dispatch (evtName, text, options, globals) {
    if (listeners.hasOwnProperty(evtName)) {
      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
        if (nText && typeof nText !== 'undefined') {
          text = nText;
        }
      }
    }
    return text;
  };

  /**
   * Listen to an event
   * @param {string} name
   * @param {function} callback
   * @returns {showdown.Converter}
   */
  this.listen = function (name, callback) {
    listen(name, callback);
    return this;
  };

  /**
   * Converts a markdown string into HTML
   * @param {string} text
   * @returns {*}
   */
  this.makeHtml = function (text) {
    //check if text is not falsy
    if (!text) {
      return text;
    }

    var globals = {
      gHtmlBlocks:     [],
      gHtmlMdBlocks:   [],
      gHtmlSpans:      [],
      gUrls:           {},
      gTitles:         {},
      gDimensions:     {},
      gListLevel:      0,
      hashLinkCounts:  {},
      langExtensions:  langExtensions,
      outputModifiers: outputModifiers,
      converter:       this,
      ghCodeBlocks:    [],
      metadata: {
        parsed: {},
        raw: '',
        format: ''
      }
    };

    // This lets us use ¨ trema as an escape char to avoid md5 hashes
    // The choice of character is arbitrary; anything that isn't
    // magic in Markdown will work.
    text = text.replace(/¨/g, '¨T');

    // Replace $ with ¨D
    // RegExp interprets $ as a special character
    // when it's in a replacement string
    text = text.replace(/\$/g, '¨D');

    // Standardize line endings
    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
    text = text.replace(/\r/g, '\n'); // Mac to Unix

    // Stardardize line spaces
    text = text.replace(/\u00A0/g, '&nbsp;');

    if (options.smartIndentationFix) {
      text = rTrimInputText(text);
    }

    // Make sure text begins and ends with a couple of newlines:
    text = '\n\n' + text + '\n\n';

    // detab
    text = showdown.subParser('detab')(text, options, globals);

    /**
     * Strip any lines consisting only of spaces and tabs.
     * This makes subsequent regexs easier to write, because we can
     * match consecutive blank lines with /\n+/ instead of something
     * contorted like /[ \t]*\n+/
     */
    text = text.replace(/^[ \t]+$/mg, '');

    //run languageExtensions
    showdown.helper.forEach(langExtensions, function (ext) {
      text = showdown.subParser('runExtension')(ext, text, options, globals);
    });

    // run the sub parsers
    text = showdown.subParser('metadata')(text, options, globals);
    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
    text = showdown.subParser('hashCodeTags')(text, options, globals);
    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
    text = showdown.subParser('blockGamut')(text, options, globals);
    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

    // attacklab: Restore dollar signs
    text = text.replace(/¨D/g, '$$');

    // attacklab: Restore tremas
    text = text.replace(/¨T/g, '¨');

    // render a complete html document instead of a partial if the option is enabled
    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

    // Run output modifiers
    showdown.helper.forEach(outputModifiers, function (ext) {
      text = showdown.subParser('runExtension')(ext, text, options, globals);
    });

    // update metadata
    metadata = globals.metadata;
    return text;
  };

  /**
   * Converts an HTML string into a markdown string
   * @param src
   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
   * @returns {string}
   */
  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

    // replace \r\n with \n
    src = src.replace(/\r\n/g, '\n');
    src = src.replace(/\r/g, '\n'); // old macs

    // due to an edge case, we need to find this: > <
    // to prevent removing of non silent white spaces
    // ex: <em>this is</em> <strong>sparta</strong>
    src = src.replace(/>[ \t]+</, '>¨NBSP;<');

    if (!HTMLParser) {
      if (window && window.document) {
        HTMLParser = window.document;
      } else {
        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
      }
    }

    var doc = HTMLParser.createElement('div');
    doc.innerHTML = src;

    var globals = {
      preList: substitutePreCodeTags(doc)
    };

    // remove all newlines and collapse spaces
    clean(doc);

    // some stuff, like accidental reference links must now be escaped
    // TODO
    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

    var nodes = doc.childNodes,
        mdDoc = '';

    for (var i = 0; i < nodes.length; i++) {
      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
    }

    function clean (node) {
      for (var n = 0; n < node.childNodes.length; ++n) {
        var child = node.childNodes[n];
        if (child.nodeType === 3) {
          if (!/\S/.test(child.nodeValue)) {
            node.removeChild(child);
            --n;
          } else {
            child.nodeValue = child.nodeValue.split('\n').join(' ');
            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
          }
        } else if (child.nodeType === 1) {
          clean(child);
        }
      }
    }

    // find all pre tags and replace contents with placeholder
    // we need this so that we can remove all indentation from html
    // to ease up parsing
    function substitutePreCodeTags (doc) {

      var pres = doc.querySelectorAll('pre'),
          presPH = [];

      for (var i = 0; i < pres.length; ++i) {

        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
          var content = pres[i].firstChild.innerHTML.trim(),
              language = pres[i].firstChild.getAttribute('data-language') || '';

          // if data-language attribute is not defined, then we look for class language-*
          if (language === '') {
            var classes = pres[i].firstChild.className.split(' ');
            for (var c = 0; c < classes.length; ++c) {
              var matches = classes[c].match(/^language-(.+)$/);
              if (matches !== null) {
                language = matches[1];
                break;
              }
            }
          }

          // unescape html entities in content
          content = showdown.helper.unescapeHTMLEntities(content);

          presPH.push(content);
          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
        } else {
          presPH.push(pres[i].innerHTML);
          pres[i].innerHTML = '';
          pres[i].setAttribute('prenum', i.toString());
        }
      }
      return presPH;
    }

    return mdDoc;
  };

  /**
   * Set an option of this Converter instance
   * @param {string} key
   * @param {*} value
   */
  this.setOption = function (key, value) {
    options[key] = value;
  };

  /**
   * Get the option of this Converter instance
   * @param {string} key
   * @returns {*}
   */
  this.getOption = function (key) {
    return options[key];
  };

  /**
   * Get the options of this Converter instance
   * @returns {{}}
   */
  this.getOptions = function () {
    return options;
  };

  /**
   * Add extension to THIS converter
   * @param {{}} extension
   * @param {string} [name=null]
   */
  this.addExtension = function (extension, name) {
    name = name || null;
    _parseExtension(extension, name);
  };

  /**
   * Use a global registered extension with THIS converter
   * @param {string} extensionName Name of the previously registered extension
   */
  this.useExtension = function (extensionName) {
    _parseExtension(extensionName);
  };

  /**
   * Set the flavor THIS converter should use
   * @param {string} name
   */
  this.setFlavor = function (name) {
    if (!flavor.hasOwnProperty(name)) {
      throw Error(name + ' flavor was not found');
    }
    var preset = flavor[name];
    setConvFlavor = name;
    for (var option in preset) {
      if (preset.hasOwnProperty(option)) {
        options[option] = preset[option];
      }
    }
  };

  /**
   * Get the currently set flavor of this converter
   * @returns {string}
   */
  this.getFlavor = function () {
    return setConvFlavor;
  };

  /**
   * Remove an extension from THIS converter.
   * Note: This is a costly operation. It's better to initialize a new converter
   * and specify the extensions you wish to use
   * @param {Array} extension
   */
  this.removeExtension = function (extension) {
    if (!showdown.helper.isArray(extension)) {
      extension = [extension];
    }
    for (var a = 0; a < extension.length; ++a) {
      var ext = extension[a];
      for (var i = 0; i < langExtensions.length; ++i) {
        if (langExtensions[i] === ext) {
          langExtensions[i].splice(i, 1);
        }
      }
      for (var ii = 0; ii < outputModifiers.length; ++i) {
        if (outputModifiers[ii] === ext) {
          outputModifiers[ii].splice(i, 1);
        }
      }
    }
  };

  /**
   * Get all extension of THIS converter
   * @returns {{language: Array, output: Array}}
   */
  this.getAllExtensions = function () {
    return {
      language: langExtensions,
      output: outputModifiers
    };
  };

  /**
   * Get the metadata of the previously parsed document
   * @param raw
   * @returns {string|{}}
   */
  this.getMetadata = function (raw) {
    if (raw) {
      return metadata.raw;
    } else {
      return metadata.parsed;
    }
  };

  /**
   * Get the metadata format of the previously parsed document
   * @returns {string}
   */
  this.getMetadataFormat = function () {
    return metadata.format;
  };

  /**
   * Private: set a single key, value metadata pair
   * @param {string} key
   * @param {string} value
   */
  this._setMetadataPair = function (key, value) {
    metadata.parsed[key] = value;
  };

  /**
   * Private: set metadata format
   * @param {string} format
   */
  this._setMetadataFormat = function (format) {
    metadata.format = format;
  };

  /**
   * Private: set metadata raw text
   * @param {string} raw
   */
  this._setMetadataRaw = function (raw) {
    metadata.raw = raw;
  };
};

/**
 * Turn Markdown link shortcuts into XHTML <a> tags.
 */
showdown.subParser('anchors', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('anchors.before', text, options, globals);

  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
    if (showdown.helper.isUndefined(title)) {
      title = '';
    }
    linkId = linkId.toLowerCase();

    // Special case for explicit empty url
    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
      url = '';
    } else if (!url) {
      if (!linkId) {
        // lower-case and turn embedded newlines into spaces
        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
      }
      url = '#' + linkId;

      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
        url = globals.gUrls[linkId];
        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
          title = globals.gTitles[linkId];
        }
      } else {
        return wholeMatch;
      }
    }

    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

    var result = '<a href="' + url + '"';

    if (title !== '' && title !== null) {
      title = title.replace(/"/g, '&quot;');
      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
      result += ' title="' + title + '"';
    }

    // optionLinksInNewWindow only applies
    // to external links. Hash links (#) open in same page
    if (options.openLinksInNewWindow && !/^#/.test(url)) {
      // escaped _
      result += ' rel="noopener noreferrer" target="¨E95Eblank"';
    }

    result += '>' + linkText + '</a>';

    return result;
  };

  // First, handle reference-style links: [link text] [id]
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

  // Next, inline-style links: [link text](url "optional title")
  // cases with crazy urls like ./image/cat1).png
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
    writeAnchorTag);

  // normal cases
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
    writeAnchorTag);

  // handle reference-style shortcuts: [link text]
  // These must come last in case you've also got [link test][1]
  // or [link test](/foo)
  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

  // Lastly handle GithubMentions if option is enabled
  if (options.ghMentions) {
    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
      if (escape === '\\') {
        return st + mentions;
      }

      //check if options.ghMentionsLink is a string
      if (!showdown.helper.isString(options.ghMentionsLink)) {
        throw new Error('ghMentionsLink option must be a string');
      }
      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
          target = '';
      if (options.openLinksInNewWindow) {
        target = ' rel="noopener noreferrer" target="¨E95Eblank"';
      }
      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
    });
  }

  text = globals.converter._dispatch('anchors.after', text, options, globals);
  return text;
});

// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

    replaceLink = function (options) {
      'use strict';
      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
        var lnkTxt = link,
            append = '',
            target = '',
            lmc    = leadingMagicChars || '',
            tmc    = trailingMagicChars || '';
        if (/^www\./i.test(link)) {
          link = link.replace(/^www\./i, 'http://www.');
        }
        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
          append = trailingPunctuation;
        }
        if (options.openLinksInNewWindow) {
          target = ' rel="noopener noreferrer" target="¨E95Eblank"';
        }
        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
      };
    },

    replaceMail = function (options, globals) {
      'use strict';
      return function (wholeMatch, b, mail) {
        var href = 'mailto:';
        b = b || '';
        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
        if (options.encodeEmails) {
          href = showdown.helper.encodeEmailAddress(href + mail);
          mail = showdown.helper.encodeEmailAddress(mail);
        } else {
          href = href + mail;
        }
        return b + '<a href="' + href + '">' + mail + '</a>';
      };
    };

showdown.subParser('autoLinks', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

  text = text.replace(delimUrlRegex, replaceLink(options));
  text = text.replace(delimMailRegex, replaceMail(options, globals));

  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

  return text;
});

showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {
  'use strict';

  if (!options.simplifiedAutoLink) {
    return text;
  }

  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

  if (options.excludeTrailingPunctuationFromURLs) {
    text = text.replace(simpleURLRegex2, replaceLink(options));
  } else {
    text = text.replace(simpleURLRegex, replaceLink(options));
  }
  text = text.replace(simpleMailRegex, replaceMail(options, globals));

  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

  return text;
});

/**
 * These are all the transformations that form block-level
 * tags like paragraphs, headers, and list items.
 */
showdown.subParser('blockGamut', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

  // we parse blockquotes first so that we can have headings and hrs
  // inside blockquotes
  text = showdown.subParser('blockQuotes')(text, options, globals);
  text = showdown.subParser('headers')(text, options, globals);

  // Do Horizontal Rules:
  text = showdown.subParser('horizontalRule')(text, options, globals);

  text = showdown.subParser('lists')(text, options, globals);
  text = showdown.subParser('codeBlocks')(text, options, globals);
  text = showdown.subParser('tables')(text, options, globals);

  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
  // was to escape raw HTML in the original Markdown source. This time,
  // we're escaping the markup we've just created, so that we don't wrap
  // <p> tags around block-level tags.
  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
  text = showdown.subParser('paragraphs')(text, options, globals);

  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

  return text;
});

showdown.subParser('blockQuotes', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

  // add a couple extra lines after the text and endtext mark
  text = text + '\n\n';

  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

  if (options.splitAdjacentBlockquotes) {
    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
  }

  text = text.replace(rgx, function (bq) {
    // attacklab: hack around Konqueror 3.5.4 bug:
    // "----------bug".replace(/^-/g,"") == "bug"
    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

    // attacklab: clean up hack
    bq = bq.replace(/¨0/g, '');

    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

    bq = bq.replace(/(^|\n)/g, '$1  ');
    // These leading spaces screw with <pre> content, so we need to fix that:
    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
      var pre = m1;
      // attacklab: hack around Konqueror 3.5.4 bug:
      pre = pre.replace(/^  /mg, '¨0');
      pre = pre.replace(/¨0/g, '');
      return pre;
    });

    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
  });

  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
  return text;
});

/**
 * Process Markdown `<pre><code>` blocks.
 */
showdown.subParser('codeBlocks', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
  text += '¨0';

  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
  text = text.replace(pattern, function (wholeMatch, m1, m2) {
    var codeblock = m1,
        nextChar = m2,
        end = '\n';

    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
    codeblock = showdown.subParser('detab')(codeblock, options, globals);
    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

    if (options.omitExtraWLInCodeBlocks) {
      end = '';
    }

    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
  });

  // strip sentinel
  text = text.replace(/¨0/, '');

  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
  return text;
});

/**
 *
 *   *  Backtick quotes are used for <code></code> spans.
 *
 *   *  You can use multiple backticks as the delimiters if you want to
 *     include literal backticks in the code span. So, this input:
 *
 *         Just type ``foo `bar` baz`` at the prompt.
 *
 *       Will translate to:
 *
 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
 *
 *    There's no arbitrary limit to the number of backticks you
 *    can use as delimters. If you need three consecutive backticks
 *    in your code, use four for delimiters, etc.
 *
 *  *  You can use spaces to get literal backticks at the edges:
 *
 *         ... type `` `bar` `` ...
 *
 *       Turns to:
 *
 *         ... type <code>`bar`</code> ...
 */
showdown.subParser('codeSpans', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

  if (typeof text === 'undefined') {
    text = '';
  }
  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
    function (wholeMatch, m1, m2, m3) {
      var c = m3;
      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
      c = showdown.subParser('encodeCode')(c, options, globals);
      c = m1 + '<code>' + c + '</code>';
      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
      return c;
    }
  );

  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
  return text;
});

/**
 * Create a full HTML document from the processed markdown
 */
showdown.subParser('completeHTMLDocument', function (text, options, globals) {
  'use strict';

  if (!options.completeHTMLDocument) {
    return text;
  }

  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

  var doctype = 'html',
      doctypeParsed = '<!DOCTYPE HTML>\n',
      title = '',
      charset = '<meta charset="utf-8">\n',
      lang = '',
      metadata = '';

  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
    if (doctype === 'html' || doctype === 'html5') {
      charset = '<meta charset="utf-8">';
    }
  }

  for (var meta in globals.metadata.parsed) {
    if (globals.metadata.parsed.hasOwnProperty(meta)) {
      switch (meta.toLowerCase()) {
        case 'doctype':
          break;

        case 'title':
          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
          break;

        case 'charset':
          if (doctype === 'html' || doctype === 'html5') {
            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
          } else {
            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
          }
          break;

        case 'language':
        case 'lang':
          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
          break;

        default:
          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
      }
    }
  }

  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
  return text;
});

/**
 * Convert all tabs to spaces
 */
showdown.subParser('detab', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('detab.before', text, options, globals);

  // expand first n-1 tabs
  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

  // replace the nth with two sentinels
  text = text.replace(/\t/g, '¨A¨B');

  // use the sentinel to anchor our regex so it doesn't explode
  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
    var leadingText = m1,
        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

    // there *must* be a better way to do this:
    for (var i = 0; i < numSpaces; i++) {
      leadingText += ' ';
    }

    return leadingText;
  });

  // clean up sentinels
  text = text.replace(/¨A/g, '    ');  // g_tab_width
  text = text.replace(/¨B/g, '');

  text = globals.converter._dispatch('detab.after', text, options, globals);
  return text;
});

showdown.subParser('ellipsis', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

  text = text.replace(/\.\.\./g, '…');

  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

  return text;
});

/**
 * Turn emoji codes into emojis
 *
 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
 */
showdown.subParser('emoji', function (text, options, globals) {
  'use strict';

  if (!options.emoji) {
    return text;
  }

  text = globals.converter._dispatch('emoji.before', text, options, globals);

  var emojiRgx = /:([\S]+?):/g;

  text = text.replace(emojiRgx, function (wm, emojiCode) {
    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
      return showdown.helper.emojis[emojiCode];
    }
    return wm;
  });

  text = globals.converter._dispatch('emoji.after', text, options, globals);

  return text;
});

/**
 * Smart processing for ampersands and angle brackets that need to be encoded.
 */
showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
  // http://bumppo.net/projects/amputator/
  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

  // Encode naked <'s
  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

  // Encode <
  text = text.replace(/</g, '&lt;');

  // Encode >
  text = text.replace(/>/g, '&gt;');

  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
  return text;
});

/**
 * Returns the string, with after processing the following backslash escape sequences.
 *
 * attacklab: The polite way to do this is with the new escapeCharacters() function:
 *
 *    text = escapeCharacters(text,"\\",true);
 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
 *
 * ...but we're sidestepping its use of the (slow) RegExp constructor
 * as an optimization for Firefox.  This function gets called a LOT.
 */
showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
  return text;
});

/**
 * Encode/escape certain characters inside Markdown code runs.
 * The point is that in code, these characters are literals,
 * and lose their special Markdown meanings.
 */
showdown.subParser('encodeCode', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

  // Encode all ampersands; HTML entities are not
  // entities within a Markdown code span.
  text = text
    .replace(/&/g, '&amp;')
  // Do the angle bracket song and dance:
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
  // Now, escape characters that are magic in Markdown:
    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
  return text;
});

/**
 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
 * don't conflict with their use in Markdown for code, italics and strong.
 */
showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

  // Build a regex to find HTML tags.
  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

  text = text.replace(tags, function (wholeMatch) {
    return wholeMatch
      .replace(/(.)<\/?code>(?=.)/g, '$1`')
      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
  });

  text = text.replace(comments, function (wholeMatch) {
    return wholeMatch
      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
  });

  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
  return text;
});

/**
 * Handle github codeblocks prior to running HashHTML so that
 * HTML contained within the codeblock gets escaped properly
 * Example:
 * ```ruby
 *     def hello_world(x)
 *       puts "Hello, #{x}"
 *     end
 * ```
 */
showdown.subParser('githubCodeBlocks', function (text, options, globals) {
  'use strict';

  // early exit if option is not enabled
  if (!options.ghCodeBlocks) {
    return text;
  }

  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

  text += '¨0';

  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

    // First parse the github code block
    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
    codeblock = showdown.subParser('detab')(codeblock, options, globals);
    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

    // Since GHCodeblocks can be false positives, we need to
    // store the primitive text and the parsed text in a global var,
    // and then return a token
    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
  });

  // attacklab: strip sentinel
  text = text.replace(/¨0/, '');

  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
});

showdown.subParser('hashBlock', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
  text = text.replace(/(^\n+|\n+$)/g, '');
  text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
  return text;
});

/**
 * Hash and escape <code> elements that should not be parsed as markdown
 */
showdown.subParser('hashCodeTags', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

  var repFunc = function (wholeMatch, match, left, right) {
    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
  };

  // Hash naked <code>
  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
  return text;
});

showdown.subParser('hashElement', function (text, options, globals) {
  'use strict';

  return function (wholeMatch, m1) {
    var blockText = m1;

    // Undo double lines
    blockText = blockText.replace(/\n\n/g, '\n');
    blockText = blockText.replace(/^\n/, '');

    // strip trailing blank lines
    blockText = blockText.replace(/\n+$/g, '');

    // Replace the element text with a marker ("¨KxK" where x is its key)
    blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

    return blockText;
  };
});

showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

  var blockTags = [
        'pre',
        'div',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'blockquote',
        'table',
        'dl',
        'ol',
        'ul',
        'script',
        'noscript',
        'form',
        'fieldset',
        'iframe',
        'math',
        'style',
        'section',
        'header',
        'footer',
        'nav',
        'article',
        'aside',
        'address',
        'audio',
        'canvas',
        'figure',
        'hgroup',
        'output',
        'video',
        'p'
      ],
      repFunc = function (wholeMatch, match, left, right) {
        var txt = wholeMatch;
        // check if this html element is marked as markdown
        // if so, it's contents should be parsed as markdown
        if (left.search(/\bmarkdown\b/) !== -1) {
          txt = left + globals.converter.makeHtml(match) + right;
        }
        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
      };

  if (options.backslashEscapesHTMLTags) {
    // encode backslash escaped HTML tags
    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
      return '&lt;' + inside + '&gt;';
    });
  }

  // hash HTML Blocks
  for (var i = 0; i < blockTags.length; ++i) {

    var opTagPos,
        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
        patRight = '</' + blockTags[i] + '>';
    // 1. Look for the first position of the first opening HTML tag in the text
    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

      // if the HTML tag is \ escaped, we need to escape it and break


      //2. Split the text in that position
      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
          //3. Match recursively
          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

      // prevent an infinite loop
      if (newSubText1 === subTexts[1]) {
        break;
      }
      text = subTexts[0].concat(newSubText1);
    }
  }
  // HR SPECIAL CASE
  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
    showdown.subParser('hashElement')(text, options, globals));

  // Special case for standalone HTML comments
  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
    return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
  }, '^ {0,3}<!--', '-->', 'gm');

  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
    showdown.subParser('hashElement')(text, options, globals));

  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
  return text;
});

/**
 * Hash span elements that should not be parsed as markdown
 */
showdown.subParser('hashHTMLSpans', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

  function hashHTMLSpan (html) {
    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
  }

  // Hash Self Closing tags
  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash tags without properties
  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash tags with properties
  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash self closing tags without />
  text = text.replace(/<[^>]+?>/gi, function (wm) {
    return hashHTMLSpan(wm);
  });

  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
  return text;
});

/**
 * Unhash HTML spans
 */
showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
    var repText = globals.gHtmlSpans[i],
        // limiter to prevent infinite loop (assume 10 as limit for recurse)
        limit = 0;

    while (/¨C(\d+)C/.test(repText)) {
      var num = RegExp.$1;
      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
      if (limit === 10) {
        console.error('maximum nesting of 10 spans reached!!!');
        break;
      }
      ++limit;
    }
    text = text.replace('¨C' + i + 'C', repText);
  }

  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
  return text;
});

/**
 * Hash and escape <pre><code> elements that should not be parsed as markdown
 */
showdown.subParser('hashPreCodeTags', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

  var repFunc = function (wholeMatch, match, left, right) {
    // encode html entities
    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
  };

  // Hash <pre><code>
  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
  return text;
});

showdown.subParser('headers', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('headers.before', text, options, globals);

  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

      // Set text-style headers:
      //	Header 1
      //	========
      //
      //	Header 2
      //	--------
      //
      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
        hLevel = headerLevelStart,
        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
    return showdown.subParser('hashBlock')(hashBlock, options, globals);
  });

  text = text.replace(setextRegexH2, function (matchFound, m1) {
    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
        hLevel = headerLevelStart + 1,
        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
    return showdown.subParser('hashBlock')(hashBlock, options, globals);
  });

  // atx-style headers:
  //  # Header 1
  //  ## Header 2
  //  ## Header 2 with closing hashes ##
  //  ...
  //  ###### Header 6
  //
  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
    var hText = m2;
    if (options.customizedHeaderId) {
      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
    }

    var span = showdown.subParser('spanGamut')(hText, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
        hLevel = headerLevelStart - 1 + m1.length,
        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

    return showdown.subParser('hashBlock')(header, options, globals);
  });

  function headerId (m) {
    var title,
        prefix;

    // It is separate from other options to allow combining prefix and customized
    if (options.customizedHeaderId) {
      var match = m.match(/\{([^{]+?)}\s*$/);
      if (match && match[1]) {
        m = match[1];
      }
    }

    title = m;

    // Prefix id to prevent causing inadvertent pre-existing style matches.
    if (showdown.helper.isString(options.prefixHeaderId)) {
      prefix = options.prefixHeaderId;
    } else if (options.prefixHeaderId === true) {
      prefix = 'section-';
    } else {
      prefix = '';
    }

    if (!options.rawPrefixHeaderId) {
      title = prefix + title;
    }

    if (options.ghCompatibleHeaderId) {
      title = title
        .replace(/ /g, '-')
        // replace previously escaped chars (&, ¨ and $)
        .replace(/&amp;/g, '')
        .replace(/¨T/g, '')
        .replace(/¨D/g, '')
        // replace rest of the chars (&~$ are repeated as they might have been escaped)
        // borrowed from github's redcarpet (some they should produce similar results)
        .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
        .toLowerCase();
    } else if (options.rawHeaderId) {
      title = title
        .replace(/ /g, '-')
        // replace previously escaped chars (&, ¨ and $)
        .replace(/&amp;/g, '&')
        .replace(/¨T/g, '¨')
        .replace(/¨D/g, '$')
        // replace " and '
        .replace(/["']/g, '-')
        .toLowerCase();
    } else {
      title = title
        .replace(/[^\w]/g, '')
        .toLowerCase();
    }

    if (options.rawPrefixHeaderId) {
      title = prefix + title;
    }

    if (globals.hashLinkCounts[title]) {
      title = title + '-' + (globals.hashLinkCounts[title]++);
    } else {
      globals.hashLinkCounts[title] = 1;
    }
    return title;
  }

  text = globals.converter._dispatch('headers.after', text, options, globals);
  return text;
});

/**
 * Turn Markdown link shortcuts into XHTML <a> tags.
 */
showdown.subParser('horizontalRule', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
  return text;
});

/**
 * Turn Markdown image shortcuts into <img> tags.
 */
showdown.subParser('images', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('images.before', text, options, globals);

  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
    url = url.replace(/\s/g, '');
    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
  }

  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

    var gUrls   = globals.gUrls,
        gTitles = globals.gTitles,
        gDims   = globals.gDimensions;

    linkId = linkId.toLowerCase();

    if (!title) {
      title = '';
    }
    // Special case for explicit empty url
    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
      url = '';

    } else if (url === '' || url === null) {
      if (linkId === '' || linkId === null) {
        // lower-case and turn embedded newlines into spaces
        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
      }
      url = '#' + linkId;

      if (!showdown.helper.isUndefined(gUrls[linkId])) {
        url = gUrls[linkId];
        if (!showdown.helper.isUndefined(gTitles[linkId])) {
          title = gTitles[linkId];
        }
        if (!showdown.helper.isUndefined(gDims[linkId])) {
          width = gDims[linkId].width;
          height = gDims[linkId].height;
        }
      } else {
        return wholeMatch;
      }
    }

    altText = altText
      .replace(/"/g, '&quot;')
    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
    //url = showdown.helper.escapeCharacters(url, '*_', false);
    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
    var result = '<img src="' + url + '" alt="' + altText + '"';

    if (title && showdown.helper.isString(title)) {
      title = title
        .replace(/"/g, '&quot;')
      //title = showdown.helper.escapeCharacters(title, '*_', false);
        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
      result += ' title="' + title + '"';
    }

    if (width && height) {
      width  = (width === '*') ? 'auto' : width;
      height = (height === '*') ? 'auto' : height;

      result += ' width="' + width + '"';
      result += ' height="' + height + '"';
    }

    result += ' />';

    return result;
  }

  // First, handle reference-style labeled images: ![alt text][id]
  text = text.replace(referenceRegExp, writeImageTag);

  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

  // base64 encoded images
  text = text.replace(base64RegExp, writeImageTagBase64);

  // cases with crazy urls like ./image/cat1).png
  text = text.replace(crazyRegExp, writeImageTag);

  // normal cases
  text = text.replace(inlineRegExp, writeImageTag);

  // handle reference-style shortcuts: ![img text]
  text = text.replace(refShortcutRegExp, writeImageTag);

  text = globals.converter._dispatch('images.after', text, options, globals);
  return text;
});

showdown.subParser('italicsAndBold', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

  // it's faster to have 3 separate regexes for each case than have just one
  // because of backtracing, in some cases, it could lead to an exponential effect
  // called "catastrophic backtrace". Ominous!

  function parseInside (txt, left, right) {
    /*
    if (options.simplifiedAutoLink) {
      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
    }
    */
    return left + txt + right;
  }

  // Parse underscores
  if (options.literalMidWordUnderscores) {
    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
      return parseInside (txt, '<strong><em>', '</em></strong>');
    });
    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
      return parseInside (txt, '<strong>', '</strong>');
    });
    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
      return parseInside (txt, '<em>', '</em>');
    });
  } else {
    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
    });
    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
    });
    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
    });
  }

  // Now parse asterisks
  if (options.literalMidWordAsterisks) {
    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
    });
    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<strong>', '</strong>');
    });
    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<em>', '</em>');
    });
  } else {
    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
    });
    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
    });
    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
    });
  }


  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
  return text;
});

/**
 * Form HTML ordered (numbered) and unordered (bulleted) lists.
 */
showdown.subParser('lists', function (text, options, globals) {
  'use strict';

  /**
   * Process the contents of a single ordered or unordered list, splitting it
   * into individual list items.
   * @param {string} listStr
   * @param {boolean} trimTrailing
   * @returns {string}
   */
  function processListItems (listStr, trimTrailing) {
    // The $g_list_level global keeps track of when we're inside a list.
    // Each time we enter a list, we increment it; when we leave a list,
    // we decrement. If it's zero, we're not in a list anymore.
    //
    // We do this because when we're not inside a list, we want to treat
    // something like this:
    //
    //    I recommend upgrading to version
    //    8. Oops, now this line is treated
    //    as a sub-list.
    //
    // As a single paragraph, despite the fact that the second line starts
    // with a digit-period-space sequence.
    //
    // Whereas when we're inside a list (or sub-list), that line will be
    // treated as the start of a sub-list. What a kludge, huh? This is
    // an aspect of Markdown's syntax that's hard to parse perfectly
    // without resorting to mind-reading. Perhaps the solution is to
    // change the syntax rules such that sub-lists must start with a
    // starting cardinal number; e.g. "1." or "a.".
    globals.gListLevel++;

    // trim trailing blank lines:
    listStr = listStr.replace(/\n{2,}$/, '\n');

    // attacklab: add sentinel to emulate \z
    listStr += '¨0';

    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
        isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
    // which is a syntax breaking change
    // activating this option reverts to old behavior
    if (options.disableForced4SpacesIndentedSublists) {
      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
    }

    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
      checked = (checked && checked.trim() !== '');

      var item = showdown.subParser('outdent')(m4, options, globals),
          bulletStyle = '';

      // Support for github tasklists
      if (taskbtn && options.tasklists) {
        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
          if (checked) {
            otp += ' checked';
          }
          otp += '>';
          return otp;
        });
      }

      // ISSUE #312
      // This input: - - - a
      // causes trouble to the parser, since it interprets it as:
      // <ul><li><li><li>a</li></li></li></ul>
      // instead of:
      // <ul><li>- - a</li></ul>
      // So, to prevent it, we will put a marker (¨A)in the beginning of the line
      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
        return '¨A' + wm2;
      });

      // m1 - Leading line or
      // Has a double return (multi paragraph) or
      // Has sublist
      if (m1 || (item.search(/\n{2,}/) > -1)) {
        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
        item = showdown.subParser('blockGamut')(item, options, globals);
      } else {
        // Recursion for sub-lists:
        item = showdown.subParser('lists')(item, options, globals);
        item = item.replace(/\n$/, ''); // chomp(item)
        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

        // Colapse double linebreaks
        item = item.replace(/\n\n+/g, '\n\n');
        if (isParagraphed) {
          item = showdown.subParser('paragraphs')(item, options, globals);
        } else {
          item = showdown.subParser('spanGamut')(item, options, globals);
        }
      }

      // now we need to remove the marker (¨A)
      item = item.replace('¨A', '');
      // we can finally wrap the line in list item tags
      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

      return item;
    });

    // attacklab: strip sentinel
    listStr = listStr.replace(/¨0/g, '');

    globals.gListLevel--;

    if (trimTrailing) {
      listStr = listStr.replace(/\s+$/, '');
    }

    return listStr;
  }

  function styleStartNumber (list, listType) {
    // check if ol and starts by a number different than 1
    if (listType === 'ol') {
      var res = list.match(/^ *(\d+)\./);
      if (res && res[1] !== '1') {
        return ' start="' + res[1] + '"';
      }
    }
    return '';
  }

  /**
   * Check and parse consecutive lists (better fix for issue #142)
   * @param {string} list
   * @param {string} listType
   * @param {boolean} trimTrailing
   * @returns {string}
   */
  function parseConsecutiveLists (list, listType, trimTrailing) {
    // check if we caught 2 or more consecutive lists by mistake
    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
        result = '';

    if (list.search(counterRxg) !== -1) {
      (function parseCL (txt) {
        var pos = txt.search(counterRxg),
            style = styleStartNumber(list, listType);
        if (pos !== -1) {
          // slice
          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

          // invert counterType and listType
          listType = (listType === 'ul') ? 'ol' : 'ul';
          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

          //recurse
          parseCL(txt.slice(pos));
        } else {
          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
        }
      })(list);
    } else {
      var style = styleStartNumber(list, listType);
      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
    }

    return result;
  }

  /** Start of list parsing **/
  text = globals.converter._dispatch('lists.before', text, options, globals);
  // add sentinel to hack around khtml/safari bug:
  // http://bugs.webkit.org/show_bug.cgi?id=11231
  text += '¨0';

  if (globals.gListLevel) {
    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
      function (wholeMatch, list, m2) {
        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
        return parseConsecutiveLists(list, listType, true);
      }
    );
  } else {
    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
      function (wholeMatch, m1, list, m3) {
        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
        return parseConsecutiveLists(list, listType, false);
      }
    );
  }

  // strip sentinel
  text = text.replace(/¨0/, '');
  text = globals.converter._dispatch('lists.after', text, options, globals);
  return text;
});

/**
 * Parse metadata at the top of the document
 */
showdown.subParser('metadata', function (text, options, globals) {
  'use strict';

  if (!options.metadata) {
    return text;
  }

  text = globals.converter._dispatch('metadata.before', text, options, globals);

  function parseMetadataContents (content) {
    // raw is raw so it's not changed in any way
    globals.metadata.raw = content;

    // escape chars forbidden in html attributes
    // double quotes
    content = content
      // ampersand first
      .replace(/&/g, '&amp;')
      // double quotes
      .replace(/"/g, '&quot;');

    content = content.replace(/\n {4}/g, ' ');
    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
      globals.metadata.parsed[key] = value;
      return '';
    });
  }

  text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
    parseMetadataContents(content);
    return '¨M';
  });

  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
    if (format) {
      globals.metadata.format = format;
    }
    parseMetadataContents(content);
    return '¨M';
  });

  text = text.replace(/¨M/g, '');

  text = globals.converter._dispatch('metadata.after', text, options, globals);
  return text;
});

/**
 * Remove one level of line-leading tabs or spaces
 */
showdown.subParser('outdent', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('outdent.before', text, options, globals);

  // attacklab: hack around Konqueror 3.5.4 bug:
  // "----------bug".replace(/^-/g,"") == "bug"
  text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

  // attacklab: clean up hack
  text = text.replace(/¨0/g, '');

  text = globals.converter._dispatch('outdent.after', text, options, globals);
  return text;
});

/**
 *
 */
showdown.subParser('paragraphs', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
  // Strip leading and trailing lines:
  text = text.replace(/^\n+/g, '');
  text = text.replace(/\n+$/g, '');

  var grafs = text.split(/\n{2,}/g),
      grafsOut = [],
      end = grafs.length; // Wrap <p> tags

  for (var i = 0; i < end; i++) {
    var str = grafs[i];
    // if this is an HTML marker, copy it
    if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
      grafsOut.push(str);

    // test for presence of characters to prevent empty lines being parsed
    // as paragraphs (resulting in undesired extra empty paragraphs)
    } else if (str.search(/\S/) >= 0) {
      str = showdown.subParser('spanGamut')(str, options, globals);
      str = str.replace(/^([ \t]*)/g, '<p>');
      str += '</p>';
      grafsOut.push(str);
    }
  }

  /** Unhashify HTML blocks */
  end = grafsOut.length;
  for (i = 0; i < end; i++) {
    var blockText = '',
        grafsOutIt = grafsOut[i],
        codeFlag = false;
    // if this is a marker for an html block...
    // use RegExp.test instead of string.search because of QML bug
    while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
      var delim = RegExp.$1,
          num   = RegExp.$2;

      if (delim === 'K') {
        blockText = globals.gHtmlBlocks[num];
      } else {
        // we need to check if ghBlock is a false positive
        if (codeFlag) {
          // use encoded version of all text
          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
        } else {
          blockText = globals.ghCodeBlocks[num].codeblock;
        }
      }
      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

      grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
      // Check if grafsOutIt is a pre->code
      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
        codeFlag = true;
      }
    }
    grafsOut[i] = grafsOutIt;
  }
  text = grafsOut.join('\n');
  // Strip leading and trailing lines:
  text = text.replace(/^\n+/g, '');
  text = text.replace(/\n+$/g, '');
  return globals.converter._dispatch('paragraphs.after', text, options, globals);
});

/**
 * Run extension
 */
showdown.subParser('runExtension', function (ext, text, options, globals) {
  'use strict';

  if (ext.filter) {
    text = ext.filter(text, globals.converter, options);

  } else if (ext.regex) {
    // TODO remove this when old extension loading mechanism is deprecated
    var re = ext.regex;
    if (!(re instanceof RegExp)) {
      re = new RegExp(re, 'g');
    }
    text = text.replace(re, ext.replace);
  }

  return text;
});

/**
 * These are all the transformations that occur *within* block-level
 * tags like paragraphs, headers, and list items.
 */
showdown.subParser('spanGamut', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
  text = showdown.subParser('codeSpans')(text, options, globals);
  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

  // Process anchor and image tags. Images must come first,
  // because ![foo][f] looks like an anchor.
  text = showdown.subParser('images')(text, options, globals);
  text = showdown.subParser('anchors')(text, options, globals);

  // Make links out of things like `<http://example.com/>`
  // Must come after anchors, because you can use < and >
  // delimiters in inline links like [this](<url>).
  text = showdown.subParser('autoLinks')(text, options, globals);
  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
  text = showdown.subParser('emoji')(text, options, globals);
  text = showdown.subParser('underline')(text, options, globals);
  text = showdown.subParser('italicsAndBold')(text, options, globals);
  text = showdown.subParser('strikethrough')(text, options, globals);
  text = showdown.subParser('ellipsis')(text, options, globals);

  // we need to hash HTML tags inside spans
  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

  // now we encode amps and angles
  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

  // Do hard breaks
  if (options.simpleLineBreaks) {
    // GFM style hard breaks
    // only add line breaks if the text does not contain a block (special case for lists)
    if (!/\n\n¨K/.test(text)) {
      text = text.replace(/\n+/g, '<br />\n');
    }
  } else {
    // Vanilla hard breaks
    text = text.replace(/  +\n/g, '<br />\n');
  }

  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
  return text;
});

showdown.subParser('strikethrough', function (text, options, globals) {
  'use strict';

  function parseInside (txt) {
    if (options.simplifiedAutoLink) {
      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
    }
    return '<del>' + txt + '</del>';
  }

  if (options.strikethrough) {
    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
  }

  return text;
});

/**
 * Strips link definitions from text, stores the URLs and titles in
 * hash references.
 * Link defs are in the form: ^[id]: url "optional title"
 */
showdown.subParser('stripLinkDefinitions', function (text, options, globals) {
  'use strict';

  var regex       = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
      base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
  text += '¨0';

  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {
    linkId = linkId.toLowerCase();
    if (url.match(/^data:.+?\/.+?;base64,/)) {
      // remove newlines
      globals.gUrls[linkId] = url.replace(/\s/g, '');
    } else {
      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
    }

    if (blankLines) {
      // Oops, found blank lines, so it's not a title.
      // Put back the parenthetical statement we stole.
      return blankLines + title;

    } else {
      if (title) {
        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
      }
      if (options.parseImgDimensions && width && height) {
        globals.gDimensions[linkId] = {
          width:  width,
          height: height
        };
      }
    }
    // Completely remove the definition from the text
    return '';
  };

  // first we try to find base64 link references
  text = text.replace(base64Regex, replaceFunc);

  text = text.replace(regex, replaceFunc);

  // attacklab: strip sentinel
  text = text.replace(/¨0/, '');

  return text;
});

showdown.subParser('tables', function (text, options, globals) {
  'use strict';

  if (!options.tables) {
    return text;
  }

  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
      //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

  function parseStyles (sLine) {
    if (/^:[ \t]*--*$/.test(sLine)) {
      return ' style="text-align:left;"';
    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
      return ' style="text-align:right;"';
    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
      return ' style="text-align:center;"';
    } else {
      return '';
    }
  }

  function parseHeaders (header, style) {
    var id = '';
    header = header.trim();
    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
    if (options.tablesHeaderId || options.tableHeaderId) {
      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
    }
    header = showdown.subParser('spanGamut')(header, options, globals);

    return '<th' + id + style + '>' + header + '</th>\n';
  }

  function parseCells (cell, style) {
    var subText = showdown.subParser('spanGamut')(cell, options, globals);
    return '<td' + style + '>' + subText + '</td>\n';
  }

  function buildTable (headers, cells) {
    var tb = '<table>\n<thead>\n<tr>\n',
        tblLgn = headers.length;

    for (var i = 0; i < tblLgn; ++i) {
      tb += headers[i];
    }
    tb += '</tr>\n</thead>\n<tbody>\n';

    for (i = 0; i < cells.length; ++i) {
      tb += '<tr>\n';
      for (var ii = 0; ii < tblLgn; ++ii) {
        tb += cells[i][ii];
      }
      tb += '</tr>\n';
    }
    tb += '</tbody>\n</table>\n';
    return tb;
  }

  function parseTable (rawTable) {
    var i, tableLines = rawTable.split('\n');

    for (i = 0; i < tableLines.length; ++i) {
      // strip wrong first and last column if wrapped tables are used
      if (/^ {0,3}\|/.test(tableLines[i])) {
        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
      }
      if (/\|[ \t]*$/.test(tableLines[i])) {
        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
      }
      // parse code spans first, but we only support one line code spans
      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
    }

    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
        rawCells = [],
        headers = [],
        styles = [],
        cells = [];

    tableLines.shift();
    tableLines.shift();

    for (i = 0; i < tableLines.length; ++i) {
      if (tableLines[i].trim() === '') {
        continue;
      }
      rawCells.push(
        tableLines[i]
          .split('|')
          .map(function (s) {
            return s.trim();
          })
      );
    }

    if (rawHeaders.length < rawStyles.length) {
      return rawTable;
    }

    for (i = 0; i < rawStyles.length; ++i) {
      styles.push(parseStyles(rawStyles[i]));
    }

    for (i = 0; i < rawHeaders.length; ++i) {
      if (showdown.helper.isUndefined(styles[i])) {
        styles[i] = '';
      }
      headers.push(parseHeaders(rawHeaders[i], styles[i]));
    }

    for (i = 0; i < rawCells.length; ++i) {
      var row = [];
      for (var ii = 0; ii < headers.length; ++ii) {
        if (showdown.helper.isUndefined(rawCells[i][ii])) {

        }
        row.push(parseCells(rawCells[i][ii], styles[ii]));
      }
      cells.push(row);
    }

    return buildTable(headers, cells);
  }

  text = globals.converter._dispatch('tables.before', text, options, globals);

  // find escaped pipe characters
  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

  // parse multi column tables
  text = text.replace(tableRgx, parseTable);

  // parse one column tables
  text = text.replace(singeColTblRgx, parseTable);

  text = globals.converter._dispatch('tables.after', text, options, globals);

  return text;
});

showdown.subParser('underline', function (text, options, globals) {
  'use strict';

  if (!options.underline) {
    return text;
  }

  text = globals.converter._dispatch('underline.before', text, options, globals);

  if (options.literalMidWordUnderscores) {
    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
      return '<u>' + txt + '</u>';
    });
    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
      return '<u>' + txt + '</u>';
    });
  } else {
    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
    });
    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
    });
  }

  // escape remaining underscores to prevent them being parsed by italic and bold
  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('underline.after', text, options, globals);

  return text;
});

/**
 * Swap back in all the special characters we've hidden.
 */
showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

  text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
    var charCodeToReplace = parseInt(m1);
    return String.fromCharCode(charCodeToReplace);
  });

  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
  return text;
});

showdown.subParser('makeMarkdown.blockquote', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    var children = node.childNodes,
        childrenLength = children.length;

    for (var i = 0; i < childrenLength; ++i) {
      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

      if (innerTxt === '') {
        continue;
      }
      txt += innerTxt;
    }
  }
  // cleanup
  txt = txt.trim();
  txt = '> ' + txt.split('\n').join('\n> ');
  return txt;
});

showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {
  'use strict';

  var lang = node.getAttribute('language'),
      num  = node.getAttribute('precodenum');
  return '```' + lang + '\n' + globals.preList[num] + '\n```';
});

showdown.subParser('makeMarkdown.codeSpan', function (node) {
  'use strict';

  return '`' + node.innerHTML + '`';
});

showdown.subParser('makeMarkdown.emphasis', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '*';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '*';
  }
  return txt;
});

showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {
  'use strict';

  var headerMark = new Array(headerLevel + 1).join('#'),
      txt = '';

  if (node.hasChildNodes()) {
    txt = headerMark + ' ';
    var children = node.childNodes,
        childrenLength = children.length;

    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
  }
  return txt;
});

showdown.subParser('makeMarkdown.hr', function () {
  'use strict';

  return '---';
});

showdown.subParser('makeMarkdown.image', function (node) {
  'use strict';

  var txt = '';
  if (node.hasAttribute('src')) {
    txt += '![' + node.getAttribute('alt') + '](';
    txt += '<' + node.getAttribute('src') + '>';
    if (node.hasAttribute('width') && node.hasAttribute('height')) {
      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
    }

    if (node.hasAttribute('title')) {
      txt += ' "' + node.getAttribute('title') + '"';
    }
    txt += ')';
  }
  return txt;
});

showdown.subParser('makeMarkdown.links', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes() && node.hasAttribute('href')) {
    var children = node.childNodes,
        childrenLength = children.length;
    txt = '[';
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '](';
    txt += '<' + node.getAttribute('href') + '>';
    if (node.hasAttribute('title')) {
      txt += ' "' + node.getAttribute('title') + '"';
    }
    txt += ')';
  }
  return txt;
});

showdown.subParser('makeMarkdown.list', function (node, globals, type) {
  'use strict';

  var txt = '';
  if (!node.hasChildNodes()) {
    return '';
  }
  var listItems       = node.childNodes,
      listItemsLenght = listItems.length,
      listNum = node.getAttribute('start') || 1;

  for (var i = 0; i < listItemsLenght; ++i) {
    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
      continue;
    }

    // define the bullet to use in list
    var bullet = '';
    if (type === 'ol') {
      bullet = listNum.toString() + '. ';
    } else {
      bullet = '- ';
    }

    // parse list item
    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
    ++listNum;
  }

  // add comment at the end to prevent consecutive lists to be parsed as one
  txt += '\n<!-- -->\n';
  return txt.trim();
});

showdown.subParser('makeMarkdown.listItem', function (node, globals) {
  'use strict';

  var listItemTxt = '';

  var children = node.childNodes,
      childrenLenght = children.length;

  for (var i = 0; i < childrenLenght; ++i) {
    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
  }
  // if it's only one liner, we need to add a newline at the end
  if (!/\n$/.test(listItemTxt)) {
    listItemTxt += '\n';
  } else {
    // it's multiparagraph, so we need to indent
    listItemTxt = listItemTxt
      .split('\n')
      .join('\n    ')
      .replace(/^ {4}$/gm, '')
      .replace(/\n\n+/g, '\n\n');
  }

  return listItemTxt;
});



showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {
  'use strict';

  spansOnly = spansOnly || false;

  var txt = '';

  // edge case of text without wrapper paragraph
  if (node.nodeType === 3) {
    return showdown.subParser('makeMarkdown.txt')(node, globals);
  }

  // HTML comment
  if (node.nodeType === 8) {
    return '<!--' + node.data + '-->\n\n';
  }

  // process only node elements
  if (node.nodeType !== 1) {
    return '';
  }

  var tagName = node.tagName.toLowerCase();

  switch (tagName) {

    //
    // BLOCKS
    //
    case 'h1':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
      break;
    case 'h2':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
      break;
    case 'h3':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
      break;
    case 'h4':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
      break;
    case 'h5':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
      break;
    case 'h6':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
      break;

    case 'p':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
      break;

    case 'blockquote':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
      break;

    case 'hr':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
      break;

    case 'ol':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
      break;

    case 'ul':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
      break;

    case 'precode':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
      break;

    case 'pre':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
      break;

    case 'table':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
      break;

    //
    // SPANS
    //
    case 'code':
      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
      break;

    case 'em':
    case 'i':
      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
      break;

    case 'strong':
    case 'b':
      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
      break;

    case 'del':
      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
      break;

    case 'a':
      txt = showdown.subParser('makeMarkdown.links')(node, globals);
      break;

    case 'img':
      txt = showdown.subParser('makeMarkdown.image')(node, globals);
      break;

    default:
      txt = node.outerHTML + '\n\n';
  }

  // common normalization
  // TODO eventually

  return txt;
});

showdown.subParser('makeMarkdown.paragraph', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
  }

  // some text normalization
  txt = txt.trim();

  return txt;
});

showdown.subParser('makeMarkdown.pre', function (node, globals) {
  'use strict';

  var num  = node.getAttribute('prenum');
  return '<pre>' + globals.preList[num] + '</pre>';
});

showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '~~';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '~~';
  }
  return txt;
});

showdown.subParser('makeMarkdown.strong', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '**';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '**';
  }
  return txt;
});

showdown.subParser('makeMarkdown.table', function (node, globals) {
  'use strict';

  var txt = '',
      tableArray = [[], []],
      headings   = node.querySelectorAll('thead>tr>th'),
      rows       = node.querySelectorAll('tbody>tr'),
      i, ii;
  for (i = 0; i < headings.length; ++i) {
    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
        allign = '---';

    if (headings[i].hasAttribute('style')) {
      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
      switch (style) {
        case 'text-align:left;':
          allign = ':---';
          break;
        case 'text-align:right;':
          allign = '---:';
          break;
        case 'text-align:center;':
          allign = ':---:';
          break;
      }
    }
    tableArray[0][i] = headContent.trim();
    tableArray[1][i] = allign;
  }

  for (i = 0; i < rows.length; ++i) {
    var r = tableArray.push([]) - 1,
        cols = rows[i].getElementsByTagName('td');

    for (ii = 0; ii < headings.length; ++ii) {
      var cellContent = ' ';
      if (typeof cols[ii] !== 'undefined') {
        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
      }
      tableArray[r].push(cellContent);
    }
  }

  var cellSpacesCount = 3;
  for (i = 0; i < tableArray.length; ++i) {
    for (ii = 0; ii < tableArray[i].length; ++ii) {
      var strLen = tableArray[i][ii].length;
      if (strLen > cellSpacesCount) {
        cellSpacesCount = strLen;
      }
    }
  }

  for (i = 0; i < tableArray.length; ++i) {
    for (ii = 0; ii < tableArray[i].length; ++ii) {
      if (i === 1) {
        if (tableArray[i][ii].slice(-1) === ':') {
          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
        } else {
          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
        }
      } else {
        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
      }
    }
    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
  }

  return txt.trim();
});

showdown.subParser('makeMarkdown.tableCell', function (node, globals) {
  'use strict';

  var txt = '';
  if (!node.hasChildNodes()) {
    return '';
  }
  var children = node.childNodes,
      childrenLength = children.length;

  for (var i = 0; i < childrenLength; ++i) {
    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
  }
  return txt.trim();
});

showdown.subParser('makeMarkdown.txt', function (node) {
  'use strict';

  var txt = node.nodeValue;

  // multiple spaces are collapsed
  txt = txt.replace(/ +/g, ' ');

  // replace the custom ¨NBSP; with a space
  txt = txt.replace(/¨NBSP;/g, ' ');

  // ", <, > and & should replace escaped html entities
  txt = showdown.helper.unescapeHTMLEntities(txt);

  // escape markdown magic characters
  // emphasis, strong and strikethrough - can appear everywhere
  // we also escape pipe (|) because of tables
  // and escape ` because of code blocks and spans
  txt = txt.replace(/([*_~|`])/g, '\\$1');

  // escape > because of blockquotes
  txt = txt.replace(/^(\s*)>/g, '\\$1>');

  // hash character, only troublesome at the beginning of a line because of headers
  txt = txt.replace(/^#/gm, '\\#');

  // horizontal rules
  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

  // images and links, ] followed by ( is problematic, so we escape it
  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

  // reference URIs must also be escaped
  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

  return txt;
});

var root = this;

// AMD Loader
if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    'use strict';
    return showdown;
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

// CommonJS/nodeJS Loader
} else {}
}).call(this);

//# sourceMappingURL=showdown.js.map


/***/ }),

/***/ "../../node_modules/.pnpm/traverse@0.6.7/node_modules/traverse/index.js":
/***/ ((module) => {

"use strict";


// TODO: use call-bind, is-date, is-regex, is-string, is-boolean-object, is-number-object
function toS(obj) { return Object.prototype.toString.call(obj); }
function isDate(obj) { return toS(obj) === '[object Date]'; }
function isRegExp(obj) { return toS(obj) === '[object RegExp]'; }
function isError(obj) { return toS(obj) === '[object Error]'; }
function isBoolean(obj) { return toS(obj) === '[object Boolean]'; }
function isNumber(obj) { return toS(obj) === '[object Number]'; }
function isString(obj) { return toS(obj) === '[object String]'; }

// TODO: use isarray
var isArray = Array.isArray || function isArray(xs) {
	return Object.prototype.toString.call(xs) === '[object Array]';
};

// TODO: use for-each?
function forEach(xs, fn) {
	if (xs.forEach) { return xs.forEach(fn); }
	for (var i = 0; i < xs.length; i++) {
		fn(xs[i], i, xs);
	}
	return void undefined;
}

// TODO: use object-keys
var objectKeys = Object.keys || function keys(obj) {
	var res = [];
	for (var key in obj) { res.push(key); } // eslint-disable-line no-restricted-syntax
	return res;
};

// TODO: use object.hasown
var hasOwnProperty = Object.prototype.hasOwnProperty || function (obj, key) {
	return key in obj;
};

function copy(src) {
	if (typeof src === 'object' && src !== null) {
		var dst;

		if (isArray(src)) {
			dst = [];
		} else if (isDate(src)) {
			dst = new Date(src.getTime ? src.getTime() : src);
		} else if (isRegExp(src)) {
			dst = new RegExp(src);
		} else if (isError(src)) {
			dst = { message: src.message };
		} else if (isBoolean(src) || isNumber(src) || isString(src)) {
			dst = Object(src);
		} else if (Object.create && Object.getPrototypeOf) {
			dst = Object.create(Object.getPrototypeOf(src));
		} else if (src.constructor === Object) {
			dst = {};
		} else {
			var proto = (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {};
			var T = function T() {}; // eslint-disable-line func-style, func-name-matching
			T.prototype = proto;
			dst = new T();
		}

		forEach(objectKeys(src), function (key) {
			dst[key] = src[key];
		});
		return dst;
	}
	return src;
}

function walk(root, cb, immutable) {
	var path = [];
	var parents = [];
	var alive = true;

	return (function walker(node_) {
		var node = immutable ? copy(node_) : node_;
		var modifiers = {};

		var keepGoing = true;

		var state = {
			node: node,
			node_: node_,
			path: [].concat(path),
			parent: parents[parents.length - 1],
			parents: parents,
			key: path[path.length - 1],
			isRoot: path.length === 0,
			level: path.length,
			circular: null,
			update: function (x, stopHere) {
				if (!state.isRoot) {
					state.parent.node[state.key] = x;
				}
				state.node = x;
				if (stopHere) { keepGoing = false; }
			},
			delete: function (stopHere) {
				delete state.parent.node[state.key];
				if (stopHere) { keepGoing = false; }
			},
			remove: function (stopHere) {
				if (isArray(state.parent.node)) {
					state.parent.node.splice(state.key, 1);
				} else {
					delete state.parent.node[state.key];
				}
				if (stopHere) { keepGoing = false; }
			},
			keys: null,
			before: function (f) { modifiers.before = f; },
			after: function (f) { modifiers.after = f; },
			pre: function (f) { modifiers.pre = f; },
			post: function (f) { modifiers.post = f; },
			stop: function () { alive = false; },
			block: function () { keepGoing = false; },
		};

		if (!alive) { return state; }

		function updateState() {
			if (typeof state.node === 'object' && state.node !== null) {
				if (!state.keys || state.node_ !== state.node) {
					state.keys = objectKeys(state.node);
				}

				state.isLeaf = state.keys.length === 0;

				for (var i = 0; i < parents.length; i++) {
					if (parents[i].node_ === node_) {
						state.circular = parents[i];
						break; // eslint-disable-line no-restricted-syntax
					}
				}
			} else {
				state.isLeaf = true;
				state.keys = null;
			}

			state.notLeaf = !state.isLeaf;
			state.notRoot = !state.isRoot;
		}

		updateState();

		// use return values to update if defined
		var ret = cb.call(state, state.node);
		if (ret !== undefined && state.update) { state.update(ret); }

		if (modifiers.before) { modifiers.before.call(state, state.node); }

		if (!keepGoing) { return state; }

		if (
			typeof state.node === 'object'
			&& state.node !== null
			&& !state.circular
		) {
			parents.push(state);

			updateState();

			forEach(state.keys, function (key, i) {
				path.push(key);

				if (modifiers.pre) { modifiers.pre.call(state, state.node[key], key); }

				var child = walker(state.node[key]);
				if (immutable && hasOwnProperty.call(state.node, key)) {
					state.node[key] = child.node;
				}

				child.isLast = i === state.keys.length - 1;
				child.isFirst = i === 0;

				if (modifiers.post) { modifiers.post.call(state, child); }

				path.pop();
			});
			parents.pop();
		}

		if (modifiers.after) { modifiers.after.call(state, state.node); }

		return state;
	}(root)).node;
}

function Traverse(obj) {
	this.value = obj;
}

Traverse.prototype.get = function (ps) {
	var node = this.value;
	for (var i = 0; i < ps.length; i++) {
		var key = ps[i];
		if (!node || !hasOwnProperty.call(node, key)) {
			return void undefined;
		}
		node = node[key];
	}
	return node;
};

Traverse.prototype.has = function (ps) {
	var node = this.value;
	for (var i = 0; i < ps.length; i++) {
		var key = ps[i];
		if (!node || !hasOwnProperty.call(node, key)) {
			return false;
		}
		node = node[key];
	}
	return true;
};

Traverse.prototype.set = function (ps, value) {
	var node = this.value;
	for (var i = 0; i < ps.length - 1; i++) {
		var key = ps[i];
		if (!hasOwnProperty.call(node, key)) { node[key] = {}; }
		node = node[key];
	}
	node[ps[i]] = value;
	return value;
};

Traverse.prototype.map = function (cb) {
	return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
	this.value = walk(this.value, cb, false);
	return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
	var skip = arguments.length === 1;
	var acc = skip ? this.value : init;
	this.forEach(function (x) {
		if (!this.isRoot || !skip) {
			acc = cb.call(this, acc, x);
		}
	});
	return acc;
};

Traverse.prototype.paths = function () {
	var acc = [];
	this.forEach(function () {
		acc.push(this.path);
	});
	return acc;
};

Traverse.prototype.nodes = function () {
	var acc = [];
	this.forEach(function () {
		acc.push(this.node);
	});
	return acc;
};

Traverse.prototype.clone = function () {
	var parents = [];
	var nodes = [];

	return (function clone(src) {
		for (var i = 0; i < parents.length; i++) {
			if (parents[i] === src) {
				return nodes[i];
			}
		}

		if (typeof src === 'object' && src !== null) {
			var dst = copy(src);

			parents.push(src);
			nodes.push(dst);

			forEach(objectKeys(src), function (key) {
				dst[key] = clone(src[key]);
			});

			parents.pop();
			nodes.pop();
			return dst;
		}

		return src;

	}(this.value));
};

function traverse(obj) {
	return new Traverse(obj);
}

// TODO: replace with object.assign?
forEach(objectKeys(Traverse.prototype), function (key) {
	traverse[key] = function (obj) {
		var args = [].slice.call(arguments, 1);
		var t = new Traverse(obj);
		return t[key].apply(t, args);
	};
});

module.exports = traverse;


/***/ })

}]);